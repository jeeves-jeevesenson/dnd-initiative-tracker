#!/usr/bin/env python3
"""
DnD Initiative Tracker (v41) — LAN Proof-of-Concept

This edition layers a small LAN/mobile web client on top of the Tk app without rewriting it.
- DM runs the Tk app.
- LAN server starts automatically (and can be stopped/restarted from the "LAN" menu).
- Players open the LAN URL on mobile and are auto-assigned a Player Character by IP, then can move their token (on their turn).
"""

from __future__ import annotations

import asyncio
import random
import math
from functools import lru_cache
from pathlib import Path
import json
import queue
import socket
import ipaddress
import fnmatch
import importlib.util
import importlib
import threading
import time
import logging
import shutil
import re
import os
import hashlib
import hmac
import secrets
import traceback
import urllib.parse
from datetime import datetime
from dataclasses import asdict, dataclass, field, is_dataclass
from typing import Any, Callable, Dict, Iterable, List, Optional, Tuple
import copy
from collections import deque
import sys

import tkinter as tk
from tkinter import filedialog, messagebox, scrolledtext, simpledialog, ttk

# Monster YAML loader (PyYAML)
try:
    import yaml  # type: ignore
except Exception:
    yaml = None  # type: ignore

try:
    from pypdf import PdfReader  # type: ignore
except Exception:
    PdfReader = None  # type: ignore

try:
    from PIL import Image, ImageTk  # type: ignore
except Exception:
    Image = None  # type: ignore
    ImageTk = None  # type: ignore

# Import the full tracker as the base.
# Keep this file in the same folder as helper_script.py
try:
    import helper_script as base
    import update_checker
except Exception as e:  # pragma: no cover
    raise SystemExit(
        "Arrr! I can’t find/load helper_script.py in this folder.\n"
        "Make sure helper_script and dnd_initative_tracker be in the same directory.\n\n"
        f"Import error: {e}"
    )


FAIL_OUTCOME_LABELS = {"fail", "failed", "failure", "failed_save", "fail_save"}
USER_YAML_DIRNAME = "Dnd-Init-Yamls"
SESSION_SNAPSHOT_SCHEMA_VERSION = 1


def _app_base_dir() -> Path:
    try:
        if getattr(sys, "frozen", False):
            return Path(sys.executable).parent
    except Exception:
        pass
    try:
        return Path(__file__).resolve().parent
    except Exception:
        try:
            return Path.cwd()
        except Exception:
            return Path(".")


def _app_data_dir() -> Path:
    override = os.getenv("INITTRACKER_DATA_DIR")
    if override:
        try:
            return Path(override).expanduser()
        except Exception:
            pass
    try:
        docs_dir = Path.home() / "Documents"
        return docs_dir / USER_YAML_DIRNAME
    except Exception:
        pass
    return _app_base_dir()


def _normalize_public_url(raw_value: Any, *, required_scheme: Optional[str] = None) -> Optional[str]:
    text = str(raw_value or "").strip()
    if not text:
        return None
    parsed = urllib.parse.urlparse(text)
    if not parsed.scheme:
        return None
    scheme = parsed.scheme.lower()
    if required_scheme and scheme != required_scheme:
        return None
    if scheme not in {"http", "https"}:
        return None
    if not parsed.netloc:
        return None
    normalized = urllib.parse.urlunparse((scheme, parsed.netloc, parsed.path or "/", "", parsed.query, parsed.fragment))
    if not normalized.endswith("/"):
        normalized += "/"
    return normalized


def _normalize_lan_url_mode(raw_mode: Any) -> str:
    mode = str(raw_mode or "http").strip().lower()
    if mode in {"http", "https", "both"}:
        return mode
    return "http"


def _rules_pdf_default_path() -> Path:
    return _app_data_dir() / "rules" / "PlayersHandbook2024.pdf"


def _resolve_rules_pdf_path() -> Optional[Path]:
    override = str(os.getenv("INITTRACKER_RULES_PDF") or "").strip()
    if override:
        try:
            return Path(override).expanduser()
        except Exception:
            return None

    default_path = _rules_pdf_default_path()
    try:
        if default_path.exists() and default_path.is_file():
            return default_path
    except Exception:
        return None

    rules_dir = default_path.parent
    try:
        candidates = sorted(path for path in rules_dir.glob("*.pdf") if path.is_file())
    except Exception:
        return None
    return candidates[0] if candidates else None


def _safe_rules_filename(path: Optional[Path]) -> Optional[str]:
    if not path:
        return None
    try:
        return path.name
    except Exception:
        return None


def _coerce_outline_items(raw_outline: Any) -> List[Any]:
    if raw_outline is None:
        return []
    if isinstance(raw_outline, list):
        return raw_outline
    if isinstance(raw_outline, tuple):
        return list(raw_outline)
    return [raw_outline]


def _normalize_spell_source_name(value: str) -> str:
    text = str(value or "").strip().lower().replace("’", "'")
    if not text:
        return ""
    text = re.sub(r"\[[^\]]*\]", "", text)
    text = re.sub(r"[^a-z0-9]+", " ", text)
    return re.sub(r"\s+", " ", text).strip()


@lru_cache(maxsize=1)
def _load_spell_source_page_map() -> Dict[str, int]:
    path = _app_base_dir() / "Spells" / "spells_by_page.md"
    try:
        lines = path.read_text(encoding="utf-8").splitlines()
    except Exception:
        return {}
    mapping: Dict[str, int] = {}
    current_page: Optional[int] = None
    in_spells_section = False
    page_header_re = re.compile(r"^##\s*p\.(\d+)\s*$", re.IGNORECASE)
    for raw in lines:
        line = str(raw or "").strip()
        page_match = page_header_re.match(line)
        if page_match:
            try:
                current_page = int(page_match.group(1))
            except Exception:
                current_page = None
            in_spells_section = False
            continue
        if line.startswith("## "):
            current_page = None
            in_spells_section = False
            continue
        if line == "**Spells**":
            in_spells_section = True
            continue
        if line.startswith("**") and line.endswith("**") and line != "**Spells**":
            in_spells_section = False
            continue
        if not in_spells_section or current_page is None or not line.startswith("- "):
            continue
        name = line[2:].strip()
        key = _normalize_spell_source_name(name)
        if key:
            mapping[key] = current_page
    return mapping


def _seed_user_players_dir() -> None:
    _seed_user_items_dir()
    user_dir = _app_data_dir() / "players"
    base_dir = _app_base_dir() / "players"
    if not base_dir.exists():
        return
    try:
        if user_dir.exists():
            if any(user_dir.glob("*.y*ml")):
                return
    except Exception:
        return
    try:
        user_dir.mkdir(parents=True, exist_ok=True)
        for path in list(base_dir.glob("*.y*ml")):
            dest = user_dir / path.name
            if not dest.exists():
                shutil.copy2(path, dest)
    except Exception:
        pass


def _bundled_spells_dir() -> Optional[Path]:
    base_dir = _app_base_dir()
    canonical = base_dir / "Spells"
    fallback = base_dir / "spells"
    if canonical.exists():
        return canonical
    if fallback.exists():
        return fallback
    return None


def _seed_user_spells_dir() -> Optional[Path]:
    source_dir = _bundled_spells_dir()
    if source_dir is None:
        return None
    user_dir = _app_data_dir() / "Spells"
    try:
        user_dir.mkdir(parents=True, exist_ok=True)
    except Exception:
        return source_dir
    try:
        for path in list(source_dir.glob("*.y*ml")):
            dest = user_dir / path.name
            if not dest.exists():
                shutil.copy2(path, dest)
    except Exception:
        pass
    return user_dir


def _seed_user_monsters_dir() -> Path:
    user_dir = _app_data_dir() / "Monsters"
    base_dir = _app_base_dir() / "Monsters"
    try:
        user_dir.mkdir(parents=True, exist_ok=True)
    except Exception:
        return base_dir
    if not base_dir.exists():
        return user_dir
    try:
        for path in base_dir.rglob("*"):
            if not path.is_file() or path.suffix.lower() not in {".yaml", ".yml"}:
                continue
            rel = path.relative_to(base_dir)
            dest = user_dir / rel
            if dest.exists():
                continue
            dest.parent.mkdir(parents=True, exist_ok=True)
            shutil.copy2(path, dest)
    except Exception:
        pass
    return user_dir


def _seed_user_items_dir() -> Path:
    user_dir = _app_data_dir() / "Items"
    base_dir = _app_base_dir() / "Items"
    try:
        (user_dir / "Weapons").mkdir(parents=True, exist_ok=True)
        (user_dir / "Armor").mkdir(parents=True, exist_ok=True)
    except Exception:
        return base_dir
    if not base_dir.exists():
        return user_dir
    try:
        for path in base_dir.rglob("*"):
            if not path.is_file() or path.suffix.lower() not in {".yaml", ".yml"}:
                continue
            rel = path.relative_to(base_dir)
            dest = user_dir / rel
            if dest.exists():
                continue
            dest.parent.mkdir(parents=True, exist_ok=True)
            shutil.copy2(path, dest)
    except Exception:
        pass
    return user_dir


def _load_character_schema_helpers() -> Tuple[Callable[[], Dict[str, Any]], Callable[[Any, Any], Any], Callable[[str, str], str]]:
    base_template = None
    merge_defaults = None
    slugify = None
    try:
        scripts_dir = Path(__file__).resolve().parent / "scripts"
        module_path = scripts_dir / "skeleton_gui.py"
        if module_path.exists():
            spec = importlib.util.spec_from_file_location("inittracker_skeleton_gui", module_path)
            if spec and spec.loader:
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                base_template = getattr(module, "base_template", None)
                merge_defaults = getattr(module, "merge_defaults", None)
                slugify = getattr(module, "slugify", None)
    except Exception:
        base_template = None
        merge_defaults = None
        slugify = None

    def fallback_base_template() -> Dict[str, Any]:
        return {
            "name": "",
            "player": "",
            "campaign": "",
            "ip": "",
            "identity": {},
            "leveling": {},
            "abilities": {},
            "proficiency": {},
            "vitals": {},
            "defenses": {},
            "resources": {},
            "features": [],
            "actions": [
                {
                    "name": "Attack",
                    "description": "Make a weapon or unarmed attack against a target within range.",
                    "type": "action",
                },
                {
                    "name": "Dash",
                    "description": "Gain extra movement for the current turn equal to your speed.",
                    "type": "action",
                },
                {
                    "name": "Disengage",
                    "description": "Your movement does not provoke opportunity attacks for the rest of the turn.",
                    "type": "action",
                },
                {
                    "name": "Dodge",
                    "description": "Until the start of your next turn, attack rolls against you have disadvantage if you can see the attacker, and you make Dexterity saves with advantage.",
                    "type": "action",
                },
                {
                    "name": "Help",
                    "description": "Aid a creature in the next ability check or attack roll against a target within 5 feet of you.",
                    "type": "action",
                },
                {
                    "name": "Hide",
                    "description": "Attempt to hide by making a Dexterity (Stealth) check.",
                    "type": "action",
                },
                {
                    "name": "Influence",
                    "description": "Attempt to influence a creature through conversation, bargaining, or intimidation.",
                    "type": "action",
                },
                {
                    "name": "Magic",
                    "description": "Cast a spell or use a magical feature that takes an action.",
                    "type": "action",
                },
                {
                    "name": "Ready",
                    "description": "Prepare an action and a trigger; use your reaction to perform it when the trigger occurs.",
                    "type": "action",
                },
                {
                    "name": "Search",
                    "description": "Devote attention to finding something by making a Wisdom (Perception) or Intelligence (Investigation) check.",
                    "type": "action",
                },
                {
                    "name": "Study",
                    "description": "Focus on detailed observation or research to gain information about a creature, object, or situation.",
                    "type": "action",
                },
                {
                    "name": "Utilize",
                    "description": "Use an object or interact with the environment in a significant way.",
                    "type": "action",
                },
            ],
            "reactions": [
                {
                    "name": "Opportunity Attack",
                    "description": "When a hostile creature you can see moves out of your reach, you can use your reaction to make one melee attack against it.",
                    "type": "reaction",
                },
                {
                    "name": "Reaction",
                    "description": "You can take a reaction when a trigger occurs. A reaction is only available once per round.",
                    "type": "reaction",
                },
            ],
            "bonus_actions": [
                {
                    "name": "Bonus Action",
                    "description": "You can take a bonus action only when a feature, spell, or ability says you can.",
                    "type": "bonus_action",
                }
            ],
            "spellcasting": {},
            "inventory": {},
            "notes": {},
        }

    def fallback_merge_defaults(user_obj: Any, defaults: Any) -> Any:
        if isinstance(defaults, dict):
            if not isinstance(user_obj, dict):
                user_obj = {}
            for key, value in defaults.items():
                if key not in user_obj:
                    user_obj[key] = copy.deepcopy(value)
                else:
                    user_obj[key] = fallback_merge_defaults(user_obj[key], value)
            return user_obj
        return user_obj

    def fallback_slugify(value: str, sep: str = "_") -> str:
        text = str(value or "").strip().lower()
        text = re.sub(r"[^\w\s-]", "", text)
        text = re.sub(r"[\s-]+", sep, text).strip(sep)
        return text or "id"

    base_template = base_template or fallback_base_template
    merge_defaults = merge_defaults or fallback_merge_defaults
    slugify = slugify or fallback_slugify
    return base_template, merge_defaults, slugify


_CHARACTER_BASE_TEMPLATE, _CHARACTER_MERGE_DEFAULTS, _CHARACTER_SLUGIFY = _load_character_schema_helpers()


def _character_schema_path() -> Path:
    try:
        return Path(__file__).resolve().parent / "assets" / "web" / "new_character" / "schema.json"
    except Exception:
        return Path("assets") / "web" / "new_character" / "schema.json"


def _schema_type_name(value: Any) -> str:
    if isinstance(value, dict):
        return "object"
    if isinstance(value, list):
        return "array"
    if isinstance(value, bool):
        return "boolean"
    if isinstance(value, int):
        return "integer"
    if isinstance(value, float):
        return "number"
    if isinstance(value, str):
        return "string"
    if value is None:
        return "null"
    return type(value).__name__


def _scan_spell_ids(spells_dir: Optional[Path]) -> List[str]:
    if not spells_dir or not spells_dir.is_dir():
        return []
    ids = [path.stem for path in spells_dir.iterdir() if path.is_file() and path.suffix.lower() == ".yaml"]
    ids.sort()
    return ids


def _read_spell_yaml_text(spells_dir: Optional[Path], spell_id: str, max_chars: int = 200_000) -> str:
    if not spells_dir:
        return ""
    path = spells_dir / f"{spell_id}.yaml"
    if not path.is_file():
        return ""
    try:
        with path.open("r", encoding="utf-8") as handle:
            return handle.read(max_chars)
    except Exception as exc:
        return f"# Error reading {path}: {exc}"


def _schema_node_from_field(field: Dict[str, Any]) -> Dict[str, Any]:
    node: Dict[str, Any] = {
        "type": field.get("type", "string"),
        "required": bool(field.get("required", False)),
    }
    if "default" in field:
        node["default"] = field["default"]
    if node["type"] == "object":
        node["fields"] = {child["key"]: _schema_node_from_field(child) for child in field.get("fields", [])}
    if node["type"] == "array":
        items = field.get("items")
        node["items"] = _schema_node_from_field(items) if isinstance(items, dict) else {"type": "string"}
    if node["type"] == "map":
        node["value_type"] = field.get("value_type", "string")
    return node


def _insert_schema_node(root: Dict[str, Any], path: List[str], node: Dict[str, Any]) -> None:
    cursor = root
    for key in path[:-1]:
        fields = cursor.setdefault("fields", {})
        if key not in fields:
            fields[key] = {"type": "object", "fields": {}}
        cursor = fields[key]
    if not path:
        root.setdefault("fields", {}).update(node.get("fields", {}))
    else:
        cursor.setdefault("fields", {})[path[-1]] = node


def _build_character_schema_tree(config: Dict[str, Any]) -> Dict[str, Any]:
    root: Dict[str, Any] = {"type": "object", "fields": {}}
    for section in config.get("sections", []):
        if not isinstance(section, dict):
            continue
        section_type = section.get("type", "object")
        node: Dict[str, Any] = {"type": section_type}
        if "default" in section:
            node["default"] = section["default"]
        if section_type == "object":
            node["fields"] = {child["key"]: _schema_node_from_field(child) for child in section.get("fields", [])}
        elif section_type == "array":
            items = section.get("items")
            node["items"] = _schema_node_from_field(items) if isinstance(items, dict) else {"type": "string"}
        elif section_type == "map":
            node["value_type"] = section.get("value_type", "string")
        path = section.get("path") or []
        _insert_schema_node(root, list(path), node)
    return root


def _schema_default_for_node(node: Dict[str, Any]) -> Any:
    if "default" in node:
        return copy.deepcopy(node["default"])
    node_type = node.get("type")
    if isinstance(node_type, list):
        return ""
    if node_type == "object":
        return {key: _schema_default_for_node(child) for key, child in node.get("fields", {}).items()}
    if node_type == "array":
        return []
    if node_type == "map":
        return {}
    if node_type == "boolean":
        return False
    if node_type in ("integer", "number"):
        return 0
    return ""


def _schema_defaults_from_tree(tree: Dict[str, Any]) -> Dict[str, Any]:
    if tree.get("type") != "object":
        return {}
    return _schema_default_for_node(tree)


def _schema_type_matches(value: Any, expected: Any) -> bool:
    if isinstance(expected, list):
        return any(_schema_type_matches(value, item) for item in expected)
    if expected == "object":
        return isinstance(value, dict)
    if expected == "array":
        return isinstance(value, list)
    if expected == "map":
        return isinstance(value, dict)
    if expected == "boolean":
        return isinstance(value, bool)
    if expected == "integer":
        return isinstance(value, int) and not isinstance(value, bool)
    if expected == "number":
        return isinstance(value, (int, float)) and not isinstance(value, bool)
    if expected == "string":
        return isinstance(value, str)
    return True


def _character_schema_errors_from_tree(payload: Any, schema: Dict[str, Any], path: str = "") -> List[Dict[str, str]]:
    errors: List[Dict[str, str]] = []

    def add_error(message: str) -> None:
        errors.append({"path": path or ".", "message": message})

    expected_type = schema.get("type")
    if expected_type == "object":
        if not isinstance(payload, dict):
            add_error(f"Expected object, got {_schema_type_name(payload)}.")
            return errors
        fields = schema.get("fields", {})
        for key, child_schema in fields.items():
            if child_schema.get("required") and key not in payload:
                errors.append({"path": f"{path}.{key}" if path else key, "message": "Missing required field."})
                continue
            if key in payload:
                next_path = f"{path}.{key}" if path else key
                errors.extend(_character_schema_errors_from_tree(payload[key], child_schema, next_path))
        return errors
    if expected_type == "array":
        if not isinstance(payload, list):
            add_error(f"Expected array, got {_schema_type_name(payload)}.")
            return errors
        item_schema = schema.get("items")
        if isinstance(item_schema, dict):
            for index, item in enumerate(payload):
                next_path = f"{path}[{index}]" if path else f"[{index}]"
                errors.extend(_character_schema_errors_from_tree(item, item_schema, next_path))
        return errors
    if expected_type == "map":
        if not isinstance(payload, dict):
            add_error(f"Expected object map, got {_schema_type_name(payload)}.")
            return errors
        value_type = schema.get("value_type")
        if value_type:
            for key, value in payload.items():
                if not _schema_type_matches(value, value_type):
                    errors.append(
                        {
                            "path": f"{path}.{key}" if path else key,
                            "message": f"Expected {value_type}, got {_schema_type_name(value)}.",
                        }
                    )
        return errors
    if expected_type is not None:
        if not _schema_type_matches(payload, expected_type):
            add_error(f"Expected {expected_type}, got {_schema_type_name(payload)}.")
    return errors


def _readme_section_headings(readme_path: Path) -> List[str]:
    try:
        text = readme_path.read_text(encoding="utf-8")
    except Exception:
        return []
    headings: List[str] = []
    in_section = False
    for line in text.splitlines():
        if line.startswith("## "):
            heading = line[3:].strip()
            in_section = heading == "Complete YAML Structure Reference"
            continue
        if in_section and line.startswith("### "):
            headings.append(line[4:].strip())
    return headings


def _character_schema_readme_map(config: Dict[str, Any]) -> Dict[str, Any]:
    readme_path = Path(__file__).resolve().parent / config.get("readme_path", "players/README.md")
    headings = _readme_section_headings(readme_path)
    schema_headings = [
        section.get("readme_heading")
        for section in config.get("sections", [])
        if isinstance(section, dict) and section.get("readme_heading")
    ]
    missing_in_readme = [heading for heading in schema_headings if heading not in headings]
    missing_in_schema = [heading for heading in headings if heading not in schema_headings]
    return {
        "readme_headings": headings,
        "schema_headings": schema_headings,
        "missing_in_readme": missing_in_readme,
        "missing_in_schema": missing_in_schema,
        "readme_path": str(readme_path),
    }


def _load_character_schema_config() -> Tuple[Dict[str, Any], Dict[str, Any], Dict[str, Any], Dict[str, Any]]:
    path = _character_schema_path()
    try:
        raw = json.loads(path.read_text(encoding="utf-8"))
    except Exception:
        return {}, {}, {}, {}
    if not isinstance(raw, dict):
        return {}, {}, {}, {}
    tree = _build_character_schema_tree(raw)
    defaults = _schema_defaults_from_tree(tree)
    readme_map = _character_schema_readme_map(raw)
    return raw, tree, defaults, readme_map


_CHARACTER_SCHEMA_CONFIG, _CHARACTER_SCHEMA_TREE, _CHARACTER_SCHEMA_DEFAULTS, _CHARACTER_SCHEMA_README_MAP = (
    _load_character_schema_config()
)


@dataclass
class CharacterApiError(Exception):
    status_code: int
    detail: Any


def _ensure_logs_dir() -> Path:
    """Create logs/ in the app data directory (best effort)."""
    base_dir = _app_data_dir()
    logs = base_dir / "logs"
    try:
        logs.mkdir(parents=True, exist_ok=True)
    except Exception:
        pass
    return logs


def _archive_startup_logs() -> None:
    """Move existing .log files in logs/ into logs/old logs/<timestamp>/."""
    try:
        logs = _ensure_logs_dir()
    except OSError:
        return
    try:
        candidates = (
            entry
            for entry in logs.iterdir()
            if entry.is_file() and entry.name.endswith(".log") and entry.name != "time.log"
        )
        first_entry = next(candidates, None)
    except OSError:
        return
    if first_entry is None:
        return
    entries = [first_entry, *candidates]
    try:
        archive_root = logs / "old logs"
        archive_root.mkdir(parents=True, exist_ok=True)
        stamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
        archive_dir = archive_root / stamp
        archive_dir.mkdir(parents=True, exist_ok=True)
    except OSError:
        return
    for entry in entries:
        try:
            dest = archive_dir / entry.name
            if dest.exists():
                base = entry.stem
                suffix = entry.suffix
                n = 1
                while dest.exists():
                    dest = archive_dir / f"{base}_{n}{suffix}"
                    n += 1
            shutil.move(str(entry), str(dest))
        except OSError:
            pass

def _archive_startup_time_log() -> None:
    """Archive logs/time.log into logs/time/<timestamp>_archived.log when non-empty."""
    try:
        logs = _ensure_logs_dir()
    except OSError:
        return

    time_log = logs / "time.log"
    if not time_log.exists() or not time_log.is_file():
        return

    try:
        has_data = bool((time_log.read_text(encoding="utf-8") or "").strip())
    except OSError:
        return

    if has_data:
        try:
            archive_dir = logs / "time"
            archive_dir.mkdir(parents=True, exist_ok=True)
            stamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
            archived = archive_dir / f"{stamp}_archived.log"
            if archived.exists():
                n = 1
                while archived.exists():
                    archived = archive_dir / f"{stamp}_archived_{n}.log"
                    n += 1
            shutil.move(str(time_log), str(archived))
        except OSError:
            return

    try:
        time_log.parent.mkdir(parents=True, exist_ok=True)
        time_log.write_text("", encoding="utf-8")
    except OSError:
        pass



def _make_ops_logger() -> logging.Logger:
    """Return a logger that writes to terminal + ./logs/operations.log."""
    lg = logging.getLogger("inittracker.ops")
    if getattr(lg, "_inittracker_configured", False):
        return lg

    lg.setLevel(logging.INFO)
    logs = _ensure_logs_dir()
    fmt = logging.Formatter("[%(asctime)s] %(levelname)s %(message)s", "%Y-%m-%d %H:%M:%S")

    try:
        fh = logging.FileHandler(logs / "operations.log", encoding="utf-8")
        fh.setLevel(logging.INFO)
        fh.setFormatter(fmt)
        lg.addHandler(fh)
    except Exception:
        pass

    try:
        sh = logging.StreamHandler()
        sh.setLevel(logging.INFO)
        sh.setFormatter(fmt)
        lg.addHandler(sh)
    except Exception:
        pass

    lg.propagate = False
    setattr(lg, "_inittracker_configured", True)
    return lg


def _make_client_error_logger() -> logging.Logger:
    """Return a logger that writes to ./logs/client_errors.log."""
    lg = logging.getLogger("inittracker.client_errors")
    if getattr(lg, "_inittracker_configured", False):
        return lg

    lg.setLevel(logging.INFO)
    logs = _ensure_logs_dir()
    fmt = logging.Formatter("[%(asctime)s] %(levelname)s %(message)s", "%Y-%m-%d %H:%M:%S")

    try:
        fh = logging.FileHandler(logs / "client_errors.log", encoding="utf-8")
        fh.setLevel(logging.INFO)
        fh.setFormatter(fmt)
        lg.addHandler(fh)
    except Exception:
        pass

    lg.propagate = False
    setattr(lg, "_inittracker_configured", True)
    return lg


def _make_lan_logger() -> logging.Logger:
    """Return a logger that writes to ./logs/lan_server.log."""
    lg = logging.getLogger("inittracker.lan_server")
    if getattr(lg, "_inittracker_configured", False):
        return lg

    lg.setLevel(logging.INFO)
    logs = _ensure_logs_dir()
    fmt = logging.Formatter("[%(asctime)s] %(levelname)s %(message)s", "%Y-%m-%d %H:%M:%S")

    try:
        fh = logging.FileHandler(logs / "lan_server.log", encoding="utf-8")
        fh.setLevel(logging.INFO)
        fh.setFormatter(fmt)
        lg.addHandler(fh)
    except Exception:
        pass

    lg.propagate = False
    setattr(lg, "_inittracker_configured", True)
    return lg


def _normalize_cid_value(
    value: Any,
    context: str = "",
    log_fn: Optional[Callable[[str], None]] = None,
) -> Optional[int]:
    if value is None:
        return None
    if isinstance(value, bool):
        if log_fn:
            log_fn(f"CID normalization skipped bool value for {context}: {value!r}")
        return None
    if isinstance(value, int):
        return value
    if isinstance(value, float):
        if value.is_integer():
            if log_fn:
                log_fn(f"CID normalization coerced float for {context}: {value!r}")
            return int(value)
        if log_fn:
            log_fn(f"CID normalization rejected non-integer float for {context}: {value!r}")
        return None
    if isinstance(value, str):
        trimmed = value.strip()
        if not trimmed:
            return None
        try:
            parsed = int(trimmed)
            if log_fn:
                log_fn(f"CID normalization coerced string for {context}: {value!r}")
            return parsed
        except ValueError:
            try:
                parsed_float = float(trimmed)
            except ValueError:
                parsed_float = None
            if parsed_float is not None and parsed_float.is_integer():
                if log_fn:
                    log_fn(f"CID normalization coerced float string for {context}: {value!r}")
                return int(parsed_float)
        if log_fn:
            log_fn(f"CID normalization rejected string for {context}: {value!r}")
        return None
    if log_fn:
        log_fn(f"CID normalization rejected {type(value).__name__} for {context}: {value!r}")
    return None


def _read_index_file(path: Path) -> Dict[str, Any]:
    try:
        if not path.exists():
            return {}
        raw = json.loads(path.read_text(encoding="utf-8"))
    except Exception:
        return {}
    return raw if isinstance(raw, dict) else {}


def _write_index_file(path: Path, payload: Dict[str, Any]) -> None:
    try:
        path.parent.mkdir(parents=True, exist_ok=True)
        path.write_text(json.dumps(payload, indent=2, sort_keys=True), encoding="utf-8")
    except Exception:
        pass


def _file_stat_metadata(fp: Path) -> Dict[str, object]:
    try:
        stat = fp.stat()
        return {"mtime_ns": stat.st_mtime_ns, "size": stat.st_size}
    except Exception:
        return {"mtime_ns": 0, "size": 0}


def _metadata_matches(entry: Dict[str, object], meta: Dict[str, object]) -> bool:
    return entry.get("mtime_ns") == meta.get("mtime_ns") and entry.get("size") == meta.get("size")


def _parse_fractional_cr(value: str) -> Optional[float]:
    match = re.match(r"^\s*(\d+)\s*/\s*(\d+)\s*$", value)
    if not match:
        return None
    denom = int(match.group(2))
    if denom == 0:
        return None
    return int(match.group(1)) / denom


def _cr_to_float(value: Any) -> Optional[float]:
    """Parse challenge rating values from YAML/JSON sources.

    Supports numbers, fractional strings (e.g. ``"1/2"``), and mixed
    strings that include CR first followed by extra text.
    """
    if isinstance(value, (int, float)):
        return float(value)
    if not isinstance(value, str):
        return None

    text = value.strip()
    if not text:
        return None

    fraction = _parse_fractional_cr(text)
    if fraction is not None:
        return fraction

    try:
        return float(text)
    except ValueError:
        pass

    first_token = text.split(maxsplit=1)[0]
    fraction = _parse_fractional_cr(first_token)
    if fraction is not None:
        return fraction
    try:
        return float(first_token)
    except ValueError:
        return None


def _hash_text(text: str) -> str:
    return hashlib.sha256(text.encode("utf-8")).hexdigest()


def _directory_signature(directory: Path, files: List[Path]) -> Tuple[int, int, Tuple[str, ...]]:
    try:
        stat = directory.stat()
        mtime_ns = int(stat.st_mtime_ns)
    except Exception:
        mtime_ns = 0
    names = tuple(sorted(path.name for path in files))
    return (mtime_ns, len(names), names)


def _files_signature(files: List[Path]) -> Tuple[Tuple[str, int, int], ...]:
    rows: List[Tuple[str, int, int]] = []
    for path in files:
        try:
            stat = path.stat()
            rows.append((path.name, int(stat.st_mtime_ns), int(stat.st_size)))
        except Exception:
            rows.append((path.name, 0, 0))
    return tuple(sorted(rows))


# --- App metadata ---
APP_VERSION = "41"

# --- LAN POC switches ---
POC_AUTO_START_LAN = True
POC_AUTO_SEED_PCS = os.getenv("POC_AUTO_SEED_PCS", "false").lower() == "true"
LAN_TERRAIN_DEBUG = bool(os.getenv("INITTRACKER_LAN_TERRAIN_DEBUG"))

DAMAGE_TYPES = list(base.DAMAGE_TYPES)
if "hellfire" not in {str(dtype).strip().lower() for dtype in DAMAGE_TYPES}:
    DAMAGE_TYPES.append("hellfire")


def _build_damage_type_options(damage_types: List[str]) -> str:
    return "\n".join(
        f'              <option value="{damage_type}">{damage_type}</option>'
        if damage_type
        else '              <option value=""></option>'
        for damage_type in damage_types
    )


DAMAGE_TYPE_OPTIONS = _build_damage_type_options(DAMAGE_TYPES)

# ----------------------------- LAN Server -----------------------------

_LAN_ASSET_DIR = Path(__file__).resolve().parent / "assets" / "web" / "lan"
_CAST_TIME_BONUS_RE = re.compile(r"\bbonus[\s-]*action\b")
_CAST_TIME_REACTION_RE = re.compile(r"\breaction\b")
_CAST_TIME_ACTION_RE = re.compile(r"\baction\b")

_SMITE_SPELL_CONFIG: Dict[str, Dict[str, Any]] = {
    "divine-smite": {"damage_type": "radiant", "base_dice": "2d8", "base_slot": 1, "upcast_die": "1d8"},
    "searing-smite": {
        "damage_type": "fire",
        "base_dice": "1d6",
        "base_slot": 1,
        "upcast_die": "1d6",
        "start_turn_rider": {"dice": "1d6", "type": "fire", "save_ability": "con"},
    },
    "thunderous-smite": {
        "damage_type": "thunder",
        "base_dice": "2d6",
        "base_slot": 1,
        "upcast_die": "1d6",
        "save": {"ability": "str", "apply_prone": True, "push_10ft": True},
    },
    "wrathful-smite": {
        "damage_type": "necrotic",
        "base_dice": "1d6",
        "base_slot": 1,
        "upcast_die": "1d6",
        "save": {"ability": "wis", "condition": "frightened", "repeat_each_turn": True},
    },
    "shining-smite": {"damage_type": "radiant", "base_dice": "2d6", "base_slot": 2, "upcast_die": "1d6"},
    "blinding-smite": {
        "damage_type": "radiant",
        "base_dice": "3d8",
        "base_slot": 3,
        "upcast_die": "1d8",
        "save": {"ability": "con", "condition": "blinded", "repeat_each_turn": True},
    },
    "staggering-smite": {
        "damage_type": "psychic",
        "base_dice": "4d6",
        "base_slot": 4,
        "upcast_die": "1d6",
        "save": {"ability": "wis", "condition": "stunned", "duration_turns": 1},
    },
    "banishing-smite": {
        "damage_type": "force",
        "base_dice": "5d10",
        "base_slot": 5,
        "save": {"ability": "cha", "condition": "incapacitated", "duration_turns": 10, "hp_threshold_max": 50},
    },
}


@lru_cache(maxsize=None)
def _load_lan_asset(name: str) -> str:
    try:
        asset_path = _LAN_ASSET_DIR / name
    except Exception:
        asset_path = Path("assets") / "web" / "lan" / name
    return asset_path.read_text(encoding="utf-8")


HTML_INDEX = _load_lan_asset("index.html").replace("__DAMAGE_TYPE_OPTIONS__", DAMAGE_TYPE_OPTIONS)
SERVICE_WORKER_JS = _load_lan_asset("sw.js")


# ----------------------------- LAN plumbing -----------------------------

@dataclass
class LanConfig:
    host: str = "0.0.0.0"
    port: int = 8787
    vapid_public_key: Optional[str] = None
    vapid_private_key: Optional[str] = None
    vapid_subject: str = "mailto:dm@example.com"
    allowlist: List[str] = field(default_factory=list)
    denylist: List[str] = field(default_factory=list)
    access_file: Optional[str] = None
    admin_password: Optional[str] = None
    yaml_host_assignments_enabled: bool = False

    def __post_init__(self) -> None:
        env_public = os.getenv("INITTRACKER_VAPID_PUBLIC_KEY")
        env_private = os.getenv("INITTRACKER_VAPID_PRIVATE_KEY")
        env_subject = os.getenv("INITTRACKER_VAPID_SUBJECT")
        env_allowlist = os.getenv("INITTRACKER_LAN_ALLOWLIST")
        env_denylist = os.getenv("INITTRACKER_LAN_DENYLIST")
        env_access_file = os.getenv("INITTRACKER_LAN_ACCESS_FILE")
        env_admin_password = os.getenv("INITTRACKER_ADMIN_PASSWORD")
        env_yaml_host_assignments = os.getenv("INITTRACKER_LAN_YAML_HOST_ASSIGNMENTS")
        if env_public:
            self.vapid_public_key = env_public.strip()
        if env_private:
            self.vapid_private_key = env_private.strip()
        if env_subject:
            self.vapid_subject = env_subject.strip()
        if env_access_file:
            self.access_file = env_access_file.strip()
        file_config = self._load_access_file(self.access_file)
        if file_config:
            self.allowlist.extend(file_config.get("allowlist", []))
            self.denylist.extend(file_config.get("denylist", []))
            file_admin_password = str(file_config.get("admin_password") or "").strip()
            if file_admin_password:
                self.admin_password = file_admin_password
        if env_admin_password:
            self.admin_password = env_admin_password.strip()
        self.allowlist.extend(self._parse_access_entries(env_allowlist))
        self.denylist.extend(self._parse_access_entries(env_denylist))
        self.allowlist = self._normalize_access_entries(self.allowlist)
        self.denylist = self._normalize_access_entries(self.denylist)
        if self._parse_env_flag(env_yaml_host_assignments):
            self.yaml_host_assignments_enabled = True


    @staticmethod
    def _parse_env_flag(value: Optional[str]) -> bool:
        if not value:
            return False
        raw = value.strip().lower()
        return raw in ("1", "true", "yes", "y", "on")

    @staticmethod
    def _normalize_access_entries(entries: List[str]) -> List[str]:
        seen = set()
        normalized: List[str] = []
        for entry in entries:
            cleaned = str(entry or "").strip()
            if not cleaned or cleaned in seen:
                continue
            seen.add(cleaned)
            normalized.append(cleaned)
        return normalized

    @staticmethod
    def _parse_access_entries(value: Optional[str]) -> List[str]:
        if not value:
            return []
        raw = value.strip()
        if not raw:
            return []
        if raw.startswith("[") or raw.startswith("{"):
            try:
                parsed = json.loads(raw)
            except Exception:
                parsed = None
            if isinstance(parsed, list):
                return [str(entry).strip() for entry in parsed if str(entry).strip()]
        parts = re.split(r"[,\s]+", raw)
        return [part for part in (p.strip() for p in parts) if part]

    @staticmethod
    def _load_access_file(path: Optional[str]) -> Dict[str, Any]:
        if not path:
            return {}
        file_path = Path(path)
        if not file_path.exists():
            return {}
        try:
            content = file_path.read_text(encoding="utf-8")
        except Exception:
            return {}
        parsed: Any = None
        try:
            parsed = json.loads(content)
        except Exception:
            parsed = None
        if parsed is None:
            yaml_spec = importlib.util.find_spec("yaml")
            if yaml_spec is not None:
                yaml = importlib.import_module("yaml")
                try:
                    parsed = yaml.safe_load(content)
                except Exception:
                    parsed = None
        if isinstance(parsed, list):
            return {"allowlist": [str(entry).strip() for entry in parsed if str(entry).strip()]}
        if isinstance(parsed, dict):
            allowlist = parsed.get("allowlist", []) if isinstance(parsed.get("allowlist", []), list) else []
            denylist = parsed.get("denylist", []) if isinstance(parsed.get("denylist", []), list) else []
            admin_password = parsed.get("admin_password")
            return {
                "allowlist": [str(entry).strip() for entry in allowlist if str(entry).strip()],
                "denylist": [str(entry).strip() for entry in denylist if str(entry).strip()],
                "admin_password": admin_password,
            }
        return {}


@dataclass
class MonsterSpec:
    filename: str
    name: str
    mtype: str
    cr: Optional[float]
    hp: Optional[int]
    speed: Optional[int]
    swim_speed: Optional[int]
    fly_speed: Optional[int]
    burrow_speed: Optional[int]
    climb_speed: Optional[int]
    dex: Optional[int]
    init_mod: Optional[int]
    saving_throws: Dict[str, int]
    ability_mods: Dict[str, int]
    raw_data: Dict[str, Any]


@dataclass
class PlayerProfile:
    name: str
    format_version: int = 0
    identity: Dict[str, Any] = field(default_factory=dict)
    leveling: Dict[str, Any] = field(default_factory=dict)
    abilities: Dict[str, Any] = field(default_factory=dict)
    proficiency: Dict[str, Any] = field(default_factory=dict)
    vitals: Dict[str, Any] = field(default_factory=dict)
    defenses: Dict[str, Any] = field(default_factory=dict)
    attacks: Dict[str, Any] = field(default_factory=dict)
    resources: Dict[str, Any] = field(default_factory=dict)
    spellcasting: Dict[str, Any] = field(default_factory=dict)
    inventory: Dict[str, Any] = field(default_factory=dict)
    features: List[Dict[str, Any]] = field(default_factory=list)
    feature_state: Dict[str, Dict[str, Any]] = field(default_factory=dict)
    feature_effects: Dict[str, List[Dict[str, Any]]] = field(default_factory=dict)
    prepared_wild_shapes: List[str] = field(default_factory=list)
    summon_on_start: List[Dict[str, Any]] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "name": self.name,
            "format_version": self.format_version,
            "identity": dict(self.identity),
            "leveling": dict(self.leveling),
            "abilities": dict(self.abilities),
            "proficiency": dict(self.proficiency),
            "vitals": dict(self.vitals),
            "defenses": dict(self.defenses),
            "attacks": dict(self.attacks),
            "resources": dict(self.resources),
            "spellcasting": dict(self.spellcasting),
            "inventory": dict(self.inventory),
            "features": [dict(entry) for entry in self.features if isinstance(entry, dict)],
            "feature_state": {str(key): dict(value) for key, value in self.feature_state.items() if isinstance(value, dict)},
            "feature_effects": {
                str(key): [dict(entry) for entry in value if isinstance(entry, dict)]
                for key, value in self.feature_effects.items()
                if isinstance(value, list)
            },
            "prepared_wild_shapes": list(self.prepared_wild_shapes),
            "summon_on_start": [dict(entry) for entry in self.summon_on_start if isinstance(entry, dict)],
        }


@dataclass
class LanUrlSettings:
    url_mode: str = "http"
    public_https_url: Optional[str] = None
    public_http_url: Optional[str] = None


class LanController:
    """Runs a FastAPI+WebSocket server in a background thread and bridges actions into the Tk thread."""
    _ACTION_MESSAGE_TYPES = (
        "move",
        "set_facing",
        "dash",
        "perform_action",
        "end_turn",
        "use_action",
        "use_bonus_action",
        "set_color",
        "reset_turn",
        "cast_aoe",
        "cast_spell",
        "echo_summon",
        "echo_swap",
        "aoe_move",
        "aoe_remove",
        "dismiss_summons",
        "reset_player_characters",
        "mount_request",
        "mount_response",
        "echo_tether_response",
        "dismount",
        "initiative_roll",
        "attack_request",
        "spell_target_request",
        "wild_shape_apply",
        "wild_shape_revert",
        "wild_shape_regain_use",
        "wild_shape_regain_spell",
        "wild_shape_pool_set_current",
        "wild_shape_set_known",
        "second_wind_use",
        "action_surge_use",
        "lay_on_hands_use",
        "monk_patient_defense",
        "monk_step_of_wind",
        "monk_elemental_attunement",
        "monk_elemental_burst",
        "monk_uncanny_metabolism",
    )

    def __init__(self, app: "InitiativeTracker") -> None:
        if not isinstance(app, InitiativeTracker):
            raise TypeError("LanController requires an InitiativeTracker app instance.")
        self._tracker = app
        self.cfg = LanConfig()
        self.url_settings = LanUrlSettings()
        self._server_thread: Optional[threading.Thread] = None
        self._loop: Optional[asyncio.AbstractEventLoop] = None
        self._uvicorn_server = None
        self._admin_password_hash: Optional[bytes] = None
        self._admin_password_salt: Optional[bytes] = None
        self._admin_tokens: Dict[str, float] = {}
        self._admin_token_ttl_seconds: int = 15 * 60

        self._clients_lock = threading.RLock()
        self._clients: Dict[int, Any] = {}  # id(websocket) -> websocket
        self._clients_meta: Dict[int, Dict[str, Any]] = {}  # id(websocket) -> {host,port,ua,connected_at}
        self._client_hosts: Dict[int, str] = {}  # id(websocket) -> host
        self._view_only_clients: set[int] = set()
        self._planning_chat_clients: set[int] = set()
        self._claims: Dict[int, int] = {}   # id(websocket) -> cid
        self._cid_to_ws: Dict[int, set[int]] = {}  # cid -> {id(websocket), ...}
        self._cid_to_host: Dict[int, set[str]] = {}  # cid -> {host, ...}
        self._client_ids: Dict[int, str] = {}  # id(websocket) -> client_id
        self._client_id_to_ws: Dict[str, set[int]] = {}  # client_id -> {id(websocket), ...}
        self._client_id_claims: Dict[str, int] = {}  # client_id -> cid
        self._client_claim_revs: Dict[str, int] = {}  # client_id -> monotonically increasing claim revision
        self._ws_claim_revs: Dict[int, int] = {}  # fallback revision tracking for ws sessions without client_id
        self._host_presets: Dict[str, Dict[str, Any]] = self._load_host_presets()
        self._cid_push_subscriptions: Dict[int, List[Dict[str, Any]]] = {}
        self._battle_log_subscribers: set[int] = set()
        self._battle_log_limit_default: int = 200
        self._battle_log_follow_offset: int = 0
        self._battle_log_follow_partial: bytes = b""
        self._battle_log_follow_inode: Optional[Tuple[int, int]] = None
        self._battle_log_follow_size: int = 0
        self._battle_log_follow_last_check: float = 0.0
        self._battle_log_follow_interval_s: float = 0.35
        self._client_error_logger = _make_client_error_logger()
        self._client_log_lock = threading.Lock()
        self._client_log_state: Dict[str, Tuple[float, int]] = {}
        self._client_log_window_s: float = 60.0
        self._client_log_max: int = 30
        self._lan_logger = _make_lan_logger()
        self._lan_log_lock = threading.Lock()
        self._lan_log_buffer = deque(maxlen=2000)
        if os.getenv("LAN_BIND_DEBUG") == "1":
            self._lan_logger.info(
                "LAN_BIND_DEBUG LanController init tracker=%s id=%s",
                type(self._tracker),
                id(self._tracker),
            )

        self._actions: "queue.Queue[Dict[str, Any]]" = queue.Queue()
        self._last_snapshot: Optional[Dict[str, Any]] = None
        self._last_static_json: Optional[str] = None
        self._monster_choices_cache: List[Dict[str, Any]] = []
        self._monster_choices_cache_key: Optional[Tuple[int, int]] = None
        self._last_static_check_ts: float = 0.0
        self._static_check_interval_s: float = 0.9
        self._polling: bool = False
        self._grid_version: int = 0
        self._grid_pending: Dict[int, Tuple[int, float]] = {}
        self._grid_resend_seconds: float = 1.5
        self._grid_last_sent: Optional[Tuple[Optional[int], Optional[int]]] = None
        self._terrain_version: int = 0
        self._terrain_pending: Dict[int, Tuple[int, float]] = {}
        self._terrain_resend_seconds: float = 1.5
        self._ko_round_num: Optional[int] = None
        self._ko_played: bool = False
        self._cached_snapshot: Dict[str, Any] = {
            "grid": None,
            "obstacles": [],
            "units": [],
            "active_cid": None,
            "round_num": 0,
        }
        self._cached_pcs: List[Dict[str, Any]] = []
        self._idle_poll_interval_ms: int = 350
        self._active_poll_interval_ms: int = 120
        self._idle_cache_refresh_interval_s: float = 1.0
        self._last_idle_cache_refresh: float = 0.0
        self._rules_toc_cache_key: Optional[Tuple[str, int, int]] = None
        self._rules_toc_cache_payload: Optional[Dict[str, Any]] = None
        self._init_admin_auth()

    @property
    def tracker(self) -> "InitiativeTracker":
        return self._tracker

    @tracker.setter
    def tracker(self, _value: "InitiativeTracker") -> None:
        raise AttributeError("LanController.tracker is read-only.")

    @property
    def app(self) -> "InitiativeTracker":
        return self._tracker

    @app.setter
    def app(self, _value: "InitiativeTracker") -> None:
        raise AttributeError("LanController.app is read-only.")

    def __setattr__(self, name: str, value: Any) -> None:
        if name == "_tracker" and hasattr(self, "_tracker"):
            if os.getenv("LAN_BIND_DEBUG") == "1":
                stack = traceback.extract_stack(limit=4)
                caller = stack[-2] if len(stack) >= 2 else None
                context = f"{caller.name} ({caller.filename}:{caller.lineno})" if caller else "unknown"
                old_tracker = getattr(self, "_tracker", None)
                self._lan_logger.info(
                    "LAN_BIND_DEBUG LanController tracker rebind blocked "
                    "old=%s id=%s new=%s id=%s context=%s",
                    type(old_tracker),
                    id(old_tracker),
                    type(value),
                    id(value),
                    context,
                )
            raise AttributeError("LanController.tracker is read-only.")
        super().__setattr__(name, value)

    # ---------- Tk thread API ----------

    def _resolve_reverse_dns(self, host: str) -> Optional[str]:
        host = str(host or "").strip()
        if not host:
            return None
        try:
            resolved, _, _ = socket.gethostbyaddr(host)
        except Exception:
            return None
        resolved = str(resolved or "").strip()
        return resolved or None

    def _host_matches_entry(self, host: str, entry: str) -> bool:
        host = str(host or "").strip()
        entry = str(entry or "").strip()
        if not host or not entry:
            return False
        if entry == "*":
            return True
        if "*" in entry:
            return fnmatch.fnmatch(host, entry)
        host_ip: Optional[ipaddress._BaseAddress]
        try:
            host_ip = ipaddress.ip_address(host)
        except ValueError:
            host_ip = None
        if host_ip is not None:
            try:
                network = ipaddress.ip_network(entry, strict=False)
                return host_ip in network
            except ValueError:
                pass
        return host == entry

    def _is_host_allowed(self, host: str) -> bool:
        host = str(host or "").strip()
        if not host:
            return False if self.cfg.allowlist else True
        for entry in self.cfg.denylist:
            if self._host_matches_entry(host, entry):
                return False
        if not self.cfg.allowlist:
            return True
        return any(self._host_matches_entry(host, entry) for entry in self.cfg.allowlist)

    def _init_admin_auth(self) -> None:
        password = str(self.cfg.admin_password or "").strip()
        if not password:
            return
        salt = os.urandom(16)
        self._admin_password_salt = salt
        self._admin_password_hash = self._derive_admin_password_hash(password, salt)
        self.cfg.admin_password = None

    @staticmethod
    def _derive_admin_password_hash(password: str, salt: bytes) -> bytes:
        return hashlib.pbkdf2_hmac("sha256", password.encode("utf-8"), salt, 120_000)

    def _admin_password_matches(self, password: str) -> bool:
        if not self._admin_password_hash or not self._admin_password_salt:
            return False
        candidate = self._derive_admin_password_hash(password, self._admin_password_salt)
        return hmac.compare_digest(candidate, self._admin_password_hash)

    def _issue_admin_token(self) -> str:
        token = secrets.token_urlsafe(32)
        self._admin_tokens[token] = time.time() + float(self._admin_token_ttl_seconds)
        return token

    @staticmethod
    def _json_dumps(payload: Any) -> str:
        def sanitize(value: Any) -> Any:
            if isinstance(value, float):
                return value if math.isfinite(value) else 0.0
            if isinstance(value, dict):
                return {key: sanitize(item) for key, item in value.items()}
            if isinstance(value, list):
                return [sanitize(item) for item in value]
            if isinstance(value, tuple):
                return [sanitize(item) for item in value]
            if isinstance(value, set):
                return [sanitize(item) for item in value]
            return value

        def default(value: Any) -> Any:
            if isinstance(value, Path):
                return str(value)
            if isinstance(value, (set, tuple)):
                return list(value)
            return str(value)

        return json.dumps(sanitize(payload), allow_nan=False, default=default)

    def _is_admin_token_valid(self, token: str) -> bool:
        token = str(token or "").strip()
        if not token:
            return False
        expires = self._admin_tokens.get(token)
        if not expires:
            return False
        now = time.time()
        if expires <= now:
            self._admin_tokens.pop(token, None)
            return False
        return True

    def _require_admin(self, request: "Request") -> None:
        from fastapi import HTTPException

        if not self._admin_password_hash:
            raise HTTPException(status_code=403, detail="Admin password is not configured.")
        header = request.headers.get("authorization", "")
        token = ""
        if header.lower().startswith("bearer "):
            token = header.split(" ", 1)[1].strip()
        if not self._is_admin_token_valid(token):
            raise HTTPException(status_code=401, detail="Unauthorized.")

    def _allow_client_log(self, host: str) -> bool:
        host = str(host or "").strip() or "unknown"
        now = time.time()
        with self._client_log_lock:
            window_start, count = self._client_log_state.get(host, (now, 0))
            if now - window_start >= self._client_log_window_s:
                window_start, count = now, 0
            if count >= self._client_log_max:
                self._client_log_state[host] = (window_start, count)
                return False
            count += 1
            self._client_log_state[host] = (window_start, count)
            return True

    def _log_client_error(self, entry: Dict[str, Any]) -> None:
        try:
            payload = self._json_dumps(entry)
            self._client_error_logger.info(payload)
        except Exception:
            self.app._oplog("Failed to record client error log entry.", level="warning")

    def _append_lan_log(self, message: str, level: str = "error") -> None:
        text = str(message)
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        prefix = f"[{timestamp}] {level.upper()} "
        lines = text.splitlines() or [""]
        try:
            with self._lan_log_lock:
                for line in lines:
                    self._lan_log_buffer.append(f"{prefix}{line}")
        except Exception:
            pass
        try:
            logger = self._lan_logger
            fn = getattr(logger, level, logger.error)
            fn(text)
        except Exception:
            pass

    def _move_debug_log(self, payload: Dict[str, Any], level: str = "info") -> None:
        if os.getenv("LAN_MOVE_DEBUG") != "1":
            return
        try:
            message = self._json_dumps(payload)
        except Exception:
            message = str(payload)
        self._append_lan_log(message, level=level)

    def _spell_debug_log(self, payload: Dict[str, Any], level: str = "info") -> None:
        if os.getenv("LAN_SPELL_DEBUG") != "1":
            return
        try:
            message = self._json_dumps(payload)
        except Exception:
            message = str(payload)
        self._append_lan_log(message, level=level)

    def _log_lan_exception(self, context: str, exc: BaseException) -> None:
        details = traceback.format_exc()
        self._append_lan_log(f"{context}: {exc}\n{details}", level="error")

    @staticmethod
    def _normalize_client_id(value: Any) -> Optional[str]:
        if value is None:
            return None
        if isinstance(value, (dict, list, tuple, set)):
            return None
        text = str(value).strip()
        if not text:
            return None
        if len(text) > 128:
            return None
        return ""

    def _lan_log_lines(self, limit: int = 200) -> List[str]:
        with self._lan_log_lock:
            lines = list(self._lan_log_buffer)
        if limit > 0:
            return lines[-limit:]
        return lines

    def admin_disconnect_session(self, ws_id: int, reason: str = "Disconnected by the DM.") -> None:
        if not self._loop:
            return
        coro = self._disconnect_session_async(int(ws_id), reason)
        try:
            asyncio.run_coroutine_threadsafe(coro, self._loop)
        except Exception:
            pass

    @staticmethod
    def _normalize_push_subscription(subscription: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        if not isinstance(subscription, dict):
            return None
        endpoint = str(subscription.get("endpoint", "") or "").strip()
        keys = subscription.get("keys")
        if not endpoint or not isinstance(keys, dict):
            return None
        p256dh = str(keys.get("p256dh", "") or "").strip()
        auth = str(keys.get("auth", "") or "").strip()
        if not p256dh or not auth:
            return None
        return {"endpoint": endpoint, "keys": {"p256dh": p256dh, "auth": auth}}

    def _save_push_subscription(self, cid: int, subscription: Dict[str, Any]) -> bool:
        sub = self._normalize_push_subscription(subscription)
        if not sub:
            return False
        with self._clients_lock:
            existing = self._cid_push_subscriptions.setdefault(int(cid), [])
            for entry in existing:
                if entry.get("endpoint") == sub["endpoint"]:
                    entry["keys"] = sub["keys"]
                    return True
            existing.append(sub)
        return True

    def _subscriptions_for_cid(self, cid: int) -> List[Dict[str, Any]]:
        with self._clients_lock:
            subs = self._cid_push_subscriptions.get(int(cid), [])
            return [dict(entry) for entry in subs]

    def _remove_push_subscription(self, cid: int, endpoint: str) -> None:
        endpoint = str(endpoint).strip()
        if not endpoint:
            return
        with self._clients_lock:
            subs = self._cid_push_subscriptions.get(int(cid), [])
            self._cid_push_subscriptions[int(cid)] = [
                entry for entry in subs if str(entry.get("endpoint", "")) != endpoint
            ]

    def _host_presets_path(self) -> Path:
        return _ensure_logs_dir() / "lan_gui_presets.json"

    def _load_host_presets(self) -> Dict[str, Dict[str, Any]]:
        data = _read_index_file(self._host_presets_path())
        raw = data.get("presets") if isinstance(data, dict) else None
        presets: Dict[str, Dict[str, Any]] = {}
        if isinstance(raw, dict):
            for host, preset in raw.items():
                key = str(host or "").strip()
                if not key or not isinstance(preset, dict):
                    continue
                presets[key] = preset
        return presets

    def _rules_pdf_status_payload(self) -> Dict[str, Any]:
        path = _resolve_rules_pdf_path()
        default_rel = f"~/{Path('Documents') / USER_YAML_DIRNAME / 'rules' / 'PlayersHandbook2024.pdf'}"
        payload: Dict[str, Any] = {
            "available": False,
            "filename": None,
            "toc_available": False,
            "error": None,
            "expected_path": default_rel,
        }
        if not path:
            payload["error"] = "Rules PDF is not configured."
            return payload
        payload["filename"] = _safe_rules_filename(path)
        try:
            if not path.exists() or not path.is_file():
                payload["error"] = "Rules PDF file was not found."
                return payload
        except Exception:
            payload["error"] = "Unable to access rules PDF file."
            return payload
        payload["available"] = True
        toc_payload = self._rules_pdf_toc_payload(path)
        payload["toc_available"] = bool(toc_payload.get("toc"))
        if toc_payload.get("error"):
            payload["error"] = str(toc_payload.get("error"))
        return payload

    def _rules_pdf_toc_payload(self, path: Optional[Path] = None) -> Dict[str, Any]:
        resolved_path = path or _resolve_rules_pdf_path()
        if not resolved_path:
            return {"available": False, "filename": None, "toc": [], "error": "Rules PDF is not configured."}
        filename = _safe_rules_filename(resolved_path)
        try:
            stat = resolved_path.stat()
            cache_key = (str(resolved_path), int(stat.st_mtime_ns), int(stat.st_size))
        except Exception:
            return {"available": False, "filename": filename, "toc": [], "error": "Rules PDF is unavailable."}
        if self._rules_toc_cache_key == cache_key and isinstance(self._rules_toc_cache_payload, dict):
            return dict(self._rules_toc_cache_payload)
        payload = {"available": True, "filename": filename, "toc": [], "error": None}
        if PdfReader is None:
            payload["error"] = "pypdf dependency is unavailable."
            self._rules_toc_cache_key = cache_key
            self._rules_toc_cache_payload = dict(payload)
            return payload
        try:
            reader = PdfReader(str(resolved_path))
            raw_outline = getattr(reader, "outline", None)
            if raw_outline is None:
                raw_outline = getattr(reader, "outlines", None)
            page_count = len(getattr(reader, "pages", []))
            outline_items = _coerce_outline_items(raw_outline)
            toc = self._normalize_rules_outline(reader, outline_items, page_count)
            payload["toc"] = toc
            if not toc:
                payload["error"] = "No PDF bookmarks found."
        except Exception:
            payload["toc"] = []
            payload["error"] = "Failed to parse PDF bookmarks."
        self._rules_toc_cache_key = cache_key
        self._rules_toc_cache_payload = dict(payload)
        return payload

    def _normalize_rules_outline(self, reader: Any, items: List[Any], page_count: int) -> List[Dict[str, Any]]:
        toc: List[Dict[str, Any]] = []
        current_parent: Optional[Dict[str, Any]] = None
        for item in items:
            if isinstance(item, list):
                if current_parent is None:
                    toc.extend(self._normalize_rules_outline(reader, item, page_count))
                else:
                    current_parent["children"] = self._normalize_rules_outline(reader, item, page_count)
                continue
            node = self._outline_node(reader, item, page_count)
            if node is None:
                continue
            toc.append(node)
            current_parent = node
        return toc

    def _outline_node(self, reader: Any, item: Any, page_count: int) -> Optional[Dict[str, Any]]:
        title = str(getattr(item, "title", "") or "").strip()
        if not title:
            return None
        page_num: Optional[int] = None
        try:
            destination = item
            if hasattr(item, "page"):
                destination = item
            page_index = reader.get_destination_page_number(destination)
            if isinstance(page_index, int) and page_index >= 0:
                page_num = page_index + 1
        except Exception:
            page_num = None
        if page_num is not None and page_count > 0:
            page_num = max(1, min(page_num, page_count))
        return {"title": title, "page": page_num, "children": []}

    def _rules_pdf_log_message(self, prefix: str, path: Optional[Path]) -> None:
        filename = _safe_rules_filename(path) or "unknown"
        found = bool(path)
        self._append_lan_log(f"{prefix} filename={filename} found={found}")

    def start(self, quiet: bool = False) -> None:
        if self._server_thread and self._server_thread.is_alive():
            self.app._oplog("LAN server already runnin'.")
            return

        # Lazy imports so the base app still works without these deps installed.
        try:
            from fastapi import Body, FastAPI, HTTPException, Request, WebSocket, WebSocketDisconnect
            from fastapi.responses import FileResponse, HTMLResponse, RedirectResponse, Response, StreamingResponse
            from fastapi.staticfiles import StaticFiles
            import uvicorn
            # Expose these in module globals so FastAPI's type resolver can see 'em even from nested defs.
            globals()["WebSocket"] = WebSocket
            globals()["WebSocketDisconnect"] = WebSocketDisconnect
            globals()["Request"] = Request
        except Exception as e:
            if quiet:
                self.app._oplog(f"LAN server needs fastapi + uvicorn (missing): {e}")
                return
            messagebox.showerror(
                "LAN Server missing deps",
                f"Arrr, LAN server needs fastapi + uvicorn.\n\nError: {e}",
            )
            return

        self._fastapi_app = FastAPI()
        # Used to bust LAN-client caches for JS/CSS without needing a rebuild.
        app_version = str(APP_VERSION)
        assets_dir = Path(__file__).parent / "assets"
        monster_images_dir = Path(__file__).parent / "Monsters" / "Images"
        monster_images_dir.mkdir(parents=True, exist_ok=True)
        self._fastapi_app.mount("/assets", StaticFiles(directory=assets_dir), name="assets")
        self._fastapi_app.mount("/monsters/images", StaticFiles(directory=monster_images_dir), name="monster-images")
        web_entrypoint = assets_dir / "web" / "new_character" / "index.html"
        edit_entrypoint = assets_dir / "web" / "edit_character" / "index.html"
        required_config_ids = (
            "draft-status",
            "overwrite-button",
            "refresh-cache-button",
            "export-button",
            "filename-input",
            "character-form",
            "character-select",
            "open-character-button",
            "upload-yaml-input",
            "upload-yaml-button",
        )

        def _inject_asset_version(html: str) -> str:
            # HTML shells can reference __APP_VERSION__ in their asset URLs.
            return html.replace("__APP_VERSION__", app_version)

        @self._fastapi_app.middleware("http")
        async def _disable_stale_asset_caching(request: Request, call_next):
            response = await call_next(request)
            path = request.url.path
            # Never cache HTML shells; they decide which JS/CSS to load.
            if path in ("/", "/planning", "/new_character", "/edit_character"):
                response.headers["Cache-Control"] = "no-store"
            # Force revalidation of the web editors so updates show up immediately.
            elif path.startswith("/assets/web/new_character/") or path.startswith("/assets/web/edit_character/"):
                response.headers["Cache-Control"] = "no-cache, must-revalidate"
            return response

        def load_edit_character_html() -> str:
            if not edit_entrypoint.exists():
                raise HTTPException(status_code=404, detail="Edit character page missing.")
            html = _inject_asset_version(edit_entrypoint.read_text(encoding="utf-8"))
            missing = [element_id for element_id in required_config_ids if f'id="{element_id}"' not in html]
            if '/assets/web/edit_character/app.js' not in html:
                missing.append("script:/assets/web/edit_character/app.js")
            if missing:
                raise HTTPException(
                    status_code=500,
                    detail=(
                        "Edit character HTML shell is invalid. Missing required "
                        f"selectors/assets: {', '.join(missing)}"
                    ),
                )
            return html
        for asset_name in ("alert.wav", "ko.wav"):
            if not (assets_dir / asset_name).exists():
                self.app._oplog(
                    f"LAN assets missing {asset_name} at {assets_dir / asset_name} (check assets_dir path).",
                    level="warning",
                )

        @self._fastapi_app.get("/")
        async def index():
            push_key = self.cfg.vapid_public_key
            push_key_value = json.dumps(push_key) if push_key else "undefined"
            html = HTML_INDEX.replace("__PUSH_PUBLIC_KEY__", push_key_value)
            base_url = self.html_injected_base_url()
            html = html.replace("__LAN_BASE_URL__", "undefined" if base_url is None else json.dumps(base_url))
            return HTMLResponse(html)

        @self._fastapi_app.get("/planning")
        async def planning():
            push_key = self.cfg.vapid_public_key
            push_key_value = json.dumps(push_key) if push_key else "undefined"
            html = HTML_INDEX.replace("__PUSH_PUBLIC_KEY__", push_key_value)
            base_url = self.html_injected_base_url()
            html = html.replace("__LAN_BASE_URL__", "undefined" if base_url is None else json.dumps(base_url))
            return HTMLResponse(html)

        @self._fastapi_app.get("/new_character")
        async def new_character():
            if not web_entrypoint.exists():
                raise HTTPException(status_code=404, detail="New character page missing.")
            html = _inject_asset_version(web_entrypoint.read_text(encoding="utf-8"))
            return HTMLResponse(html)

        @self._fastapi_app.get("/edit_character")
        async def edit_character():
            return HTMLResponse(load_edit_character_html())

        @self._fastapi_app.get("/config")
        async def config_redirect():
            return RedirectResponse("/edit_character", status_code=302)

        @self._fastapi_app.get("/sw.js")
        async def service_worker():
            return Response(SERVICE_WORKER_JS, media_type="application/javascript")

        @self._fastapi_app.get("/rules.pdf")
        async def rules_pdf(request: Request):
            host = getattr(getattr(request, "client", None), "host", "")
            if not self._is_host_allowed(host):
                raise HTTPException(status_code=403, detail="Unauthorized host.")
            rules_path = _resolve_rules_pdf_path()
            self._rules_pdf_log_message("rules.pdf request", rules_path)
            if not rules_path:
                raise HTTPException(status_code=404, detail="Rules PDF is not configured.")
            try:
                if not rules_path.exists() or not rules_path.is_file():
                    raise HTTPException(status_code=404, detail="Rules PDF not found.")
                file_size = int(rules_path.stat().st_size)
                common_headers = {"Accept-Ranges": "bytes"}
                range_header = str(request.headers.get("range") or "").strip()
                if not range_header:
                    return FileResponse(path=str(rules_path), media_type="application/pdf", headers=common_headers)

                match = re.fullmatch(r"bytes=(\d*)-(\d*)", range_header)
                if not match:
                    return Response(
                        status_code=416,
                        headers={**common_headers, "Content-Range": f"bytes */{file_size}"},
                    )

                start_text, end_text = match.group(1), match.group(2)
                if start_text:
                    start = int(start_text)
                    end = int(end_text) if end_text else file_size - 1
                elif end_text:
                    suffix_len = int(end_text)
                    if suffix_len <= 0:
                        return Response(
                            status_code=416,
                            headers={**common_headers, "Content-Range": f"bytes */{file_size}"},
                        )
                    start = max(file_size - suffix_len, 0)
                    end = file_size - 1
                else:
                    return Response(
                        status_code=416,
                        headers={**common_headers, "Content-Range": f"bytes */{file_size}"},
                    )

                if start < 0 or start >= file_size or end < start:
                    return Response(
                        status_code=416,
                        headers={**common_headers, "Content-Range": f"bytes */{file_size}"},
                    )

                end = min(end, file_size - 1)
                content_length = end - start + 1

                def iter_rules_pdf_chunks() -> Iterable[bytes]:
                    with rules_path.open("rb") as stream:
                        stream.seek(start)
                        remaining = content_length
                        while remaining > 0:
                            chunk = stream.read(min(65536, remaining))
                            if not chunk:
                                break
                            remaining -= len(chunk)
                            yield chunk

                return StreamingResponse(
                    iter_rules_pdf_chunks(),
                    status_code=206,
                    media_type="application/pdf",
                    headers={
                        **common_headers,
                        "Content-Length": str(content_length),
                        "Content-Range": f"bytes {start}-{end}/{file_size}",
                    },
                )
            except HTTPException:
                raise
            except Exception:
                raise HTTPException(status_code=404, detail="Rules PDF not found.")

        @self._fastapi_app.get("/api/rules/status")
        async def rules_status(request: Request):
            host = getattr(getattr(request, "client", None), "host", "")
            if not self._is_host_allowed(host):
                raise HTTPException(status_code=403, detail="Unauthorized host.")
            return self._rules_pdf_status_payload()

        @self._fastapi_app.get("/api/rules/toc")
        async def rules_toc(request: Request):
            host = getattr(getattr(request, "client", None), "host", "")
            if not self._is_host_allowed(host):
                raise HTTPException(status_code=403, detail="Unauthorized host.")
            path = _resolve_rules_pdf_path()
            if not path:
                return {
                    "available": False,
                    "filename": None,
                    "toc": [],
                    "error": "Rules PDF is not configured.",
                }
            payload = self._rules_pdf_toc_payload(path)
            if "available" not in payload:
                payload["available"] = True
            if "toc" not in payload:
                payload["toc"] = []
            return payload

        @self._fastapi_app.get("/api/rules/spell-pages")
        async def rules_spell_pages(request: Request):
            host = getattr(getattr(request, "client", None), "host", "")
            if not self._is_host_allowed(host):
                raise HTTPException(status_code=403, detail="Unauthorized host.")
            return {"pages": _load_spell_source_page_map()}

        @self._fastapi_app.post("/api/push/subscribe")
        async def push_subscribe(payload: Dict[str, Any] = Body(...)):
            if not isinstance(payload, dict):
                raise HTTPException(status_code=400, detail="Invalid payload.")
            subscription = payload.get("subscription")
            if subscription is None and "endpoint" in payload:
                subscription = payload
            if not isinstance(subscription, dict):
                raise HTTPException(status_code=400, detail="Invalid subscription.")
            player_id = payload.get("playerId")
            try:
                player_id = int(player_id)
            except Exception:
                player_id = None
            if player_id is None:
                raise HTTPException(status_code=404, detail="Unable to resolve player.")
            ok = self._save_push_subscription(player_id, subscription)
            if not ok:
                raise HTTPException(status_code=400, detail="Invalid subscription payload.")
            return {"ok": True, "playerId": player_id}

        @self._fastapi_app.post("/api/admin/login")
        async def admin_login(payload: Dict[str, Any] = Body(...)):
            if not isinstance(payload, dict):
                raise HTTPException(status_code=400, detail="Invalid payload.")
            password = str(payload.get("password") or "")
            if not password:
                raise HTTPException(status_code=400, detail="Missing password.")
            if not self._admin_password_hash:
                raise HTTPException(status_code=403, detail="Admin password is not configured.")
            if not self._admin_password_matches(password):
                raise HTTPException(status_code=401, detail="Invalid password.")
            token = self._issue_admin_token()
            return {"token": token, "expires_in": self._admin_token_ttl_seconds}

        @self._fastapi_app.get("/api/admin/sessions")
        async def admin_sessions(request: Request):
            self._require_admin(request)
            return self._admin_sessions_payload()

        @self._fastapi_app.get("/api/lan/logs")
        async def lan_logs(request: Request, limit: int = 200, full: bool = False):
            self._require_admin(request)
            if full:
                return {"lines": self._lan_battle_log_lines(limit=0)}
            try:
                limit = int(limit)
            except Exception:
                limit = 200
            limit = max(1, min(limit, 1000))
            return {"lines": self._lan_log_lines(limit)}

        @self._fastapi_app.post("/api/client-log")
        async def client_log(request: Request, payload: Dict[str, Any] = Body(...)):
            if not isinstance(payload, dict):
                raise HTTPException(status_code=400, detail="Invalid payload.")
            host = getattr(getattr(request, "client", None), "host", "")
            if not self._is_host_allowed(host):
                raise HTTPException(status_code=403, detail="Unauthorized host.")
            if not self._allow_client_log(host):
                return {"ok": True, "logged": False, "rate_limited": True}
            missing = [
                field
                for field in ("message", "stack", "url", "userAgent", "timestamp")
                if field not in payload
            ]
            if missing:
                raise HTTPException(status_code=400, detail=f"Missing fields: {', '.join(missing)}.")

            def normalize_field(
                name: str,
                value: Any,
                *,
                required: bool = True,
                max_len: int = 2048,
            ) -> str:
                if value is None:
                    if required:
                        raise HTTPException(status_code=400, detail=f"Missing {name}.")
                    return ""
                if isinstance(value, (dict, list)):
                    raise HTTPException(status_code=400, detail=f"Invalid {name}.")
                text = str(value).strip()
                if required and not text:
                    raise HTTPException(status_code=400, detail=f"Missing {name}.")
                if len(text) > max_len:
                    text = text[:max_len]
                return text

            message = normalize_field("message", payload.get("message"), max_len=4000)
            stack = normalize_field("stack", payload.get("stack"), required=False, max_len=20000)
            url = normalize_field("url", payload.get("url"), max_len=2000)
            user_agent = normalize_field("userAgent", payload.get("userAgent"), max_len=512)
            timestamp = normalize_field("timestamp", payload.get("timestamp"), max_len=128)
            entry = {
                "message": message,
                "stack": stack,
                "url": url,
                "userAgent": user_agent,
                "timestamp": timestamp,
                "host": host,
                "received_at": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            }
            self._log_client_error(entry)
            return {"ok": True, "logged": True}

        @self._fastapi_app.get("/api/spells")
        async def list_spells(details: bool = False, raw: bool = False):
            spells_dir = self.app._resolve_spells_dir()
            ids = _scan_spell_ids(spells_dir)
            payload: Dict[str, Any] = {"ids": ids}
            if not details:
                return payload
            spells: List[Dict[str, Any]] = []
            if not spells_dir:
                payload["spells"] = spells
                return payload
            for spell_id in ids:
                text = _read_spell_yaml_text(spells_dir, spell_id)
                if not text:
                    spells.append({"id": spell_id, "raw": None, "parsed": None, "error": "Spell not found."})
                    continue
                entry: Dict[str, Any] = {"id": spell_id, "raw": text}
                if not raw and yaml is not None:
                    try:
                        entry["parsed"] = yaml.safe_load(text)
                    except Exception as exc:
                        entry["parsed"] = None
                        entry["error"] = f"Failed to parse YAML: {exc}"
                spells.append(entry)
            payload["spells"] = spells
            return payload

        @self._fastapi_app.get("/api/spells/{spell_id}")
        async def get_spell(spell_id: str, raw: bool = False):
            spell_id = str(spell_id or "").strip()
            if not spell_id:
                raise HTTPException(status_code=400, detail="Missing spell id.")
            spells_dir = self.app._resolve_spells_dir()
            if not spells_dir:
                raise HTTPException(status_code=404, detail="Spells directory not found.")
            text = _read_spell_yaml_text(spells_dir, spell_id)
            if not text:
                raise HTTPException(status_code=404, detail="Spell not found.")
            payload: Dict[str, Any] = {"id": spell_id, "raw": text}
            if not raw and yaml is not None:
                try:
                    payload["parsed"] = yaml.safe_load(text)
                except Exception as exc:
                    payload["parsed"] = None
                    payload["error"] = f"Failed to parse YAML: {exc}"
            return payload

        @self._fastapi_app.post("/api/spells/{spell_id}/color")
        async def update_spell_color(spell_id: str, payload: Dict[str, Any] = Body(...)):
            if not isinstance(payload, dict):
                raise HTTPException(status_code=400, detail="Invalid payload.")
            spell_id = str(spell_id or "").strip()
            if not spell_id:
                raise HTTPException(status_code=400, detail="Missing spell id.")
            try:
                result = self.app._save_spell_color(spell_id, payload.get("color"))
            except FileNotFoundError:
                raise HTTPException(status_code=404, detail="Spell not found.")
            except ValueError as exc:
                raise HTTPException(status_code=400, detail=str(exc))
            except RuntimeError as exc:
                raise HTTPException(status_code=500, detail=str(exc))
            except Exception:
                raise HTTPException(status_code=500, detail="Failed to save spell color.")
            return {"ok": True, "spell": result}

        @self._fastapi_app.get("/api/characters")
        async def list_characters():
            return {"files": self.app._list_character_filenames()}

        @self._fastapi_app.get("/api/characters/schema")
        async def get_character_schema():
            return {
                "schema": self.app._character_schema_config(),
                "readme_map": self.app._character_schema_readme_map(),
            }
        @self._fastapi_app.post("/api/players/cache/refresh")
        async def refresh_players_cache(payload: Dict[str, Any] = Body(default={})):
            clear_only = bool((payload or {}).get("clear_only", False)) if isinstance(payload, dict) else False
            self.app._yaml_players_refresh_cache(rebuild=not clear_only)
            return {"ok": True, "rebuild": not clear_only}

        @self._fastapi_app.get("/api/players/list")
        async def list_players():
            roster = []
            try:
                profiles = self.app._player_profiles_payload()
                in_combat = {
                    str(getattr(c, "name", "")).strip().lower()
                    for c in self.app.combatants.values()
                    if str(getattr(c, "name", "")).strip()
                }
                for name in sorted(profiles.keys(), key=lambda value: str(value).lower()):
                    profile = profiles.get(name)
                    roster.append(
                        {
                            "name": str(name),
                            "assigned": str(name).strip().lower() in in_combat,
                            "profile": profile if isinstance(profile, dict) else {},
                        }
                    )
            except Exception:
                roster = []
            return {"players": roster}

        @self._fastapi_app.post("/api/encounter/players/add")
        async def add_encounter_players(request: Request, payload: Dict[str, Any] = Body(default={})):
            auth_header = str(request.headers.get("authorization") or "")
            token = ""
            if auth_header.lower().startswith("bearer "):
                token = auth_header.split(" ", 1)[1].strip()
            if not token or not self._is_admin_token_valid(token):
                raise HTTPException(status_code=401, detail="Admin authentication required.")

            names = payload.get("names") if isinstance(payload, dict) else None
            if not isinstance(names, list):
                raise HTTPException(status_code=400, detail="Payload must include a names list.")

            added: List[str] = []
            skipped: List[str] = []
            self.app._yaml_players_refresh_cache(rebuild=True)
            existing = {
                str(getattr(c, "name", "")).strip().lower()
                for c in self.app.combatants.values()
                if str(getattr(c, "name", "")).strip()
            }
            for raw_name in names:
                name = str(raw_name or "").strip()
                if not name:
                    continue
                profile = self.app._player_yaml_data_by_name.get(name)
                if not isinstance(profile, dict):
                    skipped.append(name)
                    continue
                if name.lower() in existing:
                    skipped.append(name)
                    continue
                cid = self.app._create_pc_from_profile(name, profile)
                if isinstance(cid, int):
                    added.append(name)
                    existing.add(name.lower())
                else:
                    skipped.append(name)
            if added:
                try:
                    self.app._rebuild_table(scroll_to_current=True)
                except Exception:
                    pass
            self.app._lan_force_state_broadcast()
            return {"ok": True, "added": added, "skipped": skipped}


        @self._fastapi_app.post("/api/characters/export")
        async def export_character(payload: Dict[str, Any] = Body(...)):
            if not isinstance(payload, dict):
                raise HTTPException(status_code=400, detail="Invalid payload.")
            if yaml is None:
                raise HTTPException(status_code=500, detail="YAML support is not available.")
            data = payload.get("data")
            if data is None:
                raise HTTPException(status_code=400, detail="Missing character data.")
            try:
                text = yaml.safe_dump(data, sort_keys=False, allow_unicode=True)
            except Exception as exc:
                raise HTTPException(status_code=500, detail=f"Unable to export YAML: {exc}")
            return Response(text, media_type="application/x-yaml")

        @self._fastapi_app.get("/api/characters/by_ip")
        async def get_character_by_ip(request: Request):
            host = getattr(getattr(request, "client", None), "host", "")
            name = self._assigned_character_name_for_host(host)
            if not name:
                raise HTTPException(status_code=404, detail="No assigned character.")
            try:
                return self.app._get_character_payload(name)
            except CharacterApiError as exc:
                raise HTTPException(status_code=exc.status_code, detail=exc.detail)

        @self._fastapi_app.get("/api/characters/{name}")
        async def get_character(name: str):
            try:
                return self.app._get_character_payload(name)
            except CharacterApiError as exc:
                raise HTTPException(status_code=exc.status_code, detail=exc.detail)

        @self._fastapi_app.post("/api/characters")
        async def create_character(payload: Dict[str, Any] = Body(...)):
            try:
                return self.app._create_character_payload(payload)
            except CharacterApiError as exc:
                raise HTTPException(status_code=exc.status_code, detail=exc.detail)

        @self._fastapi_app.put("/api/characters/{name}")
        async def update_character(name: str, payload: Dict[str, Any] = Body(...)):
            try:
                return self.app._update_character_payload(name, payload)
            except CharacterApiError as exc:
                raise HTTPException(status_code=exc.status_code, detail=exc.detail)

        @self._fastapi_app.post("/api/characters/{name}/overwrite")
        async def overwrite_character(name: str, payload: Dict[str, Any] = Body(...)):
            try:
                return self.app._overwrite_character_payload(name, payload)
            except CharacterApiError as exc:
                raise HTTPException(status_code=exc.status_code, detail=exc.detail)

        @self._fastapi_app.post("/api/characters/upload")
        async def upload_character(payload: Dict[str, Any] = Body(...)):
            try:
                return self.app._upload_character_yaml_payload(payload)
            except CharacterApiError as exc:
                raise HTTPException(status_code=exc.status_code, detail=exc.detail)

        @self._fastapi_app.post("/api/players/{name}/spells")
        async def update_player_spells(name: str, payload: Dict[str, Any] = Body(...)):
            if not isinstance(payload, dict):
                raise HTTPException(status_code=400, detail="Invalid payload.")
            player_name = str(name or "").strip()
            if not player_name:
                raise HTTPException(status_code=400, detail="Missing player name.")
            try:
                normalized = self.app._save_player_spell_config(player_name, payload)
            except ValueError as exc:
                raise HTTPException(status_code=400, detail=str(exc))
            except RuntimeError as exc:
                raise HTTPException(status_code=500, detail=str(exc))
            except Exception as exc:
                error_details = traceback.format_exc()
                self._append_lan_log(
                    f"LAN player spell save failed for {player_name}: {exc}\n{error_details}",
                    level="error",
                )
                raise HTTPException(status_code=500, detail="Failed to save player spells.")
            return {"ok": True, "player": {"name": player_name, **normalized}}

        @self._fastapi_app.get("/api/monsters/{slug}")
        async def get_monster_stat_block(slug: str, variant: Optional[str] = None, slot_level: Optional[int] = None):
            monster_slug = str(slug or "").strip().lower()
            if not monster_slug:
                raise HTTPException(status_code=400, detail="Missing monster slug.")
            if slot_level is not None and (slot_level < 0 or slot_level > 9):
                raise HTTPException(status_code=400, detail="slot_level must be between 0 and 9.")
            spec = self.app._find_monster_spec_by_slug(monster_slug)
            if spec is None:
                raise HTTPException(status_code=404, detail="Monster not found.")
            mod_spec = self.app._apply_monster_variant(spec, variant, slot_level)
            return {"monster": self.app._monster_stat_block_payload(mod_spec)}

        @self._fastapi_app.post("/api/players/{name}/spellbook")
        async def update_player_spellbook(name: str, payload: Dict[str, Any] = Body(...)):
            if not isinstance(payload, dict):
                raise HTTPException(status_code=400, detail="Invalid payload.")
            player_name = str(name or "").strip()
            if not player_name:
                raise HTTPException(status_code=400, detail="Missing player name.")
            try:
                profile = self.app._save_player_spellbook(player_name, payload)
            except ValueError as exc:
                raise HTTPException(status_code=400, detail=str(exc))
            except RuntimeError as exc:
                raise HTTPException(status_code=500, detail=str(exc))
            except Exception as exc:
                error_details = traceback.format_exc()
                self._append_lan_log(
                    f"LAN player spellbook save failed for {player_name}: {exc}\n{error_details}",
                    level="error",
                )
                raise HTTPException(status_code=500, detail="Failed to save player spellbook.")
            return {"ok": True, "player": profile}

        @self._fastapi_app.websocket("/ws")
        async def ws_endpoint(ws: WebSocket):
            try:
                host = getattr(getattr(ws, "client", None), "host", "?")
                port = getattr(getattr(ws, "client", None), "port", "")
                ua = ""
                try:
                    ua = ws.headers.get("user-agent", "")
                except Exception:
                    ua = ""
                connected_at = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            except Exception:
                host, port, ua, connected_at = "?", "", "", ""
            if not self._is_host_allowed(host):
                await ws.accept()
                await ws.close(code=1008, reason="Unauthorized IP.")
                self.app._oplog(f"LAN session rejected host={host}:{port} ua={ua}", level="warning")
                return

            await ws.accept()
            ws_id = id(ws)
            reverse_dns = self._resolve_reverse_dns(host)

            with self._clients_lock:
                self._clients[ws_id] = ws
                self._clients_meta[ws_id] = {
                    "host": host,
                    "port": port,
                    "ua": ua,
                    "connected_at": connected_at,
                    "last_seen": connected_at,
                    "reverse_dns": reverse_dns,
                }
                self._client_hosts[ws_id] = host
            self.app._oplog(f"LAN session connected ws_id={ws_id} host={host}:{port} ua={ua}")
            try:
                await self._send_grid_update_async(ws_id, self._cached_snapshot.get("grid", {}))
                await self._send_terrain_update_async(ws_id, self._terrain_payload())
                # Send static data first (spell presets, etc.) - only sent once
                await ws.send_text(
                    self._json_dumps({"type": "static_data", "data": self._static_data_payload()})
                )
                # Then send initial state without static data, with personalized "you" field
                you_data = self._build_you_payload(ws_id)
                await ws.send_text(
                    self._json_dumps({
                        "type": "state", 
                        "state": self._dynamic_snapshot_payload(), 
                        "pcs": self._pcs_payload(),
                        "you": you_data
                    })
                )
            except (TypeError, ValueError) as exc:
                error_details = traceback.format_exc()
                self.app._oplog(
                    f"LAN session serialization failed during initial send ws_id={ws_id}: {exc}\n{error_details}",
                    level="warning",
                )
                self._log_lan_exception(
                    f"LAN session serialization failed during initial send ws_id={ws_id}", exc
                )
                await ws.close(code=1011, reason="Server error while preparing state.")
                return
            except Exception as exc:
                error_details = traceback.format_exc()
                self.app._oplog(
                    f"LAN session error during initial send ws_id={ws_id}: {exc}\n{error_details}",
                    level="warning",
                )
                self._log_lan_exception(f"LAN session error during initial send ws_id={ws_id}", exc)
                return
            try:
                while True:
                    raw = await ws.receive_text()
                    try:
                        with self._clients_lock:
                            if ws_id in self._clients_meta:
                                self._clients_meta[ws_id]["last_seen"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    except Exception:
                        pass
                    try:
                        msg = json.loads(raw)
                    except Exception:
                        continue
                    typ = str(msg.get("type") or "")
                    if typ == "client_hello":
                        client_id = self._normalize_client_id(msg.get("client_id"))
                        if not client_id:
                            self._spell_debug_log(
                                {
                                    "event": "client_hello",
                                    "ws_id": ws_id,
                                    "host": host,
                                    "reason": "missing_client_id",
                                }
                            )
                            continue
                        self._register_client_id(ws_id, client_id)
                        with self._clients_lock:
                            self._ws_claim_revs[ws_id] = int(self._client_claim_revs.get(client_id, 0))
                        cached_claim = self._client_claim_for_id(client_id)
                        with self._clients_lock:
                            current_claim = self._claims.get(ws_id)
                        if cached_claim is None:
                            self._spell_debug_log(
                                {
                                    "event": "client_hello",
                                    "ws_id": ws_id,
                                    "host": host,
                                    "client_id": client_id,
                                    "reason": "no_saved_claim",
                                }
                            )
                            continue
                        if current_claim is not None:
                            self._spell_debug_log(
                                {
                                    "event": "client_hello",
                                    "ws_id": ws_id,
                                    "host": host,
                                    "client_id": client_id,
                                    "cid": current_claim,
                                    "reason": "already_claimed",
                                }
                            )
                            continue
                        self._spell_debug_log(
                            {
                                "event": "client_hello",
                                "ws_id": ws_id,
                                "host": host,
                                "client_id": client_id,
                                "cid": cached_claim,
                                "reason": "restoring_claim",
                            }
                        )
                        await self._claim_ws_async(ws_id, int(cached_claim), note="Restored claim.")
                        claim_rev = int(self._client_claim_revs.get(client_id, 0))
                        await self._send_async(
                            ws_id,
                            {
                                "type": "claim_ack",
                                "ok": True,
                                "claimed_cid": int(cached_claim),
                                "claim_rev": claim_rev,
                                "you": self._build_you_payload(ws_id),
                                "reason": "restored_claim",
                            },
                        )
                    elif typ == "save_preset":
                        preset = msg.get("preset")
                        if preset is not None and not isinstance(preset, dict):
                            await ws.send_text(self._json_dumps({"type": "preset_error", "error": "Invalid preset payload."}))
                            continue
                        host_key = self._client_hosts.get(ws_id) or f"ws:{ws_id}"
                        if preset is None:
                            self._host_presets.pop(host_key, None)
                        else:
                            self._host_presets[host_key] = preset
                        self._save_host_presets()
                        await ws.send_text(self._json_dumps({"type": "preset_saved"}))
                    elif typ == "load_preset":
                        host_key = self._client_hosts.get(ws_id) or f"ws:{ws_id}"
                        preset = self._host_presets.get(host_key)
                        await ws.send_text(self._json_dumps({"type": "preset", "preset": preset}))
                    elif typ == "grid_request":
                        await self._send_grid_update_async(ws_id, self._cached_snapshot.get("grid", {}))
                    elif typ == "terrain_request":
                        await self._send_terrain_update_async(ws_id, self._terrain_payload())
                    elif typ == "state_request":
                        await self._send_full_state_async(ws_id)
                    elif typ == "grid_ack":
                        ver = msg.get("version")
                        with self._clients_lock:
                            pending = self._grid_pending.get(ws_id)
                            if pending and pending[0] == ver:
                                self._grid_pending.pop(ws_id, None)
                    elif typ == "terrain_ack":
                        ver = msg.get("version")
                        with self._clients_lock:
                            pending = self._terrain_pending.get(ws_id)
                            if pending and pending[0] == ver:
                                self._terrain_pending.pop(ws_id, None)
                    elif typ == "log_request":
                        try:
                            req_limit = int(msg.get("limit") or self._battle_log_limit_default)
                        except Exception:
                            req_limit = self._battle_log_limit_default
                        try:
                            lines = self.app._lan_battle_log_lines(limit=req_limit)
                        except Exception:
                            lines = []
                        await ws.send_text(self._json_dumps({"type": "battle_log", "lines": lines}))
                    elif typ == "log_subscribe":
                        try:
                            req_limit = int(msg.get("limit") or self._battle_log_limit_default)
                        except Exception:
                            req_limit = self._battle_log_limit_default
                        req_limit = max(1, min(req_limit, 5000))
                        with self._clients_lock:
                            self._battle_log_subscribers.add(ws_id)
                        try:
                            lines = self.app._lan_battle_log_lines(limit=req_limit)
                        except Exception:
                            lines = []
                        await ws.send_text(self._json_dumps({"type": "battle_log", "lines": lines}))
                    elif typ == "log_unsubscribe":
                        with self._clients_lock:
                            self._battle_log_subscribers.discard(ws_id)
                    elif typ == "claim":
                        client_id = self._normalize_client_id(msg.get("client_id"))
                        if not client_id:
                            client_id = self._client_id_for_ws(ws_id)
                        if client_id:
                            self._register_client_id(ws_id, client_id)
                        cid = _normalize_cid_value(
                            msg.get("cid"),
                            "lan_message.cid",
                            log_fn=lambda message: self._append_lan_log(message, level="warning"),
                        )
                        if cid is None:
                            await self._send_async(ws_id, {"type": "toast", "text": "Pick a character first, matey."})
                            _, claim_rev, _ = self._claim_identity_for_ws(ws_id)
                            await self._send_async(
                                ws_id,
                                {
                                    "type": "claim_ack",
                                    "ok": False,
                                    "claimed_cid": None,
                                    "claim_rev": int(claim_rev),
                                    "reason": "missing_cid",
                                },
                            )
                            continue
                        claim_ok = await self._claim_ws_async(ws_id, int(cid), note="Assigned.", allow_override=False)
                        claim_rev: Optional[int] = None
                        if client_id:
                            if claim_ok:
                                claim_rev = self._set_client_claim(client_id, int(cid))
                                with self._clients_lock:
                                    self._ws_claim_revs[ws_id] = int(claim_rev)
                            else:
                                with self._clients_lock:
                                    claim_rev = int(self._client_claim_revs.get(client_id, 0))
                            self._spell_debug_log(
                                {
                                    "event": "claim",
                                    "ws_id": ws_id,
                                    "host": host,
                                    "client_id": client_id,
                                    "cid": int(cid),
                                }
                            )
                            other_ws_ids = self._ws_ids_for_client_id(client_id)
                            for other_ws_id in other_ws_ids:
                                if other_ws_id == ws_id:
                                    continue
                                await self._claim_ws_async(
                                    other_ws_id,
                                    int(cid),
                                    note="Synced claim.",
                                    allow_override=False,
                                )
                                if claim_rev is not None:
                                    with self._clients_lock:
                                        self._ws_claim_revs[other_ws_id] = int(claim_rev)
                        else:
                            if claim_ok:
                                claim_rev = self._next_claim_rev_for_ws(ws_id)
                            self._spell_debug_log(
                                {
                                    "event": "claim",
                                    "ws_id": ws_id,
                                    "host": host,
                                    "cid": int(cid),
                                    "reason": "missing_client_id",
                                }
                            )
                        effective_cid, effective_rev, _ = self._claim_identity_for_ws(ws_id)
                        await self._send_async(
                            ws_id,
                            {
                                "type": "claim_ack",
                                "ok": bool(claim_ok),
                                "claimed_cid": int(effective_cid) if effective_cid is not None else None,
                                "claim_rev": int(effective_rev),
                                "you": self._build_you_payload(ws_id),
                                "reason": "ok" if claim_ok else "rejected",
                            },
                        )
                    elif typ == "unclaim":
                        claim_rev = await self._unclaim_ws_async(ws_id, reason="Unclaimed", clear_ownership=False)
                        client_id = self._normalize_client_id(msg.get("client_id")) or self._client_id_for_ws(ws_id)
                        if client_id:
                            self._spell_debug_log(
                                {
                                    "event": "unclaim",
                                    "ws_id": ws_id,
                                    "host": host,
                                    "client_id": client_id,
                                }
                            )
                        _, effective_rev, _ = self._claim_identity_for_ws(ws_id)
                        await self._send_async(
                            ws_id,
                            {
                                "type": "unclaim_ack",
                                "ok": True,
                                "claimed_cid": None,
                                "claim_rev": int(effective_rev if effective_rev is not None else (claim_rev or 0)),
                                "you": self._build_you_payload(ws_id),
                            },
                        )
                    elif typ == "planning_hello":
                        with self._clients_lock:
                            self._planning_chat_clients.add(ws_id)
                    elif typ == "planning_chat":
                        with self._clients_lock:
                            if ws_id not in self._planning_chat_clients:
                                continue
                        text = str(msg.get("text") or "").strip()
                        if not text:
                            continue
                        if len(text) > 500:
                            text = text[:500]
                        display_name = self._assigned_character_name_for_host(host)
                        if not display_name or str(display_name).startswith("cid:"):
                            display_name = str(host or "?")
                        payload = {
                            "type": "planning_chat",
                            "ts": datetime.utcnow().isoformat() + "Z",
                            "host": str(host or "?"),
                            "name": str(display_name),
                            "text": text,
                        }
                        with self._clients_lock:
                            targets = list(self._planning_chat_clients)
                        for target_ws_id in targets:
                            await self._send_async(target_ws_id, payload)
                    elif typ in self._ACTION_MESSAGE_TYPES:
                        # enqueue for Tk thread
                        with self._clients_lock:
                            claimed_cid = self._claims.get(ws_id)
                        if typ == "move":
                            to = msg.get("to") or {}
                            self._move_debug_log(
                                {
                                    "event": "lan_move_received",
                                    "type": typ,
                                    "ws_id": ws_id,
                                    "host": host,
                                    "_claimed_cid": claimed_cid,
                                    "cid": msg.get("cid"),
                                    "to": {"col": to.get("col"), "row": to.get("row")},
                                },
                                level="info",
                            )
                        msg["_claimed_cid"] = claimed_cid
                        msg["_ws_id"] = ws_id
                        self._actions.put(msg)
                    elif typ == "toast":
                        # Client wants a toast? ignore
                        pass
            except WebSocketDisconnect:
                pass
            except Exception as exc:
                self.app._oplog(f"LAN session error during loop ws_id={ws_id}: {exc}", level="warning")
                self._log_lan_exception(f"LAN session error during loop ws_id={ws_id}", exc)
            finally:
                with self._clients_lock:
                    self._clients.pop(ws_id, None)
                    self._clients_meta.pop(ws_id, None)
                    self._client_hosts.pop(ws_id, None)
                    self._ws_claim_revs.pop(ws_id, None)
                    self._view_only_clients.discard(ws_id)
                    self._planning_chat_clients.discard(ws_id)
                    self._battle_log_subscribers.discard(ws_id)
                    client_id = self._client_ids.pop(ws_id, None)
                    if client_id:
                        ws_set = self._client_id_to_ws.get(client_id)
                        if ws_set is not None:
                            ws_set.discard(ws_id)
                            if not ws_set:
                                self._client_id_to_ws.pop(client_id, None)
                    old = self._drop_claim(ws_id)
                    self._grid_pending.pop(ws_id, None)
                    self._terrain_pending.pop(ws_id, None)
                if old is not None:
                    name = self._tracker._pc_name_for(int(old))
                    self.app._oplog(f"LAN session disconnected ws_id={ws_id} (claimed {name})")
                else:
                    self.app._oplog(f"LAN session disconnected ws_id={ws_id}")

        # Start uvicorn server in a thread (with its own event loop).
        try:
            self._cached_snapshot = self.app._lan_snapshot(include_static=False, hydrate_static=False)
            self._cached_pcs = list(
                self.app._lan_pcs() if hasattr(self.app, "_lan_pcs") else self.app._lan_claimable()
            )
        except Exception:
            pass
        def run_server():
            # Create fresh loop for this thread
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            self._loop = loop

            config = uvicorn.Config(self._fastapi_app, host=self.cfg.host, port=self.cfg.port, log_level="warning", access_log=False)
            server = uvicorn.Server(config)
            self._uvicorn_server = server
            loop.run_until_complete(server.serve())

        self._server_thread = threading.Thread(target=run_server, name="InitTrackerLAN", daemon=True)
        self._server_thread.start()

        # Start Tk polling for actions and state broadcasts
        if not self._polling:
            self._polling = True
            self.app.after(60, self._tick)

        url = self._best_lan_url()
        self.app._oplog(f"LAN server hoisted at {url}  (open on yer phone, matey)")

    def stop(self) -> None:
        # Ask uvicorn to stop
        if self._uvicorn_server is not None:
            try:
                self._uvicorn_server.should_exit = True
            except Exception:
                pass
        self.app._oplog("LAN server be lowerin' sails (stoppin').")

    def notify_turn_start(self, cid: int, round_num: int, turn_num: int) -> None:
        """Send push notification for the newly active combatant (if subscribed)."""
        try:
            cid = int(cid)
        except Exception:
            return
        worker = threading.Thread(
            target=self._dispatch_turn_notification,
            args=(cid, int(round_num), int(turn_num)),
            daemon=True,
        )
        worker.start()

    def _dispatch_turn_notification(self, cid: int, round_num: int, turn_num: int) -> None:
        try:
            name = self._tracker._pc_name_for(cid)
        except Exception:
            name = f"cid:{cid}"
        subscriptions = self._subscriptions_for_cid(cid)
        if subscriptions:
            payload = {
                "title": "Your turn!",
                "body": f"{name} is up (round {round_num}, turn {turn_num}).",
                "url": "/",
            }
            invalid = self._send_push_notifications(subscriptions, payload)
            for endpoint in invalid:
                self._remove_push_subscription(cid, endpoint)

        try:
            next_cid = self._next_turn_notification_target(cid)
        except Exception:
            next_cid = None
        if next_cid is None or next_cid == cid:
            return
        next_subscriptions = self._subscriptions_for_cid(next_cid)
        if not next_subscriptions:
            return
        up_next_payload = {
            "title": "You're up next",
            "body": f"{name}'s turn started — you're next. Plan your move.",
            "url": "/",
        }
        invalid_next = self._send_push_notifications(next_subscriptions, up_next_payload)
        for endpoint in invalid_next:
            self._remove_push_subscription(next_cid, endpoint)

    def _next_turn_notification_target(self, cid: int) -> Optional[int]:
        try:
            current_cid = int(cid)
        except Exception:
            return None
        ordered = self._tracker._display_order()
        ids = [int(c.cid) for c in ordered if getattr(c, "cid", None) is not None]
        if len(ids) <= 1 or current_cid not in ids:
            return None
        start_index = ids.index(current_cid)
        for offset in range(1, len(ids)):
            candidate = ids[(start_index + offset) % len(ids)]
            try:
                if self._tracker._should_skip_turn(candidate):
                    continue
            except Exception:
                pass
            return candidate
        return None

    def _send_push_notifications(self, subscriptions: List[Dict[str, Any]], payload: Dict[str, Any]) -> List[str]:
        if not subscriptions:
            return []
        try:
            from pywebpush import webpush, WebPushException  # type: ignore
        except Exception as exc:
            self.app._oplog(f"Push notifications unavailable (pywebpush missing): {exc}", level="warning")
            return []
        if not self.cfg.vapid_private_key or not self.cfg.vapid_public_key:
            self.app._oplog(
                "Push notifications skipped (missing VAPID keys). Set INITTRACKER_VAPID_PUBLIC_KEY/PRIVATE_KEY.",
                level="warning",
            )
            return []
        invalid: List[str] = []
        data = json.dumps(payload)
        for sub in subscriptions:
            endpoint = str(sub.get("endpoint", "") or "").strip()
            keys = sub.get("keys") if isinstance(sub, dict) else None
            if not endpoint or not isinstance(keys, dict):
                continue
            p256dh = str(keys.get("p256dh", "") or "").strip()
            auth = str(keys.get("auth", "") or "").strip()
            if not p256dh or not auth:
                continue
            subscription_info = {"endpoint": endpoint, "keys": {"p256dh": p256dh, "auth": auth}}
            try:
                webpush(
                    subscription_info,
                    data=data,
                    vapid_private_key=self.cfg.vapid_private_key,
                    vapid_claims={"sub": self.cfg.vapid_subject},
                )
            except WebPushException as exc:
                status_code = getattr(getattr(exc, "response", None), "status_code", None)
                if status_code in (404, 410):
                    invalid.append(endpoint)
                else:
                    self.app._oplog(f"Push send failed for {endpoint}: {exc}", level="warning")
            except Exception as exc:
                self.app._oplog(f"Push send failed for {endpoint}: {exc}", level="warning")
        return invalid

    # ---------- Sessions / Claims (Tk thread safe) ----------

    def sessions_snapshot(self) -> List[Dict[str, Any]]:
        """Return a best-effort list of connected clients + who they claim."""
        out: List[Dict[str, Any]] = []
        with self._clients_lock:
            for ws_id, ws in list(self._clients.items()):
                meta = dict(self._clients_meta.get(ws_id, {}))
                cid = self._claims.get(ws_id)
                host = meta.get("host", "?")
                reverse_dns = meta.get("reverse_dns")
                if reverse_dns is None and host not in ("", "?"):
                    reverse_dns = self._resolve_reverse_dns(host)
                    if ws_id in self._clients_meta:
                        self._clients_meta[ws_id]["reverse_dns"] = reverse_dns
                claimed_name = self._tracker._pc_name_for(int(cid)) if isinstance(cid, int) else None
                out.append(
                    {
                        "ws_id": int(ws_id),
                        "cid": int(cid) if cid is not None else None,
                        "claimed_name": claimed_name if claimed_name and not claimed_name.startswith("cid:") else None,
                        "host": host,
                        "port": meta.get("port", ""),
                        "user_agent": meta.get("ua", ""),
                        "connected_at": meta.get("connected_at", ""),
                        "last_seen": meta.get("last_seen", meta.get("connected_at", "")),
                        "reverse_dns": reverse_dns,
                        "status": "connected",
                    }
                )
        out.sort(key=lambda s: int(s.get("ws_id", 0)))
        return out

    def _pc_exists(self, cid: int) -> bool:
        try:
            cid = int(cid)
        except Exception:
            return False
        pcs = {int(p.get("cid")) for p in self._cached_pcs if isinstance(p.get("cid"), int)}
        return cid in pcs

    def _admin_sessions_payload(self) -> Dict[str, Any]:
        sessions = self.sessions_snapshot()
        for entry in sessions:
            entry["ip"] = entry.get("host")
        sessions.sort(key=lambda s: str(s.get("ip", "")))
        pcs_payload = [
            {"cid": int(p.get("cid")), "name": str(p.get("name", ""))}
            for p in self._cached_pcs
            if isinstance(p.get("cid"), int)
        ]
        pcs_payload.sort(key=lambda p: str(p.get("name", "")).lower())
        return {"sessions": sessions, "pcs": pcs_payload}

    def admin_sessions_payload(self) -> Dict[str, Any]:
        """Return admin sessions payload for both web and DM-side tooling."""
        return self._admin_sessions_payload()

    def assign_session(self, ws_id: int, cid: Optional[int], note: str = "Assigned by the DM.") -> None:
        """DM assigns a PC to a session (or clears assignment if cid is None)."""
        if not self._loop:
            return
        coro = self._assign_session_async(int(ws_id), cid, note)
        try:
            asyncio.run_coroutine_threadsafe(coro, self._loop)
        except Exception:
            pass

    async def _assign_session_async(self, ws_id: int, cid: Optional[int], note: str) -> None:
        with self._clients_lock:
            ws = self._clients.get(ws_id)
        if not ws:
            return
        if cid is None:
            # unclaim
            await self._unclaim_ws_async(ws_id, reason=note, clear_ownership=False)
            return
        await self._claim_ws_async(ws_id, int(cid), note=note, allow_override=True)

    async def _disconnect_session_async(self, ws_id: int, reason: str) -> None:
        with self._clients_lock:
            ws = self._clients.get(ws_id)
        if not ws:
            return
        try:
            await self._unclaim_ws_async(ws_id, reason=reason, clear_ownership=False)
        except Exception:
            pass
        try:
            await ws.close(code=1000)
        except Exception:
            pass

    def _tick(self) -> None:
        """Runs on Tk thread: process actions and broadcast state when changed."""
        move_debug_entries: List[Dict[str, Any]] = []
        should_schedule_next = True
        next_tick_ms = int(self._active_poll_interval_ms)
        try:
            # 1) process queued actions from clients
            processed_any = False
            while True:
                try:
                    msg = self._actions.get_nowait()
                except queue.Empty:
                    break
                processed_any = True
                try:
                    typ = str(msg.get("type") or "")
                    if typ == "move":
                        to = msg.get("to") or {}
                        self._move_debug_log(
                            {
                                "event": "lan_move_dequeued",
                                "type": typ,
                                "ws_id": msg.get("_ws_id"),
                                "_claimed_cid": msg.get("_claimed_cid"),
                                "cid": msg.get("cid"),
                                "to": {"col": to.get("col"), "row": to.get("row")},
                            },
                            level="info",
                        )
                        self._move_debug_log(
                            {
                                "event": "lan_move_apply_call",
                                "type": typ,
                                "ws_id": msg.get("_ws_id"),
                                "_claimed_cid": msg.get("_claimed_cid"),
                                "cid": msg.get("cid"),
                            },
                            level="info",
                        )
                    if os.getenv("LAN_BIND_DEBUG") == "1":
                        self.app._oplog(
                            "LAN_BIND_DEBUG _tick apply_action: "
                            f"app_type={type(self.app)} app_id={id(self.app)} "
                            f"has_apply_action={hasattr(self.app, '_lan_apply_action')} "
                            f"has_pc_name_for={hasattr(self.app, '_pc_name_for')}",
                            level="debug",
                        )
                    self._tracker._lan_apply_action(msg)
                    if typ == "move":
                        move_debug_entries.append(
                            {
                                "ws_id": msg.get("_ws_id"),
                                "_claimed_cid": msg.get("_claimed_cid"),
                                "cid": msg.get("cid"),
                                "applied": msg.get("_move_applied"),
                                "reject_reason": msg.get("_move_reject_reason"),
                            }
                        )
                except Exception as exc:
                    ws_id = msg.get("_ws_id")
                    error_details = traceback.format_exc()
                    self.app._oplog(f"LAN action failed: {exc}\n{error_details}", level="warning")
                    self._append_lan_log(f"LAN action failed: {exc}\n{error_details}", level="error")
                    try:
                        self.toast(ws_id, "Something went wrong handling that action.")
                    except Exception:
                        pass

            with self._clients_lock:
                has_live_clients = bool(self._clients)
                has_battle_log_subscribers = bool(self._battle_log_subscribers)

            if has_battle_log_subscribers:
                self._poll_battle_log_updates()

            # Keep idle polling cheap for the DM UI: when no clients are connected and no
            # actions are queued, avoid rebuilding/broadcasting snapshots every 120ms.
            if not has_live_clients and not processed_any:
                next_tick_ms = int(self._idle_poll_interval_ms)
                now = time.monotonic()
                if now - self._last_idle_cache_refresh >= self._idle_cache_refresh_interval_s:
                    self._last_idle_cache_refresh = now
                    self._cached_snapshot = self.app._lan_snapshot(include_static=False, hydrate_static=False)
                    try:
                        self._cached_pcs = list(
                            self.app._lan_pcs() if hasattr(self.app, "_lan_pcs") else self.app._lan_claimable()
                        )
                    except Exception as exc:
                        self._cached_pcs = []
                        self._log_lan_exception("LAN cached PC snapshot failed", exc)
                return

            # 2) broadcast snapshot if changed (polling-based, avoids wiring every hook)
            snap = self.app._lan_snapshot(include_static=False)
            self._cached_snapshot = snap
            try:
                self._cached_pcs = list(
                    self.app._lan_pcs() if hasattr(self.app, "_lan_pcs") else self.app._lan_claimable()
                )
            except Exception as exc:
                self._cached_pcs = []
                self._log_lan_exception("LAN cached PC snapshot failed", exc)
            grid = snap.get("grid", {}) if isinstance(snap, dict) else {}
            if isinstance(grid, dict):
                cols = grid.get("cols")
                rows = grid.get("rows")
                if self._grid_last_sent != (cols, rows):
                    self._grid_version += 1
                    self._grid_last_sent = (cols, rows)
                    self._broadcast_grid_update(grid)
            prev_snap = self._last_snapshot or {}
            if self._last_snapshot is None:
                self._last_snapshot = copy.deepcopy(snap)
                if move_debug_entries:
                    for entry in move_debug_entries:
                        self._move_debug_log(
                            {
                                "event": "lan_move_broadcast",
                                "ws_id": entry.get("ws_id"),
                                "_claimed_cid": entry.get("_claimed_cid"),
                                "cid": entry.get("cid"),
                                "applied": entry.get("applied"),
                                "reject_reason": entry.get("reject_reason"),
                                "units_snapshot_sent": False,
                                "unit_updates_count": 0,
                                "terrain_patch_sent": False,
                                "aoe_patch_sent": False,
                                "initial_snapshot_only": True,
                            },
                            level="info",
                        )
            else:
                turn_update = self._build_turn_update(prev_snap, snap)
                if turn_update:
                    self._broadcast_payload({"type": "turn_update", **turn_update})

                units_snapshot, unit_updates = self._build_unit_updates(prev_snap, snap)
                if units_snapshot is not None:
                    self._broadcast_payload({"type": "units_snapshot", "units": units_snapshot})
                elif unit_updates:
                    self._broadcast_payload({"type": "unit_update", "updates": unit_updates})

                terrain_patch = self._build_terrain_patch(prev_snap, snap)
                if terrain_patch:
                    self._broadcast_payload({"type": "terrain_patch", **terrain_patch})
                    self._apply_terrain_patch_to_map(terrain_patch)

                aoe_patch = self._build_aoe_patch(prev_snap, snap)
                if aoe_patch:
                    self._broadcast_payload({"type": "aoe_patch", **aoe_patch})

                if move_debug_entries:
                    for entry in move_debug_entries:
                        self._move_debug_log(
                            {
                                "event": "lan_move_broadcast",
                                "ws_id": entry.get("ws_id"),
                                "_claimed_cid": entry.get("_claimed_cid"),
                                "cid": entry.get("cid"),
                                "applied": entry.get("applied"),
                                "reject_reason": entry.get("reject_reason"),
                                "units_snapshot_sent": units_snapshot is not None,
                                "unit_updates_count": len(unit_updates),
                                "terrain_patch_sent": bool(terrain_patch),
                                "aoe_patch_sent": bool(aoe_patch),
                            },
                            level="info",
                        )

                self._last_snapshot = copy.deepcopy(snap)

            now = time.monotonic()
            static_check_due = bool(processed_any)
            if not static_check_due:
                static_check_due = (
                    now - float(getattr(self, "_last_static_check_ts", 0.0))
                    >= float(getattr(self, "_static_check_interval_s", 0.9))
                )
            if static_check_due:
                self._last_static_check_ts = now
                static_payload: Optional[Dict[str, Any]] = None
                static_json: Optional[str] = None
                static_build_ms = 0.0
                static_json_ms = 0.0
                monster_choices_count = 0
                try:
                    build_start = time.perf_counter()
                    static_payload = self._static_data_payload()
                    static_build_ms = (time.perf_counter() - build_start) * 1000.0
                    json_start = time.perf_counter()
                    static_json = json.dumps(static_payload, sort_keys=True, separators=(",", ":"))
                    static_json_ms = (time.perf_counter() - json_start) * 1000.0
                    monster_choices_count = len(static_payload.get("monster_choices", []))
                except Exception as exc:
                    self._log_lan_exception("LAN static payload build failed", exc)
                if os.getenv("LAN_PERF_DEBUG") == "1":
                    self._lan_logger.info(
                        "LAN_PERF static_check build_ms=%.2f json_ms=%.2f monster_choices=%d",
                        static_build_ms,
                        static_json_ms,
                        monster_choices_count,
                    )
                if static_payload is not None and static_json is not None:
                    if self._last_static_json is None:
                        self._last_static_json = static_json
                    elif static_json != self._last_static_json:
                        self._last_static_json = static_json
                        self._broadcast_payload({"type": "static_data", "data": static_payload})
        except KeyboardInterrupt:
            should_schedule_next = False
            self._polling = False
            try:
                self.stop()
            except Exception:
                pass
            try:
                self.app.quit()
            except Exception:
                pass
        except Exception as exc:
            self._log_lan_exception("LAN tick error", exc)
        finally:
            # 3) continue polling
            if should_schedule_next and self._polling:
                self.app.after(next_tick_ms, self._tick)

    def _poll_battle_log_updates(self) -> None:
        now = time.monotonic()
        if now - self._battle_log_follow_last_check < self._battle_log_follow_interval_s:
            return
        self._battle_log_follow_last_check = now
        path = self.app._history_file_path()
        try:
            st = path.stat()
        except Exception:
            return
        inode = (int(getattr(st, "st_dev", 0)), int(getattr(st, "st_ino", 0)))
        size = int(getattr(st, "st_size", 0))
        if self._battle_log_follow_inode is None:
            self._battle_log_follow_inode = inode
            self._battle_log_follow_offset = size
            self._battle_log_follow_size = size
            self._battle_log_follow_partial = b""
            return
        rotated = inode != self._battle_log_follow_inode
        truncated = size < self._battle_log_follow_offset
        if rotated or truncated:
            self._battle_log_follow_inode = inode
            self._battle_log_follow_offset = size
            self._battle_log_follow_size = size
            self._battle_log_follow_partial = b""
            self._broadcast_battle_log_snapshot()
            return
        if size <= self._battle_log_follow_offset:
            self._battle_log_follow_size = size
            return
        start = self._battle_log_follow_offset
        try:
            with path.open("rb") as fh:
                fh.seek(start)
                chunk = fh.read(max(0, size - start))
        except Exception:
            return
        self._battle_log_follow_offset = size
        self._battle_log_follow_size = size
        if not chunk and not self._battle_log_follow_partial:
            return
        data = self._battle_log_follow_partial + chunk
        raw_lines = data.splitlines(keepends=True)
        complete: List[bytes] = []
        trailing_partial = b""
        for raw_line in raw_lines:
            if raw_line.endswith((b"\n", b"\r")):
                complete.append(raw_line)
            else:
                trailing_partial = raw_line
        self._battle_log_follow_partial = trailing_partial
        if not complete:
            return
        try:
            lines = [line.decode("utf-8", errors="ignore").rstrip("\r\n") for line in complete]

        except Exception:
            return
        if lines:
            self._broadcast_battle_log_append(lines)

    def _broadcast_battle_log_snapshot(self, limit: Optional[int] = None) -> None:
        if limit is None:
            limit = self._battle_log_limit_default
        try:
            lines = self.app._lan_battle_log_lines(limit=int(limit))
        except Exception:
            lines = []
        self._broadcast_battle_log_payload({"type": "battle_log", "lines": lines})

    def _broadcast_battle_log_append(self, lines: List[str]) -> None:
        if not lines:
            return
        self._broadcast_battle_log_payload({"type": "battle_log_append", "lines": lines})

    def _broadcast_battle_log_payload(self, payload: Dict[str, Any]) -> None:
        if not self._loop:
            return
        coro = self._broadcast_battle_log_payload_async(payload)
        try:
            asyncio.run_coroutine_threadsafe(coro, self._loop)
        except Exception as exc:
            self._log_lan_exception("LAN battle log payload scheduling failed", exc)

    async def _broadcast_battle_log_payload_async(self, payload: Dict[str, Any]) -> None:
        try:
            text = self._json_dumps(payload)
        except Exception as exc:
            self._log_lan_exception("LAN battle log payload serialization failed", exc)
            return
        to_drop: List[int] = []
        with self._clients_lock:
            subscriber_ids = list(self._battle_log_subscribers)
            items = [(ws_id, self._clients.get(ws_id)) for ws_id in subscriber_ids]
        for ws_id, ws in items:
            if ws is None:
                to_drop.append(ws_id)
                continue
            try:
                await ws.send_text(text)
            except Exception as exc:
                to_drop.append(ws_id)
                self._log_lan_exception(f"LAN battle log send failed ws_id={ws_id}", exc)
        if to_drop:
            with self._clients_lock:
                for ws_id in to_drop:
                    self._battle_log_subscribers.discard(ws_id)

    @staticmethod
    def _unit_lookup(units: Any) -> Dict[int, Dict[str, Any]]:
        lookup: Dict[int, Dict[str, Any]] = {}
        if not isinstance(units, list):
            return lookup
        for unit in units:
            if not isinstance(unit, dict):
                continue
            try:
                cid = int(unit.get("cid"))
            except Exception:
                continue
            lookup[cid] = unit
        return lookup

    @staticmethod
    def _rough_lookup(rough: Any) -> Dict[Tuple[int, int], Dict[str, Any]]:
        lookup: Dict[Tuple[int, int], Dict[str, Any]] = {}
        if not isinstance(rough, list):
            return lookup
        for cell in rough:
            if not isinstance(cell, dict):
                continue
            try:
                key = (int(cell.get("col")), int(cell.get("row")))
            except Exception:
                continue
            lookup[key] = cell
        return lookup

    @staticmethod
    def _obstacle_lookup(obstacles: Any) -> set[Tuple[int, int]]:
        out: set[Tuple[int, int]] = set()
        if not isinstance(obstacles, list):
            return out
        for entry in obstacles:
            if not isinstance(entry, dict):
                continue
            try:
                out.add((int(entry.get("col")), int(entry.get("row"))))
            except Exception:
                continue
        return out

    def _build_turn_update(self, prev: Dict[str, Any], curr: Dict[str, Any]) -> Dict[str, Any]:
        update: Dict[str, Any] = {}
        if prev.get("active_cid") != curr.get("active_cid"):
            update["active_cid"] = curr.get("active_cid")
        if prev.get("round_num") != curr.get("round_num"):
            update["round_num"] = curr.get("round_num")
        if prev.get("turn_order") != curr.get("turn_order"):
            update["turn_order"] = curr.get("turn_order")
        return update

    def _build_unit_updates(
        self, prev: Dict[str, Any], curr: Dict[str, Any]
    ) -> Tuple[Optional[List[Dict[str, Any]]], List[Dict[str, Any]]]:
        prev_units = self._unit_lookup(prev.get("units"))
        curr_units = self._unit_lookup(curr.get("units"))
        if set(prev_units.keys()) != set(curr_units.keys()):
            return list(curr.get("units", [])) if isinstance(curr.get("units"), list) else [], []

        updates: List[Dict[str, Any]] = []
        fields = [
            "name",
            "role",
            "token_color",
            "hp",
            "move_remaining",
            "move_total",
            "action_remaining",
            "action_total",
            "attack_resource_remaining",
            "bonus_action_remaining",
            "reaction_remaining",
            "spell_cast_remaining",
            "marks",
            "is_prone",
            "is_spellcaster",
            "actions",
            "bonus_actions",
            "reactions",
        ]
        for cid, curr_unit in curr_units.items():
            prev_unit = prev_units.get(cid, {})
            patch: Dict[str, Any] = {"cid": cid}
            prev_pos = prev_unit.get("pos") if isinstance(prev_unit.get("pos"), dict) else {}
            curr_pos = curr_unit.get("pos") if isinstance(curr_unit.get("pos"), dict) else {}
            if prev_pos != curr_pos and curr_pos:
                patch["pos"] = curr_pos
            for field in fields:
                if prev_unit.get(field) != curr_unit.get(field):
                    patch[field] = curr_unit.get(field)
            if len(patch) > 1:
                updates.append(patch)
        return None, updates

    def _build_terrain_patch(self, prev: Dict[str, Any], curr: Dict[str, Any]) -> Dict[str, Any]:
        prev_rough = self._rough_lookup(prev.get("rough_terrain"))
        curr_rough = self._rough_lookup(curr.get("rough_terrain"))
        rough_updates: List[Dict[str, Any]] = []
        rough_removals: List[Dict[str, int]] = []
        for key, cell in curr_rough.items():
            if prev_rough.get(key) != cell:
                rough_updates.append(cell)
        for key in prev_rough.keys() - curr_rough.keys():
            rough_removals.append({"col": key[0], "row": key[1]})

        prev_obs = self._obstacle_lookup(prev.get("obstacles"))
        curr_obs = self._obstacle_lookup(curr.get("obstacles"))
        obstacle_updates = [{"col": key[0], "row": key[1]} for key in sorted(curr_obs - prev_obs)]
        obstacle_removals = [{"col": key[0], "row": key[1]} for key in sorted(prev_obs - curr_obs)]

        patch: Dict[str, Any] = {}
        if rough_updates:
            patch["rough_updates"] = rough_updates
        if rough_removals:
            patch["rough_removals"] = rough_removals
        if obstacle_updates:
            patch["obstacle_updates"] = obstacle_updates
        if obstacle_removals:
            patch["obstacle_removals"] = obstacle_removals
        return patch

    def _normalize_rough_cell(self, cell: object, mw: Optional[object] = None) -> Dict[str, object]:
        if mw is not None and hasattr(mw, "_rough_cell_data"):
            try:
                cell_data = mw._rough_cell_data(cell)
            except Exception:
                cell_data = None
            if isinstance(cell_data, dict):
                return {
                    "color": cell_data.get("color"),
                    "label": str(cell_data.get("label") or ""),
                    "movement_type": cell_data.get("movement_type"),
                    "is_swim": bool(cell_data.get("is_swim")),
                    "is_rough": bool(cell_data.get("is_rough")),
                }

        if isinstance(cell, dict):
            color = self.app._normalize_token_color(cell.get("color")) or "#8d6e63"
            is_swim = bool(cell.get("is_swim", False))
            movement_type = self.app._normalize_movement_type(cell.get("movement_type"), is_swim=is_swim)
            is_swim = movement_type == "water"
            is_rough = bool(cell.get("is_rough", False))
            label = str(cell.get("label") or "")
            return {
                "color": color,
                "label": label,
                "movement_type": movement_type,
                "is_swim": is_swim,
                "is_rough": is_rough,
            }
        if isinstance(cell, str):
            color = self.app._normalize_token_color(cell) or "#8d6e63"
            return {
                "color": color,
                "label": "",
                "movement_type": "ground",
                "is_swim": False,
                "is_rough": True,
            }
        return {
            "color": "#8d6e63",
            "label": "",
            "movement_type": "ground",
            "is_swim": False,
            "is_rough": True,
        }

    def _apply_terrain_patch_to_map(self, terrain_patch: Dict[str, Any]) -> None:
        if not isinstance(terrain_patch, dict):
            return
        rough_updates = terrain_patch.get("rough_updates") or []
        rough_removals = terrain_patch.get("rough_removals") or []
        if not rough_updates and not rough_removals:
            return

        handler_name = "_apply_terrain_patch_to_map"

        def _normalize_rough_key(raw_key: object) -> Optional[Tuple[int, int]]:
            if isinstance(raw_key, str):
                parts = [part.strip() for part in raw_key.split(",")]
                if len(parts) == 2:
                    try:
                        return (int(parts[0]), int(parts[1]))
                    except (TypeError, ValueError):
                        return None
            if isinstance(raw_key, (list, tuple)) and len(raw_key) == 2:
                try:
                    return (int(raw_key[0]), int(raw_key[1]))
                except (TypeError, ValueError):
                    return None
            return None

        mw = getattr(self.app, "_map_window", None)
        mw_ready = mw is not None and hasattr(mw, "winfo_exists") and mw.winfo_exists()
        rough_state: Dict[Tuple[int, int], Dict[str, object]] = {}
        existing_state = getattr(self.app, "_lan_rough_terrain", {}) or {}
        if isinstance(existing_state, dict):
            for raw_key, value in existing_state.items():
                key = _normalize_rough_key(raw_key)
                if key is None:
                    continue
                cell_data = self._normalize_rough_cell(value, mw if mw_ready else None)
                rough_state[key] = cell_data
        mw_updates: List[Tuple[Tuple[int, int], Dict[str, object]]] = []
        mw_removals: List[Tuple[int, int]] = []

        for entry in rough_updates:
            if not isinstance(entry, dict):
                continue
            try:
                col = int(entry.get("col"))
                row = int(entry.get("row"))
            except (TypeError, ValueError):
                continue
            cell_data = self._normalize_rough_cell(entry, mw if mw_ready else None)
            key = (col, row)
            rough_state[key] = cell_data
            if mw_ready:
                mw_updates.append((key, dict(cell_data)))

        for entry in rough_removals:
            if not isinstance(entry, dict):
                continue
            try:
                col = int(entry.get("col"))
                row = int(entry.get("row"))
            except (TypeError, ValueError):
                continue
            key = (col, row)
            rough_state.pop(key, None)
            if mw_ready:
                mw_removals.append(key)

        self.app._lan_rough_terrain = rough_state
        if mw_ready:
            updates = list(mw_updates)
            removals = list(mw_removals)

            def _apply_to_map_window(
                updates: List[Tuple[Tuple[int, int], Dict[str, object]]],
                removals: List[Tuple[int, int]],
            ) -> None:
                draw_ran = False
                rough_map: Optional[Dict[Tuple[int, int], Dict[str, object]]] = None
                try:
                    if mw is None or not mw.winfo_exists():
                        return
                except Exception:
                    return
                try:
                    rough_map = getattr(mw, "rough_terrain", None)
                    if rough_map is None:
                        rough_map = {}
                        setattr(mw, "rough_terrain", rough_map)
                except Exception:
                    rough_map = None
                if isinstance(rough_map, dict):
                    for key, cell in updates:
                        rough_map[key] = dict(cell)
                    for key in removals:
                        rough_map.pop(key, None)
                try:
                    mw._draw_rough_terrain()
                    draw_ran = True
                except Exception:
                    pass
                try:
                    mw._update_move_highlight()
                except Exception:
                    pass
                if LAN_TERRAIN_DEBUG:
                    try:
                        sample_key = next(iter((rough_map or {}).keys()), None)
                    except Exception:
                        sample_key = None
                    self._append_lan_log(
                        f"LAN terrain patch handler={handler_name} thread={threading.get_ident()} "
                        f"sample_key={sample_key} draw_ran={draw_ran}",
                        level="info",
                    )

            try:
                mw.after(0, lambda: _apply_to_map_window(updates, removals))
            except Exception:
                pass
        elif LAN_TERRAIN_DEBUG:
            try:
                sample_key = next(iter(rough_state.keys()), None)
            except Exception:
                sample_key = None
            self._append_lan_log(
                f"LAN terrain patch handler={handler_name} thread={threading.get_ident()} "
                f"sample_key={sample_key} draw_ran=False",
                level="info",
            )

    def _build_aoe_patch(self, prev: Dict[str, Any], curr: Dict[str, Any]) -> Dict[str, Any]:
        prev_aoes = {int(a.get("aid")): a for a in prev.get("aoes", []) if isinstance(a, dict) and "aid" in a}
        curr_aoes = {int(a.get("aid")): a for a in curr.get("aoes", []) if isinstance(a, dict) and "aid" in a}
        updates: List[Dict[str, Any]] = []
        removals: List[int] = []
        for aid, aoe in curr_aoes.items():
            if prev_aoes.get(aid) != aoe:
                updates.append(aoe)
        for aid in prev_aoes.keys() - curr_aoes.keys():
            removals.append(int(aid))
        patch: Dict[str, Any] = {}
        if updates:
            patch["updates"] = updates
        if removals:
            patch["removals"] = removals
        return patch

    def _pcs_payload(self) -> List[Dict[str, Any]]:
        pcs = list(self._cached_pcs)
        with self._clients_lock:
            cid_to_host = {cid: set(hosts) for cid, hosts in self._cid_to_host.items()}
        profiles: Dict[str, Any] = {}
        try:
            profiles_fn = object.__getattribute__(self.app, "_player_profiles_payload")
        except Exception:
            profiles_fn = None
        if callable(profiles_fn):
            try:
                profiles = profiles_fn()
            except Exception:
                profiles = {}
        out: List[Dict[str, Any]] = []
        for p in pcs:
            pp = dict(p)
            cid = int(pp.get("cid", -1))
            hosts = cid_to_host.get(cid) or set()
            pp["claimed_by"] = ", ".join(sorted(hosts)) if hosts else None
            name = str(pp.get("name") or "")
            if name and isinstance(profiles, dict):
                profile = profiles.get(name)
                if isinstance(profile, dict):
                    pp["player_profile"] = profile
            out.append(pp)
        out.sort(key=lambda d: str(d.get("name", "")))
        return out

    def _can_auto_claim(self, cid: int) -> bool:
        try:
            cid = int(cid)
        except Exception:
            return False
        pcs = {int(p.get("cid")) for p in self._cached_pcs if isinstance(p.get("cid"), int)}
        if cid not in pcs:
            return False
        return True

    # ---------- Server-thread safe broadcast ----------

    def _broadcast_state(self, snap: Dict[str, Any]) -> None:
        if not self._loop:
            return
        coro = self._broadcast_state_async(snap)
        try:
            asyncio.run_coroutine_threadsafe(coro, self._loop)
        except Exception:
            pass

    def _broadcast_payload(self, payload: Dict[str, Any]) -> None:
        if not self._loop:
            return
        coro = self._broadcast_payload_async(payload)
        try:
            asyncio.run_coroutine_threadsafe(coro, self._loop)
        except Exception as exc:
            self._log_lan_exception("LAN payload broadcast scheduling failed", exc)

    async def _broadcast_state_async(self, snap: Dict[str, Any]) -> None:
        # Build the base state payload once
        try:
            state_data = self._dynamic_snapshot_payload()
            pcs_data = self._pcs_payload()
        except Exception as exc:
            self.app._oplog(f"LAN state broadcast serialization failed: {exc}", level="warning")
            self._log_lan_exception("LAN state broadcast serialization failed", exc)
            return
        
        to_drop: List[int] = []
        with self._clients_lock:
            items = list(self._clients.items())
            view_only_clients = set(self._view_only_clients)
        view_only_state = None
        if view_only_clients:
            view_only_state = self._view_only_state_payload(state_data)
        
        # Send personalized payload to each client with their own "you" field
        for ws_id, ws in items:
            try:
                you_data = self._build_you_payload(ws_id)
                payload_state = view_only_state if ws_id in view_only_clients and view_only_state is not None else state_data
                payload = self._json_dumps({
                    "type": "state", 
                    "state": payload_state, 
                    "pcs": pcs_data,
                    "you": you_data
                })
                await ws.send_text(payload)
            except Exception as exc:
                to_drop.append(ws_id)
                self._log_lan_exception(f"LAN state broadcast send failed ws_id={ws_id}", exc)
        if to_drop:
            with self._clients_lock:
                for ws_id in to_drop:
                    # cleanup drop
                    self._drop_claim(ws_id)
                    self._clients.pop(ws_id, None)
                    self._clients_meta.pop(ws_id, None)
                    self._client_hosts.pop(ws_id, None)

    async def _broadcast_payload_async(self, payload: Dict[str, Any]) -> None:
        try:
            text = self._json_dumps(payload)
        except Exception as exc:
            self.app._oplog(f"LAN payload broadcast serialization failed: {exc}", level="warning")
            self._log_lan_exception("LAN payload broadcast serialization failed", exc)
            return
        to_drop: List[int] = []
        with self._clients_lock:
            items = list(self._clients.items())
        for ws_id, ws in items:
            try:
                await ws.send_text(text)
            except Exception as exc:
                to_drop.append(ws_id)
                self._log_lan_exception(f"LAN payload broadcast send failed ws_id={ws_id}", exc)
        if to_drop:
            with self._clients_lock:
                for ws_id in to_drop:
                    self._drop_claim(ws_id)
                    self._clients.pop(ws_id, None)
                    self._clients_meta.pop(ws_id, None)
                    self._client_hosts.pop(ws_id, None)

    def _broadcast_grid_update(self, grid: Dict[str, Any]) -> None:
        if not self._loop:
            return
        coro = self._broadcast_grid_update_async(grid)
        try:
            asyncio.run_coroutine_threadsafe(coro, self._loop)
        except Exception:
            pass

    def _broadcast_terrain_update(self, terrain: Dict[str, Any]) -> None:
        if not self._loop:
            return
        coro = self._broadcast_terrain_update_async(terrain)
        try:
            asyncio.run_coroutine_threadsafe(coro, self._loop)
        except Exception:
            pass

    async def _broadcast_grid_update_async(self, grid: Dict[str, Any]) -> None:
        try:
            payload = self._json_dumps({"type": "grid_update", "grid": grid, "version": self._grid_version})
        except Exception as exc:
            self.app._oplog(f"LAN grid broadcast serialization failed: {exc}", level="warning")
            self._log_lan_exception("LAN grid broadcast serialization failed", exc)
            return
        now = time.time()
        with self._clients_lock:
            items = list(self._clients.items())
        for ws_id, ws in items:
            try:
                await ws.send_text(payload)
                with self._clients_lock:
                    self._grid_pending[ws_id] = (self._grid_version, now)
            except Exception as exc:
                with self._clients_lock:
                    self._grid_pending.pop(ws_id, None)
                self._log_lan_exception(f"LAN grid broadcast send failed ws_id={ws_id}", exc)

    async def _broadcast_terrain_update_async(self, terrain: Dict[str, Any]) -> None:
        try:
            payload = self._json_dumps(
                {"type": "terrain_update", "terrain": terrain, "version": self._terrain_version}
            )
        except Exception as exc:
            self.app._oplog(f"LAN terrain broadcast serialization failed: {exc}", level="warning")
            self._log_lan_exception("LAN terrain broadcast serialization failed", exc)
            return
        now = time.time()
        with self._clients_lock:
            items = list(self._clients.items())
        for ws_id, ws in items:
            try:
                await ws.send_text(payload)
                with self._clients_lock:
                    self._terrain_pending[ws_id] = (self._terrain_version, now)
            except Exception as exc:
                with self._clients_lock:
                    self._terrain_pending.pop(ws_id, None)
                self._log_lan_exception(f"LAN terrain broadcast send failed ws_id={ws_id}", exc)

    async def _send_grid_update_async(self, ws_id: int, grid: Dict[str, Any]) -> None:
        payload = self._json_dumps({"type": "grid_update", "grid": grid, "version": self._grid_version})
        with self._clients_lock:
            ws = self._clients.get(ws_id)
        if not ws:
            return
        if isinstance(grid, dict):
            self._grid_last_sent = (grid.get("cols"), grid.get("rows"))
        try:
            await ws.send_text(payload)
            with self._clients_lock:
                self._grid_pending[ws_id] = (self._grid_version, time.time())
        except Exception as exc:
            with self._clients_lock:
                self._grid_pending.pop(ws_id, None)
            self._log_lan_exception(f"LAN grid update send failed ws_id={ws_id}", exc)

    async def _send_terrain_update_async(self, ws_id: int, terrain: Dict[str, Any]) -> None:
        payload = self._json_dumps({"type": "terrain_update", "terrain": terrain, "version": self._terrain_version})
        with self._clients_lock:
            ws = self._clients.get(ws_id)
        if not ws:
            return
        try:
            await ws.send_text(payload)
            with self._clients_lock:
                self._terrain_pending[ws_id] = (self._terrain_version, time.time())
        except Exception as exc:
            with self._clients_lock:
                self._terrain_pending.pop(ws_id, None)
            self._log_lan_exception(f"LAN terrain update send failed ws_id={ws_id}", exc)

    def _resend_grid_updates(self) -> None:
        if not self._loop or not self._grid_pending:
            return
        now = time.time()
        with self._clients_lock:
            pending = list(self._grid_pending.items())
            clients = dict(self._clients)
        for ws_id, (ver, last_sent) in pending:
            if ver != self._grid_version:
                with self._clients_lock:
                    self._grid_pending.pop(ws_id, None)
                continue
            if now - last_sent < self._grid_resend_seconds:
                continue
            ws = clients.get(ws_id)
            if not ws:
                with self._clients_lock:
                    self._grid_pending.pop(ws_id, None)
                continue
            payload = {"type": "grid_update", "grid": self._cached_snapshot.get("grid", {}), "version": self._grid_version}
            try:
                asyncio.run_coroutine_threadsafe(ws.send_text(self._json_dumps(payload)), self._loop)
                with self._clients_lock:
                    self._grid_pending[ws_id] = (self._grid_version, now)
            except Exception:
                with self._clients_lock:
                    self._grid_pending.pop(ws_id, None)

    def _resend_terrain_updates(self) -> None:
        if not self._loop or not self._terrain_pending:
            return
        now = time.time()
        with self._clients_lock:
            pending = list(self._terrain_pending.items())
            clients = dict(self._clients)
        for ws_id, (ver, last_sent) in pending:
            if ver != self._terrain_version:
                with self._clients_lock:
                    self._terrain_pending.pop(ws_id, None)
                continue
            if now - last_sent < self._terrain_resend_seconds:
                continue
            ws = clients.get(ws_id)
            if not ws:
                with self._clients_lock:
                    self._terrain_pending.pop(ws_id, None)
                continue
            payload = {"type": "terrain_update", "terrain": self._terrain_payload(), "version": self._terrain_version}
            try:
                asyncio.run_coroutine_threadsafe(ws.send_text(self._json_dumps(payload)), self._loop)
                with self._clients_lock:
                    self._terrain_pending[ws_id] = (self._terrain_version, now)
            except Exception:
                with self._clients_lock:
                    self._terrain_pending.pop(ws_id, None)

    def send_echo_tether_prompt(self, ws_id: Optional[int], request_id: str) -> None:
        if ws_id is None or not self._loop:
            return
        payload = {
            "type": "echo_tether_prompt",
            "request_id": str(request_id or "").strip(),
            "text": "Warning. Moving here will destroy your echo. Proceed?",
        }
        try:
            asyncio.run_coroutine_threadsafe(self._send_async(int(ws_id), payload), self._loop)
        except Exception:
            pass

    def send_initiative_prompt(self, ws_id: Optional[int], cid: int, name: str) -> None:
        """Prompt a claimed LAN player to roll initiative for their PC."""
        if ws_id is None or not self._loop:
            return
        try:
            cid_value = int(cid)
        except Exception:
            return
        payload = {
            "type": "initiative_prompt",
            "cid": cid_value,
            "name": str(name or "").strip() or "Player Character",
        }
        try:
            asyncio.run_coroutine_threadsafe(self._send_async(int(ws_id), payload), self._loop)
        except Exception:
            pass

    def toast(self, ws_id: Optional[int], text: str) -> None:
        """Send a small toast to one client (best effort)."""
        if ws_id is None or not self._loop:
            return
        coro = self._toast_async(ws_id, text)
        try:
            asyncio.run_coroutine_threadsafe(coro, self._loop)
        except Exception:
            pass

    def play_ko(self, attacker_cid: Optional[int]) -> None:
        """Play a KO sound on the attacker's claimed LAN client (once per round)."""
        if not self._loop or attacker_cid is None:
            return
        try:
            attacker_cid = int(attacker_cid)
        except Exception:
            return
        round_num = int(getattr(self.app, "round_num", 0) or 0)
        if self._ko_round_num != round_num:
            self._ko_round_num = round_num
            self._ko_played = False
        if self._ko_played:
            return
        pc_cids = {int(p.get("cid")) for p in self._cached_pcs if isinstance(p.get("cid"), int)}
        if attacker_cid not in pc_cids:
            return
        with self._clients_lock:
            ws_ids = list(self._cid_to_ws.get(attacker_cid, set()))
        if not ws_ids:
            return
        self._ko_played = True
        for ws_id in ws_ids:
            coro = self._send_async(ws_id, {"type": "play_audio", "audio": "ko", "cid": attacker_cid})
            try:
                asyncio.run_coroutine_threadsafe(coro, self._loop)
            except Exception:
                pass

    async def _toast_async(self, ws_id: int, text: str) -> None:
        with self._clients_lock:
            ws = self._clients.get(ws_id)
        if not ws:
            return
        try:
            await ws.send_text(self._json_dumps({"type": "toast", "text": text}))
        except Exception:
            pass

    async def _send_async(self, ws_id: int, payload: Dict[str, Any]) -> None:
        with self._clients_lock:
            ws = self._clients.get(ws_id)
        if not ws:
            return
        try:
            await ws.send_text(self._json_dumps(payload))
        except Exception as exc:
            self._log_lan_exception(f"LAN send failed ws_id={ws_id}", exc)

    async def _send_full_state_async(self, ws_id: int) -> None:
        try:
            await self._send_grid_update_async(ws_id, self._cached_snapshot.get("grid", {}))
        except Exception as exc:
            self._log_lan_exception(f"LAN full state grid send failed ws_id={ws_id}", exc)
        try:
            await self._send_terrain_update_async(ws_id, self._terrain_payload())
        except Exception as exc:
            self._log_lan_exception(f"LAN full state terrain send failed ws_id={ws_id}", exc)
        try:
            await self._send_async(ws_id, {"type": "static_data", "data": self._static_data_payload()})
        except Exception as exc:
            self._log_lan_exception(f"LAN full state static send failed ws_id={ws_id}", exc)
        try:
            you_data = self._build_you_payload(ws_id)
            with self._clients_lock:
                is_view_only = ws_id in self._view_only_clients
            state_payload = self._dynamic_snapshot_payload()
            if is_view_only:
                state_payload = self._view_only_state_payload(state_payload)
            await self._send_async(
                ws_id,
                {
                    "type": "state", 
                    "state": state_payload, 
                    "pcs": self._pcs_payload(),
                    "you": you_data
                },
            )
        except Exception as exc:
            self._log_lan_exception(f"LAN full state send failed ws_id={ws_id}", exc)

    def _drop_claim(self, ws_id: int) -> Optional[int]:
        with self._clients_lock:
            old = self._claims.pop(ws_id, None)
            if old is None:
                return None
            host = self._client_hosts.get(ws_id, "")
            ws_set = self._cid_to_ws.get(int(old))
            if ws_set is not None:
                ws_set.discard(ws_id)
                if not ws_set:
                    self._cid_to_ws.pop(int(old), None)
            host_set = self._cid_to_host.get(int(old))
            if host_set is not None and host:
                remaining_ws = self._cid_to_ws.get(int(old), set())
                still_has_host = any(self._client_hosts.get(w) == host for w in remaining_ws)
                if not still_has_host:
                    host_set.discard(host)
                    if not host_set:
                        self._cid_to_host.pop(int(old), None)
        return old

    def _register_client_id(self, ws_id: int, client_id: str) -> None:
        with self._clients_lock:
            self._client_ids[ws_id] = client_id
            self._client_id_to_ws.setdefault(client_id, set()).add(ws_id)

    def _client_id_for_ws(self, ws_id: int) -> Optional[str]:
        with self._clients_lock:
            return self._client_ids.get(ws_id)

    def _next_claim_rev_for_ws(self, ws_id: int) -> int:
        with self._clients_lock:
            next_rev = int(self._ws_claim_revs.get(ws_id, 0)) + 1
            self._ws_claim_revs[ws_id] = next_rev
            return next_rev

    def _set_client_claim(self, client_id: str, cid: int) -> int:
        with self._clients_lock:
            self._client_id_claims[client_id] = int(cid)
            next_rev = int(self._client_claim_revs.get(client_id, 0)) + 1
            self._client_claim_revs[client_id] = next_rev
            return next_rev

    def _client_claim_for_id(self, client_id: str) -> Optional[int]:
        with self._clients_lock:
            return self._client_id_claims.get(client_id)

    def _clear_client_claim(self, client_id: str) -> int:
        with self._clients_lock:
            self._client_id_claims.pop(client_id, None)
            next_rev = int(self._client_claim_revs.get(client_id, 0)) + 1
            self._client_claim_revs[client_id] = next_rev
            return next_rev

    def _ws_ids_for_client_id(self, client_id: str) -> set[int]:
        with self._clients_lock:
            return set(self._client_id_to_ws.get(client_id, set()))

    def _claim_identity_for_ws(self, ws_id: int) -> Tuple[Optional[int], int, Optional[str]]:
        with self._clients_lock:
            client_id = self._client_ids.get(ws_id)
            claimed_cid = self._claims.get(ws_id)
            if client_id is not None and client_id in self._client_id_claims:
                claimed_cid = self._client_id_claims.get(client_id)
            if client_id is not None:
                claim_rev = int(self._client_claim_revs.get(client_id, 0))
            else:
                claim_rev = int(self._ws_claim_revs.get(ws_id, 0))
        return claimed_cid, claim_rev, client_id

    def _claims_payload(self) -> Dict[str, str]:
        """Return a server-authoritative CID -> client_id map for active LAN claims."""
        payload: Dict[str, str] = {}
        with self._clients_lock:
            ws_claims = dict(self._claims)
            ws_client_ids = dict(self._client_ids)
        for ws_id, cid in ws_claims.items():
            try:
                cid_value = int(cid)
            except Exception:
                continue
            client_id = self._normalize_client_id(ws_client_ids.get(ws_id))
            if not client_id:
                continue
            payload[str(cid_value)] = client_id
        return payload

    def claimed_cids_snapshot(self) -> set[int]:
        """Return currently claimed CIDs using active LAN claim state."""
        with self._clients_lock:
            claimed: set[int] = set()
            for raw_cid in self._claims.values():
                try:
                    claimed.add(int(raw_cid))
                except Exception:
                    continue
            for client_id, raw_cid in self._client_id_claims.items():
                ws_ids = self._client_id_to_ws.get(client_id, set())
                if not ws_ids:
                    continue
                if not any(ws_id in self._clients for ws_id in ws_ids):
                    continue
                try:
                    claimed.add(int(raw_cid))
                except Exception:
                    continue
        return claimed

    async def _unclaim_ws_async(
        self, ws_id: int, reason: str = "Unclaimed", clear_ownership: bool = False
    ) -> int:
        # Drop claim mapping
        old = self._drop_claim(ws_id)
        if old is not None:
            name = self._tracker._pc_name_for(int(old))
            self.app._oplog(f"LAN session ws_id={ws_id} unclaimed {name} ({reason})")

        claim_rev: int
        client_id = self._client_id_for_ws(ws_id)
        if client_id:
            claim_rev = self._clear_client_claim(client_id)
            ws_ids = self._ws_ids_for_client_id(client_id)
            with self._clients_lock:
                for member_ws_id in ws_ids:
                    self._ws_claim_revs[member_ws_id] = int(claim_rev)
        else:
            claim_rev = self._next_claim_rev_for_ws(ws_id)

        await self._send_async(
            ws_id,
            {
                "type": "force_unclaim",
                "text": reason,
                "pcs": self._pcs_payload(),
                "claimed_cid": None,
                "claim_rev": int(claim_rev),
                "reason": "revoked",
                "you": self._build_you_payload(ws_id),
            },
        )
        return int(claim_rev)

    async def _claim_ws_async(
        self, ws_id: int, cid: int, note: str = "Claimed", allow_override: bool = False
    ) -> bool:
        # Ensure cid is a PC
        pcs = {int(p.get("cid")): p for p in self._cached_pcs}
        if int(cid) not in pcs:
            self._spell_debug_log(
                {"event": "claim", "ws_id": ws_id, "cid": int(cid), "reason": "not_claimable"},
                level="warning",
            )
            await self._send_async(ws_id, {"type": "toast", "text": "That character ain't claimable, matey."})
            return False

        with self._clients_lock:
            current_claim = self._claims.get(ws_id)
        if current_claim is not None and int(current_claim) == int(cid):
            self._spell_debug_log(
                {"event": "claim", "ws_id": ws_id, "cid": int(cid), "reason": "noop_already_claimed"}
            )
            # Still send confirmation to clear client's in-flight state
            await self._send_async(ws_id, {"type": "force_claim", "cid": int(cid), "text": note, "you": self._build_you_payload(ws_id)})
            return True

        self._drop_claim(ws_id)
        with self._clients_lock:
            host = self._client_hosts.get(ws_id, "")
            self._claims[ws_id] = int(cid)
            self._cid_to_ws.setdefault(int(cid), set()).add(ws_id)
            if host:
                self._cid_to_host.setdefault(int(cid), set()).add(host)

        await self._send_async(ws_id, {"type": "force_claim", "cid": int(cid), "text": note, "you": self._build_you_payload(ws_id)})
        name = self._tracker._pc_name_for(int(cid))
        self.app._oplog(f"LAN session ws_id={ws_id} claimed {name} ({note})")
        return True

    # ---------- helpers ----------

    def _resolve_local_ip(self) -> str:
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                sock.connect(("8.8.8.8", 80))
                ip = sock.getsockname()[0]
                if ip and not ip.startswith("127."):
                    return ip
        except Exception:
            pass
        try:
            ip = socket.gethostbyname(socket.gethostname())
            if ip and not ip.startswith("127."):
                return ip
        except Exception:
            pass
        return "127.0.0.1"

    def _display_host(self) -> str:
        host = str(self.cfg.host or "").strip()
        if host in ("", "0.0.0.0", "::", "127.0.0.1", "localhost"):
            return self._resolve_local_ip()
        return host

    def is_running(self) -> bool:
        return bool(self._server_thread and self._server_thread.is_alive())

    def _computed_http_url(self) -> str:
        return f"http://{self._display_host()}:{self.cfg.port}/"

    def published_urls(self) -> Dict[str, str]:
        settings = getattr(self, "url_settings", None)
        mode = _normalize_lan_url_mode(getattr(settings, "url_mode", "http"))
        configured_http = _normalize_public_url(getattr(settings, "public_http_url", None), required_scheme="http")
        configured_https = _normalize_public_url(getattr(settings, "public_https_url", None), required_scheme="https")
        http_url = configured_http or self._computed_http_url()
        urls: Dict[str, str] = {}
        if mode in {"http", "both"}:
            urls["http"] = http_url
        if mode in {"https", "both"} and configured_https:
            urls["https"] = configured_https
        return urls

    def preferred_url(self) -> Optional[str]:
        settings = getattr(self, "url_settings", None)
        mode = _normalize_lan_url_mode(getattr(settings, "url_mode", "http"))
        urls = self.published_urls()
        if mode == "https":
            return urls.get("https")
        if mode == "both":
            return urls.get("https") or urls.get("http")
        return urls.get("http")

    def html_injected_base_url(self) -> Optional[str]:
        settings = getattr(self, "url_settings", None)
        mode = _normalize_lan_url_mode(getattr(settings, "url_mode", "http"))
        if mode == "both":
            return None
        if mode == "https":
            return _normalize_public_url(getattr(settings, "public_https_url", None), required_scheme="https")
        urls = self.published_urls()
        return urls.get("http")

    def _best_lan_url(self) -> str:
        return self.preferred_url() or self._computed_http_url()

    def _cached_snapshot_payload(self) -> Dict[str, Any]:
        snap = dict(self._cached_snapshot)
        units = snap.get("units")
        if isinstance(units, list):
            with self._clients_lock:
                cid_to_host = {cid: set(hosts) for cid, hosts in self._cid_to_host.items()}
            enriched = []
            for unit in units:
                if not isinstance(unit, dict):
                    enriched.append(unit)
                    continue
                copy_unit = dict(unit)
                try:
                    cid = int(copy_unit.get("cid", -1))
                except Exception:
                    cid = -1
                hosts = cid_to_host.get(cid) or set()
                copy_unit["claimed_by"] = ", ".join(sorted(hosts)) if hosts else None
                enriched.append(copy_unit)
            snap["units"] = enriched
        return snap

    def _terrain_payload(self, snap: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        src = snap if isinstance(snap, dict) else self._cached_snapshot
        rough = src.get("rough_terrain")
        if not isinstance(rough, list):
            rough = []
        obstacles = src.get("obstacles")
        if not isinstance(obstacles, list):
            obstacles = []
        return {"rough_terrain": rough, "obstacles": obstacles}

    def _monster_choices_payload(self) -> List[Dict[str, Any]]:
        specs = getattr(self.app, "_monster_specs", [])
        if not isinstance(specs, list):
            specs = []
        cache_key = (id(specs), len(specs))
        if cache_key == getattr(self, "_monster_choices_cache_key", None):
            return getattr(self, "_monster_choices_cache", [])

        monster_choices: List[Dict[str, Any]] = []

        def _as_int(value: Any) -> Optional[int]:
            try:
                if value is None:
                    return None
                if isinstance(value, bool):
                    return int(value)
                if isinstance(value, (int, float)):
                    return int(value)
                text = str(value).strip()
                if not text:
                    return None
                return int(float(text))
            except Exception:
                return None

        def _ability_score(raw_data: Dict[str, Any], ability: str) -> int:
            abilities = raw_data.get("abilities") if isinstance(raw_data.get("abilities"), dict) else {}
            score = _as_int(abilities.get(ability))
            if score is None:
                return 10
            return max(1, min(30, int(score)))

        try:
            monster_choices = [
                {
                    "name": str(spec.name),
                    "slug": Path(str(spec.filename or "")).with_suffix("").as_posix(),
                    "template": {
                        "name": str(spec.name or ""),
                        "type": str(spec.mtype or "construct"),
                        "hp": max(1, int(spec.hp or 1)),
                        "ac": max(
                            1,
                            int(
                                _as_int((spec.raw_data or {}).get("ac"))
                                or _as_int((spec.raw_data or {}).get("armor_class"))
                                or 10
                            ),
                        ),
                        "speeds": {
                            "walk": max(1, int(spec.speed or 30)),
                            "swim": max(0, int(spec.swim_speed or 0)),
                            "fly": max(0, int(spec.fly_speed or 0)),
                            "burrow": max(0, int(spec.burrow_speed or 0)),
                            "climb": max(0, int(spec.climb_speed or 0)),
                        },
                        "abilities": {
                            "str": _ability_score(spec.raw_data if isinstance(spec.raw_data, dict) else {}, "str"),
                            "dex": _ability_score(spec.raw_data if isinstance(spec.raw_data, dict) else {}, "dex"),
                            "con": _ability_score(spec.raw_data if isinstance(spec.raw_data, dict) else {}, "con"),
                            "int": _ability_score(spec.raw_data if isinstance(spec.raw_data, dict) else {}, "int"),
                            "wis": _ability_score(spec.raw_data if isinstance(spec.raw_data, dict) else {}, "wis"),
                            "cha": _ability_score(spec.raw_data if isinstance(spec.raw_data, dict) else {}, "cha"),
                        },
                    },
                }
                for spec in specs
            ]
        except Exception:
            monster_choices = []

        self._monster_choices_cache_key = cache_key
        self._monster_choices_cache = monster_choices
        return monster_choices

    def _static_data_payload(self, planning: bool = False) -> Dict[str, Any]:
        """Return static data that only needs to be sent once on connection."""
        spell_presets = self.app._spell_presets_payload() if planning else self._cached_snapshot.get("spell_presets", [])
        monster_choices = self._monster_choices_payload()
        return {
            "spell_presets": spell_presets,
            "player_spells": self._cached_snapshot.get("player_spells", {}),
            "player_profiles": self._cached_snapshot.get("player_profiles", {}),
            "resource_pools": self._cached_snapshot.get("resource_pools", {}),
            "monster_choices": monster_choices,
            "conditions": [
                "blinded", "charmed", "deafened", "frightened", "grappled", "incapacitated",
                "invisible", "paralyzed", "petrified", "poisoned", "prone", "restrained", "stunned", "unconscious",
            ],
            "dice_types": ["d4", "d6", "d8", "d10", "d12", "d20", "d100"],
            "token_colours": ["#6aa9ff", "#ff6a6a", "#66d17a", "#f1c95f", "#c97dff", "#61d8d8"],
        }

    def _resolve_planning_auth(self, request: "Request", player_cid: Optional[int] = None) -> Dict[str, Any]:
        from fastapi import HTTPException

        host = getattr(getattr(request, "client", None), "host", "")
        if not self._is_host_allowed(host):
            raise HTTPException(status_code=403, detail="Unauthorized host.")
        header = request.headers.get("authorization", "")
        admin_token = ""
        if header.lower().startswith("bearer "):
            admin_token = header.split(" ", 1)[1].strip()
        is_admin = bool(admin_token and self._is_admin_token_valid(admin_token))
        claim_cid: Optional[int] = None
        client_id = self._normalize_client_id(
            request.headers.get("x-client-id") or request.query_params.get("client_id")
        )
        if client_id:
            claim_cid = self._client_claim_for_id(client_id)
        if claim_cid is None:
            claim_name = self._assigned_character_name_for_host(host)
            if claim_name:
                for c in self.app.combatants.values():
                    if str(getattr(c, "name", "")).strip().lower() == str(claim_name).strip().lower():
                        claim_cid = int(getattr(c, "cid", -1))
                        break
        if player_cid is not None:
            claim_cid = int(player_cid)
        if claim_cid is None and not is_admin:
            raise HTTPException(status_code=401, detail="No claimed character.")
        if claim_cid is not None and int(claim_cid) not in self.app.combatants and not is_admin:
            raise HTTPException(status_code=403, detail="Character is not in the encounter.")
        return {"is_admin": is_admin, "player_cid": claim_cid, "client_id": client_id}

    def _assigned_character_name_for_host(self, host: str) -> Optional[str]:
        """Return the claimed PC name for ``host`` if one is currently assigned."""
        host_key = str(host or "").strip()
        if not host_key:
            return None
        with self._clients_lock:
            claimed_cids = sorted(
                int(cid)
                for cid, hosts in self._cid_to_host.items()
                if host_key in (hosts or set())
            )
        for cid in claimed_cids:
            name = self._pc_name_for(int(cid))
            if name and not str(name).startswith("cid:"):
                return str(name)
        return None

    def _planning_snapshot_payload(self, viewer_cid: Optional[int], is_admin: bool = False) -> Dict[str, Any]:
        snap = copy.deepcopy(self.app._lan_snapshot())
        units = snap.get("units") if isinstance(snap, dict) else []
        if not isinstance(units, list):
            units = []
        filtered_units: List[Dict[str, Any]] = []
        for unit in units:
            if not isinstance(unit, dict):
                continue
            item = copy.deepcopy(unit)
            role = str(item.get("role") or "").strip().lower()
            owner_cid = _normalize_cid_value(item.get("summoned_by_cid"), "planning.owner")
            can_view_hp = is_admin or role in ("pc", "ally") or (viewer_cid is not None and owner_cid == int(viewer_cid))
            if not can_view_hp:
                item["hp"] = None
            filtered_units.append(item)

        conditions: Dict[str, List[str]] = {}
        summons: List[Dict[str, Any]] = []
        for unit in filtered_units:
            cid = _normalize_cid_value(unit.get("cid"), "planning.unit.cid")
            if cid is None:
                continue
            marks = str(unit.get("marks") or "").strip()
            if marks:
                conditions[str(cid)] = [part.strip() for part in marks.split(",") if part and part.strip()]
            if unit.get("summoned_by_cid") is not None:
                summons.append(
                    {
                        "cid": cid,
                        "name": unit.get("name"),
                        "summoned_by_cid": unit.get("summoned_by_cid"),
                        "summon_source_spell": unit.get("summon_source_spell"),
                        "summon_group_id": unit.get("summon_group_id"),
                    }
                )

        map_image = getattr(self.app, "_map_image_reference", None)
        if map_image is None:
            map_image = getattr(self.app, "_map_image_path", None)

        return {
            "map_image": map_image,
            "grid": snap.get("grid"),
            "obstacles": snap.get("obstacles", []),
            "rough_terrain": snap.get("rough_terrain", []),
            "aoes": snap.get("aoes", []),
            "combatants": [
                {
                    "cid": unit.get("cid"),
                    "name": unit.get("name"),
                    "pos": unit.get("pos"),
                    "initiative_order": (snap.get("turn_order") or []).index(unit.get("cid")) + 1 if unit.get("cid") in (snap.get("turn_order") or []) else None,
                    "hp": unit.get("hp"),
                    "token_color": unit.get("token_color"),
                    "role": unit.get("role"),
                    "summoned_by_cid": unit.get("summoned_by_cid"),
                    "summon_source_spell": unit.get("summon_source_spell"),
                    "summon_group_id": unit.get("summon_group_id"),
                }
                for unit in filtered_units
            ],
            "conditions": conditions,
            "summons": summons,
            "spell_presets": self.app._spell_presets_payload(),
            "turn_order": snap.get("turn_order", []),
            "active_cid": snap.get("active_cid"),
            "round_num": snap.get("round_num"),
            "viewer_cid": viewer_cid,
            "is_admin": bool(is_admin),
        }

    def _dynamic_snapshot_payload(self) -> Dict[str, Any]:
        """Return dynamic state without static data (for regular broadcasts)."""
        snap = self._cached_snapshot_payload()
        snap["claims"] = self._claims_payload()
        # Remove static fields to reduce payload size
        snap.pop("spell_presets", None)
        snap.pop("player_spells", None)
        snap.pop("player_profiles", None)
        snap.pop("rough_terrain", None)
        snap.pop("obstacles", None)
        snap.pop("grid", None)
        return snap

    def _view_only_state_payload(self, base_state: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        state = dict(base_state) if isinstance(base_state, dict) else dict(self._dynamic_snapshot_payload())
        snap = self._cached_snapshot_payload()
        if "grid" not in state:
            state["grid"] = snap.get("grid")
        if "rough_terrain" not in state:
            state["rough_terrain"] = snap.get("rough_terrain", [])
        if "obstacles" not in state:
            state["obstacles"] = snap.get("obstacles", [])
        return state

    def _pc_name_for(self, cid: int) -> str:
        for pc in self._cached_pcs:
            if int(pc.get("cid", -1)) == int(cid):
                name = pc.get("name")
                if name:
                    return str(name)
        return f"cid:{cid}"

    def _get_claimed_cid_for_ws(self, ws_id: int) -> Optional[int]:
        """Return the claimed CID for a websocket, or None if unclaimed."""
        with self._clients_lock:
            return self._claims.get(ws_id)

    def _build_you_payload(self, ws_id: int) -> Dict[str, Any]:
        """Build the 'you' field for a state payload - server-authoritative claim state."""
        claimed_cid, claim_rev, _ = self._claim_identity_for_ws(ws_id)
        result: Dict[str, Any] = {}
        if claimed_cid is not None:
            result["claimed_cid"] = int(claimed_cid)
            result["claimed_name"] = self._pc_name_for(int(claimed_cid))
        else:
            result["claimed_cid"] = None
            result["claimed_name"] = None
        result["claim_rev"] = int(claim_rev)
        return result


# ----------------------------- Tracker -----------------------------

class InitiativeTracker(base.InitiativeTracker):
    _wild_shape_beast_cache: Optional[List[Dict[str, Any]]] = None

    @staticmethod
    def _druid_level_from_profile(profile: Dict[str, Any]) -> int:
        leveling = profile.get("leveling") if isinstance(profile.get("leveling"), dict) else {}
        classes = leveling.get("classes") if isinstance(leveling.get("classes"), list) else []
        total = 0
        for entry in classes:
            if not isinstance(entry, dict):
                continue
            name = str(entry.get("name") or "").strip().lower()
            if name != "druid":
                continue
            try:
                total += int(entry.get("level") or 0)
            except Exception:
                continue
        if total > 0:
            return total
        klass = str(leveling.get("class") or "").strip().lower()
        if klass == "druid":
            try:
                return max(0, int(leveling.get("level") or 0))
            except Exception:
                return 0
        return 0

    @staticmethod
    def _fighter_level_from_profile(profile: Dict[str, Any]) -> int:
        leveling = profile.get("leveling") if isinstance(profile.get("leveling"), dict) else {}
        classes = leveling.get("classes") if isinstance(leveling.get("classes"), list) else []
        total = 0
        for entry in classes:
            if not isinstance(entry, dict):
                continue
            name = str(entry.get("name") or "").strip().lower()
            if name != "fighter":
                continue
            try:
                total += int(entry.get("level") or 0)
            except Exception:
                continue
        if total > 0:
            return total
        klass = str(leveling.get("class") or "").strip().lower()
        if klass == "fighter":
            try:
                return max(0, int(leveling.get("level") or 0))
            except Exception:
                return 0
        return 0

    @staticmethod
    def _wild_shape_max_uses_for_level(druid_level: int) -> int:
        if druid_level < 2:
            return 0
        return max(2, min(4, 2 + (int(druid_level) // 3)))

    @staticmethod
    def _wild_shape_known_limit(druid_level: int) -> int:
        if druid_level < 2:
            return 0
        return min(8, 4 + (max(0, int(druid_level) - 2) // 2))

    @staticmethod
    def _second_wind_max_uses_for_level(fighter_level: int) -> int:
        level = max(0, int(fighter_level or 0))
        if level < 1:
            return 0
        if level >= 10:
            return 4
        if level >= 4:
            return 3
        return 2

    @staticmethod
    def _parse_cr_value(value: Any) -> float:
        if isinstance(value, (int, float)):
            return float(value)
        text = str(value or "").strip()
        if not text:
            return 0.0
        if "/" in text:
            parts = text.split("/", 1)
            try:
                num = float(parts[0])
                den = float(parts[1])
                if den == 0:
                    return 0.0
                return num / den
            except Exception:
                return 0.0
        try:
            return float(text)
        except Exception:
            return 0.0

    def _load_beast_forms(self) -> List[Dict[str, Any]]:
        if isinstance(self._wild_shape_beast_cache, list):
            return self._wild_shape_beast_cache

        def is_beast_type(value: Any) -> bool:
            text = str(value or "").strip().lower()
            return text == "beast" or text.startswith("beast (")

        def parse_int_field(value: Any, default: int) -> int:
            if isinstance(value, (int, float)):
                try:
                    return int(value)
                except Exception:
                    return default
            text = str(value or "").strip()
            if not text:
                return default
            match = re.match(r"^\s*(\d+)", text)
            if match:
                return int(match.group(1))
            return default

        def ability_value(abilities: Dict[str, Any], key: str, default: int = 10) -> int:
            return parse_int_field(
                abilities.get(key)
                or abilities.get(key.lower())
                or abilities.get(key.upper())
                or default,
                default,
            )

        forms: List[Dict[str, Any]] = []
        seen_ids: set[str] = set()
        specs = getattr(self, "_monster_specs", None)
        has_specs = isinstance(specs, list) and bool(specs)
        if has_specs:
            for spec in specs:
                if not isinstance(spec, MonsterSpec):
                    continue
                raw = spec.raw_data if isinstance(spec.raw_data, dict) else {}
                if not is_beast_type(raw.get("type") or spec.mtype):
                    continue
                form_id = Path(str(spec.filename or "")).stem or str(raw.get("name") or spec.name or "").strip().lower().replace(" ", "-")
                if form_id in seen_ids:
                    continue
                seen_ids.add(form_id)
                parsed_speed = base._parse_speed_data(raw.get("speed")) if raw.get("speed") is not None else None
                raw_abilities = raw.get("abilities") if isinstance(raw.get("abilities"), dict) else {}
                forms.append(
                    {
                        "id": form_id,
                        "name": str(raw.get("name") or spec.name).strip() or str(spec.name),
                        "challenge_rating": self._parse_cr_value(raw.get("challenge_rating", spec.cr) or 0),
                        "size": str(raw.get("size") or "Medium").strip() or "Medium",
                        "ac": parse_int_field(raw.get("ac"), 10),
                        "hp": parse_int_field(raw.get("hp") or spec.hp, 1),
                        "speed": {
                            "walk": int((parsed_speed[0] if parsed_speed is not None else spec.speed) or 0),
                            "swim": int((parsed_speed[1] if parsed_speed is not None else spec.swim_speed) or 0),
                            "fly": int((parsed_speed[2] if parsed_speed is not None else spec.fly_speed) or 0),
                            "climb": int((parsed_speed[4] if parsed_speed is not None else spec.climb_speed) or 0),
                        },
                        "abilities": {
                            "str": ability_value(raw_abilities, "Str"),
                            "dex": ability_value(raw_abilities, "Dex"),
                            "con": ability_value(raw_abilities, "Con"),
                            "int": ability_value(raw_abilities, "Int"),
                            "wis": ability_value(raw_abilities, "Wis"),
                            "cha": ability_value(raw_abilities, "Cha"),
                        },
                        "actions": list(raw.get("actions") if isinstance(raw.get("actions"), list) else []),
                    }
                )
        else:
            monsters_dir = _app_base_dir() / "Monsters"
            if yaml is not None and monsters_dir.is_dir():
                for path in monsters_dir.glob("*.yaml"):
                    try:
                        raw = yaml.safe_load(path.read_text(encoding="utf-8"))
                    except Exception:
                        continue
                    if not isinstance(raw, dict):
                        continue
                    if not is_beast_type(raw.get("type")):
                        continue
                    speed_data = raw.get("speed")
                    walk = swim = fly = climb = 0
                    if speed_data is not None:
                        parsed = base._parse_speed_data(speed_data)
                        walk = int(parsed[0] or 0)
                        swim = int(parsed[1] or 0)
                        fly = int(parsed[2] or 0)
                        climb = int(parsed[4] or 0)
                    abilities = raw.get("abilities") if isinstance(raw.get("abilities"), dict) else {}
                    form_id = path.stem
                    seen_ids.add(form_id)
                    forms.append(
                        {
                            "id": form_id,
                            "name": str(raw.get("name") or path.stem).strip() or path.stem,
                            "challenge_rating": self._parse_cr_value(raw.get("challenge_rating") or 0),
                            "size": str(raw.get("size") or "Medium").strip() or "Medium",
                            "ac": parse_int_field(raw.get("ac"), 10),
                            "hp": parse_int_field(raw.get("hp"), 1),
                            "speed": {"walk": walk, "swim": swim, "fly": fly, "climb": climb},
                            "abilities": {
                                "str": ability_value(abilities, "Str"),
                                "dex": ability_value(abilities, "Dex"),
                                "con": ability_value(abilities, "Con"),
                                "int": ability_value(abilities, "Int"),
                                "wis": ability_value(abilities, "Wis"),
                                "cha": ability_value(abilities, "Cha"),
                            },
                            "actions": list(raw.get("actions") if isinstance(raw.get("actions"), list) else []),
                        }
                    )
        forms.sort(key=lambda entry: (entry.get("challenge_rating", 0.0), entry.get("name", "")))
        self._wild_shape_beast_cache = forms
        return forms

    def _wild_shape_available_forms(
        self,
        profile: Dict[str, Any],
        known_only: bool = True,
        include_locked: bool = False,
    ) -> List[Dict[str, Any]]:
        druid_level = self._druid_level_from_profile(profile)
        known = set(self._normalized_prepared_wild_shapes_from_profile(profile))
        if druid_level < 2:
            return []
        if druid_level >= 8:
            max_cr = 1.0
        elif druid_level >= 4:
            max_cr = 0.5
        else:
            max_cr = 0.25
        result: List[Dict[str, Any]] = []
        for form in self._load_beast_forms():
            form_cr = float(form.get("challenge_rating") or 0.0)
            if form_cr > 2.0:
                continue
            allowed = True
            if form_cr > max_cr:
                allowed = False
            speed = form.get("speed") if isinstance(form.get("speed"), dict) else {}
            if int(speed.get("fly") or 0) > 0 and druid_level < 8:
                allowed = False
            if int(speed.get("swim") or 0) > 0 and druid_level < 4:
                allowed = False
            if str(form.get("size") or "").strip().lower() == "tiny" and druid_level < 11:
                allowed = False
            if known_only and str(form.get("id") or "").strip().lower() not in known:
                allowed = False
            if allowed or include_locked:
                entry = dict(form)
                entry["allowed"] = bool(allowed)
                result.append(entry)
        return result

    def _normalize_prepared_wild_shapes(self, raw_values: Any, known_limit: Optional[int] = None) -> List[str]:
        if not isinstance(raw_values, list):
            return []
        deduped: List[str] = []
        for raw in raw_values:
            beast_id = self._wild_shape_identifier_key(raw)
            if not beast_id or beast_id in deduped:
                continue
            deduped.append(beast_id)
            if isinstance(known_limit, int) and known_limit >= 0 and len(deduped) >= known_limit:
                break
        return deduped

    def _normalized_prepared_wild_shapes_from_profile(self, profile: Dict[str, Any]) -> List[str]:
        if not isinstance(profile, dict):
            return []
        raw_values = profile.get("prepared_wild_shapes")
        if not isinstance(raw_values, list):
            raw_values = profile.get("learned_wild_shapes")
        known_limit: Optional[int] = None
        druid_level = self._druid_level_from_profile(profile)
        if druid_level >= 2:
            known_limit = self._wild_shape_known_limit(druid_level)
        return self._normalize_prepared_wild_shapes(raw_values, known_limit=known_limit)

    """Tk tracker + LAN proof-of-concept server."""

    def __init__(self) -> None:
        _archive_startup_time_log()
        _archive_startup_logs()
        super().__init__()
        self.title(f"DnD Initiative Tracker — v{APP_VERSION}")

        # Operations logger (terminal + ./logs/operations.log)
        self._ops_logger = _make_ops_logger()

        self._lan = LanController(self)
        self._load_lan_url_settings()
        self._install_lan_menu()

        # Monster library (YAML files in ./Monsters)
        self._monster_specs: List[MonsterSpec] = []
        self._monsters_by_name: Dict[str, MonsterSpec] = {}
        self._load_monsters_index()
        # Swap the Name entry for a monster dropdown + library button
        self.after(0, self._install_monster_dropdown_widget)

        # Spell preset cache (YAML files in ./Spells)
        self._spell_presets_cache: Optional[List[Dict[str, Any]]] = None
        self._spell_index_entries: Dict[str, Any] = {}
        self._spell_index_loaded = False
        self._spell_dir_notice: Optional[str] = None
        self._spell_dir_signature: Optional[Tuple[int, int, Tuple[str, ...]]] = None
        self._items_registry_cache: Optional[Dict[str, Dict[str, Dict[str, Any]]]] = None
        self._items_dir_signature: Optional[Tuple[Tuple[int, int, Tuple[str, ...]], Tuple[int, int, Tuple[str, ...]], Tuple[Tuple[str, int, int], ...], Tuple[Tuple[str, int, int], ...]]] = None
        self._items_dir_cache: Optional[Path] = None
        self._wild_shape_known_by_player: Dict[str, List[str]] = {}
        self._player_yaml_cache_by_path: Dict[Path, Optional[Dict[str, Any]]] = {}
        self._player_yaml_meta_by_path: Dict[Path, Dict[str, object]] = {}
        self._player_yaml_data_by_name: Dict[str, Dict[str, Any]] = {}
        self._player_yaml_name_map: Dict[str, Path] = {}
        self._player_yaml_dir_signature: Optional[Tuple[int, int, Tuple[str, ...]]] = None
        self._player_yaml_last_refresh = 0.0
        self._player_yaml_refresh_interval_s = 1.0
        self._lan_resource_pools_last_build = 0.0
        self._player_yaml_lock = threading.Lock()
        self._spell_yaml_lock = threading.Lock()
        self._player_yaml_refresh_scheduled = False
        self._yaml_players_index_path_cache: Optional[Path] = None
        self._roster_manager_refresh: Optional[Callable[[], None]] = None
        self._yaml_players_refresh_cache(rebuild=True)

        # LAN state for when map window isn't open
        self._lan_grid_cols = 20
        self._lan_grid_rows = 20
        self._lan_positions: Dict[int, Tuple[int, int]] = {}  # cid -> (col,row)
        self._lan_obstacles: set[Tuple[int, int]] = set()
        self._lan_rough_terrain: Dict[Tuple[int, int], object] = {}
        self._lan_aoes: Dict[int, Dict[str, Any]] = {}
        self._lan_next_aoe_id = 1
        self._lan_auras_enabled = True
        self._session_bg_images: List[Dict[str, Any]] = []
        self._session_next_bg_id = 1
        self._turn_snapshots: Dict[int, Dict[str, Any]] = {}
        self._summon_groups: Dict[str, List[int]] = {}
        self._summon_group_meta: Dict[str, Dict[str, Any]] = {}
        self._pending_pre_summons: Dict[int, Dict[str, Any]] = {}
        self._pending_mount_requests: Dict[str, Dict[str, Any]] = {}
        self._pending_echo_tether_confirms: Dict[str, Dict[str, Any]] = {}
        self._session_has_saved = False

        # POC helpers: start the LAN server automatically.
        # Start quietly (log on success; avoid popups if deps missing)
        self.after(0, self._auto_load_quick_save_on_startup)
        self.after(600, self._check_for_updates_on_startup)
        if POC_AUTO_START_LAN:
            self.after(250, lambda: self._lan.start(quiet=True))

    def _open_combatant_stat_block(self, c: base.Combatant) -> None:
        """Use the full creature-info modal for player/allied YAML profiles too."""
        if not (c.is_pc or c.ally):
            super()._open_combatant_stat_block(c)
            return
        player_data = self._lookup_player_yaml_for_combatant(c)
        if not isinstance(player_data, dict):
            super()._open_combatant_stat_block(c)
            return
        player_spec = self._player_yaml_to_monster_spec(c, player_data)
        self._open_monster_stat_block(player_spec)

    def _lookup_player_yaml_for_combatant(self, c: base.Combatant) -> Optional[Dict[str, Any]]:
        self._load_player_yaml_cache()
        candidates = [str(c.name or "").strip()]
        normalized = self._normalize_character_lookup_key(c.name)
        if normalized:
            candidates.append(normalized)
        for key in candidates:
            if key in self._player_yaml_data_by_name:
                return self._player_yaml_data_by_name.get(key)
        if normalized:
            path = self._player_yaml_name_map.get(normalized)
            if isinstance(path, Path):
                cached = self._player_yaml_cache_by_path.get(path)
                if isinstance(cached, dict):
                    return cached
        return None

    def _player_yaml_to_monster_spec(self, c: base.Combatant, player_data: Dict[str, Any]) -> MonsterSpec:
        identity = player_data.get("identity") if isinstance(player_data.get("identity"), dict) else {}
        leveling = player_data.get("leveling") if isinstance(player_data.get("leveling"), dict) else {}
        vitals = player_data.get("vitals") if isinstance(player_data.get("vitals"), dict) else {}
        defenses = player_data.get("defenses") if isinstance(player_data.get("defenses"), dict) else {}
        proficiency = player_data.get("proficiency") if isinstance(player_data.get("proficiency"), dict) else {}
        abilities = player_data.get("abilities") if isinstance(player_data.get("abilities"), dict) else {}
        actions = player_data.get("actions") if isinstance(player_data.get("actions"), list) else list(c.actions)
        bonus_actions = player_data.get("bonus_actions") if isinstance(player_data.get("bonus_actions"), list) else list(c.bonus_actions)
        reactions = player_data.get("reactions") if isinstance(player_data.get("reactions"), list) else list(c.reactions)

        speed = vitals.get("speed") if isinstance(vitals.get("speed"), dict) else {}
        ac_block = defenses.get("ac") if isinstance(defenses.get("ac"), dict) else {}
        ac_sources = ac_block.get("sources") if isinstance(ac_block.get("sources"), list) else []
        ac_value: object = getattr(c, "ac", None)
        if isinstance(ac_sources, list):
            for source in ac_sources:
                if isinstance(source, dict):
                    ac_value = source.get("value") or source.get("base_formula") or ac_value
                    break

        traits: List[Dict[str, str]] = []
        classes = leveling.get("classes") if isinstance(leveling.get("classes"), list) else []
        if classes:
            class_text = ", ".join(
                f"{entry.get('name', 'Class')} {entry.get('level', '?')}"
                for entry in classes
                if isinstance(entry, dict)
            )
            if class_text:
                traits.append({"name": "Classes", "description": class_text})

        features = player_data.get("features") if isinstance(player_data.get("features"), list) else []
        for feature in features:
            if not isinstance(feature, dict):
                continue
            fname = str(feature.get("name") or "").strip()
            fdesc = str(feature.get("description") or feature.get("desc") or "").strip()
            if fname:
                traits.append({"name": fname, "description": fdesc})

        spellcasting = player_data.get("spellcasting") if isinstance(player_data.get("spellcasting"), dict) else {}
        if spellcasting.get("enabled"):
            spell_lines: List[str] = []
            casting_ability = spellcasting.get("casting_ability")
            if casting_ability:
                spell_lines.append(f"Casting Ability: {str(casting_ability).upper()}")
            for key, label in (("save_dc_formula", "Save DC"), ("spell_attack_formula", "Spell Attack")):
                value = spellcasting.get(key)
                if value:
                    spell_lines.append(f"{label}: {value}")
            prepared = spellcasting.get("prepared_spells")
            if isinstance(prepared, dict) and isinstance(prepared.get("prepared"), list):
                prepared_spells = [str(name).strip() for name in prepared.get("prepared", []) if str(name).strip()]
                if prepared_spells:
                    spell_lines.append("Prepared: " + ", ".join(prepared_spells))
            if spell_lines:
                traits.append({"name": "Spellcasting", "description": " | ".join(spell_lines)})

        description_parts = []
        for key in ("ancestry", "background", "alignment", "description"):
            value = identity.get(key)
            if value:
                description_parts.append(f"{key.title()}: {value}")

        pb = proficiency.get("bonus")
        saves = proficiency.get("saves") if isinstance(proficiency.get("saves"), list) else []
        skills = proficiency.get("skills") if isinstance(proficiency.get("skills"), dict) else {}

        raw_data: Dict[str, Any] = {
            "name": str(player_data.get("name") or c.name),
            "size": "Medium",
            "type": "player character" if c.is_pc else "ally",
            "alignment": identity.get("alignment") or "—",
            "cr": "—",
            "initiative": {"modifier": c.initiative},
            "ac": ac_value,
            "hp": {
                "average": vitals.get("current_hp", c.hp),
                "max": vitals.get("max_hp", c.hp),
            },
            "speed": {
                "walk": speed.get("walk", c.speed),
                "swim": speed.get("swim", c.swim_speed),
                "fly": speed.get("fly", c.fly_speed),
                "climb": speed.get("climb", c.climb_speed),
            },
            "proficiency_bonus": pb if pb is not None else "—",
            "abilities": {ab: abilities.get(ab) for ab in ("str", "dex", "con", "int", "wis", "cha") if ab in abilities},
            "saving_throws": [str(save).upper() for save in saves if str(save).strip()],
            "skills": {
                "proficient": skills.get("proficient", []),
                "expertise": skills.get("expertise", []),
            },
            "damage_vulnerabilities": defenses.get("vulnerabilities", []),
            "damage_resistances": defenses.get("resistances", []),
            "damage_immunities": defenses.get("immunities", []),
            "condition_immunities": defenses.get("condition_immunities", []),
            "traits": traits,
            "actions": actions,
            "bonus_actions": bonus_actions,
            "reactions": reactions,
            "description": "\n".join(description_parts),
            "languages": proficiency.get("languages", []),
        }

        dex_score = self._monster_int_from_value(abilities.get("dex")) if "dex" in abilities else None
        init_mod = ((dex_score - 10) // 2) if dex_score is not None else None
        return MonsterSpec(
            filename=f"player::{self._sanitize_player_filename(c.name)}.yaml",
            name=str(player_data.get("name") or c.name),
            mtype="Player Character" if c.is_pc else "Ally",
            cr=None,
            hp=self._monster_int_from_value(vitals.get("current_hp")) or int(c.hp),
            speed=self._monster_int_from_value(speed.get("walk")) or int(c.speed),
            swim_speed=self._monster_int_from_value(speed.get("swim")) or int(c.swim_speed),
            fly_speed=self._monster_int_from_value(speed.get("fly")) or int(c.fly_speed),
            burrow_speed=int(c.burrow_speed),
            climb_speed=self._monster_int_from_value(speed.get("climb")) or int(c.climb_speed),
            dex=dex_score,
            init_mod=init_mod,
            saving_throws=dict(c.saving_throws),
            ability_mods=dict(c.ability_mods),
            raw_data=raw_data,
        )

    # --------------------- Spell preset cache ---------------------

    def _spell_index_path(self) -> Path:
        return _ensure_logs_dir() / "spell_index.json"

    def _yaml_players_index_path(self) -> Path:
        cached = getattr(self, "_yaml_players_index_path_cache", None)
        if isinstance(cached, Path):
            return cached
        path = _ensure_logs_dir() / "yaml_players_index.json"
        self._yaml_players_index_path_cache = path
        return path

    def _yaml_player_key(self, path: Path, players_dir: Optional[Path] = None) -> str:
        root = players_dir or self._players_dir()
        try:
            rel_path = path.relative_to(root)
        except Exception:
            rel_path = path.name
        return _hash_text(str(rel_path).lower())

    def _yaml_players_load_index(self) -> Dict[str, Any]:
        data = _read_index_file(self._yaml_players_index_path())
        entries = data.get("entries") if isinstance(data, dict) else None
        if not isinstance(entries, dict):
            entries = {}
        version = data.get("version") if isinstance(data, dict) else None
        return {"version": int(version or 1), "entries": dict(entries)}

    def _yaml_players_save_index(self, entries: Dict[str, Dict[str, Any]]) -> None:
        payload = {"version": 1, "entries": dict(entries)}
        _write_index_file(self._yaml_players_index_path(), payload)

    def _yaml_players_sync_index(self, files: List[Path]) -> Dict[str, Dict[str, Any]]:
        index_data = self._yaml_players_load_index()
        entries: Dict[str, Dict[str, Any]] = {}
        raw_entries = index_data.get("entries")
        if isinstance(raw_entries, dict):
            for key, value in raw_entries.items():
                if isinstance(value, dict):
                    entries[str(key)] = dict(value)
        players_dir = self._players_dir()
        seen_keys: set[str] = set()
        changed = False

        for path in files:
            key = self._yaml_player_key(path, players_dir)
            seen_keys.add(key)
            entry = entries.get(key, {})
            if not isinstance(entry, dict):
                entry = {}
            try:
                rel_path = str(path.relative_to(players_dir))
            except Exception:
                rel_path = str(path)
            if entry.get("path") != rel_path:
                entry["path"] = rel_path
                changed = True
            if "enabled" not in entry:
                entry["enabled"] = True
                changed = True
            display_name = str(entry.get("display_name") or "").strip()
            if not display_name:
                display_name = self._player_name_from_filename(path) or path.stem
                entry["display_name"] = display_name
                changed = True
            entries[key] = entry

        for key in list(entries.keys()):
            if key not in seen_keys:
                entries.pop(key, None)
                changed = True

        if changed:
            self._yaml_players_save_index(entries)
        return entries

    def _yaml_players_rescan(self) -> List[Dict[str, Any]]:
        players_dir = self._players_dir()
        if not players_dir.exists():
            self._yaml_players_save_index({})
            return []
        try:
            files = sorted(list(players_dir.glob("*.yaml")) + list(players_dir.glob("*.yml")))
        except Exception:
            files = []

        index_entries = self._yaml_players_sync_index(files)
        results: List[Dict[str, Any]] = []
        now_text = datetime.now().isoformat(timespec="seconds")
        changed = False

        for path in files:
            key = self._yaml_player_key(path, players_dir)
            entry = index_entries.get(key, {})
            if not isinstance(entry, dict):
                entry = {}
            display_name = str(entry.get("display_name") or "").strip()
            parsed_name: Optional[str] = None
            if yaml is not None:
                try:
                    raw = path.read_text(encoding="utf-8")
                    parsed = yaml.safe_load(raw)
                except Exception:
                    parsed = None
                if isinstance(parsed, dict):
                    parsed_name = self._extract_character_name(parsed)
            if parsed_name:
                display_name = parsed_name
            if not display_name:
                display_name = self._player_name_from_filename(path) or path.stem
            if display_name != entry.get("display_name"):
                entry["display_name"] = display_name
                changed = True
            entry["last_seen"] = now_text
            if "enabled" not in entry:
                entry["enabled"] = True
                changed = True
            index_entries[key] = entry
            results.append(
                {
                    "key": key,
                    "path": entry.get("path") or str(path),
                    "display_name": display_name,
                    "enabled": bool(entry.get("enabled", True)),
                }
            )

        if changed:
            self._yaml_players_save_index(index_entries)
        enabled_count = sum(1 for entry in results if entry.get("enabled"))
        self._oplog(
            f"YAML player rescan: discovered={len(results)} enabled={enabled_count}",
            level="info",
        )
        return results

    def _yaml_players_set_enabled(self, key: str, enabled: bool) -> None:
        key = str(key or "").strip()
        if not key:
            return
        index_data = self._yaml_players_load_index()
        entries = index_data.get("entries")
        if not isinstance(entries, dict):
            entries = {}
        entry = entries.get(key)
        if not isinstance(entry, dict):
            entry = {"enabled": bool(enabled)}
        else:
            entry = dict(entry)
            entry["enabled"] = bool(enabled)
        entries[key] = entry
        self._yaml_players_save_index(entries)
        self._oplog(f"YAML player roster updated: key={key} enabled={bool(enabled)}", level="info")

    def _yaml_players_refresh_cache(self, rebuild: bool = True) -> None:
        self._player_yaml_cache_by_path = {}
        self._player_yaml_meta_by_path = {}
        self._player_yaml_data_by_name = {}
        self._player_yaml_name_map = {}
        self._player_yaml_dir_signature = None
        self._player_yaml_last_refresh = 0.0
        if rebuild:
            self._load_player_yaml_cache(force_refresh=True)
        try:
            self._lan._cached_pcs = []
            self._lan._cached_snapshot = {
                "grid": None,
                "obstacles": [],
                "units": [],
                "active_cid": None,
                "round_num": 0,
            }
            self._lan._last_snapshot = None
            self._lan._last_static_json = None
        except Exception:
            pass
        try:
            self._lan_force_state_broadcast()
        except Exception:
            pass
        enabled_count = len(self._player_yaml_data_by_name)
        self._oplog(f"YAML player cache refreshed: enabled_profiles={enabled_count}", level="info")

    def _refresh_player_yaml_index(self) -> None:
        self._yaml_players_rescan()
        self._yaml_players_refresh_cache(rebuild=True)
        try:
            self._lan_force_state_broadcast()
        except Exception:
            pass
        refresh_roster = getattr(self, "_roster_manager_refresh", None)
        if callable(refresh_roster):
            try:
                refresh_roster()
            except Exception:
                pass

    def _invalidate_spell_index_cache(self) -> None:
        self._spell_presets_cache = None
        self._spell_index_entries = {}
        self._spell_index_loaded = False
        self._spell_dir_signature = None

    def _resolve_items_dir(self) -> Optional[Path]:
        cached = self.__dict__.get("_items_dir_cache")
        if isinstance(cached, Path) and cached.exists():
            return cached
        items_dir = _seed_user_items_dir()
        if items_dir.exists():
            self._items_dir_cache = items_dir
            return items_dir
        return None

    def _items_registry_payload(self) -> Dict[str, Dict[str, Dict[str, Any]]]:
        cached = self.__dict__.get("_items_registry_cache")
        cached_signature = self.__dict__.get("_items_dir_signature")
        items_dir = self._resolve_items_dir()
        if items_dir is None:
            self._items_registry_cache = {"weapons": {}, "armors": {}}
            self._items_dir_signature = None
            return {"weapons": {}, "armors": {}}

        weapons_dir = items_dir / "Weapons"
        armor_dir = items_dir / "Armor"
        weapon_files = sorted(list(weapons_dir.glob("*.yaml")) + list(weapons_dir.glob("*.yml"))) if weapons_dir.is_dir() else []
        armor_files = sorted(list(armor_dir.glob("*.yaml")) + list(armor_dir.glob("*.yml"))) if armor_dir.is_dir() else []
        signature = (
            _directory_signature(weapons_dir, weapon_files) if weapons_dir.is_dir() else (0, 0, tuple()),
            _directory_signature(armor_dir, armor_files) if armor_dir.is_dir() else (0, 0, tuple()),
            _files_signature(weapon_files),
            _files_signature(armor_files),
        )
        if isinstance(cached, dict) and signature == cached_signature:
            return cached

        def parse_items_from_file(path: Path, bucket_key: str) -> List[Tuple[str, Dict[str, Any], bool]]:
            try:
                parsed = yaml.safe_load(path.read_text(encoding="utf-8")) if yaml is not None else None
            except Exception as exc:
                self._oplog(f"Items YAML parse failed for {path}: {exc}", level="warning")
                return []
            if not isinstance(parsed, dict):
                return []

            if bucket_key == "weapons":
                if "weapons" in parsed and isinstance(parsed.get("weapons"), list):
                    out: List[Tuple[str, Dict[str, Any], bool]] = []
                    for raw_entry in parsed.get("weapons") or []:
                        if not isinstance(raw_entry, dict):
                            continue
                        item_id = str(raw_entry.get("id") or "").strip().lower()
                        if not item_id:
                            continue
                        out.append((item_id, dict(raw_entry), False))
                    return out
                if "properties" in parsed and "id" not in parsed:
                    return []
            else:
                if "armors" in parsed and isinstance(parsed.get("armors"), list):
                    out = []
                    for raw_entry in parsed.get("armors") or []:
                        if not isinstance(raw_entry, dict):
                            continue
                        item_id = str(raw_entry.get("id") or "").strip().lower()
                        if not item_id:
                            continue
                        out.append((item_id, dict(raw_entry), False))
                    return out

            item_id = str(parsed.get("id") or "").strip().lower()
            if not item_id:
                return []
            return [(item_id, dict(parsed), True)]

        registry: Dict[str, Dict[str, Dict[str, Any]]] = {"weapons": {}, "armors": {}}
        sources: Dict[str, Dict[str, str]] = {"weapons": {}, "armors": {}}

        for bucket_key, files in (("weapons", weapon_files), ("armors", armor_files)):
            for path in files:
                entries = parse_items_from_file(path, bucket_key)
                for item_id, item_data, is_per_item in entries:
                    prior = registry[bucket_key].get(item_id)
                    if prior is None:
                        registry[bucket_key][item_id] = item_data
                        sources[bucket_key][item_id] = "per-item" if is_per_item else "catalog"
                        continue
                    prior_source = sources[bucket_key].get(item_id, "catalog")
                    if prior_source == "per-item" and not is_per_item:
                        self._oplog(
                            f"Duplicate {bucket_key[:-1]} id '{item_id}' in {path.name}; keeping per-item definition.",
                            level="warning",
                        )
                        continue
                    if prior_source == "catalog" and is_per_item:
                        self._oplog(
                            f"Duplicate {bucket_key[:-1]} id '{item_id}' in {path.name}; preferring per-item definition.",
                            level="warning",
                        )
                        registry[bucket_key][item_id] = item_data
                        sources[bucket_key][item_id] = "per-item"
                        continue
                    self._oplog(
                        f"Duplicate {bucket_key[:-1]} id '{item_id}' in {path.name}; keeping latest {prior_source} definition.",
                        level="warning",
                    )
                    registry[bucket_key][item_id] = item_data
                    sources[bucket_key][item_id] = "per-item" if is_per_item else "catalog"

        self._items_registry_cache = registry
        self._items_dir_signature = signature
        return registry

    def _load_spell_index_entries(self) -> Dict[str, Any]:
        if self._spell_index_loaded:
            return self._spell_index_entries
        index_data = _read_index_file(self._spell_index_path())
        entries = index_data.get("entries") if isinstance(index_data.get("entries"), dict) else {}
        self._spell_index_entries = entries if isinstance(entries, dict) else {}
        self._spell_index_loaded = True
        return self._spell_index_entries

    def _refresh_monsters_spells(self) -> None:
        self._invalidate_spell_index_cache()
        super()._refresh_monsters_spells()

    def _load_monsters_and_spells(self) -> None:
        if not hasattr(self, "_spell_presets_cache"):
            self._spell_presets_cache = None
            self._spell_index_entries = {}
            self._spell_index_loaded = False
            self._spell_dir_notice = None
            self._spell_dir_signature = None
        self._load_monsters_index()
        self._spell_presets_payload()

    # --------------------- Logging split: battle vs operations ---------------------

    def _history_file_path(self) -> Path:
        """Battle log file path (used by base _log)."""
        logs = _ensure_logs_dir()
        return logs / "battle.log"

    def _oplog(self, text: str, level: str = "info") -> None:
        """Operations log: terminal + ./logs/operations.log (no UI)."""
        try:
            lg = getattr(self, "_ops_logger", None) or _make_ops_logger()
            fn = getattr(lg, level, lg.info)
            fn(str(text))
        except Exception:
            # fallback
            try:
                print(text)
            except Exception:
                pass

    def _lan_battle_log_lines(self, limit: int = 200) -> List[str]:
        path = self._history_file_path()
        try:
            if not path.exists():
                return []
        except Exception:
            return []
        if limit <= 0:
            try:
                return path.read_text(encoding="utf-8", errors="ignore").splitlines()
            except Exception:
                return []
        max_lines = max(1, int(limit))
        chunk_size = 8192
        try:
            with path.open("rb") as fh:
                fh.seek(0, os.SEEK_END)
                file_size = fh.tell()
                if file_size <= 0:
                    return []
                blocks: List[bytes] = []
                bytes_remaining = file_size
                newline_count = 0
                while bytes_remaining > 0 and newline_count <= max_lines:
                    read_size = min(chunk_size, bytes_remaining)
                    bytes_remaining -= read_size
                    fh.seek(bytes_remaining)
                    block = fh.read(read_size)
                    if not block:
                        break
                    blocks.append(block)
                    newline_count += block.count(b"\n")
                data = b"".join(reversed(blocks))
            lines = data.decode("utf-8", errors="ignore").splitlines()
        except Exception:
            return []
        if len(lines) > max_lines:
            return lines[-max_lines:]
        return lines

    def _resolve_spells_dir(self) -> Optional[Path]:
        spells_dir = _seed_user_spells_dir()
        if spells_dir is not None and spells_dir.exists():
            return spells_dir
        base_dir = _app_base_dir()
        notice = f"No spell presets found. Expected './Spells/' under {base_dir}."
        if self._spell_dir_notice != notice:
            self._oplog(notice, "info")
            self._spell_dir_notice = notice
        return spells_dir

    def _open_starting_players_dialog(self) -> None:
        """Disable legacy startup dialog; LAN clients use the roster picker modal."""
        return


    def _should_skip_turn(self, cid: Optional[int]) -> bool:
        cid_norm = _normalize_cid_value(cid, "turn.skip.cid")
        if cid_norm is None:
            return False
        combatant = self.combatants.get(int(cid_norm))
        if combatant is None:
            return False
        summon_owner = _normalize_cid_value(getattr(combatant, "summoned_by_cid", None), "turn.skip.summon.owner")
        if summon_owner is not None and bool(getattr(combatant, "summon_shared_turn", False)):
            return True
        mounted_by = _normalize_cid_value(getattr(combatant, "mounted_by_cid", None), "turn.skip.mounted_by")
        return mounted_by is not None and bool(getattr(combatant, "mount_shared_turn", False))

    def _first_non_skipped_turn_cid(self, ordered: List[Any]) -> Optional[int]:
        for entry in ordered:
            entry_cid = _normalize_cid_value(getattr(entry, "cid", None), "turn.skip.entry")
            if entry_cid is None:
                continue
            if not self._should_skip_turn(entry_cid):
                return int(entry_cid)
        return None

    def _process_start_of_turn(self, c: Any) -> Tuple[bool, str, set[str]]:
        skip, msg, dec_skip = super()._process_start_of_turn(c)
        setattr(c, "_rage_attack_made_this_turn", False)
        setattr(c, "_rage_took_damage_this_turn", False)
        self._run_combatant_turn_hooks(c, "start_turn")
        try:
            if bool(getattr(c, "is_pc", False)):
                player_name = self._pc_name_for(int(getattr(c, "cid", 0) or 0))
                profile = self._profile_for_player_name(player_name)
                monk_level = self._class_level_from_profile(profile, "monk") if isinstance(profile, dict) else 0
                if int(monk_level) >= 10:
                    removable = {"charmed", "frightened", "poisoned"}
                    stacks = list(getattr(c, "condition_stacks", []) or [])
                    active = {str(getattr(st, "ctype", "")).strip().lower() for st in stacks}
                    if removable.intersection(active):
                        ok_pool, _pool_err = self._consume_resource_pool_for_cast(player_name, "focus_points", 1)
                        if ok_pool:
                            c.condition_stacks = [
                                st for st in stacks if str(getattr(st, "ctype", "")).strip().lower() not in removable
                            ]
                            self._log(f"{getattr(c, 'name', 'Monk')} used Self-Restoration (1 Focus).", cid=int(getattr(c, "cid", 0)))
        except Exception:
            pass
        if getattr(c, "cid", None) in self.combatants:
            riders = list(getattr(c, "start_turn_damage_riders", []) or [])
            if riders:
                save_groups: Dict[str, Dict[str, Any]] = {}
                remaining_riders: List[Dict[str, Any]] = []
                rider_msgs: List[str] = []
                for rider in riders:
                    if not isinstance(rider, dict):
                        continue
                    dice_text = str(rider.get("dice") or "").strip().lower()
                    match = re.fullmatch(r"(\d*)d(\d+)", dice_text)
                    if not match:
                        continue
                    count = int(match.group(1) or 1)
                    sides = int(match.group(2))
                    if count <= 0 or sides <= 0:
                        continue
                    amount = sum(random.randint(1, sides) for _ in range(count))
                    dtype = str(rider.get("type") or "damage").strip() or "damage"
                    source = str(rider.get("source") or "an effect").strip() or "an effect"
                    adjusted = self._adjust_damage_entries_for_target(c, [{"amount": int(amount), "type": str(dtype).lower()}])
                    applied_entries = list(adjusted.get("entries") or [])
                    applied_amount = int(sum(int(entry.get("amount", 0) or 0) for entry in applied_entries))
                    before_hp = getattr(c, "hp", None)
                    try:
                        before_hp_int = int(before_hp)
                    except Exception:
                        before_hp_int = None
                    if before_hp_int is not None and applied_amount > 0:
                        after_hp = max(0, before_hp_int - int(applied_amount))
                        setattr(c, "hp", int(after_hp))
                        rider_msgs.append(f"takes {int(applied_amount)} {dtype} from {source}")
                    elif before_hp_int is not None:
                        after_hp = before_hp_int
                        rider_msgs.append(f"ignores {int(amount)} {dtype} from {source}")
                    else:
                        after_hp = None
                    if before_hp_int is not None and after_hp is not None and before_hp_int > 0 and after_hp <= 0:
                        pre_order = [x.cid for x in self._display_order()]
                        dead_id = int(getattr(c, "cid", -1))
                        self.combatants.pop(dead_id, None)
                        if self.start_cid == dead_id:
                            self.start_cid = None
                        self._retarget_current_after_removal([dead_id], pre_order=pre_order)
                        rider_msgs.append("dropped to 0 -> removed")
                        return skip, "; ".join(filter(None, [msg, ", ".join(rider_msgs)])), dec_skip
                    remaining_riders.append(dict(rider))
                    group_key = str(rider.get("clear_group") or "").strip().lower()
                    save_ability = str(rider.get("save_ability") or "").strip().lower()
                    try:
                        save_dc = int(rider.get("save_dc"))
                    except Exception:
                        save_dc = 0
                    if group_key and save_ability and save_dc > 0 and group_key not in save_groups:
                        save_groups[group_key] = {"ability": save_ability, "dc": int(save_dc)}
                for group_key, save_cfg in save_groups.items():
                    save_roll = random.randint(1, 20)
                    save_ability = str(save_cfg.get("ability") or "").strip().lower()
                    save_dc = int(save_cfg.get("dc") or 0)
                    saves = getattr(c, "saving_throws", None)
                    save_mod = 0
                    if isinstance(saves, dict):
                        try:
                            save_mod = int(saves.get(save_ability) or 0)
                        except Exception:
                            save_mod = 0
                    if save_mod == 0:
                        mods = getattr(c, "ability_mods", None)
                        if isinstance(mods, dict):
                            try:
                                save_mod = int(mods.get(save_ability) or 0)
                            except Exception:
                                save_mod = 0
                    save_total = int(save_roll) + int(save_mod)
                    save_passed = bool(save_roll != 1 and save_total >= int(save_dc))
                    rider_msgs.append(
                        f"{save_ability.upper()} save DC {save_dc}: {save_roll} + {save_mod} = {save_total} "
                        f"({'PASS' if save_passed else 'FAIL'})"
                    )
                    if save_passed:
                        remaining_riders = [
                            rider
                            for rider in remaining_riders
                            if str(rider.get("clear_group") or "").strip().lower() != group_key
                        ]
                setattr(c, "start_turn_damage_riders", remaining_riders)
                if rider_msgs:
                    msg = "; ".join(filter(None, [msg, ", ".join(rider_msgs)]))
            save_riders = list(getattr(c, "start_turn_save_riders", []) or [])
            if save_riders:
                remaining_save_riders: List[Dict[str, Any]] = []
                cleared_groups: set[str] = set()
                rider_msgs: List[str] = []
                for rider in save_riders:
                    if not isinstance(rider, dict):
                        continue
                    save_ability = str(rider.get("save_ability") or "").strip().lower()
                    try:
                        save_dc = int(rider.get("save_dc"))
                    except Exception:
                        save_dc = 0
                    if not save_ability or save_dc <= 0:
                        continue
                    save_roll = random.randint(1, 20)
                    save_mod = 0
                    saves = getattr(c, "saving_throws", None)
                    if isinstance(saves, dict):
                        try:
                            save_mod = int(saves.get(save_ability) or 0)
                        except Exception:
                            save_mod = 0
                    if save_mod == 0:
                        mods = getattr(c, "ability_mods", None)
                        if isinstance(mods, dict):
                            try:
                                save_mod = int(mods.get(save_ability) or 0)
                            except Exception:
                                save_mod = 0
                    save_total = int(save_roll) + int(save_mod)
                    save_passed = bool(save_roll != 1 and save_total >= int(save_dc))
                    rider_msgs.append(
                        f"{save_ability.upper()} save DC {save_dc}: {save_roll} + {save_mod} = {save_total} "
                        f"({'PASS' if save_passed else 'FAIL'})"
                    )
                    clear_group = str(rider.get("clear_group") or "").strip().lower()
                    condition = str(rider.get("condition") or "").strip().lower()
                    if save_passed:
                        if clear_group:
                            cleared_groups.add(clear_group)
                        if condition:
                            stacks = list(getattr(c, "condition_stacks", []) or [])
                            stacks = [st for st in stacks if str(getattr(st, "ctype", "")).strip().lower() != condition]
                            setattr(c, "condition_stacks", stacks)
                        continue
                    remaining_save_riders.append(dict(rider))
                if cleared_groups:
                    remaining_save_riders = [
                        rider
                        for rider in remaining_save_riders
                        if str(rider.get("clear_group") or "").strip().lower() not in cleared_groups
                    ]
                    start_turn_damage_riders = list(getattr(c, "start_turn_damage_riders", []) or [])
                    start_turn_damage_riders = [
                        rider
                        for rider in start_turn_damage_riders
                        if str(rider.get("clear_group") or "").strip().lower() not in cleared_groups
                    ]
                    setattr(c, "start_turn_damage_riders", start_turn_damage_riders)
                setattr(c, "start_turn_save_riders", remaining_save_riders)
                if rider_msgs:
                    msg = "; ".join(filter(None, [msg, ", ".join(rider_msgs)]))
        try:
            setattr(c, "has_mounted_this_turn", False)
            mount_cid = _normalize_cid_value(getattr(c, "rider_cid", None), "turn.start.rider_mount")
            if mount_cid is not None and mount_cid in self.combatants:
                mount = self.combatants[int(mount_cid)]
                if self._mount_uses_rider_movement(mount):
                    mount_speed = int(self._mode_speed(mount))
                    setattr(c, "move_total", mount_speed)
                    setattr(c, "move_remaining", mount_speed)
            self._lan_record_turn_snapshot(int(getattr(c, "cid", -1)))
        except Exception:
            pass
        return skip, msg, dec_skip

    def _apply_pending_pre_summons(self) -> None:
        pending = dict(getattr(self, "_pending_pre_summons", {}) or {})
        if not pending:
            return
        for caster_cid, config in pending.items():
            caster = self.combatants.get(int(caster_cid))
            if caster is None or not isinstance(config, dict):
                continue
            spell_slug = str(config.get("spell_slug") or "").strip().lower()
            monster_slug = str(config.get("monster_slug") or "").strip().lower()
            slot_level = config.get("slot_level")
            variant = str(config.get("variant") or "").strip() or None
            if not spell_slug or not monster_slug:
                continue
            preset = self._find_spell_preset(spell_slug=spell_slug, spell_id=spell_slug)
            if not isinstance(preset, dict):
                continue
            summon_cfg = preset.get("summon") if isinstance(preset.get("summon"), dict) else {}
            if not isinstance(summon_cfg, dict):
                continue
            positions = None
            caster_pos = self._lan_current_position(int(caster_cid))
            if caster_pos is not None:
                positions = [{"col": int(caster_pos[0]), "row": int(caster_pos[1])}]
            self._spawn_mount(
                caster_cid=int(caster_cid),
                preset=preset,
                summon_cfg=summon_cfg,
                chosen_slug=monster_slug,
                slot_level=slot_level if isinstance(slot_level, int) else None,
                variant_name=variant,
                summon_positions=positions,
            )
        self._pending_pre_summons = {}

    def _format_elapsed_duration(self, elapsed_seconds: float) -> str:
        try:
            total = int(round(float(elapsed_seconds)))
        except Exception:
            total = 0
        if total < 0:
            total = 0
        hours, rem = divmod(total, 3600)
        mins, secs = divmod(rem, 60)
        if hours > 0:
            return f"{hours}:{mins:02d}:{secs:02d}"
        return f"{mins}:{secs:02d}"

    def _append_time_round_summary(self, round_num: int, buckets: Dict[str, float], order: List[str]) -> None:
        if not buckets:
            return
        try:
            logs = _ensure_logs_dir()
            logs.mkdir(parents=True, exist_ok=True)
            path = logs / "time.log"
        except Exception:
            return

        lines = [f"Round {max(1, int(round_num))}:"]
        dm_seconds = float(buckets.get("DM Time", 0.0) or 0.0)
        round_seconds = 0.0
        for value in buckets.values():
            try:
                seconds = float(value)
            except Exception:
                seconds = 0.0
            if seconds < 0:
                seconds = 0.0
            round_seconds += seconds
        lines.append(f"DM Time: {self._format_elapsed_duration(dm_seconds)}")
        for name in order:
            if name == "DM Time":
                continue
            lines.append(f"{name}: {self._format_elapsed_duration(float(buckets.get(name, 0.0) or 0.0))}")
        lines.append(f"Round Time: {self._format_elapsed_duration(round_seconds)}")
        lines.append("")
        try:
            with path.open("a", encoding="utf-8") as fh:
                fh.write("\n".join(lines))
                fh.write("\n")
        except Exception:
            return

    def _flush_timing_round_if_ready(self, next_round: Optional[int] = None) -> None:
        if not bool(getattr(self, "_turn_timing_active", False)):
            return
        last_round = int(getattr(self, "_turn_timing_last_round", 0) or 0)
        if last_round <= 0:
            return
        if next_round is None:
            next_round = int(getattr(self, "round_num", last_round) or last_round)
        if int(next_round) <= last_round:
            return
        buckets = dict(getattr(self, "_turn_timing_round_totals", {}) or {})
        order = list(getattr(self, "_turn_timing_pc_order", []) or [])
        self._append_time_round_summary(last_round, buckets, order)
        self._turn_timing_round_totals = {}
        self._turn_timing_pc_order = []
        self._turn_timing_last_round = int(next_round)

    def _log_turn_start(self, cid: int) -> None:
        super()._log_turn_start(cid)
        try:
            if not bool(getattr(self, "_turn_timing_active", False)):
                return
            current_round = int(getattr(self, "round_num", 0) or 0)
            last_round = int(getattr(self, "_turn_timing_last_round", 0) or 0)
            if last_round <= 0:
                self._turn_timing_last_round = max(1, current_round)
            elif current_round > last_round:
                self._flush_timing_round_if_ready(next_round=current_round)
            self._turn_timing_current_cid = int(cid)
            self._turn_timing_start_ts = float(time.perf_counter())
        except Exception:
            return

    def _log_turn_end(self, cid: int, note: str = "") -> None:
        super()._log_turn_end(cid, note=note)
        try:
            if not bool(getattr(self, "_turn_timing_active", False)):
                return
            running_cid = getattr(self, "_turn_timing_current_cid", None)
            started = getattr(self, "_turn_timing_start_ts", None)
            if running_cid is None or started is None or int(running_cid) != int(cid):
                return
            elapsed = float(time.perf_counter()) - float(started)
            if elapsed < 0:
                elapsed = 0.0
            combatant = getattr(self, "combatants", {}).get(int(cid)) if isinstance(getattr(self, "combatants", None), dict) else None
            bucket = "DM Time"
            if combatant is not None and bool(getattr(combatant, "is_pc", False)):
                bucket = str(getattr(combatant, "name", "") or f"#{cid}")
            totals = getattr(self, "_turn_timing_round_totals", None)
            if not isinstance(totals, dict):
                totals = {}
                self._turn_timing_round_totals = totals
            totals[bucket] = float(totals.get(bucket, 0.0) or 0.0) + float(elapsed)
            if bucket != "DM Time":
                order = getattr(self, "_turn_timing_pc_order", None)
                if not isinstance(order, list):
                    order = []
                    self._turn_timing_pc_order = order
                if bucket not in order:
                    order.append(bucket)
        except Exception:
            return
        finally:
            self._turn_timing_current_cid = None
            self._turn_timing_start_ts = None

    def _start_turns(self) -> None:
        self._apply_pending_pre_summons()
        self._turn_timing_active = True
        self._turn_timing_current_cid = None
        self._turn_timing_start_ts = None
        self._turn_timing_last_round = 1
        self._turn_timing_round_totals = {}
        self._turn_timing_pc_order = []
        ordered = self._display_order()
        if not ordered:
            messagebox.showinfo("Turn Tracker", "No combatants in the list yet.")
            return
        first_cid = self._first_non_skipped_turn_cid(ordered)
        if first_cid is None:
            first_cid = int(getattr(ordered[0], "cid", 0))
        self.current_cid = first_cid
        self.round_num = 1
        self.turn_num = 1
        self._log("--- COMBAT STARTED ---")
        self._log("--- ROUND 1 ---")
        self._enter_turn_with_auto_skip(starting=True)
        self._rebuild_table(scroll_to_current=True)

    def _claimed_cids_snapshot(self) -> set[int]:
        lan = getattr(self, "_lan", None)
        if lan is None:
            return set()
        direct_getter = getattr(lan, "claimed_cids_snapshot", None)
        if callable(direct_getter):
            try:
                claimed = direct_getter()
            except Exception:
                claimed = None
            if isinstance(claimed, (set, list, tuple)):
                normalized: set[int] = set()
                for raw_cid in claimed:
                    try:
                        normalized.add(int(raw_cid))
                    except Exception:
                        continue
                return normalized
        getter = getattr(lan, "_claims_payload", None)
        if not callable(getter):
            return set()
        try:
            payload = getter()
        except Exception:
            return set()
        if not isinstance(payload, dict):
            return set()
        claimed: set[int] = set()
        for raw_cid in payload.keys():
            try:
                claimed.add(int(raw_cid))
            except Exception:
                continue
        return claimed

    def _should_show_dm_up_alert(
        self,
        prev_cid: Optional[int],
        next_cid: Optional[int],
        claimed_cids: Optional[set[int]] = None,
    ) -> bool:
        if prev_cid is None or next_cid is None:
            return False
        if claimed_cids is None:
            claimed_cids = self._claimed_cids_snapshot()
        try:
            prev_id = int(prev_cid)
            next_id = int(next_cid)
        except Exception:
            return False
        if prev_id not in claimed_cids or next_id in claimed_cids:
            return False
        combatants = getattr(self, "combatants", None)
        if not isinstance(combatants, dict):
            return False
        prev = combatants.get(prev_id)
        if prev is None:
            return False
        return bool(getattr(prev, "is_pc", False))

    def _show_dm_up_alert_dialog(self) -> None:
        parent = self
        map_parent = None
        try:
            mw = getattr(self, "_map_window", None)
            if mw is not None and mw.winfo_exists():
                map_parent = mw
        except Exception:
            map_parent = None

        if map_parent is not None:
            parent = map_parent
            try:
                if hasattr(parent, "deiconify"):
                    parent.deiconify()
            except Exception:
                pass
            try:
                parent.lift()
            except Exception:
                pass
            try:
                parent.focus_force()
            except Exception:
                pass

        dialog = tk.Toplevel(parent)
        dialog.title("Turn Tracker")
        dialog.transient(parent)
        dialog.resizable(False, False)

        frame = ttk.Frame(dialog, padding=14)
        frame.grid(row=0, column=0, sticky="nsew")
        ttk.Label(frame, text="DM is up!").grid(row=0, column=0, sticky="w")
        ok_btn = ttk.Button(frame, text="OK", command=dialog.destroy)
        ok_btn.grid(row=1, column=0, sticky="e", pady=(10, 0))

        dialog.protocol("WM_DELETE_WINDOW", dialog.destroy)
        dialog.bind("<Return>", lambda _evt: dialog.destroy())
        dialog.bind("<Escape>", lambda _evt: dialog.destroy())

        dialog.update_idletasks()
        width = dialog.winfo_reqwidth()
        height = dialog.winfo_reqheight()

        xpos = None
        ypos = None
        try:
            parent.update_idletasks()
            parent_x = int(parent.winfo_rootx())
            parent_y = int(parent.winfo_rooty())
            parent_w = int(parent.winfo_width())
            parent_h = int(parent.winfo_height())
            if parent_w > 1 and parent_h > 1:
                xpos = parent_x + max(0, (parent_w - width) // 2)
                ypos = parent_y + max(0, (parent_h - height) // 2)
        except Exception:
            xpos = None
            ypos = None

        if xpos is None or ypos is None:
            screen_w = dialog.winfo_screenwidth()
            screen_h = dialog.winfo_screenheight()
            xpos = max(0, (screen_w - width) // 2)
            ypos = max(0, (screen_h - height) // 2)
        dialog.geometry(f"{width}x{height}+{xpos}+{ypos}")

        dialog.wm_attributes("-topmost", True)
        dialog.lift()
        dialog.focus_force()
        dialog.after_idle(lambda: dialog.wm_attributes("-topmost", False))

        dialog.grab_set()
        ok_btn.focus_set()
        dialog.wait_window(dialog)

    def _next_turn(self) -> None:
        ordered = self._display_order()
        if not ordered:
            return

        ids = [int(c.cid) for c in ordered if getattr(c, "cid", None) is not None]
        if not ids:
            return

        if self.current_cid is None or self.current_cid not in ids:
            first_cid = self._first_non_skipped_turn_cid(ordered)
            self.current_cid = first_cid if first_cid is not None else ids[0]
            self.round_num = max(1, self.round_num)
            self.turn_num = max(1, self.turn_num)
            self._enter_turn_with_auto_skip(starting=True)
            self._rebuild_table(scroll_to_current=True)
            return

        ended_cid = self.current_cid
        claimed_cids = self._claimed_cids_snapshot()
        self._end_turn_cleanup(self.current_cid)
        if ended_cid is not None:
            self._log_turn_end(ended_cid)

        idx = ids.index(self.current_cid)
        steps = 0
        wrapped = False
        next_cid = self.current_cid
        while steps < len(ids):
            nxt = (idx + 1 + steps) % len(ids)
            if nxt == 0:
                wrapped = True
            cand = ids[nxt]
            if not self._should_skip_turn(cand):
                next_cid = cand
                break
            steps += 1
        self.current_cid = next_cid
        self.turn_num += 1
        if wrapped:
            self.round_num += 1
            self._log(f"--- ROUND {self.round_num} ---")

        if self._should_show_dm_up_alert(ended_cid, self.current_cid, claimed_cids=claimed_cids):
            self._show_dm_up_alert_dialog()

        self._enter_turn_with_auto_skip(starting=False)
        current_turn_cid = _normalize_cid_value(getattr(self, "current_cid", None), "next_turn.current_cid")
        if current_turn_cid is not None:
            for _aid, aoe in list((getattr(self, "_lan_aoes", {}) or {}).items()):
                if not isinstance(aoe, dict):
                    continue
                owner_cid = _normalize_cid_value(aoe.get("owner_cid"), "next_turn.aoe.owner_cid")
                if owner_cid != int(current_turn_cid):
                    continue
                try:
                    move_limit = float(aoe.get("move_per_turn_ft"))
                except Exception:
                    continue
                if move_limit > 0:
                    aoe["move_remaining_ft"] = float(move_limit)
        self._rebuild_table(scroll_to_current=True)

    def _end_turn_cleanup(self, cid: Optional[int], skip_decrement_types: Optional[set[str]] = None) -> None:
        super()._end_turn_cleanup(cid, skip_decrement_types=skip_decrement_types)
        ending_cid = _normalize_cid_value(cid, "end_turn_cleanup.cid")
        if ending_cid is not None:
            for aid, aoe in list((getattr(self, "_lan_aoes", {}) or {}).items()):
                if not isinstance(aoe, dict) or not bool(aoe.get("over_time")):
                    continue
                trigger = str(aoe.get("trigger_on_start_or_enter") or "").strip().lower()
                if trigger not in ("end", "enter_or_end"):
                    continue
                included = self._lan_compute_included_units_for_aoe(aoe)
                if int(ending_cid) in {int(x) for x in included}:
                    self._lan_apply_aoe_trigger_to_targets(int(aid), aoe, target_cids=[int(ending_cid)])
        if cid is None or cid not in self.combatants:
            return
        c = self.combatants[cid]
        self._run_combatant_turn_hooks(c, "end_turn")
        riders = list(getattr(c, "end_turn_damage_riders", []) or [])
        if not riders:
            return
        remaining_riders: List[Dict[str, Any]] = []
        for rider in riders:
            if not isinstance(rider, dict):
                continue
            dice_text = str(rider.get("dice") or "").strip().lower()
            match = re.fullmatch(r"(\d*)d(\d+)", dice_text)
            if not match:
                continue
            count = int(match.group(1) or 1)
            sides = int(match.group(2))
            if count <= 0 or sides <= 0:
                continue
            amount = sum(random.randint(1, sides) for _ in range(count))
            dtype = str(rider.get("type") or "damage").strip() or "damage"
            source = str(rider.get("source") or "an effect").strip() or "an effect"
            adjusted = self._adjust_damage_entries_for_target(c, [{"amount": int(amount), "type": str(dtype).lower()}])
            applied_entries = list(adjusted.get("entries") or [])
            applied_amount = int(sum(int(entry.get("amount", 0) or 0) for entry in applied_entries))
            before_hp = getattr(c, "hp", None)
            try:
                before_hp_int = int(before_hp)
            except Exception:
                before_hp_int = None
            if before_hp_int is not None and applied_amount > 0:
                after_hp = max(0, before_hp_int - int(applied_amount))
                setattr(c, "hp", int(after_hp))
                self._log(
                    f"{c.name} takes {int(applied_amount)} {dtype} damage from {source} at end of turn.",
                    cid=cid,
                )
            elif before_hp_int is not None:
                after_hp = before_hp_int
                self._log(
                    f"{c.name} ignores {int(amount)} {dtype} damage from {source} at end of turn.",
                    cid=cid,
                )
            else:
                after_hp = None
            if before_hp_int is not None and after_hp is not None and before_hp_int > 0 and after_hp <= 0:
                try:
                    self._lan.play_ko(int(cid))
                except Exception:
                    pass
            turns_left = rider.get("remaining_turns")
            try:
                turns_left_int = int(turns_left)
            except Exception:
                turns_left_int = 0
            turns_left_int -= 1
            if turns_left_int > 0:
                updated = dict(rider)
                updated["remaining_turns"] = int(turns_left_int)
                remaining_riders.append(updated)
        setattr(c, "end_turn_damage_riders", remaining_riders)

    def _lan_current_position(self, cid: int) -> Optional[Tuple[int, int]]:
        mw = None
        try:
            mw = getattr(self, "_map_window", None)
            if mw is not None and not mw.winfo_exists():
                mw = None
        except Exception:
            mw = None
        if mw is not None:
            try:
                tok = getattr(mw, "unit_tokens", {}).get(cid)
                if tok:
                    return (int(tok.get("col")), int(tok.get("row")))
            except Exception:
                pass
        return self._lan_positions.get(cid)

    def _lan_record_turn_snapshot(self, cid: int) -> None:
        if cid not in self.combatants:
            return
        pos = self._lan_current_position(cid)
        if pos is None:
            return
        c = self.combatants[cid]
        self._turn_snapshots[cid] = {
            "col": int(pos[0]),
            "row": int(pos[1]),
            "move_remaining": int(getattr(c, "move_remaining", 0) or 0),
            "move_total": int(getattr(c, "move_total", 0) or 0),
            "action_remaining": int(getattr(c, "action_remaining", 0) or 0),
            "action_total": int(getattr(c, "action_total", 1) or 1),
            "attack_resource_remaining": int(getattr(c, "attack_resource_remaining", 0) or 0),
            "bonus_action_remaining": int(getattr(c, "bonus_action_remaining", 0) or 0),
            "reaction_remaining": int(getattr(c, "reaction_remaining", 0) or 0),
            "spell_cast_remaining": int(getattr(c, "spell_cast_remaining", 0) or 0),
        }

    def _lan_restore_turn_snapshot(self, cid: int) -> bool:
        snap = self._turn_snapshots.get(cid)
        if not snap or cid not in self.combatants:
            return False
        c = self.combatants[cid]
        c.move_remaining = int(snap.get("move_remaining", c.move_remaining))
        c.move_total = int(snap.get("move_total", c.move_total))
        c.action_remaining = int(snap.get("action_remaining", c.action_remaining))
        c.action_total = int(snap.get("action_total", getattr(c, "action_total", 1)))
        c.attack_resource_remaining = int(snap.get("attack_resource_remaining", getattr(c, "attack_resource_remaining", 0)))
        c.bonus_action_remaining = int(snap.get("bonus_action_remaining", c.bonus_action_remaining))
        c.reaction_remaining = int(snap.get("reaction_remaining", c.reaction_remaining))
        c.spell_cast_remaining = int(snap.get("spell_cast_remaining", c.spell_cast_remaining))

        col = int(snap.get("col", 0))
        row = int(snap.get("row", 0))
        self._lan_positions[cid] = (col, row)
        mw = self.__dict__.get("_map_window")
        try:
            if mw is not None and mw.winfo_exists():
                tok = getattr(mw, "unit_tokens", {}).get(cid)
                if tok:
                    tok["col"] = col
                    tok["row"] = row
                    mw._layout_unit(cid)
                    mw._update_groups()
                    mw._update_move_highlight()
                    mw._update_included_for_selected()
        except Exception:
            pass
        self._update_turn_ui()
        return True

    def _install_lan_menu(self) -> None:
        try:
            menubar = tk.Menu(self)
            try:
                # preserve any existing menu if base set one
                existing = self["menu"]
                if existing:
                    menubar = existing
            except Exception:
                pass

            lan = tk.Menu(menubar, tearoff=0)
            lan.add_command(label="Start LAN Server", command=self._lan.start)
            lan.add_command(label="Stop LAN Server", command=self._lan.stop)
            lan.add_separator()
            self._lan_url_mode_var = tk.StringVar(value=_normalize_lan_url_mode(getattr(getattr(self._lan, "url_settings", None), "url_mode", "http")))
            url_mode_menu = tk.Menu(lan, tearoff=0)
            for label, mode in (("HTTP", "http"), ("HTTPS", "https"), ("Both", "both")):
                url_mode_menu.add_radiobutton(
                    label=label,
                    value=mode,
                    variable=self._lan_url_mode_var,
                    command=lambda selected=mode: self._set_lan_url_mode(selected),
                )
            lan.add_cascade(label="URL Mode", menu=url_mode_menu)
            lan.add_command(label="Set HTTPS Public URL…", command=self._prompt_set_lan_https_public_url)
            lan.add_separator()
            lan.add_command(label="Show LAN URL", command=self._show_lan_url)
            lan.add_command(label="Show QR Code", command=self._show_lan_qr)
            lan.add_separator()
            lan.add_command(label="Sessions…", command=self._open_lan_sessions)
            lan.add_command(label="Admin Assignments…", command=self._open_lan_admin_assignments)
            lan.add_separator()
            lan.add_command(label="Roster Manager…", command=self._open_roster_manager)
            lan.add_command(label="Manage YAML Players…", command=self._open_yaml_player_manager)
            lan.add_command(label="Refresh Player YAML Index", command=self._refresh_player_yaml_index)
            menubar.add_cascade(label="LAN", menu=lan)

            session_menu = tk.Menu(menubar, tearoff=0)
            session_menu.add_command(label="New Session", command=self._new_session)
            session_menu.add_separator()
            session_menu.add_command(label="Save Session…", command=self._save_session_dialog)
            session_menu.add_command(label="Load Session…", command=self._load_session_dialog)
            session_menu.add_separator()
            session_menu.add_command(label="Quick Save", command=self._quick_save_session)
            session_menu.add_command(label="Quick Load", command=self._quick_load_session)
            session_menu.add_separator()
            session_menu.add_command(label="Reset Map", command=self._reset_map_state)
            menubar.add_cascade(label="Session", menu=session_menu)
            
            # Add Help menu
            help_menu = tk.Menu(menubar, tearoff=0)
            help_menu.add_command(label="Check for Updates", command=self._check_for_updates)
            help_menu.add_command(label="Update Log", command=self._show_update_log)
            help_menu.add_command(label="About", command=self._show_about)
            menubar.add_cascade(label="Help", menu=help_menu)
            
            self.config(menu=menubar)
        except Exception:
            pass

    def _lan_url_settings_path(self) -> Path:
        return _app_data_dir() / "settings" / "lan_url.json"

    def _load_lan_url_settings(self) -> None:
        path = self._lan_url_settings_path()
        try:
            if not path.exists():
                return
            payload = json.loads(path.read_text(encoding="utf-8"))
            if not isinstance(payload, dict):
                return
        except Exception:
            return
        settings = getattr(self._lan, "url_settings", LanUrlSettings())
        settings.url_mode = _normalize_lan_url_mode(payload.get("url_mode", settings.url_mode))
        settings.public_http_url = _normalize_public_url(payload.get("public_http_url"), required_scheme="http")
        settings.public_https_url = _normalize_public_url(payload.get("public_https_url"), required_scheme="https")
        self._lan.url_settings = settings

    def _save_lan_url_settings(self) -> None:
        settings = getattr(self._lan, "url_settings", LanUrlSettings())
        payload = {
            "url_mode": _normalize_lan_url_mode(getattr(settings, "url_mode", "http")),
            "public_http_url": _normalize_public_url(getattr(settings, "public_http_url", None), required_scheme="http"),
            "public_https_url": _normalize_public_url(getattr(settings, "public_https_url", None), required_scheme="https"),
        }
        path = self._lan_url_settings_path()
        try:
            path.parent.mkdir(parents=True, exist_ok=True)
            path.write_text(json.dumps(payload, indent=2, sort_keys=True), encoding="utf-8")
        except Exception:
            pass

    def _set_lan_url_mode(self, mode: str) -> None:
        settings = getattr(self._lan, "url_settings", LanUrlSettings())
        settings.url_mode = _normalize_lan_url_mode(mode)
        self._lan.url_settings = settings
        self._save_lan_url_settings()

    def _prompt_set_lan_https_public_url(self) -> None:
        current = _normalize_public_url(getattr(getattr(self._lan, "url_settings", None), "public_https_url", None), required_scheme="https")
        raw = simpledialog.askstring(
            "Set HTTPS Public URL",
            "Enter the HTTPS public URL (blank to clear):",
            initialvalue=current or "",
            parent=self,
        )
        if raw is None:
            return
        normalized = _normalize_public_url(raw, required_scheme="https")
        if str(raw).strip() and not normalized:
            messagebox.showerror("Set HTTPS Public URL", "Please enter a valid HTTPS URL, e.g. https://dnd.example.local/")
            return
        settings = getattr(self._lan, "url_settings", LanUrlSettings())
        settings.public_https_url = normalized
        self._lan.url_settings = settings
        self._save_lan_url_settings()

    def _session_saves_dir(self) -> Path:
        path = _app_data_dir() / "sessions"
        try:
            path.mkdir(parents=True, exist_ok=True)
        except Exception:
            pass
        return path

    def _session_default_filename(self) -> str:
        return f"session_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"

    def _session_quicksave_path(self) -> Path:
        return self._session_saves_dir() / "quick_save.json"

    def _json_safe(self, value: Any) -> Any:
        if value is None or isinstance(value, (bool, int, float, str)):
            return value
        if isinstance(value, Path):
            return str(value)
        if is_dataclass(value):
            try:
                return self._json_safe(asdict(value))
            except Exception:
                return str(value)
        if isinstance(value, dict):
            return {str(k): self._json_safe(v) for k, v in value.items()}
        if isinstance(value, (list, tuple, set)):
            return [self._json_safe(v) for v in value]
        return str(value)

    def _session_combatant_payload(self, c: Any) -> Dict[str, Any]:
        monster_spec = getattr(c, "monster_spec", None)
        monster_slug = str(getattr(c, "monster_slug", "") or "") or None
        monster_name = None
        if monster_spec is not None:
            monster_name = str(getattr(monster_spec, "name", "") or "") or None
            if not monster_slug:
                monster_slug = str(getattr(monster_spec, "filename", "") or "") or None
        monster_slug = self._normalize_monster_slug_value(monster_slug)
        attrs: Dict[str, Any] = {}
        for key, val in dict(getattr(c, "__dict__", {})).items():
            if key in {
                "cid", "name", "hp", "speed", "swim_speed", "fly_speed", "burrow_speed", "climb_speed",
                "movement_mode", "move_total", "move_remaining", "initiative", "dex", "roll", "nat20", "ally",
                "is_pc", "is_spellcaster", "actions", "bonus_actions", "reactions", "saving_throws", "ability_mods",
                "monster_spec",
            }:
                continue
            attrs[key] = self._json_safe(val)
        return {
            "cid": int(getattr(c, "cid", 0) or 0),
            "name": str(getattr(c, "name", "") or ""),
            "hp": int(getattr(c, "hp", 0) or 0),
            "speed": int(getattr(c, "speed", 0) or 0),
            "swim_speed": int(getattr(c, "swim_speed", 0) or 0),
            "fly_speed": int(getattr(c, "fly_speed", 0) or 0),
            "burrow_speed": int(getattr(c, "burrow_speed", 0) or 0),
            "climb_speed": int(getattr(c, "climb_speed", 0) or 0),
            "movement_mode": str(getattr(c, "movement_mode", "normal") or "normal"),
            "move_total": int(getattr(c, "move_total", 0) or 0),
            "move_remaining": int(getattr(c, "move_remaining", 0) or 0),
            "initiative": int(getattr(c, "initiative", 0) or 0),
            "dex": getattr(c, "dex", None),
            "roll": getattr(c, "roll", None),
            "nat20": bool(getattr(c, "nat20", False)),
            "ally": bool(getattr(c, "ally", False)),
            "is_pc": bool(getattr(c, "is_pc", False)),
            "is_spellcaster": bool(getattr(c, "is_spellcaster", False)),
            "monster_slug": monster_slug,
            "monster_name": monster_name,
            "actions": self._json_safe(getattr(c, "actions", [])),
            "bonus_actions": self._json_safe(getattr(c, "bonus_actions", [])),
            "reactions": self._json_safe(getattr(c, "reactions", [])),
            "saving_throws": self._json_safe(getattr(c, "saving_throws", {})),
            "ability_mods": self._json_safe(getattr(c, "ability_mods", {})),
            "attrs": attrs,
        }

    def _session_snapshot_payload(self, label: Optional[str] = None) -> Dict[str, Any]:
        mw = self.__dict__.get("_map_window")
        map_open = False
        try:
            map_open = bool(mw is not None and mw.winfo_exists())
        except Exception:
            map_open = False
            mw = None

        cols = int(getattr(self, "_lan_grid_cols", 20) or 20)
        rows = int(getattr(self, "_lan_grid_rows", 20) or 20)
        feet_per_square = 5.0
        positions = dict(self.__dict__.get("_lan_positions", {}) or {})
        obstacles = set(getattr(self, "_lan_obstacles", set()) or set())
        rough_terrain = dict(getattr(self, "_lan_rough_terrain", {}) or {})
        aoes = dict(getattr(self, "_lan_aoes", {}) or {})
        next_aoe_id = int(getattr(self, "_lan_next_aoe_id", 1) or 1)
        bg_images = list(getattr(self, "_session_bg_images", []) or [])
        next_bg_id = int(getattr(self, "_session_next_bg_id", 1) or 1)

        if map_open and mw is not None:
            try:
                cols = int(getattr(mw, "cols", cols) or cols)
                rows = int(getattr(mw, "rows", rows) or rows)
                feet_per_square = float(getattr(mw, "feet_per_square", feet_per_square) or feet_per_square)
                positions = {int(cid): (int(tok.get("col")), int(tok.get("row"))) for cid, tok in (getattr(mw, "unit_tokens", {}) or {}).items()}
                obstacles = set(getattr(mw, "obstacles", obstacles) or set())
                rough_terrain = dict(getattr(mw, "rough_terrain", rough_terrain) or {})
                aoes = dict(getattr(mw, "aoes", aoes) or {})
                next_aoe_id = int(getattr(mw, "_next_aoe_id", next_aoe_id) or next_aoe_id)
                bg_images = []
                for bid, data in sorted((getattr(mw, "bg_images", {}) or {}).items()):
                    bg_images.append({
                        "bid": int(bid),
                        "path": str(data.get("path") or ""),
                        "x": float(data.get("x", 0.0) or 0.0),
                        "y": float(data.get("y", 0.0) or 0.0),
                        "scale_pct": float(data.get("scale_pct", 100.0) or 100.0),
                        "trans_pct": float(data.get("trans_pct", 0.0) or 0.0),
                        "locked": bool(data.get("locked", False)),
                    })
                next_bg_id = int(getattr(mw, "_next_bg_id", next_bg_id) or next_bg_id)
            except Exception:
                pass

        self._lan_grid_cols, self._lan_grid_rows = cols, rows
        self._lan_positions = {int(cid): (int(pos[0]), int(pos[1])) for cid, pos in positions.items()}
        self._lan_obstacles = {(int(c), int(r)) for c, r in obstacles}
        self._lan_rough_terrain = dict(rough_terrain)
        self._lan_aoes = dict(aoes)
        self._lan_next_aoe_id = max(1, int(next_aoe_id))
        self._session_bg_images = list(bg_images)
        self._session_next_bg_id = max(1, int(next_bg_id))

        return {
            "schema_version": SESSION_SNAPSHOT_SCHEMA_VERSION,
            "metadata": {
                "saved_at": datetime.now().isoformat(timespec="seconds"),
                "app_version": APP_VERSION,
                "label": str(label or "").strip() or None,
            },
            "combat": {
                "combatants": [self._session_combatant_payload(c) for c in sorted(self.combatants.values(), key=lambda x: int(getattr(x, "cid", 0) or 0))],
                "next_id": int(getattr(self, "_next_id", 1) or 1),
                "next_stack_id": int(getattr(self, "_next_stack_id", 1) or 1),
                "current_cid": getattr(self, "current_cid", None),
                "start_cid": getattr(self, "start_cid", None),
                "round_num": int(getattr(self, "round_num", 1) or 1),
                "turn_num": int(getattr(self, "turn_num", 0) or 0),
                "in_combat": bool(getattr(self, "in_combat", False)),
                "turn_snapshots": self._json_safe(getattr(self, "_turn_snapshots", {})),
                "name_role_memory": self._json_safe(getattr(self, "_name_role_memory", {})),
                "summon_groups": self._json_safe(getattr(self, "_summon_groups", {})),
                "summon_group_meta": self._json_safe(getattr(self, "_summon_group_meta", {})),
                "pending_pre_summons": self._json_safe(getattr(self, "_pending_pre_summons", {})),
                "pending_mount_requests": self._json_safe(getattr(self, "_pending_mount_requests", {})),
                "concentration_save_state": self._json_safe(getattr(self, "_concentration_save_state", {})),
            },
            "map": {
                "grid": {"cols": cols, "rows": rows, "feet_per_square": feet_per_square},
                "positions": [{"cid": int(cid), "col": int(pos[0]), "row": int(pos[1])} for cid, pos in sorted(self._lan_positions.items())],
                "obstacles": [{"col": int(c), "row": int(r)} for c, r in sorted(self._lan_obstacles)],
                "rough_terrain": [{"col": int(c), "row": int(r), **(dict(cell) if isinstance(cell, dict) else {"color": str(cell), "movement_type": "ground", "is_swim": False, "is_rough": True})} for (c, r), cell in sorted(self._lan_rough_terrain.items())],
                "aoes": self._json_safe(self._lan_aoes),
                "next_aoe_id": int(self._lan_next_aoe_id),
                "auras_enabled": bool(getattr(self, "_lan_auras_enabled", True)),
                "bg_images": self._json_safe(self._session_bg_images),
                "next_bg_id": int(self._session_next_bg_id),
            },
            "log": {"lines": self._json_safe(self._lan_battle_log_lines(limit=0))},
        }

    def _save_session_to_path(self, path: Path, label: Optional[str] = None) -> None:
        payload = self._session_snapshot_payload(label=label)
        path.parent.mkdir(parents=True, exist_ok=True)
        path.write_text(json.dumps(payload, indent=2, sort_keys=True), encoding="utf-8")
        self._session_has_saved = True

    def _load_session_from_path(self, path: Path) -> None:
        payload = json.loads(path.read_text(encoding="utf-8"))
        if int(payload.get("schema_version", 0) or 0) != SESSION_SNAPSHOT_SCHEMA_VERSION:
            raise ValueError(f"Unsupported snapshot schema_version: {payload.get('schema_version')}")
        self._apply_session_snapshot(payload, source_path=path)

    def _restore_map_backgrounds(self, bg_entries: List[Dict[str, Any]]) -> None:
        mw = getattr(self, "_map_window", None)
        try:
            if mw is None or not mw.winfo_exists():
                return
        except Exception:
            return
        try:
            for _, data in list((getattr(mw, "bg_images", {}) or {}).items()):
                try:
                    item_id = int(data.get("item") or 0)
                    if item_id:
                        mw.canvas.delete(item_id)
                except Exception:
                    pass
            mw.bg_images = {}
        except Exception:
            return

        pil_image_mod = getattr(base, "Image", None)
        loaded: Dict[int, Dict[str, object]] = {}
        for entry in bg_entries:
            try:
                bid = int(entry.get("bid"))
                image_path = str(entry.get("path") or "")
                if not image_path or pil_image_mod is None:
                    continue
                if not Path(image_path).exists():
                    self._log(f"Session load: background image missing, skipped: {image_path}")
                    continue
                pil = pil_image_mod.open(image_path).convert("RGBA")
                loaded[bid] = {
                    "path": image_path,
                    "pil": pil,
                    "tk": None,
                    "item": None,
                    "x": float(entry.get("x", 0.0) or 0.0),
                    "y": float(entry.get("y", 0.0) or 0.0),
                    "scale_pct": float(entry.get("scale_pct", 100.0) or 100.0),
                    "trans_pct": float(entry.get("trans_pct", 0.0) or 0.0),
                    "locked": bool(entry.get("locked", False)),
                }
            except Exception:
                continue
        mw.bg_images = loaded
        for bid in sorted(loaded.keys()):
            try:
                mw._update_bg_canvas_item(int(bid), recreate=True)
            except Exception:
                pass
        try:
            mw._refresh_bg_list()
        except Exception:
            pass

    def _apply_session_snapshot(self, payload: Dict[str, Any], source_path: Optional[Path] = None) -> None:
        combat = payload.get("combat") if isinstance(payload.get("combat"), dict) else {}
        map_state = payload.get("map") if isinstance(payload.get("map"), dict) else {}
        log_state = payload.get("log") if isinstance(payload.get("log"), dict) else {}

        existing_cids = [int(cid) for cid in list(getattr(self, "combatants", {}).keys())]
        if existing_cids:
            self._remove_combatants_with_lan_cleanup(existing_cids)
        self.combatants = {}

        combatants_payload = combat.get("combatants") if isinstance(combat.get("combatants"), list) else []
        for entry in sorted(combatants_payload, key=lambda item: int(item.get("cid", 0) or 0)):
            cid = int(entry.get("cid", 0) or 0)
            if cid <= 0:
                continue
            spec = None
            if entry.get("monster_slug"):
                spec = self._find_monster_spec_by_slug(entry.get("monster_slug"))
            if spec is None and entry.get("monster_name"):
                spec = self._monsters_by_name.get(str(entry.get("monster_name")))
            self._next_id = cid
            new_cid = self._create_combatant(
                name=str(entry.get("name") or f"#{cid}"),
                hp=int(entry.get("hp", 0) or 0),
                speed=int(entry.get("speed", 0) or 0),
                swim_speed=int(entry.get("swim_speed", 0) or 0),
                fly_speed=int(entry.get("fly_speed", 0) or 0),
                burrow_speed=int(entry.get("burrow_speed", 0) or 0),
                climb_speed=int(entry.get("climb_speed", 0) or 0),
                movement_mode=str(entry.get("movement_mode") or "normal"),
                initiative=int(entry.get("initiative", 0) or 0),
                dex=entry.get("dex"),
                ally=bool(entry.get("ally", False)),
                is_pc=bool(entry.get("is_pc", False)),
                is_spellcaster=bool(entry.get("is_spellcaster", False)),
                actions=entry.get("actions") if isinstance(entry.get("actions"), list) else [],
                bonus_actions=entry.get("bonus_actions") if isinstance(entry.get("bonus_actions"), list) else [],
                reactions=entry.get("reactions") if isinstance(entry.get("reactions"), list) else [],
                saving_throws=entry.get("saving_throws") if isinstance(entry.get("saving_throws"), dict) else {},
                ability_mods=entry.get("ability_mods") if isinstance(entry.get("ability_mods"), dict) else {},
                monster_spec=spec,
            )
            c = self.combatants.get(new_cid)
            if c is None:
                continue
            setattr(c, "roll", entry.get("roll"))
            setattr(c, "nat20", bool(entry.get("nat20", False)))
            setattr(c, "move_total", int(entry.get("move_total", getattr(c, "move_total", 0)) or 0))
            setattr(c, "move_remaining", int(entry.get("move_remaining", getattr(c, "move_remaining", 0)) or 0))
            attrs = entry.get("attrs") if isinstance(entry.get("attrs"), dict) else {}
            for key, val in attrs.items():
                if key == "condition_stacks" and isinstance(val, list):
                    stacks: List[base.ConditionStack] = []
                    for st in val:
                        if not isinstance(st, dict):
                            continue
                        try:
                            stacks.append(base.ConditionStack(
                                sid=int(st.get("sid", 0) or 0),
                                ctype=str(st.get("ctype") or ""),
                                remaining_turns=st.get("remaining_turns"),
                                dot_type=st.get("dot_type"),
                                dice=st.get("dice") if isinstance(st.get("dice"), dict) else None,
                            ))
                        except Exception:
                            continue
                    setattr(c, key, stacks)
                    continue
                if key == "concentration_started_turn" and isinstance(val, list) and len(val) == 2:
                    try:
                        setattr(c, key, (int(val[0]), int(val[1])))
                    except Exception:
                        setattr(c, key, None)
                    continue
                setattr(c, key, val)

        self._next_id = int(combat.get("next_id", max(self.combatants.keys(), default=0) + 1) or 1)
        self._next_stack_id = int(combat.get("next_stack_id", getattr(self, "_next_stack_id", 1)) or 1)
        self.current_cid = combat.get("current_cid")
        self.start_cid = combat.get("start_cid")
        self.round_num = int(combat.get("round_num", 1) or 1)
        self.turn_num = int(combat.get("turn_num", 0) or 0)
        self.in_combat = bool(combat.get("in_combat", False))
        self._turn_snapshots = dict(combat.get("turn_snapshots") if isinstance(combat.get("turn_snapshots"), dict) else {})
        self._name_role_memory = dict(combat.get("name_role_memory") if isinstance(combat.get("name_role_memory"), dict) else {})
        self._summon_groups = dict(combat.get("summon_groups") if isinstance(combat.get("summon_groups"), dict) else {})
        self._summon_group_meta = dict(combat.get("summon_group_meta") if isinstance(combat.get("summon_group_meta"), dict) else {})
        self._pending_pre_summons = dict(combat.get("pending_pre_summons") if isinstance(combat.get("pending_pre_summons"), dict) else {})
        self._pending_mount_requests = dict(combat.get("pending_mount_requests") if isinstance(combat.get("pending_mount_requests"), dict) else {})
        self._concentration_save_state = dict(combat.get("concentration_save_state") if isinstance(combat.get("concentration_save_state"), dict) else {})

        grid = map_state.get("grid") if isinstance(map_state.get("grid"), dict) else {}
        self._lan_grid_cols = int(grid.get("cols", 20) or 20)
        self._lan_grid_rows = int(grid.get("rows", 20) or 20)
        self._lan_positions = {}
        for item in map_state.get("positions") if isinstance(map_state.get("positions"), list) else []:
            if isinstance(item, dict):
                try:
                    self._lan_positions[int(item.get("cid"))] = (int(item.get("col")), int(item.get("row")))
                except Exception:
                    pass
        self._lan_obstacles = set()
        for item in map_state.get("obstacles") if isinstance(map_state.get("obstacles"), list) else []:
            if isinstance(item, dict):
                try:
                    self._lan_obstacles.add((int(item.get("col")), int(item.get("row"))))
                except Exception:
                    pass
        rough: Dict[Tuple[int, int], Dict[str, object]] = {}
        for item in map_state.get("rough_terrain") if isinstance(map_state.get("rough_terrain"), list) else []:
            if not isinstance(item, dict):
                continue
            try:
                key = (int(item.get("col")), int(item.get("row")))
            except Exception:
                continue
            rough[key] = {
                "color": str(item.get("color") or ""),
                "movement_type": str(item.get("movement_type") or "ground"),
                "is_swim": bool(item.get("is_swim", False)),
                "is_rough": bool(item.get("is_rough", True)),
            }
        self._lan_rough_terrain = rough
        raw_aoes = map_state.get("aoes") if isinstance(map_state.get("aoes"), dict) else {}
        self._lan_aoes = {}
        for raw_key, raw_value in raw_aoes.items():
            try:
                self._lan_aoes[int(raw_key)] = dict(raw_value) if isinstance(raw_value, dict) else {}
            except Exception:
                continue
        self._lan_next_aoe_id = int(map_state.get("next_aoe_id", 1) or 1)
        self._lan_auras_enabled = bool(map_state.get("auras_enabled", True))
        self._session_bg_images = list(map_state.get("bg_images") if isinstance(map_state.get("bg_images"), list) else [])
        self._session_next_bg_id = int(map_state.get("next_bg_id", 1) or 1)

        # Let map mode open with the saved grid size without re-prompting.
        self._map_open_without_prompt_size = (int(self._lan_grid_cols), int(self._lan_grid_rows))

        lines = log_state.get("lines") if isinstance(log_state.get("lines"), list) else []
        history = self._history_file_path()
        history.parent.mkdir(parents=True, exist_ok=True)
        clean_lines = [str(line) for line in lines]
        history.write_text("\n".join(clean_lines) + ("\n" if clean_lines else ""), encoding="utf-8")
        self._load_history_into_log()

        # Always open map mode when loading a snapshot so saved grid + placements are immediately applied.
        try:
            self._open_map_mode()
        except Exception:
            pass

        mw = getattr(self, "_map_window", None)
        try:
            if mw is not None and mw.winfo_exists():
                mw.cols = int(self._lan_grid_cols)
                mw.rows = int(self._lan_grid_rows)
                mw.feet_per_square = float(grid.get("feet_per_square", getattr(mw, "feet_per_square", 5.0)) or 5.0)
                mw.obstacles = set(self._lan_obstacles)
                mw.rough_terrain = dict(self._lan_rough_terrain)
                mw.aoes = {int(k): dict(v) for k, v in self._lan_aoes.items()}
                mw._next_aoe_id = int(self._lan_next_aoe_id)
                mw._redraw_all()
                mw.refresh_units()
                self._apply_saved_positions_to_map_window(mw)
                try:
                    mw._refresh_aoe_list()
                except Exception:
                    pass
                self._restore_map_backgrounds(self._session_bg_images)
        except Exception:
            pass

        self._update_turn_ui()
        self._rebuild_table(scroll_to_current=True)
        self._lan_force_state_broadcast()
        if source_path is not None:
            self._log(f"Session loaded: {source_path}")

    def _save_session_dialog(self) -> None:
        default_path = self._session_saves_dir() / self._session_default_filename()
        chosen = filedialog.asksaveasfilename(
            parent=self,
            title="Save Session Snapshot",
            initialdir=str(default_path.parent),
            initialfile=default_path.name,
            defaultextension=".json",
            filetypes=[("JSON", "*.json"), ("All files", "*.*")],
        )
        if not chosen:
            return
        try:
            self._save_session_to_path(Path(chosen))
            self._log(f"Session saved: {chosen}")
        except Exception as exc:
            messagebox.showerror("Save Session", f"Failed to save session:\n{exc}", parent=self)

    def _load_session_dialog(self) -> None:
        chosen = filedialog.askopenfilename(
            parent=self,
            title="Load Session Snapshot",
            initialdir=str(self._session_saves_dir()),
            filetypes=[("JSON", "*.json"), ("All files", "*.*")],
        )
        if not chosen:
            return
        try:
            self._load_session_from_path(Path(chosen))
        except Exception as exc:
            messagebox.showerror("Load Session", f"Failed to load session:\n{exc}", parent=self)

    def _quick_save_session(self) -> None:
        path = self._session_quicksave_path()
        try:
            self._save_session_to_path(path, label="quick_save")
            self._log(f"Quick save written: {path}")
        except Exception as exc:
            messagebox.showerror("Quick Save", f"Failed to quick save session:\n{exc}", parent=self)

    def _quick_load_session(self) -> None:
        path = self._session_quicksave_path()
        if not path.exists():
            messagebox.showinfo("Quick Load", f"No quick save found at:\n{path}", parent=self)
            return
        try:
            self._load_session_from_path(path)
        except Exception as exc:
            messagebox.showerror("Quick Load", f"Failed to quick load session:\n{exc}", parent=self)

    def _auto_load_quick_save_on_startup(self) -> None:
        path = self._session_quicksave_path()
        if not path.exists():
            return
        try:
            self._load_session_from_path(path)
            self._log(f"Quick save auto-loaded: {path}")
        except Exception as exc:
            self._log(f"Quick save auto-load failed ({path}): {exc}")

    def _reset_map_state(self) -> None:
        """Clear map layout, token placements, overlays, and backgrounds."""
        self._lan_positions = {}
        self._lan_obstacles = set()
        self._lan_rough_terrain = {}
        self._lan_aoes = {}
        self._lan_next_aoe_id = 1
        self._session_bg_images = []
        self._session_next_bg_id = 1

        mw = getattr(self, "_map_window", None)
        try:
            if mw is not None and mw.winfo_exists():
                mw.obstacles = set()
                mw.rough_terrain = {}
                mw.aoes = {}
                mw._next_aoe_id = 1
                mw.unit_tokens = {}
                try:
                    mw._token_facing = {}
                except Exception:
                    pass
                try:
                    for bid, data in list((getattr(mw, "bg_images", {}) or {}).items()):
                        item_id = data.get("item") if isinstance(data, dict) else None
                        if item_id:
                            mw.canvas.delete(item_id)
                        mw.bg_images.pop(bid, None)
                except Exception:
                    pass
                mw._next_bg_id = 1
                mw._redraw_all()
                mw.refresh_units()
                try:
                    mw._refresh_aoe_list()
                except Exception:
                    pass
        except Exception:
            pass

        self._lan_force_state_broadcast()
        self._log("Map reset.")

    def _open_map_mode(self) -> None:
        super()._open_map_mode()
        mw = getattr(self, "_map_window", None)
        try:
            if mw is None or not mw.winfo_exists():
                return
        except Exception:
            return
        try:
            mw.cols = int(getattr(mw, "cols", getattr(self, "_lan_grid_cols", 20)) or 20)
            mw.rows = int(getattr(mw, "rows", getattr(self, "_lan_grid_rows", 20)) or 20)
            self._lan_grid_cols = int(mw.cols)
            self._lan_grid_rows = int(mw.rows)
            mw.obstacles = set(getattr(self, "_lan_obstacles", set()) or set())
            mw.rough_terrain = dict(getattr(self, "_lan_rough_terrain", {}) or {})
            mw.aoes = {int(k): dict(v) for k, v in dict(getattr(self, "_lan_aoes", {}) or {}).items()}
            mw._next_aoe_id = int(getattr(self, "_lan_next_aoe_id", 1) or 1)
            mw._next_bg_id = int(getattr(self, "_session_next_bg_id", 1) or 1)
            mw._redraw_all()
            mw.refresh_units()
            self._apply_saved_positions_to_map_window(mw)
            try:
                mw._refresh_aoe_list()
            except Exception:
                pass
            self._restore_map_backgrounds(list(getattr(self, "_session_bg_images", []) or []))
        except Exception:
            pass

        # Persist live map state when the DM closes Map Mode so quick save/load keeps token placement.
        try:
            original_close = getattr(mw, "_on_close", None)
            if callable(original_close) and not bool(getattr(mw, "_lan_close_hook_installed", False)):
                def _close_with_persist() -> None:
                    try:
                        self._snapshot_map_window_state()
                    except Exception:
                        pass
                    original_close()

                mw._on_close = _close_with_persist
                try:
                    mw.protocol("WM_DELETE_WINDOW", mw._on_close)
                except Exception:
                    pass
                mw._lan_close_hook_installed = True
        except Exception:
            pass

    def _snapshot_map_window_state(self) -> None:
        """Copy live map window state into session-backed LAN fields."""
        mw = getattr(self, "_map_window", None)
        try:
            if mw is None or not mw.winfo_exists():
                return
        except Exception:
            return

        try:
            self._lan_grid_cols = int(getattr(mw, "cols", self._lan_grid_cols) or self._lan_grid_cols)
            self._lan_grid_rows = int(getattr(mw, "rows", self._lan_grid_rows) or self._lan_grid_rows)
            self._lan_positions = {
                int(cid): (int(tok.get("col")), int(tok.get("row")))
                for cid, tok in (getattr(mw, "unit_tokens", {}) or {}).items()
            }
            self._lan_obstacles = set(getattr(mw, "obstacles", set()) or set())
            self._lan_rough_terrain = dict(getattr(mw, "rough_terrain", {}) or {})
            self._lan_aoes = {int(k): dict(v) for k, v in (getattr(mw, "aoes", {}) or {}).items()}
            self._lan_next_aoe_id = int(getattr(mw, "_next_aoe_id", self._lan_next_aoe_id) or self._lan_next_aoe_id)
            bg_images: List[Dict[str, Any]] = []
            for bid, data in sorted((getattr(mw, "bg_images", {}) or {}).items()):
                bg_images.append(
                    {
                        "bid": int(bid),
                        "path": str(data.get("path") or ""),
                        "x": float(data.get("x", 0.0) or 0.0),
                        "y": float(data.get("y", 0.0) or 0.0),
                        "scale_pct": float(data.get("scale_pct", 100.0) or 100.0),
                        "trans_pct": float(data.get("trans_pct", 0.0) or 0.0),
                        "locked": bool(data.get("locked", False)),
                    }
                )
            self._session_bg_images = bg_images
            self._session_next_bg_id = int(getattr(mw, "_next_bg_id", self._session_next_bg_id) or self._session_next_bg_id)
        except Exception:
            return

    def _apply_saved_positions_to_map_window(self, mw: Any) -> None:
        """Ensure map window tokens match persisted LAN positions."""
        if mw is None:
            return
        try:
            if not mw.winfo_exists():
                return
        except Exception:
            return

        positions = dict(self.__dict__.get("_lan_positions", {}) or {})
        if not positions:
            return

        changed = False
        for cid, pos in positions.items():
            if int(cid) not in self.combatants:
                continue
            try:
                col = int(pos[0])
                row = int(pos[1])
            except Exception:
                continue
            tok = getattr(mw, "unit_tokens", {}).get(int(cid))
            if tok:
                tok["col"] = col
                tok["row"] = row
                try:
                    mw._layout_unit(int(cid))
                except Exception:
                    pass
                changed = True
            else:
                try:
                    mw._create_unit_token(int(cid), col, row)
                    changed = True
                except Exception:
                    pass
        if changed:
            try:
                mw._update_groups()
            except Exception:
                pass
            try:
                mw._update_move_highlight()
            except Exception:
                pass
            try:
                mw._update_included_for_selected()
            except Exception:
                pass


    def _open_roster_manager(self) -> None:
        win = tk.Toplevel(self)
        win.title("Combat Roster Manager")
        win.geometry("820x460")
        win.transient(self)

        outer = tk.Frame(win)
        outer.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        tk.Label(
            outer,
            text="Add or remove Player Characters mid-fight. Changes sync to LAN clients immediately.",
            anchor="w",
            justify="left",
        ).pack(fill=tk.X, pady=(0, 10))

        lists = tk.Frame(outer)
        lists.pack(fill=tk.BOTH, expand=True)
        lists.columnconfigure(0, weight=1)
        lists.columnconfigure(1, weight=1)

        left_frame = tk.Frame(lists)
        left_frame.grid(row=0, column=0, sticky="nsew", padx=(0, 8))
        right_frame = tk.Frame(lists)
        right_frame.grid(row=0, column=1, sticky="nsew", padx=(8, 0))

        tk.Label(left_frame, text="Available PCs", anchor="w").pack(fill=tk.X)
        avail_scroll = tk.Scrollbar(left_frame)
        avail_list = tk.Listbox(left_frame, selectmode=tk.EXTENDED, yscrollcommand=avail_scroll.set)
        avail_scroll.config(command=avail_list.yview)
        avail_list.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        avail_scroll.pack(side=tk.RIGHT, fill=tk.Y)

        tk.Label(right_frame, text="In Combat PCs", anchor="w").pack(fill=tk.X)
        combat_scroll = tk.Scrollbar(right_frame)
        combat_list = tk.Listbox(right_frame, selectmode=tk.EXTENDED, yscrollcommand=combat_scroll.set)
        combat_scroll.config(command=combat_list.yview)
        combat_list.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        combat_scroll.pack(side=tk.RIGHT, fill=tk.Y)

        combat_cids: List[int] = []

        def refresh_lists() -> None:
            self._load_player_yaml_cache()
            avail_list.delete(0, tk.END)
            for name in sorted(self._player_yaml_data_by_name.keys(), key=lambda x: x.lower()):
                avail_list.insert(tk.END, name)

            combat_list.delete(0, tk.END)
            combat_cids.clear()
            pcs: List[Tuple[int, str]] = []
            for c in self.combatants.values():
                role = self._name_role_memory.get(str(c.name), "enemy")
                if role == "pc" or bool(getattr(c, "is_pc", False)):
                    pcs.append((int(c.cid), str(c.name)))
            pcs.sort(key=lambda entry: entry[1].lower())
            for cid, name in pcs:
                combat_list.insert(tk.END, f"{name} (cid {cid})")
                combat_cids.append(cid)

        def add_selected() -> None:
            selected = [avail_list.get(i) for i in avail_list.curselection()]
            if not selected:
                return
            self._load_player_yaml_cache()
            added = False
            for name in selected:
                profile = self._player_yaml_data_by_name.get(name)
                if not isinstance(profile, dict):
                    continue
                if self._create_pc_from_profile(name, profile) is not None:
                    added = True
            if added:
                self._rebuild_table(scroll_to_current=True)
                self._lan_force_state_broadcast()
            refresh_lists()

        def remove_selected() -> None:
            indices = list(combat_list.curselection())
            if not indices:
                return
            to_remove = [combat_cids[i] for i in indices if i < len(combat_cids)]
            if not to_remove:
                return
            if not messagebox.askyesno(
                "Remove PCs",
                f"Remove {len(to_remove)} PC(s) from combat?",
            ):
                return
            pre_order = [c.cid for c in self._display_order()]
            self._remove_combatants_with_lan_cleanup(to_remove)
            if self.start_cid in to_remove:
                self.start_cid = None
            self._retarget_current_after_removal(to_remove, pre_order=pre_order)
            self._rebuild_table(scroll_to_current=True)
            self._lan_force_state_broadcast()
            refresh_lists()

        controls = tk.Frame(outer)
        controls.pack(fill=tk.X, pady=(10, 0))
        ttk.Button(controls, text="Add to Combat →", command=add_selected).pack(side=tk.LEFT)
        ttk.Button(controls, text="← Remove from Combat", command=remove_selected).pack(
            side=tk.LEFT, padx=(8, 0)
        )
        ttk.Button(controls, text="Refresh Lists", command=refresh_lists).pack(side=tk.LEFT, padx=(12, 0))
        def close_window() -> None:
            if self._roster_manager_refresh is refresh_lists:
                self._roster_manager_refresh = None
            win.destroy()

        ttk.Button(controls, text="Close", command=close_window).pack(side=tk.RIGHT)

        self._roster_manager_refresh = refresh_lists
        win.protocol("WM_DELETE_WINDOW", close_window)
        refresh_lists()

    def _roll_lan_initiative_for_claimed_pcs(self) -> None:
        if not getattr(self, "_lan", None) or not self._lan.is_running():
            messagebox.showwarning("Roll LAN Initiative", "LAN server is not running.", parent=self)
            return

        prompted: List[str] = []
        skipped: List[str] = []
        with self._lan._clients_lock:
            cid_to_ws = {int(cid): list(ws_ids) for cid, ws_ids in self._lan._cid_to_ws.items()}
            view_only = set(self._lan._view_only_clients)

        for c in self.combatants.values():
            role = self._name_role_memory.get(str(c.name), "enemy")
            if not (bool(getattr(c, "is_pc", False)) or role == "pc"):
                continue
            cid = int(getattr(c, "cid", 0) or 0)
            if cid <= 0:
                continue
            ws_ids = [ws_id for ws_id in cid_to_ws.get(cid, []) if ws_id not in view_only]
            if not ws_ids:
                skipped.append(str(c.name))
                continue
            for ws_id in ws_ids:
                self._lan.send_initiative_prompt(ws_id, cid, str(c.name))
            prompted.append(str(c.name))

        if not prompted:
            messagebox.showinfo(
                "Roll LAN Initiative",
                "No claimed player characters have an active LAN client connection.",
                parent=self,
            )
            return

        summary = f"Prompted {len(prompted)} player character(s): {', '.join(prompted)}"
        if skipped:
            summary += f"\n\nSkipped (no claimed LAN client): {', '.join(skipped)}"
        messagebox.showinfo("Roll LAN Initiative", summary, parent=self)

    def _show_lan_url(self) -> None:
        if not self._lan.is_running():
            self._lan.start()
            if not self._lan.is_running():
                return
        settings = getattr(self._lan, "url_settings", LanUrlSettings())
        mode = _normalize_lan_url_mode(getattr(settings, "url_mode", "http"))
        urls = self._lan.published_urls()
        if mode == "https" and not urls.get("https"):
            messagebox.showwarning(
                "LAN URL",
                "HTTPS mode is enabled but no HTTPS public URL is configured.\nUse LAN → Set HTTPS Public URL…",
                parent=self,
            )
            return

        win = tk.Toplevel(self)
        win.title("LAN URL")
        win.geometry("500x240")
        win.transient(self)

        frm = tk.Frame(win)
        frm.pack(fill=tk.BOTH, expand=True, padx=12, pady=12)
        tk.Label(frm, text="Open this on yer LAN devices:", justify="left", anchor="w").pack(fill=tk.X)

        def _add_url_row(label: str, url: str) -> None:
            row = tk.Frame(frm)
            row.pack(fill=tk.X, pady=(8, 4))
            tk.Label(row, text=f"{label}:", width=8, anchor="w").pack(side=tk.LEFT)
            tk.Label(row, text=url, wraplength=320, justify="left", anchor="w").pack(side=tk.LEFT, fill=tk.X, expand=True)
            def _copy() -> None:
                try:
                    self.clipboard_clear()
                    self.clipboard_append(url)
                except Exception:
                    pass
            tk.Button(row, text="Copy", command=_copy).pack(side=tk.RIGHT)

        if mode == "both":
            http_url = urls.get("http")
            https_url = urls.get("https")
            if https_url:
                _add_url_row("HTTPS", https_url)
            if http_url:
                _add_url_row("HTTP", http_url)
        else:
            preferred = self._lan.preferred_url()
            if preferred:
                _add_url_row(mode.upper(), preferred)

        tk.Button(frm, text="Close", command=win.destroy).pack(anchor="e", pady=(12, 0))

    def _show_lan_qr(self) -> None:
        if not self._lan.is_running():
            self._lan.start()
            if not self._lan.is_running():
                return
        try:
            import qrcode  # type: ignore
        except Exception as e:
            messagebox.showerror("QR Code", f"Arrr, QR code needs the qrcode module.\n\nError: {e}")
            return
        try:
            from PIL import Image, ImageTk  # type: ignore
        except Exception as e:
            messagebox.showerror(
                "QR Code",
                "Arrr, image QR needs Pillow ImageTk. Try: sudo apt install python3-pil.imagetk\n\n" + str(e),
            )
            return

        settings = getattr(self._lan, "url_settings", LanUrlSettings())
        mode = _normalize_lan_url_mode(getattr(settings, "url_mode", "http"))
        urls = self._lan.published_urls()
        if mode == "https" and not urls.get("https"):
            messagebox.showwarning(
                "QR Code",
                "HTTPS mode is enabled but no HTTPS public URL is configured.\nUse LAN → Set HTTPS Public URL…",
                parent=self,
            )
            return

        candidates: List[Tuple[str, str]] = []
        if mode == "both":
            if urls.get("https"):
                candidates.append(("HTTPS", urls["https"]))
            if urls.get("http"):
                candidates.append(("HTTP", urls["http"]))
        else:
            preferred = self._lan.preferred_url()
            if preferred:
                candidates.append((mode.upper(), preferred))
        if not candidates:
            messagebox.showwarning("QR Code", "No LAN URL is available to encode.", parent=self)
            return

        selected = candidates[0][1]

        def _make_photo(url: str):
            qr = qrcode.QRCode(border=2, box_size=10)
            qr.add_data(url)
            qr.make(fit=True)
            img = qr.make_image(fill_color="black", back_color="white")
            try:
                img = img.convert("RGB")
            except Exception:
                pass
            try:
                img = img.resize((360, 360), Image.NEAREST)
            except Exception:
                pass
            return ImageTk.PhotoImage(img)

        win = tk.Toplevel(self)
        win.title("LAN QR Code")
        win.geometry("460x590")
        win.transient(self)

        frm = tk.Frame(win)
        frm.pack(fill=tk.BOTH, expand=True, padx=12, pady=12)

        qr_label = tk.Label(frm)
        qr_label.pack(pady=(0, 10))
        url_label = tk.Label(frm, text=selected, wraplength=420, justify="center")
        url_label.pack(pady=(0, 8))

        selected_var = tk.StringVar(value=selected)

        def _refresh() -> None:
            photo = _make_photo(selected_var.get())
            qr_label.configure(image=photo)
            qr_label.image = photo
            url_label.configure(text=selected_var.get())

        if len(candidates) > 1:
            chooser = tk.Frame(frm)
            chooser.pack(pady=(0, 8))
            tk.Label(chooser, text="QR URL:").pack(side=tk.LEFT)
            options = [entry[1] for entry in candidates]
            menu = ttk.Combobox(chooser, values=options, textvariable=selected_var, state="readonly", width=42)
            menu.pack(side=tk.LEFT, padx=(8, 0))
            menu.bind("<<ComboboxSelected>>", lambda _e: _refresh())

        _refresh()

        btns = tk.Frame(frm)
        btns.pack()

        def copy_url():
            try:
                self.clipboard_clear()
                self.clipboard_append(selected_var.get())
            except Exception:
                pass

        tk.Button(btns, text="Copy URL", command=copy_url).pack(side=tk.LEFT, padx=(0, 8))
        tk.Button(btns, text="Close", command=win.destroy).pack(side=tk.LEFT)

    def _open_lan_sessions(self) -> None:
        """DM utility: see connected LAN clients and (re)assign PCs."""
        win = tk.Toplevel(self)
        win.title("LAN Sessions")
        win.geometry("720x420")
        win.transient(self)

        outer = tk.Frame(win)
        outer.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Sessions table
        cols = ("ws_id", "host", "claimed")
        tree = ttk.Treeview(outer, columns=cols, show="headings", height=10)
        tree.heading("ws_id", text="Session")
        tree.heading("host", text="Client")
        tree.heading("claimed", text="Claimed")
        tree.column("ws_id", width=90, anchor="center")
        tree.column("host", width=260, anchor="w")
        tree.column("claimed", width=240, anchor="w")
        tree.pack(fill=tk.BOTH, expand=True)

        controls = tk.Frame(outer)
        controls.pack(fill=tk.X, pady=(10, 0))

        tk.Label(controls, text="Assign to:").pack(side=tk.LEFT)

        # PC dropdown (name shown, cid used)
        pc_map: Dict[str, Optional[int]] = {"(unassigned)": None}
        try:
            for p in self._lan_pcs():
                nm = str(p.get("name", ""))
                cid = p.get("cid")
                if nm and isinstance(cid, int):
                    pc_map[nm] = int(cid)
        except Exception:
            pass
        pc_names = sorted([k for k in pc_map.keys() if k != "(unassigned)"])
        pc_names.insert(0, "(unassigned)")

        pc_var = tk.StringVar(value="(unassigned)")
        pc_box = ttk.Combobox(controls, textvariable=pc_var, values=pc_names, width=30, state="readonly")
        pc_box.pack(side=tk.LEFT, padx=(6, 10))

        def refresh_sessions() -> None:
            tree.delete(*tree.get_children())
            sessions = self._lan.sessions_snapshot()
            # quick lookup from cid -> name
            cid_to_name: Dict[int, str] = {}
            try:
                for p in self._lan_pcs():
                    if isinstance(p.get("cid"), int):
                        cid_to_name[int(p["cid"])] = str(p.get("name", ""))
            except Exception:
                pass

            for s in sessions:
                ws_id = int(s.get("ws_id"))
                host = str(s.get("host", "?"))
                port = str(s.get("port", ""))
                host_disp = f"{host}:{port}" if port else host
                cid = s.get("cid")
                claimed = ""
                if isinstance(cid, int):
                    claimed = cid_to_name.get(int(cid), f"cid {cid}")
                tree.insert("", "end", iid=str(ws_id), values=(ws_id, host_disp, claimed))

        def get_selected_ws_id() -> Optional[int]:
            sel = tree.selection()
            if not sel:
                return None
            try:
                return int(sel[0])
            except Exception:
                return None

        def do_assign() -> None:
            ws_id = get_selected_ws_id()
            if ws_id is None:
                return
            cid = pc_map.get(pc_var.get())
            self._lan.assign_session(ws_id, cid, note="Assigned by the DM.")
            # refresh shortly after
            self.after(300, refresh_sessions)

        def do_kick() -> None:
            ws_id = get_selected_ws_id()
            if ws_id is None:
                return
            # best-effort: unclaim
            self._lan.assign_session(ws_id, None, note="Unclaimed by the DM.")
            self.after(300, refresh_sessions)

        ttk.Button(controls, text="Refresh", command=refresh_sessions).pack(side=tk.LEFT)
        ttk.Button(controls, text="Assign", command=do_assign).pack(side=tk.LEFT, padx=(10, 0))
        ttk.Button(controls, text="Unassign", command=do_kick).pack(side=tk.LEFT, padx=(6, 0))
        ttk.Button(controls, text="Close", command=win.destroy).pack(side=tk.RIGHT)

        refresh_sessions()

    def _open_yaml_player_manager(self) -> None:
        win = tk.Toplevel(self)
        win.title("YAML Player Roster")
        win.geometry("760x420")
        win.transient(self)

        outer = tk.Frame(win)
        outer.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        players_dir = self._players_dir()
        tk.Label(
            outer,
            text=f"Players folder: {players_dir}",
            anchor="w",
            justify="left",
        ).pack(fill=tk.X, pady=(0, 6))

        tk.Label(
            outer,
            text="Toggle which YAML player profiles are active. Refresh cache to apply changes.",
            anchor="w",
            justify="left",
        ).pack(fill=tk.X, pady=(0, 10))

        cols = ("enabled", "name", "path")
        tree = ttk.Treeview(outer, columns=cols, show="headings", height=12)
        tree.heading("enabled", text="Enabled")
        tree.heading("name", text="Display Name")
        tree.heading("path", text="Path")
        tree.column("enabled", width=80, anchor="center")
        tree.column("name", width=220, anchor="w")
        tree.column("path", width=380, anchor="w")
        tree.pack(fill=tk.BOTH, expand=True)
        tree.tag_configure("disabled", foreground="gray")

        def load_entries() -> None:
            tree.delete(*tree.get_children())
            entries = self._yaml_players_rescan()
            for entry in entries:
                key = str(entry.get("key") or "")
                if not key:
                    continue
                enabled = bool(entry.get("enabled", True))
                label = "Yes" if enabled else "No"
                display_name = str(entry.get("display_name") or "")
                path_text = str(entry.get("path") or "")
                tree.insert("", "end", iid=key, values=(label, display_name, path_text))
                if not enabled:
                    tree.item(key, tags=("disabled",))

        def set_selected(enabled: bool) -> None:
            selected = tree.selection()
            if not selected:
                return
            for iid in selected:
                self._yaml_players_set_enabled(iid, enabled)
            load_entries()

        def toggle_selected(_event: Optional[tk.Event] = None) -> None:
            selected = tree.selection()
            if not selected:
                return
            for iid in selected:
                current = str(tree.set(iid, "enabled") or "").strip().lower()
                new_enabled = current not in ("yes", "true", "1", "on")
                self._yaml_players_set_enabled(iid, new_enabled)
            load_entries()

        tree.bind("<Double-1>", toggle_selected)

        controls = tk.Frame(outer)
        controls.pack(fill=tk.X, pady=(10, 0))

        ttk.Button(controls, text="Enable Selected", command=lambda: set_selected(True)).pack(side=tk.LEFT)
        ttk.Button(controls, text="Disable Selected", command=lambda: set_selected(False)).pack(
            side=tk.LEFT, padx=(6, 0)
        )
        ttk.Button(controls, text="Rescan Directory", command=load_entries).pack(side=tk.LEFT, padx=(12, 0))
        ttk.Button(
            controls,
            text="Refresh YAML index/cache now",
            command=lambda: self._yaml_players_refresh_cache(rebuild=True),
        ).pack(side=tk.LEFT, padx=(12, 0))
        ttk.Button(controls, text="Close", command=win.destroy).pack(side=tk.RIGHT)

        load_entries()

    def _open_lan_admin_assignments(self) -> None:
        """DM utility: review LAN sessions (mirrors web admin)."""
        win = tk.Toplevel(self)
        win.title("LAN Admin Assignments")
        win.geometry("860x460")
        win.transient(self)

        outer = tk.Frame(win)
        outer.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        cols = ("host", "status", "claimed", "last_seen", "user_agent")
        tree = ttk.Treeview(outer, columns=cols, show="headings", height=12)
        tree.heading("host", text="Host/IP")
        tree.heading("status", text="Status")
        tree.heading("claimed", text="Claimed PC")
        tree.heading("last_seen", text="Last Seen")
        tree.heading("user_agent", text="User Agent")
        tree.column("host", width=200, anchor="w")
        tree.column("status", width=90, anchor="center")
        tree.column("claimed", width=180, anchor="w")
        tree.column("last_seen", width=140, anchor="w")
        tree.column("user_agent", width=230, anchor="w")
        tree.pack(fill=tk.BOTH, expand=True)

        controls = tk.Frame(outer)
        controls.pack(fill=tk.X, pady=(10, 0))
        def refresh_sessions() -> None:
            tree.delete(*tree.get_children())
            payload = self._lan.admin_sessions_payload()
            sessions = payload.get("sessions") if isinstance(payload, dict) else []

            if not isinstance(sessions, list):
                sessions = []
            for idx, entry in enumerate(sessions):
                if not isinstance(entry, dict):
                    continue
                host = str(entry.get("ip") or entry.get("host") or "").strip()
                port = str(entry.get("port") or "").strip()
                host_disp = f"{host}:{port}" if port else (host or "?")
                reverse_dns = str(entry.get("reverse_dns") or "").strip()
                if reverse_dns:
                    host_disp = f"{host_disp} ({reverse_dns})"
                status = str(entry.get("status") or "").strip() or "unknown"
                claimed_name = entry.get("claimed_name")
                claimed_cid = entry.get("cid")
                claimed = ""
                if claimed_name:
                    claimed = str(claimed_name)
                elif isinstance(claimed_cid, int):
                    claimed = f"cid {claimed_cid}"
                last_seen = str(entry.get("last_seen") or "").strip()
                user_agent = str(entry.get("user_agent") or entry.get("ua") or "").strip()
                iid = f"{idx}"
                tree.insert("", "end", iid=iid, values=(host_disp, status, claimed, last_seen, user_agent))

        ttk.Button(controls, text="Refresh", command=refresh_sessions).pack(side=tk.LEFT)
        ttk.Button(controls, text="Close", command=win.destroy).pack(side=tk.RIGHT)

        refresh_sessions()
    
    def _check_for_updates(self) -> None:
        """Check for available updates from GitHub."""
        try:
            # Run update check in a separate thread to avoid blocking UI
            def check_updates_thread():
                try:
                    has_update, message, update_info = update_checker.check_for_updates()

                    # Schedule UI update on main thread
                    def show_result():
                        if has_update and update_info:
                            self._offer_update_and_run_if_confirmed(message)
                        else:
                            # No updates available
                            messagebox.showinfo("No Updates", message)

                    # Schedule on main thread
                    self.after(0, show_result)

                except Exception as e:
                    # Schedule error message on main thread
                    def show_error():
                        messagebox.showerror(
                            "Update Check Failed",
                            f"Could not check for updates.\n\n"
                            f"Error: {str(e)}\n\n"
                            "Please check your internet connection and try again."
                        )
                    self.after(0, show_error)

            # Start the check in a background thread
            thread = threading.Thread(target=check_updates_thread, daemon=True)
            thread.start()

            # Show a message that we're checking
            messagebox.showinfo(
                "Checking for Updates",
                "Checking for updates from GitHub...\n\n"
                "This may take a few moments.",
                icon="info"
            )
            
        except Exception as e:
            messagebox.showerror(
                "Update Check Error",
                f"Could not check for updates.\n\nError: {str(e)}"
            )

    def _check_for_updates_on_startup(self) -> None:
        """Check for updates without user-visible popups unless an update is found."""

        def check_updates_thread() -> None:
            try:
                has_update, message, update_info = update_checker.check_for_updates()
            except Exception as exc:
                self._oplog(f"Startup update check failed: {exc}", level="debug")
                return

            if not (has_update and update_info):
                return

            self.after(0, lambda: self._offer_update_and_run_if_confirmed(message))

        thread = threading.Thread(target=check_updates_thread, daemon=True)
        thread.start()

    def _has_meaningful_session_state(self) -> bool:
        return bool(getattr(self, "combatants", {}))

    def _new_session(self) -> None:
        self._new_session_apply_blank_state(confirm=True)

    def _new_session_apply_blank_state(self, confirm: bool = True) -> bool:
        meaningful_state = self._has_meaningful_session_state()
        if confirm and meaningful_state:
            if not getattr(self, "_session_has_saved", False):
                quick_save = messagebox.askyesnocancel(
                    "New Session",
                    "This session appears unsaved. Quick Save before starting a new blank session?",
                    parent=self,
                )
                if quick_save is None:
                    return False
                if quick_save:
                    self._quick_save_session()
            if not messagebox.askyesno(
                "New Session",
                "Start a new blank session?\n\nThis clears combat, map state, and battle log.",
                parent=self,
            ):
                return False

        existing_cids = list(getattr(self, "combatants", {}).keys())
        self._remove_combatants_with_lan_cleanup(existing_cids)
        self.combatants = {}

        self._next_id = 1
        self._next_stack_id = 1
        self.current_cid = None
        self.start_cid = None
        self.round_num = 1
        self.turn_num = 0
        self.in_combat = False

        self._turn_snapshots = {}
        self._name_role_memory = {}
        self._summon_groups = {}
        self._summon_group_meta = {}
        self._pending_pre_summons = {}
        self._pending_mount_requests = {}
        self._pending_echo_tether_confirms = {}
        self._concentration_save_state = {}
        self._session_has_saved = False

        self._reset_map_state()

        history_path = self._history_file_path()
        history_path.parent.mkdir(parents=True, exist_ok=True)
        history_path.write_text("", encoding="utf-8")
        self._load_history_into_log()

        self._update_turn_ui()
        self._rebuild_table(scroll_to_current=True)
        self._lan_force_state_broadcast()
        self._log("New blank session started.")
        return True

    def _offer_update_and_run_if_confirmed(self, message: str) -> None:
        result = messagebox.askyesno(
            "Update Available",
            f"{message}\n\nWould you like to update now?\n\n"
            "Note: The application will need to be restarted after updating.",
            icon="info",
        )
        if not result:
            return
        if (
            not getattr(self, "_session_has_saved", False)
            and self._has_meaningful_session_state()
            and messagebox.askyesno("Quick Save", "quick save? yes no", parent=self)
        ):
            self._quick_save_session()
        self._launch_update_workflow(message)

    def _launch_update_workflow(self, message: str) -> None:
        import subprocess

        update_cmd = update_checker.get_update_command()
        if update_cmd:
            messagebox.showinfo(
                "Running Update",
                "The update script will now run in a separate window.\n\n"
                "Please follow the instructions in the update window.\n"
                "After the update completes, restart the application.",
            )
            if sys.platform.startswith("win"):
                subprocess.Popen(update_cmd, shell=True, creationflags=subprocess.CREATE_NEW_CONSOLE)
                return
            script_path = update_cmd.split('"')[1] if '"' in update_cmd else None
            if script_path:
                terminals = [
                    ["gnome-terminal", "--", "bash", script_path],
                    ["konsole", "-e", "bash", script_path],
                    ["xterm", "-e", "bash", script_path],
                    ["x-terminal-emulator", "-e", "bash", script_path],
                ]
                for term_cmd in terminals:
                    try:
                        subprocess.Popen(term_cmd)
                        return
                    except FileNotFoundError:
                        continue
                subprocess.Popen(["bash", script_path])
                messagebox.showinfo(
                    "Update Running",
                    "The update is running in the background.\nCheck your terminal for progress.",
                )
                return
        messagebox.showinfo(
            "Update Available",
            f"{message}\n\nTo update manually:\n\n"
            "1. Close the application\n"
            "2. Navigate to the installation directory\n"
            "3. Run: git pull origin main\n"
            "4. Run: pip install -r requirements.txt\n"
            "5. Restart the application",
        )
    
    def _show_about(self) -> None:
        """Show about dialog with version information."""
        try:
            current_version = update_checker.get_current_version()
            local_commit = update_checker.get_local_git_commit()
            
            version_info = f"Version: v{current_version}"
            if local_commit:
                version_info += f"\nCommit: {local_commit}"
            
            messagebox.showinfo(
                "About D&D Initiative Tracker",
                f"D&D Initiative Tracker\n\n"
                f"{version_info}\n\n"
                f"A combat management system for D&D 5e\n"
                f"with LAN/mobile web client support.\n\n"
                f"Repository: github.com/jeeves-jeevesenson/dnd-initiative-tracker"
            )
        except Exception as e:
            messagebox.showinfo(
                "About D&D Initiative Tracker",
                f"D&D Initiative Tracker\n\n"
                f"Version: v{APP_VERSION}\n\n"
                f"A combat management system for D&D 5e\n"
                f"with LAN/mobile web client support."
            )

    def _show_update_log(self) -> None:
        """Show the update log from the most recent update attempts."""
        log_path = _ensure_logs_dir() / "update.log"
        if not log_path.exists():
            messagebox.showinfo(
                "Update Log",
                "No update log found yet.\n\n"
                "Run Help → Check for Updates to generate one."
            )
            return

        try:
            log_text = log_path.read_text(encoding="utf-8", errors="replace")
        except Exception as exc:
            messagebox.showerror(
                "Update Log",
                f"Could not read the update log.\n\nError: {exc}"
            )
            return

        dialog = tk.Toplevel(self)
        dialog.title("Update Log")
        dialog.geometry("760x520")
        dialog.transient(self)

        text = scrolledtext.ScrolledText(dialog, wrap=tk.WORD)
        text.pack(fill=tk.BOTH, expand=True)
        text.insert("1.0", log_text)
        text.configure(state=tk.DISABLED)
    
    def _poc_seed_all_player_characters(self) -> None:
        """Temporary POC behavior: add all starting roster PCs to initiative and roll initiative.

        This makes remote/LAN testing easy over SSH without clicking through dialogs.
        Safe to call multiple times; it won't duplicate names already in combat.
        """
        try:
            roster = list(self._load_starting_players_roster())
        except Exception:
            roster = []

        if not roster:
            return

        existing = {str(c.name) for c in self.combatants.values()}

        players_dir = _app_base_dir() / "players"
        try:
            _seed_user_players_dir()
            players_dir = self._players_dir()
        except Exception:
            pass

        ymod = getattr(base, "yaml", None)
        cfg_cache: Dict[str, Optional[Dict[str, Any]]] = getattr(
            self, "_player_config_cache", None
        )
        if cfg_cache is None:
            cfg_cache = {}
            self._player_config_cache = cfg_cache
        cfg_paths: Optional[Dict[str, Path]] = getattr(self, "_player_config_paths", None)
        if cfg_paths is None:
            cfg_paths = {}
            try:
                if players_dir.exists():
                    cfg_paths = {}
                    for path in players_dir.glob("*.yaml"):
                        if not path.is_file():
                            continue
                        profile_name = self._player_name_from_filename(path)
                        # Prefer normalized player name, fall back to filename stem.
                        for key in (profile_name, path.stem):
                            if not key:
                                continue
                            if key in cfg_paths and cfg_paths[key] != path:
                                self._oplog(
                                    f"Player YAML {path.name}: name '{key}' already mapped; skipping.",
                                    level="warning",
                                )
                                continue
                            cfg_paths[key] = path
            except Exception:
                cfg_paths = {}
            self._player_config_paths = cfg_paths

        for name in roster:
            nm = str(name).strip()
            if not nm or nm in existing:
                continue

            # Defaults
            hp = 0
            temp_hp = 0
            max_hp = None
            speed = 30
            swim = 0
            fly_speed = 0
            burrow_speed = 0
            climb_speed = 0
            ac = None
            water = False
            actions: List[Dict[str, Any]] = []
            bonus_actions: List[Dict[str, Any]] = []
            reactions: List[Dict[str, Any]] = []
            token_color: Optional[str] = None
            token_border_color: Optional[str] = None

            # Future-facing: per-PC config file players/<Name>.yaml (optional)
            data = cfg_cache.get(nm, None)
            if nm not in cfg_cache:
                try:
                    cfg_path = cfg_paths.get(nm) if cfg_paths is not None else None
                    if cfg_path is not None:
                        raw = cfg_path.read_text(encoding="utf-8")
                        if ymod is not None:
                            data = ymod.safe_load(raw)
                        if not isinstance(data, dict):
                            data = None
                    cfg_cache[nm] = data
                except Exception:
                    cfg_cache[nm] = None
                    data = None
            if isinstance(data, dict):
                def to_int(value: Any, fallback: Optional[int] = None) -> Optional[int]:
                    try:
                        return int(value)
                    except Exception:
                        return fallback

                profile = self._normalize_player_profile(data, nm)
                resources = profile.get("resources", {}) if isinstance(profile, dict) else {}
                vitals = profile.get("vitals", {}) if isinstance(profile, dict) else {}
                defenses = profile.get("defenses", {}) if isinstance(profile, dict) else {}
                identity = profile.get("identity", {}) if isinstance(profile, dict) else {}
                token_color = self._normalize_token_color(identity.get("token_color"))
                token_border_color = self._normalize_token_color(identity.get("token_border_color"))
                if isinstance(vitals, dict):
                    max_hp = to_int(vitals.get("max_hp"), None)
                    hp = to_int(vitals.get("current_hp"), None) if "current_hp" in vitals else None
                    temp_hp = to_int(vitals.get("temp_hp"), 0) or 0
                if hp is None:
                    hp = max_hp
                # accept a few key names
                speed_source = resources.get("base_movement", resources.get("speed"))
                if speed_source is None and isinstance(vitals, dict):
                    speed_source = vitals.get("speed")
                if speed_source is not None:
                    parsed = base._parse_speed_data(speed_source)
                    if parsed[0] is not None:
                        speed = int(parsed[0])
                    if parsed[1] is not None:
                        swim = int(parsed[1])
                    if parsed[2] is not None:
                        fly_speed = int(parsed[2])
                    if parsed[3] is not None:
                        burrow_speed = int(parsed[3])
                    if parsed[4] is not None:
                        climb_speed = int(parsed[4])
                if "speed" in resources and speed_source is None:
                    speed = int(resources.get("speed", speed) or speed)
                swim = int(resources.get("swim_speed", swim) or swim)
                fly_speed = int(resources.get("fly_speed", fly_speed) or fly_speed)
                burrow_speed = int(resources.get("burrow_speed", burrow_speed) or burrow_speed)
                climb_speed = int(resources.get("climb_speed", climb_speed) or climb_speed)
                if hp is None:
                    hp = to_int(defenses.get("hp"), None)
                ac = self._resolve_player_ac(profile, defenses)
                if hp is None:
                    hp = 0
                if max_hp is None:
                    max_hp = hp
                actions = self._normalize_action_entries(resources.get("actions"), "action")
                bonus_actions = self._normalize_action_entries(resources.get("bonus_actions"), "bonus_action")
                reactions = self._normalize_action_entries(resources.get("reactions"), "reaction")

            try:
                init_total = random.randint(1, 20)
            except Exception:
                init_total = 10

            try:
                cid = self._create_combatant(
                    name=self._unique_name(nm),
                    hp=int(hp),
                    speed=int(speed),
                    swim_speed=int(swim),
                    fly_speed=int(fly_speed),
                    burrow_speed=int(burrow_speed),
                    climb_speed=int(climb_speed),
                    movement_mode="Swim" if water else "Normal",
                    initiative=int(init_total),
                    dex=None,
                    ally=True,
                    is_pc=True,
                    actions=actions,
                    bonus_actions=bonus_actions,
                    reactions=reactions,
                )
                try:
                    combatant = self.combatants.get(cid)
                    if combatant is not None:
                        setattr(combatant, "temp_hp", int(temp_hp or 0))
                        setattr(combatant, "max_hp", int(max_hp or hp or 0))
                        setattr(
                            combatant,
                            "feature_state",
                            copy.deepcopy(profile.get("feature_state") if isinstance(profile.get("feature_state"), dict) else {}),
                        )
                        setattr(
                            combatant,
                            "feature_effects",
                            copy.deepcopy(profile.get("feature_effects") if isinstance(profile.get("feature_effects"), dict) else {}),
                        )
                        if ac is not None:
                            setattr(combatant, "ac", int(ac))
                        if token_color:
                            setattr(combatant, "token_color", token_color)
                        if token_border_color:
                            setattr(combatant, "token_border_color", token_border_color)
                except Exception:
                    pass
                existing.add(nm)
            except Exception:
                pass

        try:
            self._rebuild_table(scroll_to_current=True)
        except Exception:
            pass

    def _create_pc_from_profile(self, name: str, profile: Dict[str, Any]) -> Optional[int]:
        def to_int(value: Any, fallback: Optional[int] = None) -> Optional[int]:
            try:
                return int(value)
            except Exception:
                return fallback

        if not isinstance(profile, dict):
            return None

        normalized = self._normalize_player_profile(profile, name)
        resources = normalized.get("resources", {}) if isinstance(normalized, dict) else {}
        vitals = normalized.get("vitals", {}) if isinstance(normalized, dict) else {}
        defenses = normalized.get("defenses", {}) if isinstance(normalized, dict) else {}
        identity = normalized.get("identity", {}) if isinstance(normalized, dict) else {}
        spellcasting = normalized.get("spellcasting", {}) if isinstance(normalized, dict) else {}

        hp = to_int(defenses.get("hp"), 0) or 0
        ac = self._resolve_player_ac(normalized, defenses)
        max_hp = to_int(vitals.get("max_hp"), None)
        temp_hp = to_int(vitals.get("temp_hp"), 0) or 0
        if "current_hp" in vitals:
            hp = to_int(vitals.get("current_hp"), hp) or hp
        if hp is None:
            hp = max_hp if max_hp is not None else 0
        if max_hp is None:
            max_hp = hp

        speed = 30
        swim = 0
        fly_speed = 0
        burrow_speed = 0
        climb_speed = 0
        movement_mode = resources.get("movement_mode") if isinstance(resources, dict) else None

        speed_source = resources.get("base_movement", resources.get("speed")) if isinstance(resources, dict) else None
        if speed_source is None and isinstance(vitals, dict):
            speed_source = vitals.get("speed")
        if speed_source is not None:
            parsed = base._parse_speed_data(speed_source)
            if parsed[0] is not None:
                speed = int(parsed[0])
            if parsed[1] is not None:
                swim = int(parsed[1])
            if parsed[2] is not None:
                fly_speed = int(parsed[2])
            if parsed[3] is not None:
                burrow_speed = int(parsed[3])
            if parsed[4] is not None:
                climb_speed = int(parsed[4])
        if isinstance(resources, dict):
            if "speed" in resources and speed_source is None:
                speed = int(resources.get("speed", speed) or speed)
            swim = int(resources.get("swim_speed", swim) or swim)
            fly_speed = int(resources.get("fly_speed", fly_speed) or fly_speed)
            burrow_speed = int(resources.get("burrow_speed", burrow_speed) or burrow_speed)
            climb_speed = int(resources.get("climb_speed", climb_speed) or climb_speed)

        actions = self._normalize_action_entries(resources.get("actions"), "action")
        bonus_actions = self._normalize_action_entries(resources.get("bonus_actions"), "bonus_action")
        reactions = self._normalize_action_entries(resources.get("reactions"), "reaction")

        try:
            init_total = random.randint(1, 20)
        except Exception:
            init_total = 10

        try:
            cid = self._create_combatant(
                name=self._unique_name(str(normalized.get("name") or name)),
                hp=int(hp),
                speed=int(speed),
                swim_speed=int(swim),
                fly_speed=int(fly_speed),
                burrow_speed=int(burrow_speed),
                climb_speed=int(climb_speed),
                movement_mode=movement_mode or "Normal",
                initiative=int(init_total),
                dex=None,
                ally=True,
                is_pc=True,
                is_spellcaster=bool(spellcasting),
                actions=actions,
                bonus_actions=bonus_actions,
                reactions=reactions,
            )
        except Exception:
            return None

        combatant = self.combatants.get(cid)
        if combatant is not None:
            setattr(combatant, "temp_hp", int(temp_hp or 0))
            setattr(combatant, "max_hp", int(max_hp or hp or 0))
            setattr(
                combatant,
                "feature_state",
                copy.deepcopy(normalized.get("feature_state") if isinstance(normalized.get("feature_state"), dict) else {}),
            )
            setattr(
                combatant,
                "feature_effects",
                copy.deepcopy(
                    normalized.get("feature_effects") if isinstance(normalized.get("feature_effects"), dict) else {}
                ),
            )
            if ac is not None:
                setattr(combatant, "ac", int(ac))
            token_color = identity.get("token_color") if isinstance(identity, dict) else None
            token_border_color = identity.get("token_border_color") if isinstance(identity, dict) else None
            if token_color:
                setattr(combatant, "token_color", token_color)
            if token_border_color:
                setattr(combatant, "token_border_color", token_border_color)
        summon_entries = normalized.get("summon_on_start", []) if isinstance(normalized, dict) else []
        if isinstance(summon_entries, list) and summon_entries:
            try:
                self._spawn_startup_summons_for_pc(cid, summon_entries)
            except Exception as exc:
                self._oplog(
                    f"Player YAML {normalized.get('name') or name}: failed to spawn summon_on_start entries ({exc}).",
                    level="warning",
                )
        return cid

    def _remove_combatants_with_lan_cleanup(self, cids: Iterable[int]) -> None:
        removed = {int(cid) for cid in cids}
        if not removed:
            return
        mw = getattr(self, "_map_window", None)
        try:
            if mw is not None and not mw.winfo_exists():
                mw = None
        except Exception:
            mw = None

        for cid in removed:
            gone = self.combatants.get(cid)
            if gone is not None:
                rider_cid = _normalize_cid_value(getattr(gone, "mounted_by_cid", None), "remove.mounted_by")
                mount_cid = _normalize_cid_value(getattr(gone, "rider_cid", None), "remove.rider")
                if rider_cid is not None and rider_cid in self.combatants:
                    setattr(self.combatants[rider_cid], "rider_cid", None)
                if mount_cid is not None and mount_cid in self.combatants:
                    m = self.combatants[mount_cid]
                    setattr(m, "mounted_by_cid", None)
                    setattr(m, "mount_controller_mode", "independent")
                    setattr(m, "mount_shared_turn", False)
            self.combatants.pop(cid, None)
            self._lan_positions.pop(cid, None)
            self._turn_snapshots.pop(cid, None)

        aoe_ids = [aid for aid, aoe in (self._lan_aoes or {}).items() if aoe.get("owner_cid") in removed]
        if mw is not None and hasattr(mw, "_remove_aoe_by_id"):
            for aid in aoe_ids:
                try:
                    mw._remove_aoe_by_id(int(aid))
                except Exception:
                    self._lan_aoes.pop(aid, None)
        else:
            for aid in aoe_ids:
                self._lan_aoes.pop(aid, None)

        if mw is not None:
            for cid in removed:
                try:
                    if hasattr(mw, "_delete_unit_token"):
                        mw._delete_unit_token(int(cid))
                    else:
                        getattr(mw, "unit_tokens", {}).pop(int(cid), None)
                except Exception:
                    pass
            if hasattr(mw, "aoes") and not hasattr(mw, "_remove_aoe_by_id"):
                for aid, aoe in list(getattr(mw, "aoes", {}).items()):
                    if aoe.get("owner_cid") in removed:
                        getattr(mw, "aoes", {}).pop(aid, None)

    # --------------------- LAN snapshot + actions ---------------------

    def _lan_claimable(self) -> List[Dict[str, Any]]:
        """Return Player Characters that can be claimed."""
        out: List[Dict[str, Any]] = []
        for c in self.combatants.values():
            role = self._name_role_memory.get(str(c.name), "enemy")
            if bool(getattr(c, "is_pc", False)) or role == "pc":
                out.append({"cid": c.cid, "name": str(c.name)})
        # sort stable
        out.sort(key=lambda x: str(x["name"]).lower())
        return out

    def _lan_pcs(self) -> List[Dict[str, Any]]:
        """Alias for LAN client character selection."""
        return self._lan_claimable()

    def _pc_name_for(self, cid: int) -> str:
        try:
            lan = object.__getattribute__(self, "_lan")
        except Exception:
            return f"cid:{cid}"
        try:
            return lan._pc_name_for(int(cid))
        except Exception:
            return f"cid:{cid}"

    def _normalize_token_color(self, color: Any) -> Optional[str]:
        if not isinstance(color, str):
            return None
        value = color.strip().lower()
        named = {
            "blue": "#6aa9ff",
            "red": "#ff6a6a",
            "green": "#66d17a",
            "yellow": "#f1c95f",
            "purple": "#c97dff",
            "teal": "#61d8d8",
        }
        if value in named:
            return named[value]
        if not re.fullmatch(r"#[0-9a-f]{6}", value):
            return None
        return value

    def _normalize_facing_degrees(self, value: Any) -> int:
        try:
            facing = float(value)
        except Exception:
            return 0
        if not math.isfinite(facing):
            return 0
        normalized = facing % 360.0
        if normalized < 0:
            normalized += 360.0
        return int(round(normalized)) % 360

    @staticmethod
    def _is_rotatable_aoe_kind(kind: Any) -> bool:
        token = str(kind or "").strip().lower()
        return token in ("line", "cone", "cube", "wall", "square")

    def _sync_owned_rotatable_aoes_with_facing(self, owner_cid: int, facing_deg: Any) -> bool:
        facing = float(self._normalize_facing_degrees(facing_deg))
        changed = False
        mw = getattr(self, "_map_window", None)
        map_ready = mw is not None and mw.winfo_exists()
        store = getattr(mw, "aoes", None) if map_ready else None
        if not isinstance(store, dict):
            store = getattr(self, "_lan_aoes", {}) or {}
        for aid, aoe in (store or {}).items():
            if not isinstance(aoe, dict):
                continue
            try:
                aoe_owner = int(aoe.get("owner_cid"))
            except Exception:
                continue
            if int(aoe_owner) != int(owner_cid):
                continue
            kind = str(aoe.get("kind") or "").strip().lower()
            if not self._is_rotatable_aoe_kind(kind):
                continue
            aoe["angle_deg"] = float(facing)
            if kind in ("line", "wall"):
                try:
                    anchor_x = float(aoe.get("ax"))
                    anchor_y = float(aoe.get("ay"))
                    half_length_squares = float(aoe.get("length_sq") or 0.0) / 2.0
                except Exception:
                    anchor_x = anchor_y = half_length_squares = None
                if (
                    anchor_x is not None
                    and anchor_y is not None
                    and half_length_squares is not None
                    and half_length_squares > 0
                ):
                    rad = math.radians(float(facing))
                    aoe["cx"] = float(anchor_x + math.cos(rad) * half_length_squares)
                    aoe["cy"] = float(anchor_y + math.sin(rad) * half_length_squares)
            elif kind == "cone":
                try:
                    aoe["cx"] = float(aoe.get("ax"))
                    aoe["cy"] = float(aoe.get("ay"))
                except Exception:
                    pass
            changed = True
            if map_ready and hasattr(mw, "_layout_aoe"):
                try:
                    mw._layout_aoe(int(aid))
                except Exception:
                    pass
        if changed:
            if map_ready:
                try:
                    self._lan_aoes = dict(getattr(mw, "aoes", {}) or {})
                except Exception:
                    pass
            else:
                self._lan_aoes = dict(store or {})
        return bool(changed)

    def _sync_owner_facing_from_rotatable_aoe(self, aoe: Dict[str, Any], angle_deg: Any) -> bool:
        if not isinstance(aoe, dict):
            return False
        if not self._is_rotatable_aoe_kind(aoe.get("kind")):
            return False
        try:
            owner_cid = int(aoe.get("owner_cid"))
        except Exception:
            return False
        c = self.combatants.get(owner_cid)
        if not c:
            return False
        next_facing = int(self._normalize_facing_degrees(angle_deg))
        if int(self._normalize_facing_degrees(getattr(c, "facing_deg", 0))) == next_facing:
            return False
        setattr(c, "facing_deg", next_facing)
        return True

    @staticmethod
    def _player_name_from_filename(path: Path) -> Optional[str]:
        """Normalize a player filename into a roster-friendly name."""
        # Example: "player-name_example" -> "player name example".
        stem = path.stem.strip()
        if not stem:
            return None
        name = stem.replace("-", " ").replace("_", " ")
        name = " ".join(name.split())  # collapse extra whitespace
        return name or None

    def _normalize_spell_color(self, color: Any) -> Optional[str]:
        return self._normalize_token_color(color)

    def _token_color_forbidden(self, color: str) -> bool:
        try:
            r = int(color[1:3], 16)
            g = int(color[3:5], 16)
            b = int(color[5:7], 16)
        except Exception:
            return True
        if r >= 245 and g >= 245 and b >= 245:
            return True
        if r >= 200 and g <= 80 and b <= 80:
            return True
        return False

    def _token_color_payload(self, c: Any) -> Optional[str]:
        return self._normalize_token_color(getattr(c, "token_color", None))

    def _token_border_color_payload(self, c: Any) -> Optional[str]:
        return self._normalize_token_color(getattr(c, "token_border_color", None))

    def _lan_sync_aoes_to_map(self, mw: Any) -> None:
        store = getattr(self, "_lan_aoes", {}) or {}
        if not store:
            return
        try:
            mw_aoes = getattr(mw, "aoes", None)
            if mw_aoes is None:
                mw_aoes = {}
                setattr(mw, "aoes", mw_aoes)
            changed = False
            for aid, aoe in store.items():
                aid_int = int(aid)
                if aid_int not in mw_aoes:
                    mw_aoes[aid_int] = dict(aoe)
                    if hasattr(mw, "_create_aoe_items"):
                        try:
                            mw._create_aoe_items(aid_int)
                        except Exception:
                            pass
                    changed = True
            if changed and hasattr(mw, "_refresh_aoe_list"):
                try:
                    mw._refresh_aoe_list()
                except Exception:
                    pass
            if mw_aoes:
                max_aid = max(int(a) for a in mw_aoes.keys())
                try:
                    next_aid = int(getattr(mw, "_next_aoe_id", max_aid + 1))
                except Exception:
                    next_aid = max_aid + 1
                if next_aid <= max_aid:
                    setattr(mw, "_next_aoe_id", max_aid + 1)
        except Exception:
            pass

    def _is_unarmed_strike_weapon(self, weapon: Any) -> bool:
        if not isinstance(weapon, dict):
            return False
        weapon_id = str(weapon.get("id") or "").strip().lower()
        weapon_name = str(weapon.get("name") or "").strip().lower()
        return bool(weapon_id == "unarmed_strike" or weapon_name == "unarmed strike")

    def _elemental_attunement_active(self, combatant: Any) -> bool:
        return bool(getattr(combatant, "elemental_attunement_active", False))

    def _monk_martial_arts_die(self, monk_level: int) -> int:
        level = max(0, int(monk_level or 0))
        if level >= 17:
            return 12
        if level >= 11:
            return 10
        if level >= 5:
            return 8
        return 6

    def _monk_save_dc_for_profile(self, profile: Dict[str, Any]) -> int:
        prof_block = profile.get("proficiency") if isinstance(profile.get("proficiency"), dict) else {}
        abilities = profile.get("abilities") if isinstance(profile.get("abilities"), dict) else {}
        try:
            prof = int(prof_block.get("bonus"))
        except Exception:
            prof = 2
        try:
            wis_score = int(abilities.get("wis"))
        except Exception:
            wis_score = 10
        wis_mod = math.floor((int(wis_score) - 10) / 2)
        return int(8 + max(0, int(prof)) + int(wis_mod))

    def _set_hidden_state(self, cid: int, hidden: bool, *, reason: str = "") -> bool:
        c = self.combatants.get(int(cid))
        if c is None:
            return False
        prev = bool(getattr(c, "is_hidden", False))
        next_state = bool(hidden)
        setattr(c, "is_hidden", next_state)
        if prev == next_state:
            return False
        if reason:
            try:
                self._log(reason, cid=int(cid))
            except Exception:
                pass
        mw = self.__dict__.get("_map_window")
        try:
            if mw is not None and mw.winfo_exists():
                if hasattr(mw, "update_unit_token_colors"):
                    mw.update_unit_token_colors()
        except Exception:
            pass
        self._lan_force_state_broadcast()
        return True

    def _hide_apply_invisible_stack(self, c: Any) -> Optional[int]:
        stacks = list(getattr(c, "condition_stacks", []) or [])
        existing_sid = getattr(c, "hide_invisible_sid", None)
        if existing_sid is not None:
            try:
                existing_sid = int(existing_sid)
            except Exception:
                existing_sid = None
        if existing_sid is not None:
            for st in stacks:
                if int(getattr(st, "sid", 0) or 0) == int(existing_sid) and str(getattr(st, "ctype", "") or "").lower() == "invisible":
                    return int(existing_sid)
        next_sid = int(self.__dict__.get("_next_stack_id", 1) or 1)
        self.__dict__["_next_stack_id"] = int(next_sid) + 1
        stacks.append(base.ConditionStack(sid=int(next_sid), ctype="invisible", remaining_turns=None))
        setattr(c, "condition_stacks", stacks)
        setattr(c, "hide_invisible_sid", int(next_sid))
        return int(next_sid)

    def _clear_hide_state(self, cid: int, *, reason: str = "") -> bool:
        c = self.combatants.get(int(cid))
        if c is None:
            return False
        changed = False
        hide_sid = getattr(c, "hide_invisible_sid", None)
        if hide_sid is not None:
            try:
                hide_sid_int = int(hide_sid)
            except Exception:
                hide_sid_int = None
            if hide_sid_int is not None:
                stacks = list(getattr(c, "condition_stacks", []) or [])
                kept = [st for st in stacks if int(getattr(st, "sid", 0) or 0) != hide_sid_int]
                if len(kept) != len(stacks):
                    setattr(c, "condition_stacks", kept)
                    changed = True
        if getattr(c, "hide_invisible_sid", None) is not None:
            setattr(c, "hide_invisible_sid", None)
            changed = True
        if getattr(c, "hide_stealth_dc", None) is not None:
            setattr(c, "hide_stealth_dc", None)
            changed = True
        if bool(getattr(c, "is_hidden", False)):
            self._set_hidden_state(int(cid), False, reason=reason)
            return True
        if changed:
            mw = self.__dict__.get("_map_window")
            try:
                if mw is not None and mw.winfo_exists() and hasattr(mw, "update_unit_token_colors"):
                    mw.update_unit_token_colors()
            except Exception:
                pass
            self._lan_force_state_broadcast()
        return changed

    @staticmethod
    def _line_of_sight_blocked(
        start: Tuple[int, int], end: Tuple[int, int], obstacles: set[Tuple[int, int]]
    ) -> bool:
        x0, y0 = int(start[0]), int(start[1])
        x1, y1 = int(end[0]), int(end[1])
        dx = abs(x1 - x0)
        dy = abs(y1 - y0)
        sx = 1 if x0 < x1 else -1
        sy = 1 if y0 < y1 else -1
        err = dx - dy
        first = True
        while True:
            if not first and (x0, y0) in obstacles:
                return True
            if x0 == x1 and y0 == y1:
                break
            e2 = 2 * err
            if e2 > -dy:
                err -= dy
                x0 += sx
            if e2 < dx:
                err += dx
                y0 += sy
            first = False
        return False

    def _observer_passive_perception(self, observer: Any) -> int:
        fallback = 10 + int(self._combatant_ability_modifier(observer, "wis"))
        profile = self._profile_for_player_name(getattr(observer, "name", ""))
        if isinstance(profile, dict):
            vitals = profile.get("vitals") if isinstance(profile.get("vitals"), dict) else {}
            passive_block = vitals.get("passive_perception") if isinstance(vitals.get("passive_perception"), dict) else {}
            try:
                value = int(passive_block.get("value"))
            except Exception:
                value = None
            if value is not None:
                return value
            formula = passive_block.get("formula")
            proficiency = profile.get("proficiency") if isinstance(profile.get("proficiency"), dict) else {}
            leveling = profile.get("leveling") if isinstance(profile.get("leveling"), dict) else {}
            level_value = self._coerce_level_value(leveling)
            if level_value > 0:
                prof_bonus = self._proficiency_bonus_for_level(level_value)
            else:
                try:
                    prof_bonus = int(proficiency.get("bonus"))
                except Exception:
                    prof_bonus = 0
            abilities = profile.get("abilities") if isinstance(profile.get("abilities"), dict) else {}
            variables = {
                "prof": prof_bonus,
                "str_mod": self._ability_score_modifier(abilities, "str"),
                "dex_mod": self._ability_score_modifier(abilities, "dex"),
                "con_mod": self._ability_score_modifier(abilities, "con"),
                "int_mod": self._ability_score_modifier(abilities, "int"),
                "wis_mod": self._ability_score_modifier(abilities, "wis"),
                "cha_mod": self._ability_score_modifier(abilities, "cha"),
            }
            evaluated = self._evaluate_spell_formula(formula, variables)
            if evaluated is not None:
                return int(math.floor(evaluated))
            return int(10 + variables["wis_mod"])
        spec = getattr(observer, "monster_spec", None)
        raw_data = getattr(spec, "raw_data", None) if spec is not None else None
        senses = raw_data.get("senses") if isinstance(raw_data, dict) else None
        sense_tokens = senses if isinstance(senses, list) else [senses] if isinstance(senses, str) else []
        for token in sense_tokens:
            match = re.search(r"passive perception\s+(\d+)", str(token or ""), flags=re.IGNORECASE)
            if match:
                return int(match.group(1))
        return int(fallback)

    def _hider_stealth_bonus(self, hider: Any) -> int:
        profile = self._profile_for_player_name(getattr(hider, "name", ""))
        if isinstance(profile, dict):
            abilities = profile.get("abilities") if isinstance(profile.get("abilities"), dict) else {}
            dex_mod = self._ability_score_modifier(abilities, "dex")
            proficiency = profile.get("proficiency") if isinstance(profile.get("proficiency"), dict) else {}
            level_value = self._coerce_level_value(profile.get("leveling") if isinstance(profile.get("leveling"), dict) else {})
            if level_value > 0:
                prof_bonus = self._proficiency_bonus_for_level(level_value)
            else:
                try:
                    prof_bonus = int(proficiency.get("bonus"))
                except Exception:
                    prof_bonus = 0
            skills = proficiency.get("skills") if isinstance(proficiency.get("skills"), dict) else {}
            proficient = [str(v).strip().lower() for v in (skills.get("proficient") or [])] if isinstance(skills.get("proficient"), list) else []
            expertise = [str(v).strip().lower() for v in (skills.get("expertise") or [])] if isinstance(skills.get("expertise"), list) else []
            if "stealth" in expertise:
                return int(dex_mod + (2 * max(0, int(prof_bonus))))
            if "stealth" in proficient:
                return int(dex_mod + max(0, int(prof_bonus)))
            return int(dex_mod)
        spec = getattr(hider, "monster_spec", None)
        raw_data = getattr(spec, "raw_data", None) if spec is not None else None
        skills = raw_data.get("skills") if isinstance(raw_data, dict) else None
        skill_tokens = skills if isinstance(skills, list) else [skills] if isinstance(skills, str) else []
        for token in skill_tokens:
            match = re.search(r"\bstealth\b\s*[:\-]?\s*([+\-]?\d+)", str(token or ""), flags=re.IGNORECASE)
            if match:
                return int(match.group(1))
        return int(self._combatant_ability_modifier(hider, "dex"))

    def _normalize_hide_state_after_condition_change(self, cid: int) -> None:
        c = self.combatants.get(int(cid))
        if c is None or not bool(getattr(c, "is_hidden", False)):
            return
        if not self._has_condition(c, "invisible"):
            self._clear_hide_state(int(cid))
            return
        stacks = [st for st in list(getattr(c, "condition_stacks", []) or []) if str(getattr(st, "ctype", "") or "").lower() == "invisible"]
        if not stacks:
            self._clear_hide_state(int(cid))
            return
        existing_sid = getattr(c, "hide_invisible_sid", None)
        try:
            existing_sid_int = int(existing_sid) if existing_sid is not None else None
        except Exception:
            existing_sid_int = None
        stack_sids = {int(getattr(st, "sid", 0) or 0) for st in stacks}
        if existing_sid_int in stack_sids:
            return
        canonical_sid = int(getattr(stacks[0], "sid", 0) or 0)
        setattr(c, "hide_invisible_sid", canonical_sid)
        mw = self.__dict__.get("_map_window")
        try:
            if mw is not None and mw.winfo_exists() and hasattr(mw, "update_unit_token_colors"):
                mw.update_unit_token_colors()
        except Exception:
            pass
        self._lan_force_state_broadcast()

    def _friendly_observers_with_los(
        self,
        hider_cid: int,
        *,
        positions: Optional[Dict[int, Tuple[int, int]]] = None,
        obstacles: Optional[set[Tuple[int, int]]] = None,
    ) -> List[Tuple[Any, Tuple[int, int]]]:
        if positions is None or obstacles is None:
            _cols, _rows, live_obstacles, _rough, live_positions = self._lan_live_map_data()
            if positions is None:
                positions = live_positions
            if obstacles is None:
                obstacles = live_obstacles
        hider_pos = positions.get(int(hider_cid)) if isinstance(positions, dict) else None
        if not (isinstance(hider_pos, tuple) and len(hider_pos) == 2):
            return []
        seen: List[Tuple[Any, Tuple[int, int]]] = []
        for observer in self.combatants.values():
            if int(getattr(observer, "cid", -1)) == int(hider_cid):
                continue
            role = str(self._name_role_memory.get(str(getattr(observer, "name", "")), "enemy") or "enemy")
            if role not in ("pc", "ally"):
                continue
            if int(getattr(observer, "hp", 0) or 0) <= 0:
                continue
            obs_pos = positions.get(int(observer.cid)) if isinstance(positions, dict) else None
            if not (isinstance(obs_pos, tuple) and len(obs_pos) == 2):
                continue
            if not self._line_of_sight_blocked((int(obs_pos[0]), int(obs_pos[1])), (int(hider_pos[0]), int(hider_pos[1])), obstacles or set()):
                seen.append((observer, (int(obs_pos[0]), int(obs_pos[1]))))
        return seen

    def _sneak_attempt_hide(
        self,
        hider_cid: int,
        *,
        prompt_when_seen: Optional[Callable[[List[str]], bool]] = None,
    ) -> Dict[str, Any]:
        hider = self.combatants.get(int(hider_cid))
        if hider is None:
            return {"ok": False, "reason": "No such combatant."}
        role = str(self._name_role_memory.get(str(getattr(hider, "name", "")), "enemy") or "enemy")
        if role != "enemy":
            return {"ok": False, "reason": "Only enemies can sneak from this control."}
        if int(getattr(self, "current_cid", -1) or -1) != int(hider_cid):
            return {"ok": False, "reason": "Only the active enemy can sneak."}
        _cols, _rows, obstacles, _rough, positions = self._lan_live_map_data()
        seen = self._friendly_observers_with_los(int(hider_cid), positions=positions, obstacles=obstacles)
        seen_names = [str(getattr(observer, "name", "Observer")) for observer, _pos in seen]
        if seen and callable(prompt_when_seen):
            try:
                if not bool(prompt_when_seen(list(seen_names))):
                    self._log(f"{hider.name} was seen by {', '.join(seen_names)} and could not hide.", cid=int(hider_cid))
                    return {"ok": False, "reason": "Sneak cancelled.", "seen_by": seen_names}
            except Exception:
                pass
        # Low-hanging fruit only: LoS is the current gate. Cover/obscurement checks can be added later.
        stealth_bonus = self._hider_stealth_bonus(hider)
        roll = random.randint(1, 20)
        total = int(roll + stealth_bonus)
        if total < 15:
            self._clear_hide_state(int(hider_cid))
            self._log(
                f"{hider.name} fails to hide (DC 15): roll {int(roll)} + {int(stealth_bonus)} = {int(total)}.",
                cid=int(hider_cid),
            )
            return {
                "ok": True,
                "hidden": False,
                "roll": int(roll),
                "stealth_bonus": int(stealth_bonus),
                "total": int(total),
                "seen_by": seen_names,
            }
        setattr(hider, "hide_stealth_dc", int(total))
        hide_sid = self._hide_apply_invisible_stack(hider)
        self._set_hidden_state(int(hider_cid), True, reason=f"{hider.name} hides ({total} Stealth vs DC 15).")
        spotted_by: List[str] = []
        for observer, _obs_pos in seen:
            if self._observer_passive_perception(observer) >= int(total):
                spotted_by.append(str(getattr(observer, "name", "Observer")))
        if spotted_by:
            self._clear_hide_state(int(hider_cid), reason=f"{hider.name} is immediately found by {', '.join(spotted_by)}.")
            return {
                "ok": True,
                "hidden": False,
                "roll": int(roll),
                "stealth_bonus": int(stealth_bonus),
                "total": int(total),
                "stealth_dc": int(total),
                "spotted_by": spotted_by,
                "seen_by": seen_names,
            }
        return {
            "ok": True,
            "hidden": True,
            "roll": int(roll),
            "stealth_bonus": int(stealth_bonus),
            "total": int(total),
            "stealth_dc": int(total),
            "hide_invisible_sid": hide_sid,
            "seen_by": seen_names,
        }

    def _sneak_handle_hidden_movement(
        self,
        hider_cid: int,
        origin: Tuple[int, int],
        dest: Tuple[int, int],
    ) -> Dict[str, Any]:
        hider = self.combatants.get(int(hider_cid))
        if hider is None or not bool(getattr(hider, "is_hidden", False)):
            return {"ok": False, "reason": "not_hidden"}
        role = str(self._name_role_memory.get(str(getattr(hider, "name", "")), "enemy") or "enemy")
        if role != "enemy":
            return {"ok": False, "reason": "not_enemy"}
        if tuple(origin) == tuple(dest):
            return {"ok": True, "checked": []}
        _cols, _rows, obstacles, _rough, positions = self._lan_live_map_data()
        turn_marker = (int(getattr(self, "round_num", 0) or 0), int(getattr(self, "turn_num", 0) or 0), int(hider_cid))
        if turn_marker != tuple(self.__dict__.get("_sneak_visibility_turn_marker", ())):
            self.__dict__["_sneak_visibility_turn_marker"] = turn_marker
            self.__dict__["_sneak_visibility_checked"] = set()
        checked: set[Tuple[int, int]] = self.__dict__.setdefault("_sneak_visibility_checked", set())
        stealth_dc = int(getattr(hider, "hide_stealth_dc", 0) or 0)

        def _bresenham_path(start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]:
            x0, y0 = int(start[0]), int(start[1])
            x1, y1 = int(end[0]), int(end[1])
            dx = abs(x1 - x0)
            dy = abs(y1 - y0)
            sx = 1 if x0 < x1 else -1
            sy = 1 if y0 < y1 else -1
            err = dx - dy
            cells: List[Tuple[int, int]] = []
            while True:
                cells.append((x0, y0))
                if x0 == x1 and y0 == y1:
                    break
                e2 = 2 * err
                if e2 > -dy:
                    err -= dy
                    x0 += sx
                if e2 < dx:
                    err += dx
                    y0 += sy
            return cells

        path_cells = _bresenham_path(tuple(origin), tuple(dest))
        if len(path_cells) > 121:
            stride = int(math.ceil((len(path_cells) - 1) / 120.0))
            sampled = [path_cells[0]] + [path_cells[idx] for idx in range(1, len(path_cells) - 1, max(1, stride))]
            if sampled[-1] != path_cells[-1]:
                sampled.append(path_cells[-1])
            path_cells = sampled
        walked_cells = path_cells[1:]

        for observer in self.combatants.values():
            if int(getattr(observer, "cid", -1)) == int(hider_cid):
                continue
            role = str(self._name_role_memory.get(str(getattr(observer, "name", "")), "enemy") or "enemy")
            if role not in ("pc", "ally"):
                continue
            if int(getattr(observer, "hp", 0) or 0) <= 0:
                continue
            obs_pos = positions.get(int(getattr(observer, "cid", 0) or 0)) if isinstance(positions, dict) else None
            if not (isinstance(obs_pos, tuple) and len(obs_pos) == 2):
                continue
            observer_cid = int(getattr(observer, "cid", 0) or 0)
            check_key = (int(hider_cid), observer_cid)
            if check_key in checked:
                continue
            blocked_at_origin = self._line_of_sight_blocked(obs_pos, tuple(origin), obstacles)
            entered_los = not blocked_at_origin
            if blocked_at_origin:
                for cell in walked_cells:
                    if not self._line_of_sight_blocked(obs_pos, cell, obstacles):
                        entered_los = True
                        break
            if not entered_los:
                continue
            checked.add(check_key)
            observer_name = str(getattr(observer, "name", "Observer"))
            observer_pp = int(self._observer_passive_perception(observer))
            stays_hidden = observer_pp < int(stealth_dc)
            self._log(
                f"Auto spot check while moving: {observer_name} passive {observer_pp} vs {hider.name} stealth {int(stealth_dc)} "+
                f"({'hidden' if stays_hidden else 'spotted'}).",
                cid=int(hider_cid),
            )
            if not stays_hidden:
                self._clear_hide_state(int(hider_cid), reason=f"{hider.name} is spotted while moving by {observer_name}.")
                return {"ok": True, "hidden": False, "spotted_by": [observer_name]}
        return {"ok": True, "hidden": True, "spotted_by": []}

    def _lan_set_token_position(self, target_cid: int, col: int, row: int) -> None:
        self._lan_positions[int(target_cid)] = (int(col), int(row))
        mw = getattr(self, "_map_window", None)
        try:
            if mw is not None and mw.winfo_exists():
                x, y = mw._grid_to_pixel(int(col), int(row))
                mw._place_unit_at_pixel(int(target_cid), x, y)
        except Exception:
            pass

    def _lan_direction_step_from_angle(self, angle_deg: Any) -> Tuple[int, int]:
        try:
            facing = float(self._normalize_facing_degrees(angle_deg))
        except Exception:
            facing = 0.0
        step_x = int(round(math.sin(math.radians(facing))))
        step_y = int(round(-math.cos(math.radians(facing))))
        if step_x == 0 and step_y == 0:
            step_y = -1
        return int(step_x), int(step_y)

    def _lan_apply_forced_movement(
        self,
        source_cid: Optional[int],
        target_cid: int,
        mode: str,
        distance_ft: float,
        *,
        source_cell: Optional[Tuple[int, int]] = None,
        direction_step: Optional[Tuple[int, int]] = None,
    ) -> bool:
        try:
            _cols, _rows, _obstacles, _rough, live_positions = self._lan_live_map_data()
            target = dict(live_positions or {}).get(int(target_cid))
            source = None
            if source_cell is not None:
                source = (int(source_cell[0]), int(source_cell[1]))
            elif source_cid is not None:
                source = dict(live_positions or {}).get(int(source_cid))
        except Exception:
            return False
        if not (isinstance(target, tuple) and len(target) == 2):
            return False
        if direction_step is None and not (isinstance(source, tuple) and len(source) == 2):
            return False
        try:
            feet_per_square = 5.0
            mw = getattr(self, "_map_window", None)
            if mw is not None and hasattr(mw, "winfo_exists") and mw.winfo_exists():
                feet_per_square = float(getattr(mw, "feet_per_square", feet_per_square) or feet_per_square)
        except Exception:
            feet_per_square = 5.0
        feet_per_square = max(1.0, float(feet_per_square))
        try:
            steps = int(math.ceil(max(0.0, float(distance_ft or 0.0)) / feet_per_square))
        except Exception:
            steps = 0
        if steps <= 0:
            return False
        tc, tr = int(target[0]), int(target[1])
        mode_key = str(mode or "").strip().lower()
        if mode_key not in ("push", "pull"):
            return False
        if isinstance(direction_step, tuple) and len(direction_step) == 2:
            step_x = int(direction_step[0])
            step_y = int(direction_step[1])
        else:
            sc, sr = int(source[0]), int(source[1])
            vec_x = float(tc - sc)
            vec_y = float(tr - sr)
            dist = math.hypot(vec_x, vec_y)
            if dist <= 1e-6:
                return False
            step_x = int(round(vec_x / dist))
            step_y = int(round(vec_y / dist))
            if step_x == 0 and step_y == 0:
                if abs(vec_x) >= abs(vec_y):
                    step_x = 1 if vec_x > 0 else -1
                else:
                    step_y = 1 if vec_y > 0 else -1
        if mode_key == "pull":
            step_x *= -1
            step_y *= -1
        if step_x == 0 and step_y == 0:
            return False
        cols, rows, obstacles, _rough, _positions = self._lan_live_map_data()
        col, row = tc, tr
        moved = False
        origin_cell = (int(tc), int(tr))
        for _ in range(int(steps)):
            nc, nr = col + int(step_x), row + int(step_y)
            if nc < 0 or nr < 0 or nc >= int(cols) or nr >= int(rows) or (nc, nr) in (obstacles or set()):
                break
            col, row = int(nc), int(nr)
            moved = True
        if moved:
            self._lan_set_token_position(int(target_cid), int(col), int(row))
            self._lan_sync_fixed_to_caster_aoes(int(target_cid))
            self._lan_handle_aoe_enter_triggers_for_moved_unit(int(target_cid), origin_cell, (int(col), int(row)))
            self._enforce_johns_echo_tether(int(target_cid))
        return moved

    def _lan_snapshot(self, include_static: bool = True, hydrate_static: bool = True) -> Dict[str, Any]:
        # Prefer map window live state when available
        mw = None
        try:
            mw = getattr(self, "_map_window", None)
            if mw is not None and not mw.winfo_exists():
                mw = None
        except Exception:
            mw = None

        cols = self._lan_grid_cols
        rows = self._lan_grid_rows
        obstacles = set(self._lan_obstacles)
        positions = dict(self._lan_positions)
        map_ready = mw is not None
        aoes: List[Dict[str, Any]] = []
        aoe_source: Dict[int, Dict[str, Any]] = dict(getattr(self, "_lan_aoes", {}) or {})
        rough_terrain: Dict[Tuple[int, int], object] = dict(getattr(self, "_lan_rough_terrain", {}) or {})
        map_batching = False

        if mw is not None:
            try:
                cols = int(getattr(mw, "cols", cols))
                rows = int(getattr(mw, "rows", rows))
            except Exception:
                pass
            try:
                map_batching = bool(
                    getattr(mw, "_suspend_lan_sync", False)
                    or getattr(mw, "_drawing_obstacles", False)
                    or getattr(mw, "_drawing_rough", False)
                )
            except Exception:
                map_batching = False
            try:
                self._lan_sync_aoes_to_map(mw)
                aoe_source = dict(getattr(mw, "aoes", {}) or {})
            except Exception:
                pass
            if not map_batching:
                try:
                    obstacles = set(getattr(mw, "obstacles", obstacles) or set())
                except Exception:
                    pass
                try:
                    rough_terrain = dict(getattr(mw, "rough_terrain", rough_terrain) or {})
                except Exception:
                    pass
            try:
                for cid, tok in (getattr(mw, "unit_tokens", {}) or {}).items():
                    positions[int(cid)] = (int(tok.get("col")), int(tok.get("row")))
            except Exception:
                pass
            try:
                self._lan_aoes = dict(aoe_source)
                if aoe_source:
                    max_aid = max(int(aid) for aid in aoe_source.keys())
                    self._lan_next_aoe_id = max(self._lan_next_aoe_id, max_aid + 1)
            except Exception:
                pass
            if not map_batching:
                try:
                    self._lan_obstacles = set(obstacles)
                    self._lan_rough_terrain = dict(rough_terrain)
                except Exception:
                    pass

        def _log_invalid_aoe_value(aid_value: int, name_value: str, kind_value: str, key: str, raw_value: Any) -> None:
            self._oplog(
                f"LAN AoE invalid value aid={aid_value} name={name_value} kind={kind_value} key={key} value={raw_value!r}",
                level="warning",
            )

        def _finite_float(
            raw_value: Any,
            aid_value: int,
            name_value: str,
            kind_value: str,
            key: str,
            *,
            default: float = 0.0,
            skip_invalid: bool = False,
        ) -> Optional[float]:
            try:
                candidate = float(raw_value)
            except Exception:
                _log_invalid_aoe_value(aid_value, name_value, kind_value, key, raw_value)
                return None if skip_invalid else default
            if not math.isfinite(candidate):
                _log_invalid_aoe_value(aid_value, name_value, kind_value, key, raw_value)
                return None if skip_invalid else default
            return candidate

        try:
            for aid, d in sorted((aoe_source or {}).items()):
                kind = str(d.get("kind") or d.get("shape") or "").lower()
                if kind not in ("circle", "square", "line", "sphere", "cube", "cone", "cylinder", "wall"):
                    continue
                aid_int = int(aid)
                name = str(d.get("name") or f"AoE {aid}")
                payload: Dict[str, Any] = {
                    "aid": aid_int,
                    "kind": kind,
                    "name": name,
                    "color": str(d.get("color") or ""),
                    "cx": _finite_float(d.get("cx") or 0.0, aid_int, name, kind, "cx") or 0.0,
                    "cy": _finite_float(d.get("cy") or 0.0, aid_int, name, kind, "cy") or 0.0,
                    "pinned": bool(d.get("pinned")),
                    "duration_turns": d.get("duration_turns"),
                    "remaining_turns": d.get("remaining_turns"),
                }
                if bool(d.get("fixed_to_caster")) and d.get("anchor_cid") is not None:
                    try:
                        anchor_cid = int(d.get("anchor_cid"))
                        anchor_pos = positions.get(anchor_cid)
                    except Exception:
                        anchor_pos = None
                    if isinstance(anchor_pos, tuple) and len(anchor_pos) == 2:
                        payload["cx"] = float(anchor_pos[0])
                        payload["cy"] = float(anchor_pos[1])
                for extra_key in (
                    "dc",
                    "save_type",
                    "damage_type",
                    "half_on_pass",
                    "default_damage",
                    "owner",
                    "owner_cid",
                    "owner_ws_id",
                    "over_time",
                    "move_per_turn_ft",
                    "move_remaining_ft",
                    "trigger_on_start_or_enter",
                    "persistent",
                    "anchor_cid",
                    "fixed_to_caster",
                    "move_action_type",
                ):
                    if d.get(extra_key) not in (None, ""):
                        payload[extra_key] = d.get(extra_key)
                if kind in ("circle", "sphere", "cylinder"):
                    payload["radius_sq"] = _finite_float(
                        d.get("radius_sq") or 0.0, aid_int, name, kind, "radius_sq"
                    ) or 0.0
                    if d.get("radius_ft") is not None:
                        radius_ft = _finite_float(
                            d.get("radius_ft"), aid_int, name, kind, "radius_ft", skip_invalid=True
                        )
                        if radius_ft is not None:
                            payload["radius_ft"] = radius_ft
                    if d.get("height_ft") is not None:
                        height_ft = _finite_float(
                            d.get("height_ft"), aid_int, name, kind, "height_ft", skip_invalid=True
                        )
                        if height_ft is not None:
                            payload["height_ft"] = height_ft
                elif kind in ("line", "wall"):
                    payload["length_sq"] = _finite_float(
                        d.get("length_sq") or 0.0, aid_int, name, kind, "length_sq"
                    ) or 0.0
                    payload["width_sq"] = _finite_float(
                        d.get("width_sq") or 0.0, aid_int, name, kind, "width_sq"
                    ) or 0.0
                    if d.get("ax") is not None:
                        ax = _finite_float(d.get("ax"), aid_int, name, kind, "ax", skip_invalid=True)
                        if ax is not None:
                            payload["ax"] = ax
                    if d.get("ay") is not None:
                        ay = _finite_float(d.get("ay"), aid_int, name, kind, "ay", skip_invalid=True)
                        if ay is not None:
                            payload["ay"] = ay
                    payload["orient"] = str(d.get("orient") or "vertical")
                    if d.get("angle_deg") is not None:
                        angle_deg = _finite_float(
                            d.get("angle_deg"), aid_int, name, kind, "angle_deg", skip_invalid=True
                        )
                        if angle_deg is not None:
                            payload["angle_deg"] = angle_deg
                    if d.get("length_ft") is not None:
                        length_ft = _finite_float(
                            d.get("length_ft"), aid_int, name, kind, "length_ft", skip_invalid=True
                        )
                        if length_ft is not None:
                            payload["length_ft"] = length_ft
                    if d.get("width_ft") is not None:
                        width_ft = _finite_float(
                            d.get("width_ft"), aid_int, name, kind, "width_ft", skip_invalid=True
                        )
                        if width_ft is not None:
                            payload["width_ft"] = width_ft
                    if d.get("thickness_ft") is not None:
                        thickness_ft = _finite_float(
                            d.get("thickness_ft"), aid_int, name, kind, "thickness_ft", skip_invalid=True
                        )
                        if thickness_ft is not None:
                            payload["thickness_ft"] = thickness_ft
                    if d.get("height_ft") is not None:
                        height_ft = _finite_float(
                            d.get("height_ft"), aid_int, name, kind, "height_ft", skip_invalid=True
                        )
                        if height_ft is not None:
                            payload["height_ft"] = height_ft
                elif kind == "cone":
                    payload["length_sq"] = _finite_float(
                        d.get("length_sq") or 0.0, aid_int, name, kind, "length_sq"
                    ) or 0.0
                    if d.get("ax") is not None:
                        ax = _finite_float(d.get("ax"), aid_int, name, kind, "ax", skip_invalid=True)
                        if ax is not None:
                            payload["ax"] = ax
                    if d.get("ay") is not None:
                        ay = _finite_float(d.get("ay"), aid_int, name, kind, "ay", skip_invalid=True)
                        if ay is not None:
                            payload["ay"] = ay
                    payload["orient"] = str(d.get("orient") or "vertical")
                    if d.get("angle_deg") is not None:
                        angle_deg = _finite_float(
                            d.get("angle_deg"), aid_int, name, kind, "angle_deg", skip_invalid=True
                        )
                        if angle_deg is not None:
                            payload["angle_deg"] = angle_deg
                    if d.get("spread_deg") is not None:
                        spread_deg = _finite_float(
                            d.get("spread_deg"), aid_int, name, kind, "spread_deg", skip_invalid=True
                        )
                        if spread_deg is not None:
                            payload["spread_deg"] = spread_deg
                    if d.get("length_ft") is not None:
                        length_ft = _finite_float(
                            d.get("length_ft"), aid_int, name, kind, "length_ft", skip_invalid=True
                        )
                        if length_ft is not None:
                            payload["length_ft"] = length_ft
                else:
                    payload["side_sq"] = _finite_float(
                        d.get("side_sq") or 0.0, aid_int, name, kind, "side_sq"
                    ) or 0.0
                    if d.get("angle_deg") is not None:
                        angle_deg = _finite_float(
                            d.get("angle_deg"), aid_int, name, kind, "angle_deg", skip_invalid=True
                        )
                        if angle_deg is not None:
                            payload["angle_deg"] = angle_deg
                    if d.get("side_ft") is not None:
                        side_ft = _finite_float(
                            d.get("side_ft"), aid_int, name, kind, "side_ft", skip_invalid=True
                        )
                        if side_ft is not None:
                            payload["side_ft"] = side_ft
                aoes.append(payload)
        except Exception:
            pass

        feet_per_square = 5.0
        try:
            if map_ready and mw is not None and mw.winfo_exists():
                feet_per_square = float(getattr(mw, "feet_per_square", 5.0) or 5.0)
        except Exception:
            feet_per_square = 5.0

        # Ensure any combatant has a position (spawn near center in a square spiral)
        if self.combatants and len(positions) < len(self.combatants):
            positions = self._lan_seed_missing_positions(positions, cols, rows)

        active_auras = self._lan_active_aura_contexts(positions=positions, feet_per_square=feet_per_square)
        for idx, aura in enumerate(active_auras):
            source_cid = aura.get("source_cid")
            source_pos = positions.get(int(source_cid)) if source_cid is not None else None
            if not (isinstance(source_pos, tuple) and len(source_pos) == 2):
                continue
            aoes.append(
                {
                    "aid": -1001 - int(idx),
                    "kind": "circle",
                    "name": str(aura.get("name") or "Aura"),
                    "color": str(aura.get("color") or "#fcebc4"),
                    "cx": float(source_pos[0]),
                    "cy": float(source_pos[1]),
                    "radius_sq": float(aura.get("radius_sq") or max(0.1, 10.0 / max(1.0, feet_per_square))),
                    "radius_ft": float(aura.get("radius_ft") or 10.0),
                    "owner_cid": int(source_cid),
                    "persistent": True,
                    "is_aura": True,
                    "aura_id": str(aura.get("aura_id") or f"aura_{idx}"),
                    "light": True,
                }
            )

        units: List[Dict[str, Any]] = []
        for c in sorted(self.combatants.values(), key=lambda x: int(x.cid)):
            role = self._name_role_memory.get(str(c.name), "enemy")
            pos = positions.get(c.cid, (max(0, cols // 2), max(0, rows // 2)))
            is_invisible = self._has_condition(c, "invisible")
            is_hidden = bool(getattr(c, "is_hidden", False))
            marks = self._lan_marks_for(c)
            actions = self._normalize_action_entries(getattr(c, "actions", []), "action")
            bonus_actions = self._normalize_action_entries(getattr(c, "bonus_actions", []), "bonus_action")
            reactions = self._normalize_action_entries(getattr(c, "reactions", []), "reaction")
            effect_icons: List[Dict[str, str]] = []
            for aura in active_auras:
                if int(c.cid) not in (aura.get("affected") or set()):
                    continue
                effect = aura.get("effect") if isinstance(aura.get("effect"), dict) else {}
                if not effect:
                    continue
                effect_icons.append(
                    {
                        "id": str(effect.get("id") or "effect"),
                        "name": str(effect.get("name") or "Effect"),
                        "icon": str(effect.get("icon") or "✨"),
                        "description": str(effect.get("description") or ""),
                    }
                )

            units.append(
                {
                    "cid": c.cid,
                    "name": str(c.name),
                    "role": role if role in ("pc", "ally", "enemy") else "enemy",
                    "ally": bool(role in ("pc", "ally")),
                    "token_color": self._token_color_payload(c),
                    "token_border_color": self._token_border_color_payload(c),
                    "hp": int(getattr(c, "hp", 0) or 0),
                    "max_hp": int(getattr(c, "max_hp", getattr(c, "hp", 0)) or 0),
                    "speed": int(getattr(c, "speed", 0) or 0),
                    "swim_speed": int(getattr(c, "swim_speed", 0) or 0),
                    "fly_speed": int(getattr(c, "fly_speed", 0) or 0),
                    "burrow_speed": int(getattr(c, "burrow_speed", 0) or 0),
                    "move_remaining": int(getattr(c, "move_remaining", 0) or 0),
                    "move_total": int(getattr(c, "move_total", 0) or 0),
                    "movement_mode": self._movement_mode_label(getattr(c, "movement_mode", "normal")),
                    "action_remaining": int(getattr(c, "action_remaining", 0) or 0),
                    "action_total": int(getattr(c, "action_total", 1) or 1),
                    "attack_resource_remaining": int(getattr(c, "attack_resource_remaining", 0) or 0),
                    "bonus_action_remaining": int(getattr(c, "bonus_action_remaining", 0) or 0),
                    "reaction_remaining": int(getattr(c, "reaction_remaining", 0) or 0),
                    "spell_cast_remaining": int(getattr(c, "spell_cast_remaining", 0) or 0),
                    "actions": actions,
                    "bonus_actions": bonus_actions,
                    "reactions": reactions,
                    "is_prone": self._has_condition(c, "prone"),
                    "is_spellcaster": bool(getattr(c, "is_spellcaster", False)),
                    "is_wild_shaped": bool(getattr(c, "is_wild_shaped", False)),
                    "wild_shape_form": str(getattr(c, "wild_shape_form_name", "") or "") or None,
                    "elemental_attunement_active": self._elemental_attunement_active(c),
                    "summoned_by_cid": _normalize_cid_value(getattr(c, "summoned_by_cid", None), "snapshot.summoned_by"),
                    "summon_source_spell": str(getattr(c, "summon_source_spell", "") or "") or None,
                    "summon_group_id": str(getattr(c, "summon_group_id", "") or "") or None,
                    "summon_controller_mode": str(getattr(c, "summon_controller_mode", "") or "") or None,
                    "summon_shared_turn": bool(getattr(c, "summon_shared_turn", False)),
                    "monster_slug": str(getattr(c, "monster_slug", "") or "") or None,
                    "concentrating": bool(getattr(c, "concentrating", False)),
                    "concentration_spell": str(getattr(c, "concentration_spell", "") or "") or None,
                    "smite_charge": self._json_safe(getattr(c, "pending_smite_charge", None)),
                    "is_mount": bool(getattr(c, "is_mount", False)),
                    "is_hidden": bool(is_hidden),
                    "is_invisible": bool(is_invisible),
                    "is_unseen": bool(is_hidden or is_invisible),
                    "rider_cid": _normalize_cid_value(getattr(c, "rider_cid", None), "snapshot.rider_cid"),
                    "mounted_by_cid": _normalize_cid_value(getattr(c, "mounted_by_cid", None), "snapshot.mounted_by"),
                    "mount_shared_turn": bool(getattr(c, "mount_shared_turn", False)),
                    "mount_controller_mode": str(getattr(c, "mount_controller_mode", "") or "") or None,
                    "has_mounted_this_turn": bool(getattr(c, "has_mounted_this_turn", False)),
                    "can_be_mounted": bool(getattr(c, "can_be_mounted", False)),
                    "facing_deg": int(self._normalize_facing_degrees(getattr(c, "facing_deg", 0))),
                    "vexed_by_cid": _normalize_cid_value(getattr(c, "_vexed_by_cid", None), "snapshot.vexed_by"),
                    "summon_variant": str(getattr(c, "summon_variant", "") or "") or None,
                    "slot_level": getattr(c, "summon_slot_level", None),
                    "pos": {"col": int(pos[0]), "row": int(pos[1])},
                    "marks": marks,
                    "effects": effect_icons,
                }
            )

        # Active creature
        active = self.current_cid if getattr(self, "current_cid", None) is not None else None

        grid_payload = None
        if map_ready:
            grid_payload = {"cols": int(cols), "rows": int(rows), "feet_per_square": float(feet_per_square)}
        turn_order: List[int] = []
        try:
            ordered = self._display_order()
            turn_order = [int(c.cid) for c in ordered if getattr(c, "cid", None) is not None]
        except Exception:
            try:
                turn_order = [int(c.cid) for c in sorted(self.combatants.values(), key=lambda x: int(x.cid))]
            except Exception:
                turn_order = []
        rough_payload: List[Dict[str, Any]] = []
        for (c, r), cell in sorted(rough_terrain.items()):
            if isinstance(cell, dict):
                color = str(cell.get("color") or "")
                is_rough = bool(cell.get("is_rough", False))
                movement_type = self._normalize_movement_type(cell.get("movement_type"), is_swim=bool(cell.get("is_swim", False)))
            else:
                color = str(cell)
                is_rough = True
                movement_type = "ground"
            rough_payload.append(
                {
                    "col": int(c),
                    "row": int(r),
                    "color": color,
                    "movement_type": movement_type,
                    "is_swim": movement_type == "water",
                    "is_rough": is_rough,
                }
            )

        snap: Dict[str, Any] = {
            "grid": grid_payload,
            "obstacles": [{"col": int(c), "row": int(r)} for (c, r) in sorted(obstacles)],
            "rough_terrain": rough_payload,
            "aoes": aoes,
            "units": units,
            "active_cid": active,
            "round_num": int(getattr(self, "round_num", 0) or 0),
            "turn_order": turn_order,
            "auras_enabled": bool(self.__dict__.get("_lan_auras_enabled", True)),
        }
        if include_static:
            snap["spell_presets"] = self._spell_presets_payload()
            snap["player_spells"] = self._player_spell_config_payload()
            snap["player_profiles"] = self._player_profiles_payload()
            snap["resource_pools"] = self._player_resource_pools_payload()
        else:
            cached_snapshot = getattr(getattr(self, "_lan", None), "_cached_snapshot", {})
            if not isinstance(cached_snapshot, dict):
                cached_snapshot = {}

            static_defaults: Dict[str, Any] = {
                "spell_presets": [],
                "player_spells": {},
                "player_profiles": {},
                "resource_pools": {},
            }
            static_builders = {
                "spell_presets": self._spell_presets_payload,
                "player_spells": self._player_spell_config_payload,
                "player_profiles": self._player_profiles_payload,
                "resource_pools": self._player_resource_pools_payload,
            }
            resource_refresh_interval_s = max(
                0.25, float(self.__dict__.get("_player_yaml_refresh_interval_s", 1.0) or 1.0)
            )
            now = time.monotonic()
            last_resource_build = float(self.__dict__.get("_lan_resource_pools_last_build", 0.0))
            for key, default in static_defaults.items():
                if key in cached_snapshot:
                    if key != "resource_pools" or (now - last_resource_build) < resource_refresh_interval_s:
                        snap[key] = cached_snapshot.get(key)
                        continue
                if not hydrate_static:
                    snap[key] = default
                    continue
                try:
                    snap[key] = static_builders[key]()
                    if key == "resource_pools":
                        self._lan_resource_pools_last_build = now
                except Exception:
                    snap[key] = default
        return snap

    def _lan_force_state_broadcast(self) -> None:
        try:
            snap = self._lan_snapshot()
            self._lan._cached_snapshot = snap
            try:
                self._lan._cached_pcs = list(
                    self._lan_pcs() if hasattr(self, "_lan_pcs") else self._lan_claimable()
                )
            except Exception:
                self._lan._cached_pcs = []
            try:
                self._lan._last_snapshot = copy.deepcopy(snap)
            except Exception:
                pass
            try:
                static_payload = self._lan._static_data_payload()
                static_json = json.dumps(static_payload, sort_keys=True, separators=(",", ":"))
                self._lan._last_static_json = static_json
                self._lan._broadcast_payload({"type": "static_data", "data": static_payload})
            except Exception:
                pass
            self._lan._broadcast_state(snap)
        except Exception:
            pass

    def _lan_marks_for(self, c: Any) -> str:
        # Match main-map effect markers (conditions, DoT, star advantage, etc.)
        try:
            text = self._format_effects(c)
        except Exception:
            text = ""
        return (text or "").strip()

    def _lan_is_friendly_unit(self, cid: int) -> bool:
        combatant = self.combatants.get(int(cid))
        if combatant is None:
            return False
        role = str(self._name_role_memory.get(str(getattr(combatant, "name", "")), "enemy") or "enemy")
        if role in ("pc", "ally"):
            return True
        owner_cid = _normalize_cid_value(getattr(combatant, "summoned_by_cid", None), "lan.aura.summon_owner")
        if owner_cid is None:
            return False
        owner = self.combatants.get(int(owner_cid))
        if owner is None:
            return False
        owner_role = str(self._name_role_memory.get(str(getattr(owner, "name", "")), "enemy") or "enemy")
        return owner_role in ("pc", "ally")

    def _lan_active_aura_contexts(
        self,
        positions: Optional[Dict[int, Tuple[int, int]]] = None,
        feet_per_square: float = 5.0,
    ) -> List[Dict[str, Any]]:
        if not bool(self.__dict__.get("_lan_auras_enabled", True)):
            return []
        pos_map = positions if isinstance(positions, dict) else dict(getattr(self, "_lan_positions", {}) or {})
        fps = max(1.0, float(feet_per_square or 5.0))
        contexts: List[Dict[str, Any]] = []
        for combatant in self.combatants.values():
            cid = _normalize_cid_value(getattr(combatant, "cid", None), "lan.aura.cid")
            if cid is None:
                continue
            if self._has_condition(combatant, "incapacitated"):
                continue
            source_name = str(getattr(combatant, "name", "") or "").strip()
            try:
                profile = self._profile_for_player_name(source_name)
            except Exception:
                profile = {}
            features = profile.get("features") if isinstance(profile, dict) else []
            if not isinstance(features, list):
                continue
            center = pos_map.get(int(cid))
            if not (isinstance(center, tuple) and len(center) == 2):
                continue
            for feature in features:
                if not isinstance(feature, dict):
                    continue
                grants = feature.get("grants") if isinstance(feature.get("grants"), dict) else {}
                aura = grants.get("aura") if isinstance(grants.get("aura"), dict) else {}
                if not aura:
                    continue
                try:
                    radius_ft = float(aura.get("radius_ft") or 0)
                except Exception:
                    radius_ft = 0.0
                if radius_ft <= 0:
                    continue
                save_bonus_cfg = aura.get("save_bonus") if isinstance(aura.get("save_bonus"), dict) else {}
                ability_mod_key = str(save_bonus_cfg.get("ability_mod") or "").strip().lower()
                min_bonus = 0
                try:
                    min_bonus = int(save_bonus_cfg.get("minimum") or 0)
                except Exception:
                    min_bonus = 0
                bonus_mod = 0
                mods = getattr(combatant, "ability_mods", None)
                if isinstance(mods, dict) and ability_mod_key:
                    try:
                        bonus_mod = int(mods.get(ability_mod_key) or 0)
                    except Exception:
                        bonus_mod = 0
                if bonus_mod == 0 and isinstance(profile, dict) and ability_mod_key:
                    abilities = profile.get("abilities") if isinstance(profile.get("abilities"), dict) else {}
                    bonus_mod = int(self._ability_score_modifier(abilities, ability_mod_key)) if abilities else 0
                save_bonus = max(int(min_bonus), int(bonus_mod))
                radius_sq = max(0.1, float(radius_ft) / fps)
                radius_sq_2 = radius_sq * radius_sq
                affected: set[int] = set()
                for other_cid, other_pos in pos_map.items():
                    if not (isinstance(other_pos, tuple) and len(other_pos) == 2):
                        continue
                    try:
                        other_int = int(other_cid)
                        dx = float(other_pos[0]) - float(center[0])
                        dy = float(other_pos[1]) - float(center[1])
                    except Exception:
                        continue
                    if (dx * dx + dy * dy) > (radius_sq_2 + 1e-6):
                        continue
                    if self._lan_is_friendly_unit(other_int):
                        affected.add(other_int)
                dmg_resist_raw = aura.get("damage_resistances") if isinstance(aura.get("damage_resistances"), list) else []
                dmg_resistances = {str(x or "").strip().lower() for x in dmg_resist_raw if str(x or "").strip()}
                effect_cfg = aura.get("effect") if isinstance(aura.get("effect"), dict) else {}
                effect_name = str(effect_cfg.get("name") or "Protected").strip() or "Protected"
                effect_icon = str(effect_cfg.get("icon") or "🛡️")
                effect_id = str(effect_cfg.get("id") or "protected").strip().lower() or "protected"
                desc_template = str(effect_cfg.get("description_template") or "").strip()
                if desc_template:
                    effect_description = (
                        desc_template.replace("{source_name}", source_name).replace("{save_bonus}", str(int(save_bonus)))
                    )
                else:
                    effect_description = (
                        f"{source_name}s oath protects you. Gain a +{int(save_bonus)} and resistance to "
                        "Necrotic, Psychic and Radiant damage"
                    )
                contexts.append(
                    {
                        "source_cid": int(cid),
                        "source_name": source_name,
                        "radius_ft": float(radius_ft),
                        "radius_sq": float(radius_sq),
                        "save_bonus": int(save_bonus),
                        "damage_resistances": dmg_resistances,
                        "affected": affected,
                        "color": str(aura.get("color") or "#fcebc4"),
                        "name": str(aura.get("name") or "Aura"),
                        "aura_id": str(aura.get("id") or effect_id or "aura").strip().lower(),
                        "effect": {
                            "id": effect_id,
                            "name": effect_name,
                            "icon": effect_icon,
                            "description": effect_description,
                        },
                    }
                )
        return contexts

    def _lan_aura_effects_for_target(self, target_obj: Any) -> Dict[str, Any]:
        try:
            target_cid = int(getattr(target_obj, "cid", 0) or 0)
        except Exception:
            return {"save_bonus": 0, "damage_resistances": set(), "effects": []}
        try:
            _, _, _, _, positions = self._lan_live_map_data()
        except Exception:
            positions = dict(self.__dict__.get("_lan_positions", {}) or {})
        contexts = self._lan_active_aura_contexts(positions=positions)
        save_bonus = 0
        damage_resistances: set[str] = set()
        effects: List[Dict[str, str]] = []
        seen_effect_ids: set[str] = set()
        for aura in contexts:
            if target_cid not in (aura.get("affected") or set()):
                continue
            save_bonus += int(aura.get("save_bonus") or 0)
            damage_resistances.update(set(aura.get("damage_resistances") or set()))
            effect = aura.get("effect") if isinstance(aura.get("effect"), dict) else None
            effect_id = str((effect or {}).get("id") or "").strip().lower()
            if effect and effect_id and effect_id not in seen_effect_ids:
                seen_effect_ids.add(effect_id)
                effects.append(effect)
        return {
            "save_bonus": int(save_bonus),
            "damage_resistances": damage_resistances,
            "effects": effects,
        }

    def _canonical_damage_type(self, value: Any) -> str:
        text = str(value or "").strip().lower()
        if not text:
            return ""
        allowed = {str(dtype or "").strip().lower() for dtype in DAMAGE_TYPES if str(dtype or "").strip()}
        return text if text in allowed else ""

    def _canonical_condition_key(self, value: Any) -> str:
        text = str(value or "").strip().lower()
        if not text:
            return ""
        cond_meta = getattr(base, "CONDITIONS_META", {})
        if not isinstance(cond_meta, dict):
            return ""
        if text in cond_meta:
            return text
        for key, meta in cond_meta.items():
            label = ""
            if isinstance(meta, dict):
                label = str(meta.get("label") or "").strip().lower()
            if label and text == label:
                return str(key).strip().lower()
        return ""

    def _combatant_defense_sets(self, target_obj: Any) -> Dict[str, set[str]]:
        defenses: Dict[str, set[str]] = {
            "damage_resistances": set(),
            "damage_immunities": set(),
            "damage_vulnerabilities": set(),
            "condition_immunities": set(),
        }

        def _add_damage(target_key: str, values: Any) -> None:
            if not isinstance(values, list):
                return
            for item in values:
                dtype = self._canonical_damage_type(item)
                if dtype:
                    defenses[target_key].add(dtype)

        def _add_condition(values: Any) -> None:
            if not isinstance(values, list):
                return
            for item in values:
                ckey = self._canonical_condition_key(item)
                if ckey:
                    defenses["condition_immunities"].add(ckey)

        def _classify_legacy(values: Any, target_key: str) -> None:
            if not isinstance(values, list):
                return
            for item in values:
                dtype = self._canonical_damage_type(item)
                if dtype:
                    defenses[target_key].add(dtype)
                    continue
                ckey = self._canonical_condition_key(item)
                if ckey:
                    defenses["condition_immunities"].add(ckey)

        def _consume_defense_map(raw_map: Any) -> None:
            if not isinstance(raw_map, dict):
                return
            _add_damage("damage_resistances", raw_map.get("damage_resistances"))
            _add_damage("damage_immunities", raw_map.get("damage_immunities"))
            _add_damage("damage_vulnerabilities", raw_map.get("damage_vulnerabilities"))
            _add_condition(raw_map.get("condition_immunities"))
            _classify_legacy(raw_map.get("resistances"), "damage_resistances")
            _classify_legacy(raw_map.get("immunities"), "damage_immunities")
            _classify_legacy(raw_map.get("vulnerabilities"), "damage_vulnerabilities")

        spec = getattr(target_obj, "monster_spec", None)
        raw_data = getattr(spec, "raw_data", None) if spec is not None else None
        _consume_defense_map(raw_data)

        if spec is not None and not isinstance(raw_data, dict):
            for alt_attr in ("raw", "data", "details"):
                _consume_defense_map(getattr(spec, alt_attr, None))

        for alt_attr in ("monster_raw_data", "raw_data", "stat_block", "monster_data"):
            _consume_defense_map(getattr(target_obj, alt_attr, None))
        _consume_defense_map(getattr(target_obj, "defenses", None))

        try:
            if bool(getattr(target_obj, "is_pc", False)):
                player_name = self._pc_name_for(int(getattr(target_obj, "cid", 0) or 0))
                profile = self._profile_for_player_name(player_name)
            else:
                profile = None
        except Exception:
            profile = None
        if isinstance(profile, dict):
            profile_defenses = profile.get("defenses") if isinstance(profile.get("defenses"), dict) else {}
            _add_damage("damage_resistances", profile_defenses.get("resistances"))
            _add_damage("damage_immunities", profile_defenses.get("immunities"))
            _add_damage("damage_vulnerabilities", profile_defenses.get("vulnerabilities"))
            _add_condition(profile_defenses.get("condition_immunities"))

        try:
            aura_effects = self._lan_aura_effects_for_target(target_obj)
        except Exception:
            aura_effects = {"damage_resistances": set()}
        aura_resistances = set((aura_effects or {}).get("damage_resistances") or set())
        for item in aura_resistances:
            dtype = self._canonical_damage_type(item)
            if dtype:
                defenses["damage_resistances"].add(dtype)
        return defenses

    def _adjust_damage_entries_for_target(self, target_obj: Any, damage_entries: List[Dict[str, Any]]) -> Dict[str, Any]:
        defenses = self._combatant_defense_sets(target_obj)
        resistances = set(defenses.get("damage_resistances") or set())
        immunities = set(defenses.get("damage_immunities") or set())
        vulnerabilities = set(defenses.get("damage_vulnerabilities") or set())
        adjusted: List[Dict[str, Any]] = []
        notes: List[Dict[str, Any]] = []
        for entry in damage_entries if isinstance(damage_entries, list) else []:
            if not isinstance(entry, dict):
                continue
            try:
                original = max(0, int(entry.get("amount") or 0))
            except Exception:
                original = 0
            if original <= 0:
                continue
            raw_type = str(entry.get("type") or "").strip().lower()
            dtype = self._canonical_damage_type(raw_type)
            applied = int(original)
            reasons: List[str] = []
            if dtype:
                if dtype in immunities:
                    applied = 0
                    reasons.append("immune")
                else:
                    is_resistant = dtype in resistances
                    is_vulnerable = dtype in vulnerabilities
                    if is_resistant and is_vulnerable:
                        reasons.append("resistant+vulnerable cancel")
                    elif is_resistant:
                        applied = int(applied // 2)
                        reasons.append("resistant")
                    elif is_vulnerable:
                        applied = int(applied * 2)
                        reasons.append("vulnerable")
            if applied > 0:
                adjusted.append({"amount": int(applied), "type": raw_type})
            if reasons:
                notes.append(
                    {
                        "type": raw_type,
                        "canonical_type": dtype,
                        "original": int(original),
                        "applied": int(applied),
                        "reasons": list(reasons),
                    }
                )
        return {"entries": adjusted, "notes": notes, "defenses": defenses}

    def _condition_is_immune_for_target(self, target_obj: Any, condition_value: Any) -> bool:
        ckey = self._canonical_condition_key(condition_value)
        if not ckey:
            return False
        defenses = self._combatant_defense_sets(target_obj)
        return ckey in set(defenses.get("condition_immunities") or set())

    def _lan_apply_aura_resistances(self, target_obj: Any, damage_entries: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        return list((self._adjust_damage_entries_for_target(target_obj, damage_entries) or {}).get("entries") or [])

    def _lan_compute_included_units_for_aoe(self, aoe: Dict[str, Any]) -> List[int]:
        if not isinstance(aoe, dict):
            return []
        kind = str(aoe.get("kind") or "").strip().lower()
        if not kind:
            return []
        _cols, _rows, _obstacles, _rough, positions = self._lan_live_map_data()
        cx = float(aoe.get("cx") or 0.0)
        cy = float(aoe.get("cy") or 0.0)
        included: List[int] = []
        token_half = 0.5
        if kind in ("circle", "sphere", "cylinder"):
            r2 = float(aoe.get("radius_sq") or 0.0) ** 2
            for cid, pos in positions.items():
                px, py = float(pos[0]), float(pos[1])
                if (px - cx) ** 2 + (py - cy) ** 2 <= r2:
                    included.append(int(cid))
        elif kind in ("line", "wall"):
            length_sq = float(aoe.get("length_sq") or 0.0)
            width_sq = float(aoe.get("width_sq") or 0.0)
            angle_deg = aoe.get("angle_deg")
            if angle_deg is None:
                orient = str(aoe.get("orient") or "vertical").strip().lower()
                angle_deg = 0.0 if orient == "horizontal" else 90.0
            angle_rad = math.radians(float(angle_deg))
            cos_a = math.cos(-angle_rad)
            sin_a = math.sin(-angle_rad)
            for cid, pos in positions.items():
                dx = float(pos[0]) - cx
                dy = float(pos[1]) - cy
                rx = dx * cos_a - dy * sin_a
                ry = dx * sin_a + dy * cos_a
                if abs(rx) <= (length_sq / 2.0) + token_half and abs(ry) <= (width_sq / 2.0) + token_half:
                    included.append(int(cid))
        elif kind == "cone":
            length_sq = float(aoe.get("length_sq") or 0.0)
            spread_deg = aoe.get("spread_deg")
            has_spread = spread_deg is not None
            if spread_deg is None:
                spread_deg = aoe.get("angle_deg")
            if spread_deg is None:
                spread_deg = 90.0
            spread_deg = float(spread_deg)
            orient = str(aoe.get("orient") or "vertical").strip().lower()
            heading_deg = 0.0 if orient == "horizontal" else -90.0
            if has_spread and aoe.get("angle_deg") is not None:
                heading_deg = float(aoe.get("angle_deg"))
            heading_rad = math.radians(float(heading_deg))
            half_spread = math.radians(spread_deg / 2.0)
            for cid, pos in positions.items():
                dx = float(pos[0]) - cx
                dy = float(pos[1]) - cy
                dist = math.hypot(dx, dy)
                if dist > length_sq + token_half:
                    continue
                angle = math.atan2(dy, dx) - heading_rad
                while angle <= -math.pi:
                    angle += math.pi * 2
                while angle > math.pi:
                    angle -= math.pi * 2
                if abs(angle) <= half_spread:
                    included.append(int(cid))
        else:
            half = float(aoe.get("side_sq") or 0.0) / 2.0
            angle = aoe.get("angle_deg") if kind in ("square", "cube") else None
            if angle is None:
                x1, y1 = cx - half, cy - half
                x2, y2 = cx + half, cy + half
                for cid, pos in positions.items():
                    px, py = float(pos[0]), float(pos[1])
                    if x1 <= px <= x2 and y1 <= py <= y2:
                        included.append(int(cid))
            else:
                angle_rad = math.radians(float(angle))
                cos_a = math.cos(-angle_rad)
                sin_a = math.sin(-angle_rad)
                for cid, pos in positions.items():
                    dx = float(pos[0]) - cx
                    dy = float(pos[1]) - cy
                    rx = dx * cos_a - dy * sin_a
                    ry = dx * sin_a + dy * cos_a
                    if abs(rx) <= half and abs(ry) <= half:
                        included.append(int(cid))
        order = [c.cid for c in self._display_order()] if hasattr(self, "_display_order") else []
        order_idx = {int(c): i for i, c in enumerate(order)}
        included.sort(key=lambda item: order_idx.get(int(item), 10**9))
        return included

    def _lan_current_turn_key(self) -> Tuple[int, int, Optional[int]]:
        round_num = int(getattr(self, "round_num", 0) or 0)
        turn_num = int(getattr(self, "turn_num", 0) or 0)
        current_cid = _normalize_cid_value(getattr(self, "current_cid", None), "aoe.current_cid")
        return (round_num, turn_num, current_cid)

    def _lan_apply_aoe_trigger_to_targets(
        self,
        aid: int,
        aoe: Dict[str, Any],
        *,
        target_cids: List[int],
        turn_key: Optional[Tuple[int, int, Optional[int]]] = None,
    ) -> bool:
        if not isinstance(aoe, dict) or not target_cids:
            return False
        if not bool(aoe.get("over_time")):
            return False
        dedupe_map = self.__dict__.get("_lan_aoe_last_applied_turn")
        if not isinstance(dedupe_map, dict):
            dedupe_map = {}
            self._lan_aoe_last_applied_turn = dedupe_map
        resolved_turn_key = turn_key if turn_key is not None else self._lan_current_turn_key()
        filtered_targets: List[int] = []
        for target_cid in target_cids:
            key = (int(aid), int(target_cid))
            if dedupe_map.get(key) == resolved_turn_key:
                continue
            filtered_targets.append(int(target_cid))
        if not filtered_targets:
            return False
        spell_slug = str(aoe.get("spell_slug") or "").strip()
        spell_id = str(aoe.get("spell_id") or "").strip()
        preset = self._find_spell_preset(spell_slug=spell_slug, spell_id=spell_id)
        if not isinstance(preset, dict):
            return False
        owner_cid = _normalize_cid_value(aoe.get("owner_cid"), "aoe.owner_cid")
        caster = self.combatants.get(owner_cid) if owner_cid in self.combatants else None
        try:
            slot_level = int(aoe.get("slot_level"))
        except Exception:
            slot_level = None
        resolved = self._lan_auto_resolve_cast_aoe(
            aid,
            aoe,
            caster=caster,
            spell_slug=spell_slug,
            spell_id=spell_id,
            slot_level=slot_level,
            preset=preset,
            included_override=filtered_targets,
            remove_on_empty=False,
            remove_after_resolve=False,
        )
        if not resolved:
            return False
        for target_cid in filtered_targets:
            dedupe_map[(int(aid), int(target_cid))] = resolved_turn_key
        return True

    def _lan_handle_aoe_enter_triggers_for_moved_unit(self, cid: int, origin_cell: Tuple[int, int], new_cell: Tuple[int, int]) -> None:
        if tuple(origin_cell) == tuple(new_cell):
            return
        turn_key = self._lan_current_turn_key()
        for aid, aoe in list((getattr(self, "_lan_aoes", {}) or {}).items()):
            if not isinstance(aoe, dict) or not bool(aoe.get("over_time")):
                continue
            trigger = str(aoe.get("trigger_on_start_or_enter") or "").strip().lower()
            if trigger not in ("enter", "start_or_enter", "enter_or_end"):
                continue
            original_positions = dict(getattr(self, "_lan_positions", {}) or {})
            was_inside = False
            is_inside = False
            try:
                self._lan_positions[int(cid)] = (int(origin_cell[0]), int(origin_cell[1]))
                was_inside = int(cid) in self._lan_compute_included_units_for_aoe(aoe)
                self._lan_positions[int(cid)] = (int(new_cell[0]), int(new_cell[1]))
                is_inside = int(cid) in self._lan_compute_included_units_for_aoe(aoe)
            finally:
                self._lan_positions = original_positions
            if (not was_inside) and is_inside:
                self._lan_apply_aoe_trigger_to_targets(int(aid), aoe, target_cids=[int(cid)], turn_key=turn_key)

    def _lan_handle_aoe_enter_triggers_for_aoe_move(self, aid: int, aoe: Dict[str, Any], before_included: List[int]) -> None:
        if not isinstance(aoe, dict) or not bool(aoe.get("over_time")):
            return
        trigger = str(aoe.get("trigger_on_start_or_enter") or "").strip().lower()
        if trigger not in ("enter", "start_or_enter", "enter_or_end"):
            return
        after_included = set(self._lan_compute_included_units_for_aoe(aoe))
        before_set = {int(cid) for cid in before_included}
        entered = sorted(int(cid) for cid in after_included if int(cid) not in before_set)
        if entered:
            self._lan_apply_aoe_trigger_to_targets(int(aid), aoe, target_cids=entered)

    def _lan_sync_fixed_to_caster_aoes(self, moved_cid: int) -> None:
        current_pos = dict(getattr(self, "_lan_positions", {}) or {}).get(int(moved_cid))
        if not (isinstance(current_pos, tuple) and len(current_pos) == 2):
            return
        for aid, aoe in list((getattr(self, "_lan_aoes", {}) or {}).items()):
            if not isinstance(aoe, dict) or not bool(aoe.get("fixed_to_caster")):
                continue
            anchor_cid = _normalize_cid_value(aoe.get("anchor_cid"), "aoe.anchor_cid")
            if anchor_cid != int(moved_cid):
                continue
            before = self._lan_compute_included_units_for_aoe(aoe)
            aoe["cx"] = float(current_pos[0])
            aoe["cy"] = float(current_pos[1])
            self._lan_handle_aoe_enter_triggers_for_aoe_move(int(aid), aoe, before)

    def _lan_auto_resolve_cast_aoe(
        self,
        aid: int,
        aoe: Dict[str, Any],
        *,
        caster: Optional[base.Combatant],
        spell_slug: str,
        spell_id: str,
        slot_level: Optional[int],
        preset: Optional[Dict[str, Any]],
        manual_damage_entries: Optional[List[Dict[str, Any]]] = None,
        included_override: Optional[List[int]] = None,
        remove_on_empty: bool = True,
        remove_after_resolve: bool = True,
    ) -> bool:
        if not isinstance(aoe, dict) or not isinstance(preset, dict):
            return False
        automation = str(preset.get("automation") or "").strip().lower()
        tags = {str(tag).strip().lower() for tag in (preset.get("tags") or []) if str(tag).strip()}
        allow_manual_damage_resolution = False
        if isinstance(manual_damage_entries, list):
            for entry in manual_damage_entries:
                if not isinstance(entry, dict):
                    continue
                try:
                    if int(entry.get("amount") or 0) > 0:
                        allow_manual_damage_resolution = True
                        break
                except Exception:
                    continue
        if automation != "full" and "automation_full" not in tags and not allow_manual_damage_resolution:
            return False
        mechanics = preset.get("mechanics") if isinstance(preset.get("mechanics"), dict) else {}
        sequence = mechanics.get("sequence") if isinstance(mechanics.get("sequence"), list) else []
        step = None
        check_kind = ""
        for candidate in sequence:
            if not isinstance(candidate, dict):
                continue
            check = candidate.get("check") if isinstance(candidate.get("check"), dict) else {}
            check_kind = str(check.get("kind") or "").strip().lower()
            if check_kind not in ("saving_throw", "none", "auto"):
                continue
            outcomes = candidate.get("outcomes") if isinstance(candidate.get("outcomes"), dict) else {}
            has_supported = False
            for bucket in outcomes.values():
                if not isinstance(bucket, list):
                    continue
                for effect in bucket:
                    if not isinstance(effect, dict):
                        continue
                    effect_name = str(effect.get("effect") or "").strip().lower()
                    if effect_name in ("damage", "condition", "forced_movement", "movement"):
                        has_supported = True
                        break
                if has_supported:
                    break
            if has_supported:
                step = candidate
                break
        if not isinstance(step, dict):
            return False
        check = step.get("check") if isinstance(step.get("check"), dict) else {}
        ability = str(check.get("ability") or aoe.get("save_type") or "").strip().lower()[:3]
        requires_save = check_kind == "saving_throw"
        if requires_save and ability not in ("str", "dex", "con", "int", "wis", "cha"):
            return False
        dc = None
        if aoe.get("dc") is not None:
            try:
                dc = int(aoe.get("dc"))
            except Exception:
                dc = None
        if dc is None:
            raw_dc = check.get("dc")
            if isinstance(raw_dc, (int, float)):
                dc = int(raw_dc)
            elif isinstance(raw_dc, str):
                raw_dc_str = raw_dc.strip().lower()
                if raw_dc_str.isdigit():
                    dc = int(raw_dc_str)
                elif raw_dc_str == "spell_save_dc" and caster is not None:
                    player_name = self._pc_name_for(int(caster.cid)) if hasattr(self, "_pc_name_for") else str(caster.name)
                    profile = self._profile_for_player_name(player_name) if hasattr(self, "_profile_for_player_name") else {}
                    if isinstance(profile, dict):
                        spellcasting = profile.get("spellcasting") if isinstance(profile.get("spellcasting"), dict) else {}
                        explicit = spellcasting.get("save_dc")
                        try:
                            dc = int(explicit)
                        except Exception:
                            dc = self._compute_spell_save_dc(profile)
        if requires_save and (dc is None or dc <= 0):
            return False
        outcomes = step.get("outcomes") if isinstance(step.get("outcomes"), dict) else {}
        included = list(included_override) if isinstance(included_override, list) else self._lan_compute_included_units_for_aoe(aoe)
        if not included:
            if remove_on_empty and aoe.get("pinned") is not True and not aoe.get("persistent") and not aoe.get("over_time"):
                self._lan_remove_aoe_by_id(aid)
            return True
        spell_name = str(preset.get("name") or aoe.get("name") or "AoE")

        def _roll_dice(expr: Any) -> Optional[int]:
            if not isinstance(expr, str):
                return None
            raw = expr.strip().lower()
            if not raw or not re.fullmatch(r"[0-9d+\-*/(). _]+", raw):
                return None
            try:
                def _replace_die(match: re.Match[str]) -> str:
                    count = int(match.group(1) or 1)
                    sides = int(match.group(2))
                    if count <= 0 or sides <= 0:
                        raise ValueError("invalid dice")
                    return str(sum(random.randint(1, sides) for _ in range(count)))
                expr_eval = re.sub(r"(\d*)d(\d+)", _replace_die, raw)
            except Exception:
                return None
            total = self._evaluate_spell_formula(expr_eval, {})
            if total is None:
                return None
            return max(0, int(math.floor(total)))

        manual_damage_map: Dict[str, int] = {}
        if isinstance(manual_damage_entries, list):
            for entry in manual_damage_entries:
                if not isinstance(entry, dict):
                    continue
                try:
                    amount = int(entry.get("amount"))
                except Exception:
                    continue
                if amount <= 0:
                    continue
                raw_type = str(entry.get("type") or "").strip().lower()
                if not raw_type:
                    continue
                canonical = self._canonical_damage_type(raw_type)
                key = canonical or raw_type
                if not key:
                    continue
                manual_damage_map[key] = max(manual_damage_map.get(key, 0), int(amount))

        def _scaled_damage(effect: Dict[str, Any]) -> int:
            base_expr = effect.get("dice")
            base_amount = _roll_dice(base_expr)
            if base_amount is None:
                return 0
            total = int(base_amount)
            scaling = effect.get("scaling") if isinstance(effect.get("scaling"), dict) else mechanics.get("scaling") if isinstance(mechanics.get("scaling"), dict) else None
            if isinstance(scaling, dict) and scaling.get("kind") == "slot_level" and slot_level is not None:
                try:
                    base_slot = int(scaling.get("base_slot"))
                except Exception:
                    base_slot = None
                add_expr = scaling.get("add_per_slot_above")
                if base_slot is not None and isinstance(add_expr, str) and slot_level > base_slot:
                    for _ in range(int(slot_level - base_slot)):
                        extra = _roll_dice(add_expr)
                        if extra is not None:
                            total += int(extra)
            mult = effect.get("multiplier")
            try:
                if mult is not None:
                    total = int(math.floor(float(total) * float(mult)))
            except Exception:
                pass
            return max(0, int(total))

        def _adjustment_note(notes: List[Dict[str, Any]]) -> str:
            chunks: List[str] = []
            for note in notes if isinstance(notes, list) else []:
                if not isinstance(note, dict):
                    continue
                reasons = [str(reason) for reason in (note.get("reasons") or []) if str(reason).strip()]
                if not reasons:
                    continue
                original = int(note.get("original") or 0)
                applied = int(note.get("applied") or 0)
                if original == applied:
                    continue
                dtype = str(note.get("canonical_type") or note.get("type") or "untyped").strip() or "untyped"
                chunks.append(f"{'+'.join(reasons)}: {original} {dtype}->{applied}")
            return f" ({'; '.join(chunks)})" if chunks else ""

        def _damage_type_label(entries: List[Dict[str, Any]]) -> str:
            labels: List[str] = []
            seen: set[str] = set()
            for entry in entries if isinstance(entries, list) else []:
                if not isinstance(entry, dict):
                    continue
                raw_type = str(entry.get("type") or "").strip().lower()
                canonical = self._canonical_damage_type(raw_type)
                dtype = canonical or raw_type
                if not dtype or dtype in seen:
                    continue
                seen.add(dtype)
                labels.append(dtype.title())
            if not labels:
                return ""
            return f" {'+'.join(labels)}"

        removed: List[int] = []
        for target_cid in included:
            target = self.combatants.get(int(target_cid))
            if target is None:
                continue
            saves = getattr(target, "saving_throws", None)
            mods = getattr(target, "ability_mods", None)
            if requires_save:
                if isinstance(saves, dict) and saves.get(ability) is not None:
                    save_mod = int(saves.get(ability) or 0)
                elif isinstance(mods, dict) and mods.get(ability) is not None:
                    save_mod = int(mods.get(ability) or 0)
                else:
                    save_mod = 0
                roll = int(random.randint(1, 20))
                total = int(roll + save_mod)
                passed = bool(roll != 1 and total >= int(dc))
            else:
                save_mod = 0
                roll = None
                total = 0
                passed = False
            outcome_key = "success" if passed else "fail"
            bucket = outcomes.get(outcome_key)
            if not isinstance(bucket, list):
                fallback_keys = ("pass", "saved", "save") if passed else tuple(FAIL_OUTCOME_LABELS)
                bucket = []
                for key in fallback_keys:
                    probe = outcomes.get(key)
                    if isinstance(probe, list):
                        bucket = probe
                        break
            damage_entries: List[Dict[str, Any]] = []
            blocked_conditions: List[str] = []
            applied_conditions: List[str] = []
            forced_moves: List[Dict[str, Any]] = []
            for effect in bucket if isinstance(bucket, list) else []:
                if not isinstance(effect, dict):
                    continue
                effect_name = str(effect.get("effect") or "").strip().lower()
                if effect_name == "damage":
                    dtype = str(effect.get("damage_type") or effect.get("type") or aoe.get("damage_type") or "").strip().lower() or "untyped"
                    canonical_dtype = self._canonical_damage_type(dtype)
                    amount = None
                    if manual_damage_map:
                        lookup_keys = [key for key in [canonical_dtype, dtype] if key]
                        for key in lookup_keys:
                            if key in manual_damage_map:
                                amount = int(manual_damage_map.get(key) or 0)
                                break
                    if amount is None:
                        amount = _scaled_damage(effect)
                    else:
                        mult = effect.get("multiplier")
                        try:
                            if mult is not None:
                                amount = int(math.floor(float(amount) * float(mult)))
                        except Exception:
                            pass
                    if amount > 0:
                        damage_entries.append({"amount": int(amount), "type": dtype})
                elif effect_name == "condition" and not passed:
                    condition_key = str(effect.get("condition") or "").strip().lower()
                    if not condition_key:
                        continue
                    duration_turns = effect.get("duration_turns")
                    remaining_turns = None
                    if duration_turns not in (None, ""):
                        try:
                            parsed = int(duration_turns)
                            remaining_turns = None if parsed <= 0 else parsed
                        except Exception:
                            remaining_turns = None
                    if self._condition_is_immune_for_target(target, condition_key):
                        blocked_conditions.append(condition_key)
                        continue
                    stacks = getattr(target, "condition_stacks", None)
                    if not isinstance(stacks, list):
                        stacks = []
                        target.condition_stacks = stacks
                    target.condition_stacks = [st for st in stacks if getattr(st, "ctype", None) != condition_key]
                    next_sid = int(getattr(self, "_next_stack_id", 1) or 1)
                    self._next_stack_id = next_sid + 1
                    target.condition_stacks.append(base.ConditionStack(sid=next_sid, ctype=condition_key, remaining_turns=remaining_turns))
                    applied_conditions.append(condition_key)
                elif effect_name in ("forced_movement", "movement"):
                    mode = str(effect.get("kind") or effect.get("mode") or effect.get("direction") or "").strip().lower()
                    if mode not in ("push", "pull"):
                        continue
                    try:
                        distance_ft = float(effect.get("distance_ft"))
                    except Exception:
                        distance_ft = 10.0
                    if distance_ft <= 0:
                        continue
                    origin = str(effect.get("origin") or "caster").strip().lower()
                    forced_moves.append({
                        "mode": mode,
                        "distance_ft": float(distance_ft),
                        "origin": origin,
                        "angle_deg": effect.get("angle_deg"),
                        "direction": effect.get("direction"),
                    })

            target_monk_level = 0
            if bool(getattr(target, "is_pc", False)):
                try:
                    target_player_name = self._pc_name_for(int(getattr(target, "cid", 0) or 0))
                    target_profile = self._profile_for_player_name(target_player_name)
                    if isinstance(target_profile, dict):
                        target_monk_level = self._class_level_from_profile(target_profile, "monk")
                except Exception:
                    target_monk_level = 0
            has_evasion = bool(
                requires_save
                and int(target_monk_level) >= 7
                and ability == "dex"
                and not self._has_condition(target, "incapacitated")
            )
            if has_evasion and damage_entries:
                if passed:
                    damage_entries = []
                else:
                    for entry in damage_entries:
                        if not isinstance(entry, dict):
                            continue
                        try:
                            entry["amount"] = int(math.floor(max(0, int(entry.get("amount") or 0)) * 0.5))
                        except Exception:
                            continue

            adjustment = self._adjust_damage_entries_for_target(target, damage_entries) if damage_entries else {"entries": [], "notes": []}
            adjusted_entries = list((adjustment or {}).get("entries") or [])
            adjustment_note = _adjustment_note(list((adjustment or {}).get("notes") or []))
            damage_type_label = _damage_type_label(damage_entries)
            total_damage = sum(int(entry.get("amount") or 0) for entry in adjusted_entries if isinstance(entry, dict))
            before = int(getattr(target, "hp", 0) or 0)
            if total_damage > 0:
                target.hp = max(0, before - int(total_damage))
                self._queue_concentration_save(target, "aoe")
            forced_move_notes: List[str] = []
            if forced_moves:
                for forced in forced_moves:
                    origin = str(forced.get("origin") or "caster").strip().lower()
                    source_cid = int(caster.cid) if caster is not None else None
                    source_cell = None
                    direction_step = None
                    if origin == "aoe_center":
                        source_cell = (int(round(float(aoe.get("cx", 0.0)))), int(round(float(aoe.get("cy", 0.0)))))
                        source_cid = None
                    elif origin == "aoe_direction":
                        angle = forced.get("angle_deg")
                        if angle is None:
                            angle = aoe.get("angle_deg")
                        if angle is None and caster is not None:
                            angle = getattr(caster, "facing_deg", 0)
                        direction_step = self._lan_direction_step_from_angle(angle)
                    elif origin == "caster" and source_cid is None:
                        source_cell = (int(round(float(aoe.get("cx", 0.0)))), int(round(float(aoe.get("cy", 0.0)))))
                    moved = self._lan_apply_forced_movement(
                        source_cid,
                        int(target_cid),
                        str(forced.get("mode") or "push"),
                        float(forced.get("distance_ft") or 10.0),
                        source_cell=source_cell,
                        direction_step=direction_step,
                    )
                    if moved:
                        forced_move_notes.append(str(forced.get("mode") or "push"))
            after = int(getattr(target, "hp", 0) or 0)
            if requires_save:
                status = "PASS" if passed else "FAIL"
                self._log(
                    f"{spell_name}: {target.name} save {ability.upper()} {status} ({total} vs DC {dc}) -> {total_damage}{damage_type_label} damage{adjustment_note}"
                )
            else:
                self._log(
                    f"{spell_name}: {target.name} auto -> {total_damage}{damage_type_label} damage{adjustment_note}"
                )
            if forced_move_notes:
                self._log(
                    f"{spell_name}: moved {target.name} ({', '.join(forced_move_notes)})",
                    cid=int(target_cid),
                )
            for cond in applied_conditions:
                self._log(f"set condition: {cond}", cid=int(target_cid))
            for cond in blocked_conditions:
                self._log(f"Condition blocked for {target.name} — immune to {cond}.", cid=int(target_cid))
            if before > 0 and after == 0:
                removed.append(int(target_cid))

        if removed:
            pre_order = [x.cid for x in self._display_order()] if hasattr(self, "_display_order") else []
            if hasattr(self, "_remove_combatants_with_lan_cleanup"):
                self._remove_combatants_with_lan_cleanup(removed)
            else:
                for dead_cid in removed:
                    self.combatants.pop(int(dead_cid), None)
            if hasattr(self, "_retarget_current_after_removal"):
                self._retarget_current_after_removal(removed, pre_order=pre_order)
        self._rebuild_table(scroll_to_current=True)
        self._lan_force_state_broadcast()
        if remove_after_resolve and aoe.get("pinned") is not True and not aoe.get("persistent") and not aoe.get("over_time"):
            self._lan_remove_aoe_by_id(aid)
        return True

    def _lan_remove_aoe_by_id(self, aid: int) -> None:
        mw = getattr(self, "_map_window", None)
        map_ready = mw is not None and mw.winfo_exists()
        if map_ready:
            try:
                if hasattr(mw, "_remove_aoe_by_id"):
                    mw._remove_aoe_by_id(int(aid))
                elif hasattr(mw, "aoes") and isinstance(mw.aoes, dict):
                    mw.aoes.pop(int(aid), None)
                if hasattr(mw, "_refresh_aoe_list"):
                    mw._refresh_aoe_list()
                self._lan_aoes = dict(getattr(mw, "aoes", {}) or {})
            except Exception:
                pass
        else:
            store = dict(getattr(self, "_lan_aoes", {}) or {})
            store.pop(int(aid), None)
            self._lan_aoes = store

    def _spell_presets_payload(self) -> List[Dict[str, Any]]:
        if yaml is None:
            return []
        spells_dir = self._resolve_spells_dir()
        if spells_dir is None:
            return []

        try:
            files = sorted(list(spells_dir.glob("*.yaml")) + list(spells_dir.glob("*.yml")))
        except Exception:
            files = []
        dir_signature = _directory_signature(spells_dir, files)

        ops = _make_ops_logger()
        if not files:
            self._spell_presets_cache = []
            self._spell_index_entries = {}
            self._spell_index_loaded = True
            self._spell_dir_signature = dir_signature
            _write_index_file(self._spell_index_path(), {"version": 1, "entries": {}})
            return []

        if self._spell_presets_cache is not None and dir_signature == self._spell_dir_signature:
            return list(self._spell_presets_cache)

        cached_entries = self._load_spell_index_entries()
        cache_keys = set(cached_entries.keys()) if isinstance(cached_entries, dict) else set()
        file_keys = {fp.name for fp in files}
        cache_names_match = cache_keys == file_keys

        def cache_is_valid(entries: Dict[str, Any]) -> bool:
            if not cache_names_match:
                return False
            for fp in files:
                meta = _file_stat_metadata(fp)
                entry = entries.get(fp.name) if isinstance(entries, dict) else None
                if not isinstance(entry, dict):
                    return False
                if not _metadata_matches(entry, meta):
                    return False
                if not isinstance(entry.get("preset"), dict):
                    return False
            return True

        if self._spell_presets_cache is not None and cache_is_valid(cached_entries):
            return list(self._spell_presets_cache)

        presets: List[Dict[str, Any]] = []
        ability_map = {
            "strength": "str",
            "str": "str",
            "dexterity": "dex",
            "dex": "dex",
            "constitution": "con",
            "con": "con",
            "intelligence": "int",
            "int": "int",
            "wisdom": "wis",
            "wis": "wis",
            "charisma": "cha",
            "cha": "cha",
        }

        def parse_number(value: Any) -> Optional[float]:
            if value in (None, ""):
                return None
            try:
                num = float(value)
            except Exception:
                return None
            if not (num == num and abs(num) != float("inf")):
                return None
            return num

        def parse_dice(value: Any) -> Optional[str]:
            if value in (None, ""):
                return None
            raw = str(value).strip().lower()
            match = re.fullmatch(r"(\\d+)d(4|6|8|10|12)", raw)
            if not match:
                return None
            count = int(match.group(1))
            if count <= 0:
                return None
            return f"{count}d{match.group(2)}"

        def normalize_color(value: Any) -> Optional[str]:
            if not isinstance(value, str):
                return None
            raw = value.strip().lower()
            if re.fullmatch(r"#[0-9a-f]{6}", raw):
                return raw
            return None

        def normalize_save_type(value: Any) -> Optional[str]:
            if value in (None, ""):
                return None
            raw = str(value).strip().lower()
            return ability_map.get(raw, raw)

        def normalize_summon_config(parsed_spell: Dict[str, Any], mechanics_block: Dict[str, Any]) -> Optional[Dict[str, Any]]:
            summon_data = mechanics_block.get("summon") if isinstance(mechanics_block.get("summon"), dict) else None
            if summon_data is None:
                automation_block = parsed_spell.get("automation")
                if isinstance(automation_block, dict) and isinstance(automation_block.get("summon"), dict):
                    summon_data = automation_block.get("summon")
            if not isinstance(summon_data, dict):
                return None
            return copy.deepcopy(summon_data)

        def parse_spell_file(fp: Path) -> Optional[Tuple[Dict[str, Any], str]]:
            try:
                raw = fp.read_text(encoding="utf-8")
            except Exception as exc:
                ops.warning("Failed reading spell YAML %s: %s", fp.name, exc)
                return None
            try:
                parsed = yaml.safe_load(raw)
            except Exception as exc:
                ops.warning("Failed parsing spell YAML %s: %s", fp.name, exc)
                return None
            if not isinstance(parsed, dict):
                ops.warning("Spell YAML %s did not parse to a dict.", fp.name)
                return None

            name = str(parsed.get("name") or "").strip()
            if not name:
                ops.warning("Spell YAML %s missing name; skipping preset.", fp.name)
                return None

            schema = parsed.get("schema")
            spell_id = parsed.get("id")
            level = parsed.get("level")
            school = parsed.get("school")
            tags_raw = parsed.get("tags")
            tags = [str(tag).strip() for tag in tags_raw if str(tag).strip()] if isinstance(tags_raw, list) else []
            casting_time = parsed.get("casting_time")
            spell_range = parsed.get("range")
            ritual = parsed.get("ritual")
            concentration = parsed.get("concentration")
            color = normalize_color(parsed.get("color"))
            import_data = parsed.get("import") if isinstance(parsed.get("import"), dict) else {}
            url = import_data.get("url")
            import_raw = import_data.get("raw") if isinstance(import_data.get("raw"), dict) else {}
            import_description = import_raw.get("description")
            if import_description in (None, ""):
                text_block = parsed.get("text") if isinstance(parsed.get("text"), dict) else {}
                import_description = text_block.get("rules")
            lists = parsed.get("lists") if isinstance(parsed.get("lists"), dict) else {}
            mechanics = parsed.get("mechanics") if isinstance(parsed.get("mechanics"), dict) else {}
            ui_block = mechanics.get("ui") if isinstance(mechanics.get("ui"), dict) else {}
            summon_config = normalize_summon_config(parsed, mechanics)
            if summon_config is not None and "summon" not in mechanics:
                mechanics = dict(mechanics)
                mechanics["summon"] = copy.deepcopy(summon_config)
            automation_raw = str(mechanics.get("automation") or "").strip().lower()
            automation = automation_raw if automation_raw in ("full", "partial", "manual") else "manual"
            errors: List[str] = []
            warnings: List[str] = []
            if not schema:
                errors.append("missing schema")
            if not spell_id:
                errors.append("missing id")
            if level is None:
                errors.append("missing level")
            if not school:
                errors.append("missing school")
            if errors:
                ops.warning("Spell YAML %s has issues: %s", fp.name, ", ".join(errors))

            preset: Dict[str, Any] = {
                "slug": fp.stem,
                "schema": schema,
                "id": spell_id,
                "name": name,
                "level": level,
                "school": school,
                "tags": tags,
                "casting_time": self._normalize_casting_time(casting_time),
                "range": str(spell_range).strip() if spell_range not in (None, "") else None,
                "ritual": ritual if isinstance(ritual, bool) else None,
                "concentration": concentration if isinstance(concentration, bool) else None,
                "lists": lists,
                "mechanics": mechanics,
                "automation": automation,
            }
            if summon_config is not None:
                preset["summon"] = summon_config
            appearance_options = ui_block.get("appearance_options")
            if isinstance(appearance_options, list):
                cleaned_options = [
                    str(option).strip()
                    for option in appearance_options
                    if str(option).strip()
                ]
                if cleaned_options:
                    preset["appearance_options"] = cleaned_options
            if color:
                preset["color"] = color
            if isinstance(url, str) and url.strip():
                preset["url"] = url.strip()
            if isinstance(import_description, str) and import_description.strip():
                preset["description"] = import_description.strip()

            targeting = mechanics.get("targeting") if isinstance(mechanics.get("targeting"), dict) else {}
            range_data = targeting.get("range") if isinstance(targeting.get("range"), dict) else {}
            range_kind = str(range_data.get("kind") or "").strip().lower() if isinstance(range_data, dict) else ""
            if range_kind == "distance" and range_data.get("distance_ft") in (None, ""):
                range_from_text: Optional[float] = None
                if spell_range not in (None, ""):
                    range_match = re.search(r"(\d+(?:\.\d+)?)\s*(?:ft|feet)", str(spell_range), flags=re.IGNORECASE)
                    if range_match:
                        try:
                            parsed_range = float(range_match.group(1))
                        except Exception:
                            parsed_range = None
                        if parsed_range is not None and math.isfinite(parsed_range) and parsed_range >= 0:
                            range_from_text = parsed_range
                if range_from_text is not None:
                    mechanics = copy.deepcopy(mechanics)
                    targeting = mechanics.get("targeting") if isinstance(mechanics.get("targeting"), dict) else {}
                    targeting = copy.deepcopy(targeting)
                    range_data = targeting.get("range") if isinstance(targeting.get("range"), dict) else {}
                    range_data = copy.deepcopy(range_data)
                    range_data["distance_ft"] = range_from_text
                    targeting["range"] = range_data
                    mechanics["targeting"] = targeting
                    preset["mechanics"] = mechanics
            area = targeting.get("area") if isinstance(targeting.get("area"), dict) else {}
            shape_raw = str(area.get("shape") or "").strip().lower()
            shape_map = {
                "circle": "sphere",
                "square": "cube",
            }
            shape = shape_map.get(shape_raw, shape_raw)
            has_area = bool(shape)
            has_aoe_tag = any(str(tag).strip().lower() == "aoe" for tag in tags)
            valid_aoe_shapes = ("sphere", "cube", "cone", "cylinder", "wall", "line")
            aoe_dimensions_present = False
            if shape in valid_aoe_shapes:
                if shape == "sphere":
                    aoe_dimensions_present = parse_number(area.get("radius_ft")) is not None
                elif shape == "cube":
                    aoe_dimensions_present = parse_number(area.get("side_ft")) is not None
                elif shape == "cylinder":
                    aoe_dimensions_present = (
                        parse_number(area.get("radius_ft")) is not None
                        and parse_number(area.get("height_ft")) is not None
                    )
                elif shape == "line":
                    aoe_dimensions_present = (
                        parse_number(area.get("length_ft")) is not None
                        and parse_number(area.get("width_ft")) is not None
                    )
                elif shape == "cone":
                    aoe_dimensions_present = parse_number(area.get("length_ft")) is not None
                elif shape == "wall":
                    aoe_dimensions_present = (
                        parse_number(area.get("length_ft")) is not None
                        and parse_number(area.get("width_ft")) is not None
                        and parse_number(area.get("height_ft")) is not None
                    )
            missing_required_fields = False
            if automation in ("full", "partial"):
                if str(range_data.get("kind") or "").strip().lower() == "distance":
                    distance_ft = parse_number(range_data.get("distance_ft"))
                    if distance_ft is None and not aoe_dimensions_present:
                        warnings.append("missing targeting.range.distance_ft")
                        missing_required_fields = True
                if shape and shape not in valid_aoe_shapes:
                    warnings.append(f"unsupported area shape '{shape_raw or shape}'")
                    missing_required_fields = True
            preset["is_aoe"] = False
            if shape in valid_aoe_shapes:
                preset["shape"] = shape
                preset["is_aoe"] = True
                missing_dimensions: List[str] = []
                if shape == "sphere":
                    radius_ft = parse_number(area.get("radius_ft"))
                    if radius_ft is not None:
                        preset["radius_ft"] = radius_ft
                    else:
                        missing_dimensions.append("radius_ft")
                if shape == "cube":
                    side_ft = parse_number(area.get("side_ft"))
                    if side_ft is not None:
                        preset["side_ft"] = side_ft
                    else:
                        missing_dimensions.append("side_ft")
                if shape == "cylinder":
                    radius_ft = parse_number(area.get("radius_ft"))
                    if radius_ft is not None:
                        preset["radius_ft"] = radius_ft
                    else:
                        missing_dimensions.append("radius_ft")
                    height_ft = parse_number(area.get("height_ft"))
                    if height_ft is not None:
                        preset["height_ft"] = height_ft
                    else:
                        missing_dimensions.append("height_ft")
                if shape == "line":
                    length_ft = parse_number(area.get("length_ft"))
                    width_ft = parse_number(area.get("width_ft"))
                    if length_ft is not None:
                        preset["length_ft"] = length_ft
                    else:
                        missing_dimensions.append("length_ft")
                    if width_ft is not None:
                        preset["width_ft"] = width_ft
                    else:
                        missing_dimensions.append("width_ft")
                    angle_deg = parse_number(area.get("angle_deg"))
                    if angle_deg is not None:
                        preset["angle_deg"] = angle_deg
                if shape == "cone":
                    length_ft = parse_number(area.get("length_ft"))
                    if length_ft is not None:
                        preset["length_ft"] = length_ft
                    else:
                        missing_dimensions.append("length_ft")
                    angle_deg = parse_number(area.get("angle_deg"))
                    if angle_deg is not None:
                        preset["angle_deg"] = angle_deg
                if shape == "wall":
                    length_ft = parse_number(area.get("length_ft"))
                    width_ft = parse_number(area.get("width_ft"))
                    height_ft = parse_number(area.get("height_ft"))
                    if length_ft is not None:
                        preset["length_ft"] = length_ft
                    else:
                        missing_dimensions.append("length_ft")
                    if width_ft is not None:
                        preset["width_ft"] = width_ft
                    else:
                        missing_dimensions.append("width_ft")
                    if height_ft is not None:
                        preset["height_ft"] = height_ft
                    else:
                        missing_dimensions.append("height_ft")
                    angle_deg = parse_number(area.get("angle_deg"))
                    if angle_deg is not None:
                        preset["angle_deg"] = angle_deg
                if missing_dimensions:
                    preset["incomplete"] = True
                    preset["incomplete_fields"] = missing_dimensions
                    if automation in ("full", "partial"):
                        warnings.append("missing area dimensions: " + ", ".join(missing_dimensions))
                        missing_required_fields = True
            elif has_aoe_tag:
                preset["is_aoe"] = True

            casting_time = str(preset.get("casting_time") or "").strip().lower()
            if "bonus" in casting_time and "action" in casting_time:
                preset["action_type"] = "bonus_action"
            elif "reaction" in casting_time:
                preset["action_type"] = "reaction"
            else:
                preset["action_type"] = "action"

            damage_types: List[str] = []
            dice: Optional[str] = None
            effect_scaling: Optional[Dict[str, Any]] = None
            save_type: Optional[str] = None
            save_dc: Optional[int] = None
            half_on_pass: Optional[bool] = None
            condition_key: Optional[str] = None
            condition_turns: Optional[int] = None

            sequence = mechanics.get("sequence") if isinstance(mechanics.get("sequence"), list) else []
            for step in sequence:
                if not isinstance(step, dict):
                    continue
                check = step.get("check") if isinstance(step.get("check"), dict) else {}
                if save_type is None and check.get("kind") == "saving_throw":
                    save_type = normalize_save_type(check.get("ability"))
                    dc_value = check.get("dc")
                    if isinstance(dc_value, (int, float)):
                        save_dc = int(dc_value)
                    elif isinstance(dc_value, str) and dc_value.strip().isdigit():
                        save_dc = int(dc_value.strip())
                outcomes = step.get("outcomes") if isinstance(step.get("outcomes"), dict) else {}
                for outcome_key, outcome_list in outcomes.items():
                    if not isinstance(outcome_list, list):
                        continue
                    outcome_label = str(outcome_key or "").strip().lower()
                    is_fail_outcome = outcome_label in FAIL_OUTCOME_LABELS
                    for effect in outcome_list:
                        if not isinstance(effect, dict):
                            continue
                        if effect.get("effect") == "condition":
                            if is_fail_outcome and condition_key is None:
                                raw_condition = effect.get("condition")
                                if raw_condition not in (None, ""):
                                    condition_key = str(raw_condition).strip().lower()
                                raw_turns = effect.get("duration_turns")
                                if raw_turns not in (None, ""):
                                    if isinstance(raw_turns, int):
                                        parsed_turns = raw_turns
                                    else:
                                        try:
                                            parsed_turns = int(str(raw_turns).strip())
                                        except ValueError:
                                            parsed_turns = None
                                    if parsed_turns is not None:
                                        if parsed_turns < 0:
                                            condition_name = condition_key or "condition"
                                            warnings.append(
                                                f"negative condition duration for {name} ({condition_name}); using 0"
                                            )
                                            parsed_turns = 0
                                        condition_turns = parsed_turns
                            continue
                        if effect.get("effect") != "damage":
                            continue
                        dtype = str(effect.get("damage_type") or "").strip()
                        if dtype and dtype not in damage_types:
                            damage_types.append(dtype)
                        if dice is None:
                            dice = parse_dice(effect.get("dice"))
                        if effect_scaling is None and isinstance(effect.get("scaling"), dict):
                            effect_scaling = effect.get("scaling")
                        if half_on_pass is None:
                            multiplier = parse_number(effect.get("multiplier"))
                            if multiplier is not None and abs(multiplier - 0.5) < 1e-9:
                                outcome_label = str(outcome_key or "").strip().lower()
                                if outcome_label in ("success", "pass", "save", "saved", "succeed"):
                                    half_on_pass = True

            scaling = mechanics.get("scaling") if isinstance(mechanics.get("scaling"), dict) else None
            if scaling is None:
                scaling = effect_scaling
            if isinstance(scaling, dict):
                preset["scaling"] = copy.deepcopy(scaling)

            if save_type:
                preset["save_type"] = save_type
            if save_dc is not None:
                preset["save_dc"] = save_dc
            if dice:
                preset["dice"] = dice
            if damage_types:
                preset["damage_types"] = damage_types
            if half_on_pass:
                preset["half_on_pass"] = True
            if condition_key:
                preset["condition_on_fail"] = True
                preset["condition_key"] = condition_key
                if condition_turns is not None:
                    preset["condition_turns"] = condition_turns

            upcast: Optional[Dict[str, Any]] = None
            if isinstance(scaling, dict) and scaling.get("kind") == "slot_level":
                base_slot = scaling.get("base_slot")
                add_per_slot = scaling.get("add_per_slot_above")
                base_level = int(base_slot) if isinstance(base_slot, int) else None
                add_dice = parse_dice(add_per_slot)
                if base_level is None and isinstance(base_slot, str) and base_slot.strip().isdigit():
                    base_level = int(base_slot.strip())
                if base_level is not None and add_dice:
                    upcast = {
                        "base_level": base_level,
                        "add_per_slot_above": add_dice,
                    }
            if isinstance(scaling, dict) and scaling.get("kind") == "character_level":
                thresholds = scaling.get("thresholds") if isinstance(scaling.get("thresholds"), dict) else {}
                increments: List[Dict[str, Any]] = []
                for threshold, data in thresholds.items():
                    if not isinstance(data, dict):
                        continue
                    try:
                        level = int(str(threshold).strip())
                    except ValueError:
                        continue
                    add_dice = parse_dice(data.get("add"))
                    if add_dice:
                        increments.append({"level": level, "add_dice": add_dice})
                if increments:
                    increments.sort(key=lambda entry: entry.get("level", 0))
                    upcast = {
                        "base_level": 1,
                        "increments": increments,
                    }
            if upcast:
                preset["upcast"] = upcast

            if not preset.get("shape") and has_aoe_tag and not has_area:
                warnings.append("tagged aoe but missing targeting area")
            if automation == "full":
                if has_aoe_tag and "shape" not in preset:
                    automation = "partial"
                if not dice and not damage_types and not save_type:
                    automation = "partial"
            if not mechanics:
                automation = "manual"
            if missing_required_fields and automation == "full":
                automation = "partial"
            if errors and automation == "full":
                automation = "partial"
            preset["automation"] = automation
            if warnings:
                ops.warning("Spell YAML %s has automation warnings: %s", fp.name, ", ".join(warnings))

            return preset, raw

        new_entries: Dict[str, Any] = {}
        used_cached_only = True
        for fp in files:
            meta = _file_stat_metadata(fp)
            entry = cached_entries.get(fp.name) if isinstance(cached_entries, dict) else None
            if isinstance(entry, dict) and _metadata_matches(entry, meta):
                preset = entry.get("preset")
                if isinstance(preset, dict):
                    if "slug" not in preset:
                        preset = dict(preset)
                        preset["slug"] = fp.stem
                        entry["preset"] = preset
                    presets.append(preset)
                    new_entry = dict(entry)
                    new_entry["mtime_ns"] = meta.get("mtime_ns")
                    new_entry["size"] = meta.get("size")
                    new_entries[fp.name] = new_entry
                    continue
            used_cached_only = False
            parsed = parse_spell_file(fp)
            if parsed is None:
                continue
            preset, raw = parsed
            presets.append(preset)
            new_entries[fp.name] = {
                "mtime_ns": meta.get("mtime_ns"),
                "size": meta.get("size"),
                "hash": _hash_text(raw),
                "preset": preset,
            }

        self._spell_presets_cache = presets
        self._spell_index_entries = new_entries
        self._spell_index_loaded = True
        self._spell_dir_signature = dir_signature
        if not used_cached_only or not cache_names_match:
            _write_index_file(self._spell_index_path(), {"version": 1, "entries": new_entries})

        return presets

    def _players_dir(self) -> Path:
        _seed_user_players_dir()
        return _app_data_dir() / "players"

    def _write_player_yaml_atomic(self, path: Path, payload: Dict[str, Any]) -> None:
        if yaml is None:
            raise RuntimeError("PyYAML is required for spell persistence.")
        normalized_payload = dict(payload or {})
        # Legacy marker was useful during migration but clutters player YAML.
        # Keep read compatibility, but stop persisting it for new writes.
        normalized_payload.pop("format_version", None)
        yaml_text = yaml.safe_dump(normalized_payload, sort_keys=False, allow_unicode=True)
        tmp_path = path.with_suffix(path.suffix + ".tmp")
        with self._player_yaml_lock:
            path.parent.mkdir(parents=True, exist_ok=True)
            tmp_path.write_text(yaml_text, encoding="utf-8")
            tmp_path.replace(path)

    @staticmethod
    def _normalize_character_lookup_key(value: Any) -> str:
        return str(value or "").strip().casefold()

    @staticmethod
    def _strip_combat_name_suffix(value: Any) -> str:
        text = str(value or "").strip()
        if not text:
            return ""
        without_form = re.sub(r"\s*\([^)]*\)\s*$", "", text).strip()
        without_dupe = re.sub(r"\s+\d+$", "", without_form).strip()
        return without_dupe or text

    def _find_player_profile_path(self, player_name: Any) -> Optional[Path]:
        lookup = self._normalize_character_lookup_key(player_name)
        if not lookup:
            return None
        lookup_slug = self._character_slugify(str(player_name or ""))
        path = self._player_yaml_name_map.get(lookup)
        if isinstance(path, Path):
            return path
        # Fallback: case-insensitive lookup from canonical profile names.
        for known_name, known_path in self._player_yaml_name_map.items():
            known_lookup = self._normalize_character_lookup_key(known_name)
            if known_lookup == lookup:
                return known_path
            if lookup_slug and self._character_slugify(known_lookup) == lookup_slug:
                return known_path
        # Duplicate combatants can get suffixes like "Name 2".
        base_lookup = re.sub(r"\s+\d+$", "", lookup).strip()
        base_lookup_slug = self._character_slugify(base_lookup)
        if base_lookup:
            for known_name, known_path in self._player_yaml_name_map.items():
                known_lookup = self._normalize_character_lookup_key(known_name)
                if known_lookup == base_lookup:
                    return known_path
                if base_lookup_slug and self._character_slugify(known_lookup) == base_lookup_slug:
                    return known_path
        stripped = self._strip_combat_name_suffix(player_name)
        stripped_lookup = self._normalize_character_lookup_key(stripped)
        stripped_slug = self._character_slugify(stripped_lookup)
        if stripped_lookup and stripped_lookup != lookup:
            direct = self._player_yaml_name_map.get(stripped_lookup)
            if isinstance(direct, Path):
                return direct
            for known_name, known_path in self._player_yaml_name_map.items():
                known_lookup = self._normalize_character_lookup_key(known_name)
                if known_lookup == stripped_lookup:
                    return known_path
                if stripped_slug and self._character_slugify(known_lookup) == stripped_slug:
                    return known_path
        return None

    @staticmethod
    def _wild_shape_identifier_key(value: Any) -> str:
        raw = str(value or "").strip().lower()
        if not raw:
            return ""
        raw = raw.replace("_", "-")
        raw = re.sub(r"\s+", "-", raw)
        raw = re.sub(r"[^a-z0-9-]", "", raw)
        raw = re.sub(r"-+", "-", raw).strip("-")
        return raw

    def _wild_shape_alias_lookup(self, forms: List[Dict[str, Any]]) -> Dict[str, str]:
        aliases: Dict[str, str] = {}
        for entry in forms:
            if not isinstance(entry, dict):
                continue
            form_id = self._wild_shape_identifier_key(entry.get("id"))
            if not form_id:
                continue
            aliases.setdefault(form_id, form_id)
            aliases.setdefault(self._wild_shape_identifier_key(str(entry.get("id") or "").replace("-", " ")), form_id)
            aliases.setdefault(self._wild_shape_identifier_key(entry.get("name")), form_id)
        return aliases

    def _profile_for_player_name(self, player_name: Any) -> Optional[Dict[str, Any]]:
        self._load_player_yaml_cache()
        lookup_name = str(player_name or "").strip()
        if not lookup_name:
            return None
        profile = self._player_yaml_data_by_name.get(lookup_name)
        if isinstance(profile, dict):
            return profile
        player_path = self._find_player_profile_path(lookup_name)
        raw_profile = self._player_yaml_cache_by_path.get(player_path) if isinstance(player_path, Path) else None
        if isinstance(raw_profile, dict):
            return raw_profile
        return None

    @staticmethod
    def _default_spell_slots_for_level(level: int, progression: str) -> Dict[str, Dict[str, int]]:
        full = {
            1: [2], 2: [3], 3: [4, 2], 4: [4, 3], 5: [4, 3, 2], 6: [4, 3, 3],
            7: [4, 3, 3, 1], 8: [4, 3, 3, 2], 9: [4, 3, 3, 3, 1], 10: [4, 3, 3, 3, 2],
            11: [4, 3, 3, 3, 2, 1], 12: [4, 3, 3, 3, 2, 1], 13: [4, 3, 3, 3, 2, 1, 1],
            14: [4, 3, 3, 3, 2, 1, 1], 15: [4, 3, 3, 3, 2, 1, 1, 1], 16: [4, 3, 3, 3, 2, 1, 1, 1],
            17: [4, 3, 3, 3, 2, 1, 1, 1, 1], 18: [4, 3, 3, 3, 3, 1, 1, 1, 1],
            19: [4, 3, 3, 3, 3, 2, 1, 1, 1], 20: [4, 3, 3, 3, 3, 2, 2, 1, 1],
        }
        half = {
            1: [], 2: [2], 3: [3], 4: [3], 5: [4, 2], 6: [4, 2], 7: [4, 3], 8: [4, 3],
            9: [4, 3, 2], 10: [4, 3, 2], 11: [4, 3, 3], 12: [4, 3, 3], 13: [4, 3, 3, 1],
            14: [4, 3, 3, 1], 15: [4, 3, 3, 2], 16: [4, 3, 3, 2], 17: [4, 3, 3, 3, 1],
            18: [4, 3, 3, 3, 1], 19: [4, 3, 3, 3, 2], 20: [4, 3, 3, 3, 2],
        }
        third = {
            1: [], 2: [], 3: [2], 4: [3], 5: [3], 6: [3], 7: [4, 2], 8: [4, 2], 9: [4, 2],
            10: [4, 3], 11: [4, 3], 12: [4, 3], 13: [4, 3, 2], 14: [4, 3, 2], 15: [4, 3, 2],
            16: [4, 3, 3], 17: [4, 3, 3], 18: [4, 3, 3], 19: [4, 3, 3, 1], 20: [4, 3, 3, 1],
        }
        table = full if progression == "full" else (third if progression == "third" else half)
        row = table.get(max(1, min(20, int(level or 1))), [])
        slots = {str(i): {"max": 0, "current": 0} for i in range(1, 10)}
        for idx, value in enumerate(row, start=1):
            if idx > 9:
                break
            count = max(0, int(value or 0))
            slots[str(idx)] = {"max": count, "current": count}
        return slots

    def _spell_slot_progression_from_profile(self, leveling: Dict[str, Any], spellcasting: Dict[str, Any]) -> str:
        raw_progression = str(spellcasting.get("slot_progression") or "").strip().lower()
        if raw_progression in {"full", "half", "third"}:
            return raw_progression
        classes = leveling.get("classes") if isinstance(leveling, dict) else None
        class_name = ""
        if isinstance(classes, list) and classes:
            first = classes[0]
            if isinstance(first, dict):
                class_name = str(first.get("name") or "").strip().lower()
        full_casters = {"bard", "cleric", "druid", "sorcerer", "wizard"}
        half_casters = {"paladin", "ranger", "artificer"}
        third_casters = {"arcane trickster", "eldritch knight"}
        if class_name in full_casters:
            return "full"
        if class_name in half_casters:
            return "half"
        if class_name in third_casters:
            return "third"
        return "full"

    def _write_spell_yaml_atomic(self, path: Path, payload: Dict[str, Any]) -> None:
        if yaml is None:
            raise RuntimeError("PyYAML is required for spell persistence.")
        yaml_text = yaml.safe_dump(payload, sort_keys=False, allow_unicode=True)
        tmp_path = path.with_suffix(path.suffix + ".tmp")
        with self._spell_yaml_lock:
            path.parent.mkdir(parents=True, exist_ok=True)
            tmp_path.write_text(yaml_text, encoding="utf-8")
            tmp_path.replace(path)

    def _schedule_player_yaml_refresh(self) -> None:
        if self._player_yaml_refresh_scheduled:
            return
        self._player_yaml_refresh_scheduled = True

        def refresh() -> None:
            self._player_yaml_refresh_scheduled = False
            try:
                self._load_player_yaml_cache(force_refresh=True)
            except Exception:
                return
            try:
                self._lan._cached_snapshot = self._lan_snapshot()
            except Exception:
                pass

        try:
            self.after(200, refresh)
        except Exception:
            refresh()

    @staticmethod
    def _sanitize_player_filename(name: str) -> str:
        slug = re.sub(r"[^A-Za-z0-9._-]+", "-", str(name or "").strip())
        slug = slug.strip("-._")
        return slug or "player"

    def _character_schema_template(self) -> Dict[str, Any]:
        if _CHARACTER_SCHEMA_DEFAULTS:
            return copy.deepcopy(_CHARACTER_SCHEMA_DEFAULTS)
        return _CHARACTER_BASE_TEMPLATE()

    def _character_schema_config(self) -> Dict[str, Any]:
        return _CHARACTER_SCHEMA_CONFIG or {}

    def _character_schema_readme_map(self) -> Dict[str, Any]:
        return _CHARACTER_SCHEMA_README_MAP or {}

    def _character_slugify(self, name: str) -> str:
        return _CHARACTER_SLUGIFY(str(name or "").strip(), "_")

    def _character_merge_defaults(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        merged = copy.deepcopy(payload)
        return _CHARACTER_MERGE_DEFAULTS(merged, self._character_schema_template())

    def _character_type_name(self, value: Any) -> str:
        if isinstance(value, dict):
            return "object"
        if isinstance(value, list):
            return "array"
        if isinstance(value, bool):
            return "boolean"
        if isinstance(value, int):
            return "integer"
        if isinstance(value, float):
            return "number"
        if isinstance(value, str):
            return "string"
        if value is None:
            return "null"
        return type(value).__name__

    def _character_schema_errors(self, payload: Any, schema: Any, path: str = "") -> List[Dict[str, str]]:
        errors: List[Dict[str, str]] = []

        def add_error(message: str) -> None:
            errors.append({"path": path or ".", "message": message})

        if isinstance(schema, dict):
            if not isinstance(payload, dict):
                add_error(f"Expected object, got {self._character_type_name(payload)}.")
                return errors
            for key, schema_value in schema.items():
                if key not in payload:
                    continue
                next_path = f"{path}.{key}" if path else key
                errors.extend(self._character_schema_errors(payload[key], schema_value, next_path))
            return errors
        if isinstance(schema, list):
            if not isinstance(payload, list):
                add_error(f"Expected array, got {self._character_type_name(payload)}.")
                return errors
            if schema:
                item_schema = schema[0]
                for index, item in enumerate(payload):
                    next_path = f"{path}[{index}]" if path else f"[{index}]"
                    errors.extend(self._character_schema_errors(item, item_schema, next_path))
            return errors
        if isinstance(schema, bool):
            if not isinstance(payload, bool):
                add_error(f"Expected boolean, got {self._character_type_name(payload)}.")
            return errors
        if isinstance(schema, int) and not isinstance(schema, bool):
            if not isinstance(payload, int) or isinstance(payload, bool):
                add_error(f"Expected integer, got {self._character_type_name(payload)}.")
            return errors
        if isinstance(schema, float):
            if not isinstance(payload, (int, float)) or isinstance(payload, bool):
                add_error(f"Expected number, got {self._character_type_name(payload)}.")
            return errors
        if isinstance(schema, str):
            if not isinstance(payload, str):
                add_error(f"Expected string, got {self._character_type_name(payload)}.")
            return errors
        return errors

    def _validate_character_payload(self, payload: Any) -> List[Dict[str, str]]:
        if not isinstance(payload, dict):
            return [{"path": ".", "message": "Expected object payload."}]
        if _CHARACTER_SCHEMA_TREE:
            return _character_schema_errors_from_tree(payload, _CHARACTER_SCHEMA_TREE)
        schema = self._character_schema_template()
        return self._character_schema_errors(payload, schema)

    def _extract_character_name(self, payload: Dict[str, Any]) -> Optional[str]:
        name = payload.get("name")
        if not name and isinstance(payload.get("identity"), dict):
            name = payload["identity"].get("name")
        text = str(name or "").strip()
        return text or None

    def _apply_character_name(self, payload: Dict[str, Any], name: str) -> Dict[str, Any]:
        payload = dict(payload)
        payload["name"] = name
        identity = payload.get("identity")
        if not isinstance(identity, dict):
            identity = {}
        if not identity.get("name"):
            identity["name"] = name
        payload["identity"] = identity
        return payload

    def _deep_merge_dict(self, base_obj: Any, updates: Any) -> Any:
        if isinstance(base_obj, dict) and isinstance(updates, dict):
            merged: Dict[str, Any] = {}
            for key in base_obj:
                merged[key] = copy.deepcopy(base_obj[key])
            for key, value in updates.items():
                merged[key] = self._deep_merge_dict(base_obj.get(key), value)
            return merged
        return copy.deepcopy(updates)

    def _resolve_character_path(self, name: str) -> Optional[Path]:
        if not name:
            return None
        self._load_player_yaml_cache()
        path = self._find_player_profile_path(name)
        if path and path.exists():
            return path
        players_dir = self._players_dir()
        slug = self._character_slugify(name)
        if slug:
            candidate = players_dir / f"{slug}.yaml"
            if candidate.exists():
                return candidate
        candidate = players_dir / name
        if candidate.suffix.lower() not in (".yaml", ".yml"):
            candidate = candidate.with_suffix(".yaml")
        if candidate.exists():
            return candidate
        return None

    def _load_character_raw(self, path: Path) -> Dict[str, Any]:
        if yaml is None:
            raise CharacterApiError(status_code=500, detail={"error": "yaml_unavailable"})
        try:
            raw = yaml.safe_load(path.read_text(encoding="utf-8"))
        except Exception as exc:
            raise CharacterApiError(status_code=500, detail={"error": "read_failed", "message": str(exc)})
        return raw if isinstance(raw, dict) else {}

    def _store_character_yaml(self, path: Path, payload: Dict[str, Any]) -> Dict[str, Any]:
        self._write_player_yaml_atomic(path, payload)
        meta = _file_stat_metadata(path)
        self._player_yaml_cache_by_path[path] = payload
        self._player_yaml_meta_by_path[path] = meta
        profile = self._normalize_player_profile(payload, path.stem)
        profile_name = profile.get("name", path.stem)
        self._player_yaml_data_by_name[profile_name] = profile
        self._player_yaml_name_map[self._normalize_character_lookup_key(profile_name)] = path
        self._player_yaml_name_map[self._normalize_character_lookup_key(path.stem)] = path
        self._schedule_player_yaml_refresh()
        return profile

    def _normalize_character_filename(self, raw_filename: Optional[str], fallback_name: str) -> str:
        filename = str(raw_filename or "").strip()
        if filename:
            base = Path(filename).name
        else:
            base = self._character_slugify(fallback_name)
        stem = Path(base).stem or base or "character"
        stem = self._sanitize_player_filename(stem)
        return f"{stem}.yaml"

    def _archive_character_file(self, path: Path) -> Path:
        players_dir = self._players_dir()
        old_dir = players_dir / "old"
        old_dir.mkdir(parents=True, exist_ok=True)
        base_name = f"{path.stem}.yaml.old"
        candidate = old_dir / base_name
        if not candidate.exists():
            path.replace(candidate)
            return candidate
        index = 1
        while True:
            candidate = old_dir / f"{base_name}.{index}"
            if not candidate.exists():
                path.replace(candidate)
                return candidate
            index += 1

    def _list_character_filenames(self) -> List[str]:
        players_dir = self._players_dir()
        if not players_dir.exists():
            return []
        files = list(players_dir.glob("*.yaml")) + list(players_dir.glob("*.yml"))
        files.sort(key=lambda path: path.name.lower())
        return [path.name for path in files]

    def _get_character_payload(self, name: str) -> Dict[str, Any]:
        path = self._resolve_character_path(name)
        if path is None:
            raise CharacterApiError(status_code=404, detail={"error": "not_found", "message": "Character not found."})
        raw = self._load_character_raw(path)
        merged = self._character_merge_defaults(raw)
        return {"filename": path.name, "character": merged}

    def _create_character_payload(self, payload: Any) -> Dict[str, Any]:
        errors = self._validate_character_payload(payload)
        if errors:
            raise CharacterApiError(
                status_code=400,
                detail={"error": "validation_error", "errors": errors},
            )
        name = self._extract_character_name(payload)
        if not name:
            raise CharacterApiError(
                status_code=400,
                detail={"error": "validation_error", "errors": [{"path": "name", "message": "Name is required."}]},
            )
        slug = self._character_slugify(name)
        players_dir = self._players_dir()
        players_dir.mkdir(parents=True, exist_ok=True)
        path = players_dir / f"{slug}.yaml"
        if path.exists():
            raise CharacterApiError(
                status_code=409,
                detail={"error": "already_exists", "message": "Character file already exists."},
            )
        normalized = self._apply_character_name(payload, name)
        normalized = self._character_merge_defaults(normalized)
        profile = self._store_character_yaml(path, normalized)
        return {"filename": path.name, "character": profile}

    def _update_character_payload(self, name: str, payload: Any) -> Dict[str, Any]:
        errors = self._validate_character_payload(payload)
        if errors:
            raise CharacterApiError(
                status_code=400,
                detail={"error": "validation_error", "errors": errors},
            )
        path = self._resolve_character_path(name)
        if path is None:
            raise CharacterApiError(status_code=404, detail={"error": "not_found", "message": "Character not found."})
        updated_name = self._extract_character_name(payload) or name
        slug = self._character_slugify(updated_name)
        if slug and path.stem.lower() != slug.lower():
            raise CharacterApiError(
                status_code=400,
                detail={
                    "error": "validation_error",
                    "errors": [{"path": "name", "message": "Name does not match the URL resource."}],
                },
            )
        raw = self._load_character_raw(path)
        merged = self._deep_merge_dict(raw, payload if isinstance(payload, dict) else {})
        merged = self._apply_character_name(merged, updated_name)
        merged = self._character_merge_defaults(merged)
        merged = self._normalize_vitals_speed_schema(merged)
        profile = self._store_character_yaml(path, merged)
        return {"filename": path.name, "character": profile}

    def _overwrite_character_payload(self, name: str, payload: Any) -> Dict[str, Any]:
        if not isinstance(payload, dict):
            raise CharacterApiError(status_code=400, detail={"error": "validation_error", "message": "Invalid payload."})
        data = payload.get("data") if "data" in payload else payload
        if not isinstance(data, dict):
            raise CharacterApiError(
                status_code=400,
                detail={"error": "validation_error", "message": "Character data is required."},
            )
        errors = self._validate_character_payload(data)
        if errors:
            raise CharacterApiError(
                status_code=400,
                detail={"error": "validation_error", "errors": errors},
            )
        path = self._resolve_character_path(name)
        if path is None:
            raise CharacterApiError(status_code=404, detail={"error": "not_found", "message": "Character not found."})

        updated_name = self._extract_character_name(data) or name
        filename = self._normalize_character_filename(payload.get("filename"), updated_name)
        players_dir = self._players_dir()
        players_dir.mkdir(parents=True, exist_ok=True)
        new_path = players_dir / filename
        if new_path.exists() and new_path.resolve() != path.resolve():
            raise CharacterApiError(
                status_code=409,
                detail={"error": "already_exists", "message": "Target filename already exists."},
            )

        archived = self._archive_character_file(path)
        normalized = self._apply_character_name(data, updated_name)
        normalized = self._character_merge_defaults(normalized)
        normalized = self._normalize_vitals_speed_schema(normalized)
        profile = self._store_character_yaml(new_path, normalized)
        return {"filename": new_path.name, "character": profile, "archived": archived.name}

    def _upload_character_yaml_payload(self, payload: Any) -> Dict[str, Any]:
        if not isinstance(payload, dict):
            raise CharacterApiError(status_code=400, detail={"error": "validation_error", "message": "Invalid payload."})
        if yaml is None:
            raise CharacterApiError(status_code=500, detail={"error": "yaml_missing", "message": "YAML support is not available."})
        yaml_text = str(payload.get("yaml_text") or "")
        if not yaml_text.strip():
            raise CharacterApiError(
                status_code=400,
                detail={"error": "validation_error", "message": "YAML file contents are required."},
            )
        try:
            data = yaml.safe_load(yaml_text)
        except Exception as exc:
            raise CharacterApiError(
                status_code=400,
                detail={"error": "validation_error", "message": f"Invalid YAML: {exc}"},
            )
        if not isinstance(data, dict):
            raise CharacterApiError(
                status_code=400,
                detail={"error": "validation_error", "message": "Uploaded YAML must be a mapping/object."},
            )
        errors = self._validate_character_payload(data)
        if errors:
            raise CharacterApiError(
                status_code=400,
                detail={"error": "validation_error", "errors": errors},
            )
        updated_name = self._extract_character_name(data) or "character"
        filename = self._normalize_character_filename(payload.get("filename"), updated_name)
        players_dir = self._players_dir()
        players_dir.mkdir(parents=True, exist_ok=True)
        path = players_dir / filename
        archived_name = None
        if path.exists():
            archived_name = self._archive_character_file(path).name
        normalized = self._apply_character_name(data, updated_name)
        normalized = self._character_merge_defaults(normalized)
        normalized = self._normalize_vitals_speed_schema(normalized)
        profile = self._store_character_yaml(path, normalized)
        return {"filename": path.name, "character": profile, "archived": archived_name}

    @staticmethod
    def _normalize_player_section(value: Any) -> Dict[str, Any]:
        return dict(value) if isinstance(value, dict) else {}

    def _normalize_identity_host(self, value: Any) -> Optional[str]:
        host = str(value or "").strip()
        if not host:
            return None
        try:
            ipaddress.ip_address(host)
            return host
        except ValueError:
            pass
        if len(host) > 253:
            return None
        labels = host.split(".")
        for label in labels:
            if not label or len(label) > 63:
                return None
            if label.startswith("-") or label.endswith("-"):
                return None
            if not re.match(r"^[A-Za-z0-9-]+$", label):
                return None
        return host

    def _spell_preset_name_lookup(self) -> Dict[str, str]:
        lookup: Dict[str, str] = {}
        try:
            presets = self._spell_presets_payload()
        except Exception:
            presets = []
        for preset in presets if isinstance(presets, list) else []:
            if not isinstance(preset, dict):
                continue
            name = str(preset.get("name") or "").strip()
            if not name:
                continue
            lookup[name.lower()] = name
            preset_id = str(preset.get("id") or "").strip()
            if preset_id:
                lookup[preset_id.lower()] = name

        entries = self._load_spell_index_entries()
        for filename, entry in entries.items():
            if not isinstance(entry, dict):
                continue
            preset = entry.get("preset")
            if not isinstance(preset, dict):
                continue
            name = str(preset.get("name") or "").strip()
            if not name:
                continue
            file_key = str(filename or "").strip()
            if file_key:
                lookup[file_key.lower()] = name
                stem = Path(file_key).stem
                if stem:
                    lookup[stem.lower()] = name
            preset_id = str(preset.get("id") or "").strip()
            if preset_id:
                lookup[preset_id.lower()] = name
        return lookup

    def _normalize_spell_reference_list(self, value: Any) -> List[str]:
        def normalize_name(raw: Any) -> Optional[str]:
            text = str(raw or "").strip()
            return text or None

        lookup = self._spell_preset_name_lookup()
        raw_list: List[str] = []
        if isinstance(value, list):
            raw_list = [name for item in value if (name := normalize_name(item))]
        elif isinstance(value, str):
            name = normalize_name(value)
            raw_list = [name] if name else []

        seen = set()
        mapped: List[str] = []
        for item in raw_list:
            key = item.lower()
            resolved = lookup.get(key, item)
            if resolved in seen:
                continue
            seen.add(resolved)
            mapped.append(resolved)
        return mapped

    @staticmethod
    def _normalize_spell_slug_list(value: Any) -> List[str]:
        def normalize_name(raw: Any) -> Optional[str]:
            text = str(raw or "").strip()
            return text or None

        if isinstance(value, list):
            raw_list = [name for item in value if (name := normalize_name(item))]
        elif isinstance(value, str):
            name = normalize_name(value)
            raw_list = [name] if name else []
        else:
            raw_list = []

        seen = set()
        slugs: List[str] = []
        for item in raw_list:
            key = item.lower()
            if key in seen:
                continue
            seen.add(key)
            slugs.append(item)
        return slugs

    @staticmethod
    def _normalize_casting_time(value: Any) -> Optional[str]:
        if value in (None, ""):
            return None
        raw = str(value).strip()
        if not raw:
            return None
        lower = raw.lower()
        if _CAST_TIME_BONUS_RE.search(lower):
            return "Bonus Action"
        if _CAST_TIME_REACTION_RE.search(lower):
            return "Reaction"
        if _CAST_TIME_ACTION_RE.search(lower):
            return "Action"
        return raw

    @staticmethod
    def _coerce_level_value(leveling: Dict[str, Any]) -> int:
        raw = leveling.get("level") or leveling.get("total_level") or leveling.get("lvl")
        try:
            value = int(raw)
        except Exception:
            return 0
        return max(0, value)

    @staticmethod
    def _proficiency_bonus_for_level(level: int) -> int:
        if level >= 17:
            return 6
        if level >= 13:
            return 5
        if level >= 9:
            return 4
        if level >= 5:
            return 3
        if level >= 1:
            return 2
        return 0

    @staticmethod
    def _normalize_spell_slots(value: Any) -> Dict[str, Dict[str, int]]:
        def normalize_number(raw: Any, fallback: int = 0) -> int:
            try:
                num = int(raw)
            except Exception:
                return fallback
            return max(0, num)

        raw_slots = value if isinstance(value, dict) else {}
        normalized: Dict[str, Dict[str, int]] = {}
        for level in range(1, 10):
            key = str(level)
            entry = raw_slots.get(key, raw_slots.get(level))
            if isinstance(entry, dict):
                max_value = normalize_number(entry.get("max"), 0)
                if "current" in entry:
                    current_value = normalize_number(entry.get("current"), 0)
                else:
                    current_value = max_value
            else:
                max_value = normalize_number(entry, 0)
                current_value = max_value
            normalized[key] = {"max": max_value, "current": current_value}
        return normalized

    @staticmethod
    def _normalize_vitals_speed_schema(payload: Dict[str, Any]) -> Dict[str, Any]:
        if not isinstance(payload, dict):
            return payload
        vitals = payload.get("vitals")
        if not isinstance(vitals, dict):
            return payload
        speed = vitals.get("speed")
        if not isinstance(speed, dict):
            return payload

        def normalize_number(raw: Any) -> Optional[int]:
            try:
                return int(raw)
            except Exception:
                return None

        legacy_map = {
            "Normal": "walk",
            "Climb": "climb",
            "Fly": "fly",
            "Swim": "swim",
            "Burrow": None,
        }
        normalized_speed: Dict[str, int] = {}
        for key in ("walk", "climb", "fly", "swim"):
            value = speed.get(key)
            if value is None:
                legacy_key = next((legacy for legacy, target in legacy_map.items() if target == key), None)
                if legacy_key is not None:
                    value = speed.get(legacy_key)
            normalized_value = normalize_number(value)
            if normalized_value is None:
                normalized_value = 0
            normalized_speed[key] = normalized_value

        vitals = dict(vitals)
        vitals["speed"] = normalized_speed
        payload = dict(payload)
        payload["vitals"] = vitals
        return payload

    def _normalize_startup_summon_entries(self, raw_value: Any, player_name: str) -> List[Dict[str, Any]]:
        def parse_entry(entry: Any) -> Optional[Dict[str, Any]]:
            if isinstance(entry, str):
                monster = entry.strip()
                if not monster:
                    return None
                return {"monster": monster, "count": 1, "overrides": {}}
            if not isinstance(entry, dict):
                return None
            entry_copy = dict(entry)
            monster_raw = entry_copy.pop("monster", entry_copy.pop("file", None))
            monster = str(monster_raw or "").strip()
            if not monster:
                return None
            count_raw = entry_copy.pop("count", 1)
            try:
                count = int(count_raw)
            except Exception:
                count = 1
            if count < 0:
                count = 0
            explicit_overrides = entry_copy.pop("overrides", {})
            overrides = dict(explicit_overrides) if isinstance(explicit_overrides, dict) else {}
            overrides.update(entry_copy)
            return {"monster": monster, "count": count, "overrides": overrides}

        entries = raw_value if isinstance(raw_value, list) else [raw_value]
        normalized: List[Dict[str, Any]] = []
        for entry in entries:
            parsed = parse_entry(entry)
            if parsed is None:
                if entry is not None:
                    self._oplog(f"Player YAML {player_name}: invalid summon_on_start entry '{entry}'.", level="warning")
                continue
            normalized.append(parsed)
        return normalized

    def _normalize_player_profile(self, data: Dict[str, Any], fallback_name: str) -> Dict[str, Any]:
        def normalize_name(value: Any) -> Optional[str]:
            text = str(value or "").strip()
            return text or None

        fmt_raw = data.get("format_version")
        try:
            fmt = int(fmt_raw)
        except Exception:
            fmt = 0
        if fmt < 1:
            fmt = 0

        identity = self._normalize_player_section(data.get("identity"))
        leveling = self._normalize_player_section(data.get("leveling"))
        abilities = self._normalize_player_section(data.get("abilities"))
        proficiency = self._normalize_player_section(data.get("proficiency"))
        vitals = self._normalize_player_section(data.get("vitals"))
        defenses = self._normalize_player_section(data.get("defenses"))
        attacks = self._normalize_player_section(data.get("attacks"))
        resources = self._normalize_player_section(data.get("resources"))
        spellcasting = self._normalize_player_section(data.get("spellcasting"))
        inventory = self._normalize_player_section(data.get("inventory"))

        def normalize_vital_int(value: Any, fallback: int = 0) -> int:
            try:
                return int(value)
            except Exception:
                return fallback

        temp_hp_raw = vitals.get("temp_hp", data.get("temp_hp", 0))
        vitals = dict(vitals)
        vitals["temp_hp"] = normalize_vital_int(temp_hp_raw, 0)

        if "level" not in leveling:
            classes = leveling.get("classes")
            if isinstance(classes, list):
                total = 0
                for entry in classes:
                    if not isinstance(entry, dict):
                        continue
                    try:
                        total += int(entry.get("level") or 0)
                    except Exception:
                        continue
                if total:
                    leveling["level"] = total
        level_value = self._coerce_level_value(leveling)
        if level_value > 0:
            proficiency["bonus"] = self._proficiency_bonus_for_level(level_value)

        name = (
            normalize_name(data.get("name"))
            or normalize_name(identity.get("name"))
            or normalize_name(identity.get("character_name"))
            or normalize_name(identity.get("player_name"))
            or normalize_name(fallback_name)
        )
        if name is None:
            name = fallback_name

        if "name" not in identity and name:
            identity["name"] = name

        if "token_color" not in identity:
            normalized_color = self._normalize_token_color(data.get("token_color"))
            if normalized_color:
                identity["token_color"] = normalized_color
        if "token_border_color" not in identity:
            normalized_border = self._normalize_token_color(data.get("token_border_color"))
            if normalized_border:
                identity["token_border_color"] = normalized_border

        raw_ip = identity.get("ip") if "ip" in identity else data.get("ip")
        normalized_ip = self._normalize_identity_host(raw_ip)
        if normalized_ip:
            identity["ip"] = normalized_ip
        else:
            if raw_ip:
                self._oplog(f"Player YAML {name}: invalid identity.ip '{raw_ip}'.", level="warning")
            identity.pop("ip", None)

        if fmt == 0:
            if "base_movement" in data and "base_movement" not in resources:
                resources["base_movement"] = data.get("base_movement")
            if "speed" in data and "base_movement" not in resources:
                resources["base_movement"] = data.get("speed")
            if "swim_speed" in data and "swim_speed" not in resources:
                resources["swim_speed"] = data.get("swim_speed")
            if "hp" in data and "hp" not in defenses:
                defenses["hp"] = data.get("hp")
            if "melee_attack_mod" in data and "melee_attack_mod" not in attacks:
                attacks["melee_attack_mod"] = data.get("melee_attack_mod")
            if "ranged_attack_mod" in data and "ranged_attack_mod" not in attacks:
                attacks["ranged_attack_mod"] = data.get("ranged_attack_mod")
            if "weapon_to_hit" in data and "weapon_to_hit" not in attacks:
                attacks["weapon_to_hit"] = data.get("weapon_to_hit")
            if "actions" in data and "actions" not in resources:
                resources["actions"] = data.get("actions")
            if "bonus_actions" in data and "bonus_actions" not in resources:
                resources["bonus_actions"] = data.get("bonus_actions")
            if "reactions" in data and "reactions" not in resources:
                resources["reactions"] = data.get("reactions")
        else:
            if "actions" in data and "actions" not in resources:
                resources["actions"] = data.get("actions")
            if "bonus_actions" in data and "bonus_actions" not in resources:
                resources["bonus_actions"] = data.get("bonus_actions")
            if "reactions" in data and "reactions" not in resources:
                resources["reactions"] = data.get("reactions")
        if fmt >= 2:
            vitals_speed = vitals.get("speed") if isinstance(vitals, dict) else None
            if vitals_speed is not None and "base_movement" not in resources and "speed" not in resources:
                resources["base_movement"] = vitals_speed

        def normalize_attack_int(value: Any) -> Optional[int]:
            try:
                return int(value)
            except Exception:
                return None

        for key in ("melee_attack_mod", "ranged_attack_mod", "weapon_to_hit"):
            if key in attacks:
                normalized_value = normalize_attack_int(attacks.get(key))
                if normalized_value is not None:
                    attacks[key] = normalized_value

        raw_weapons = attacks.get("weapons")
        normalized_weapons: List[Dict[str, Any]] = []
        weapon_registry = self._items_registry_payload().get("weapons", {}) if isinstance(raw_weapons, list) else {}
        if isinstance(raw_weapons, list):
            for entry in raw_weapons:
                if not isinstance(entry, dict):
                    continue
                player_weapon_entry = dict(entry)
                weapon = self._resolve_weapon_from_items(dict(player_weapon_entry), weapon_registry=weapon_registry)
                one_handed = dict(weapon.get("one_handed")) if isinstance(weapon.get("one_handed"), dict) else {}
                two_handed = dict(weapon.get("two_handed")) if isinstance(weapon.get("two_handed"), dict) else {}
                effect = dict(weapon.get("effect")) if isinstance(weapon.get("effect"), dict) else {}
                save_dc = normalize_attack_int(effect.get("save_dc"))
                if save_dc is None:
                    save_dc = 0
                weapon["id"] = str(weapon.get("id") or "").strip()
                weapon["name"] = str(weapon.get("name") or "").strip()
                weapon["proficient"] = bool(player_weapon_entry.get("proficient", True))
                to_hit_normalized = normalize_attack_int(weapon.get("to_hit"))
                weapon["to_hit"] = to_hit_normalized if to_hit_normalized is not None else 0
                magic_bonus_normalized = normalize_attack_int(weapon.get("magic_bonus"))
                if magic_bonus_normalized is None:
                    magic_bonus_normalized = normalize_attack_int(weapon.get("item_bonus"))
                weapon["magic_bonus"] = magic_bonus_normalized if magic_bonus_normalized is not None else 0
                weapon["range"] = str(weapon.get("range") or "").strip()
                properties = weapon.get("properties") if isinstance(weapon.get("properties"), list) else []
                normalized_properties: List[str] = []
                for prop in properties:
                    if isinstance(prop, dict):
                        prop_id = str(prop.get("id") or prop.get("name") or "").strip().lower()
                    else:
                        prop_id = str(prop or "").strip().lower()
                    if prop_id:
                        normalized_properties.append(prop_id)
                weapon["properties"] = normalized_properties
                weapon["mastery"] = str(weapon.get("mastery") or "").strip().lower()
                weapon["one_handed"] = {
                    "damage_formula": str(one_handed.get("damage_formula") or "").strip(),
                    "damage_type": str(one_handed.get("damage_type") or "").strip(),
                }
                weapon["two_handed"] = {
                    "damage_formula": str(two_handed.get("damage_formula") or "").strip(),
                    "damage_type": str(two_handed.get("damage_type") or "").strip(),
                }
                weapon["effect"] = {
                    "on_hit": str(effect.get("on_hit") or "").strip(),
                    "save_ability": str(effect.get("save_ability") or "").strip().lower(),
                    "save_dc": save_dc,
                }
                normalized_weapons.append(weapon)
        attacks["weapons"] = normalized_weapons

        raw_spell_slots = None
        if isinstance(spellcasting, dict) and "spell_slots" in spellcasting:
            raw_spell_slots = spellcasting.get("spell_slots")
        elif "spell_slots" in data:
            raw_spell_slots = data.get("spell_slots")
        spellcasting["spell_slots"] = self._normalize_spell_slots(raw_spell_slots)
        slots_total = sum(int((entry or {}).get("max", 0) or 0) for entry in spellcasting["spell_slots"].values())
        if slots_total <= 0 and bool(spellcasting):
            level_value = self._coerce_level_value(leveling)
            progression = self._spell_slot_progression_from_profile(leveling, spellcasting)
            spellcasting["spell_slots"] = self._default_spell_slots_for_level(level_value, progression)

        for key in ("known_cantrips", "known_spells", "known_spell_names"):
            if key not in spellcasting and key in data:
                spellcasting[key] = data.get(key)
        if "cantrips" not in spellcasting:
            if "cantrips" in data:
                spellcasting["cantrips"] = data.get("cantrips")
            elif "known_cantrips" in spellcasting:
                spellcasting["cantrips"] = spellcasting.get("known_cantrips")
        if "prepared_spells" not in spellcasting and "prepared_spells" in data:
            spellcasting["prepared_spells"] = data.get("prepared_spells")
        cantrips_section = spellcasting.get("cantrips")
        cantrip_list: List[str] = []
        if isinstance(cantrips_section, dict):
            cantrip_list = self._normalize_spell_slug_list(cantrips_section.get("known"))
            if cantrip_list:
                cantrips_section = dict(cantrips_section)
                cantrips_section["known"] = cantrip_list
                spellcasting["cantrips"] = cantrips_section
                if "known_cantrips" not in spellcasting:
                    spellcasting["known_cantrips"] = len(cantrip_list)
        prepared_section = spellcasting.get("prepared_spells")
        prepared_list: List[str] = []
        prepared_limit_formula = ""
        if isinstance(prepared_section, dict):
            prepared_list = self._normalize_spell_slug_list(prepared_section.get("prepared"))
            if prepared_list:
                prepared_section = dict(prepared_section)
                prepared_section["prepared"] = prepared_list
                spellcasting["prepared_spells"] = prepared_section
            prepared_limit_formula = str(prepared_section.get("max_formula") or "").strip()

        known_section = spellcasting.get("known_spells")
        known_limit = None
        known_list: List[str] = []
        if isinstance(known_section, dict):
            known_limit = known_section.get("max")
            known_list = self._normalize_spell_slug_list(known_section.get("known"))

        if "known_enabled" not in spellcasting:
            spellcasting["known_enabled"] = known_section is not None
        spellcasting["known_limit"] = int(known_limit) if str(known_limit).isdigit() else None
        spellcasting["prepared_limit_formula"] = prepared_limit_formula
        spellcasting["known_list"] = known_list
        spellcasting["prepared_list"] = prepared_list
        spellcasting["cantrips_list"] = cantrip_list

        druid_level = self._druid_level_from_profile({"leveling": leveling})
        known_limit = self._wild_shape_known_limit(druid_level) if druid_level >= 2 else None
        raw_prepared_wild_shapes = data.get("prepared_wild_shapes")
        if not isinstance(raw_prepared_wild_shapes, list):
            raw_prepared_wild_shapes = data.get("learned_wild_shapes")
        prepared_wild_shapes = self._normalize_prepared_wild_shapes(raw_prepared_wild_shapes, known_limit=known_limit)
        summon_on_start_raw = None
        for key in ("summon_on_start", "summon-on-start", "summons_on_start", "summons-on-start"):
            if key in data:
                summon_on_start_raw = data.get(key)
                break
        summon_on_start = self._normalize_startup_summon_entries(summon_on_start_raw, name)
        feature_runtime = self._feature_runtime_from_profile(data)
        feature_actions = feature_runtime.get("compiled_actions") if isinstance(feature_runtime.get("compiled_actions"), dict) else {}

        def _append_unique_actions(target_key: str, default_type: str) -> None:
            existing_entries = self._normalize_action_entries(resources.get(target_key), default_type)
            merged = list(existing_entries)
            seen_keys = {
                (
                    self._action_name_key(entry.get("name")),
                    self._action_name_key(entry.get("type") or default_type),
                )
                for entry in existing_entries
                if isinstance(entry, dict)
            }
            for candidate in feature_actions.get(target_key, []) if isinstance(feature_actions.get(target_key), list) else []:
                if not isinstance(candidate, dict):
                    continue
                dedupe_key = (
                    self._action_name_key(candidate.get("name")),
                    self._action_name_key(candidate.get("type") or default_type),
                )
                if dedupe_key in seen_keys:
                    continue
                seen_keys.add(dedupe_key)
                merged.append(copy.deepcopy(candidate))
            resources[target_key] = merged

        _append_unique_actions("actions", "action")
        _append_unique_actions("bonus_actions", "bonus_action")
        _append_unique_actions("reactions", "reaction")

        profile = PlayerProfile(
            name=name,
            format_version=fmt,
            identity=identity,
            leveling=leveling,
            abilities=abilities,
            proficiency=proficiency,
            vitals=vitals,
            defenses=defenses,
            attacks=attacks,
            resources=resources,
            spellcasting=spellcasting,
            inventory=inventory,
            features=feature_runtime.get("features", []),
            feature_state=feature_runtime.get("feature_state", {}),
            feature_effects=feature_runtime.get("feature_effects", {}),
            prepared_wild_shapes=prepared_wild_shapes,
            summon_on_start=summon_on_start,
        )
        return profile.to_dict()

    def _weapon_formula_has_ability_mod(self, formula: Any) -> bool:
        text = str(formula or "").strip().lower()
        if not text:
            return False
        return any(token in text for token in ("str_mod", "dex_mod", "con_mod", "int_mod", "wis_mod", "cha_mod", "max(str_mod, dex_mod)"))

    def _weapon_ability_mod_expression(self, item_data: Dict[str, Any]) -> str:
        properties = item_data.get("properties")
        prop_ids: set[str] = set()
        if isinstance(properties, list):
            for prop in properties:
                if isinstance(prop, dict):
                    prop_id = str(prop.get("id") or prop.get("name") or "").strip().lower()
                else:
                    prop_id = str(prop or "").strip().lower()
                if prop_id:
                    prop_ids.add(prop_id)
        category = str(item_data.get("category") or "").strip().lower()
        if "finesse" in prop_ids:
            return "max(str_mod, dex_mod)"
        if "ranged" in category:
            return "dex_mod"
        return "str_mod"

    def _append_weapon_ability_mod(self, formula: Any, item_data: Dict[str, Any]) -> str:
        base = str(formula or "").strip()
        if not base:
            return ""
        if self._weapon_formula_has_ability_mod(base):
            return base
        return f"{base} + {self._weapon_ability_mod_expression(item_data)}"

    def _resolve_weapon_from_items(
        self,
        weapon_entry: Dict[str, Any],
        weapon_registry: Optional[Dict[str, Dict[str, Any]]] = None,
    ) -> Dict[str, Any]:
        weapon = dict(weapon_entry)
        item_id = str(weapon.get("id") or "").strip().lower()
        if not item_id:
            return weapon
        registry = weapon_registry if isinstance(weapon_registry, dict) else (self._items_registry_payload().get("weapons") or {})
        item = dict(registry.get(item_id) or {})
        if not item:
            return weapon

        if not str(weapon.get("name") or "").strip():
            weapon["name"] = str(item.get("name") or "").strip()
        if not str(weapon.get("range") or "").strip():
            weapon["range"] = str(item.get("range") or "").strip()
        if "properties" not in weapon and isinstance(item.get("properties"), list):
            weapon["properties"] = list(item.get("properties") or [])
        if "mastery" not in weapon and item.get("mastery") not in (None, ""):
            weapon["mastery"] = item.get("mastery")
        if "riders" not in weapon and isinstance(item.get("riders"), list):
            weapon["riders"] = copy.deepcopy(item.get("riders") or [])

        if "magic_bonus" not in weapon and "item_bonus" not in weapon and "attack_bonus" in item:
            weapon["magic_bonus"] = item.get("attack_bonus")

        one_handed = dict(weapon.get("one_handed")) if isinstance(weapon.get("one_handed"), dict) else {}
        two_handed = dict(weapon.get("two_handed")) if isinstance(weapon.get("two_handed"), dict) else {}
        item_damage = item.get("damage") if isinstance(item.get("damage"), dict) else {}
        item_one = item_damage.get("one_handed") if isinstance(item_damage.get("one_handed"), dict) else {}
        item_versatile = item_damage.get("versatile") if isinstance(item_damage.get("versatile"), dict) else {}
        item_two = item_damage.get("two_handed") if isinstance(item_damage.get("two_handed"), dict) else {}

        if not str(one_handed.get("damage_formula") or "").strip() and item_one.get("formula") is not None:
            one_handed["damage_formula"] = self._append_weapon_ability_mod(item_one.get("formula"), item)
        if not str(one_handed.get("damage_type") or "").strip() and item_one.get("type") is not None:
            one_handed["damage_type"] = str(item_one.get("type") or "").strip()

        two_source = item_versatile if item_versatile else item_two
        if isinstance(two_source, dict):
            if not str(two_handed.get("damage_formula") or "").strip() and two_source.get("formula") is not None:
                two_handed["damage_formula"] = self._append_weapon_ability_mod(two_source.get("formula"), item)
            if not str(two_handed.get("damage_type") or "").strip() and two_source.get("type") is not None:
                two_handed["damage_type"] = str(two_source.get("type") or "").strip()

        weapon["one_handed"] = one_handed
        weapon["two_handed"] = two_handed

        effect = dict(weapon.get("effect")) if isinstance(weapon.get("effect"), dict) else {}
        if not str(effect.get("on_hit") or "").strip():
            riders = item.get("riders") if isinstance(item.get("riders"), list) else []
            pieces: List[str] = []
            has_hellfire_stack = False
            for rider in riders:
                if not isinstance(rider, dict):
                    continue
                if str(rider.get("trigger") or "").strip().lower() != "on_hit":
                    continue
                formula = str(rider.get("formula") or "").strip()
                dtype = str(rider.get("type") or "").strip()
                if formula and dtype:
                    pieces.append(f"{formula} {dtype} damage")
                notes_text = str(rider.get("notes") or "").strip().lower()
                stack_key = str(rider.get("stack_key") or "").strip().lower()
                rider_id = str(rider.get("id") or "").strip().lower()
                if "hellfire stack" in notes_text or stack_key == "hellfire" or "hellfire" in rider_id:
                    has_hellfire_stack = True
            on_hit_text = "; ".join(pieces)
            if has_hellfire_stack:
                on_hit_text = (on_hit_text + "; " if on_hit_text else "") + "hellfire stack"
            if on_hit_text:
                effect["on_hit"] = on_hit_text
        weapon["effect"] = effect
        return weapon

    def _normalize_spellcasting_ability(self, value: Any) -> Optional[str]:
        raw = str(value or "").strip().lower()
        if not raw:
            return None
        ability_map = {
            "strength": "str",
            "str": "str",
            "dexterity": "dex",
            "dex": "dex",
            "constitution": "con",
            "con": "con",
            "intelligence": "int",
            "int": "int",
            "wisdom": "wis",
            "wis": "wis",
            "charisma": "cha",
            "cha": "cha",
            "chr": "cha",
            "char": "cha",
        }
        return ability_map.get(raw)

    def _ability_score_modifier(self, abilities: Dict[str, Any], key: Optional[str]) -> int:
        if not key or not isinstance(abilities, dict):
            return 0
        candidates = [key, key.lower(), key.upper(), f"{key}_score"]
        if key == "cha":
            candidates.extend(["chr", "charisma", "CHARISMA"])
        score = None
        for candidate in candidates:
            if candidate in abilities:
                score = abilities.get(candidate)
                break
        try:
            score_value = float(score)
        except Exception:
            score_value = None
        if score_value is not None and math.isfinite(score_value):
            return int(math.floor((score_value - 10) / 2))
        for candidate in (f"{key}_mod", f"{key}_modifier"):
            if candidate in abilities:
                try:
                    mod_value = float(abilities.get(candidate))
                except Exception:
                    continue
                if math.isfinite(mod_value):
                    return int(math.floor(mod_value))
        return 0

    @staticmethod
    def _modifier_from_map(modifiers: Any, key: Optional[str]) -> Optional[int]:
        if not key or not isinstance(modifiers, dict):
            return None
        normalized_key = str(key).strip().lower()
        if not normalized_key:
            return None
        value = None
        for raw_key, raw_value in modifiers.items():
            if str(raw_key).strip().lower() == normalized_key:
                value = raw_value
                break
        if value is None:
            return None
        try:
            modifier_value = float(value)
        except Exception:
            return None
        if not math.isfinite(modifier_value):
            return None
        return int(math.floor(modifier_value))

    def _combatant_ability_modifier(self, combatant: Any, ability: Optional[str]) -> int:
        direct_mod = self._modifier_from_map(getattr(combatant, "ability_mods", None), ability)
        if direct_mod is not None:
            return int(direct_mod)

        spec = getattr(combatant, "monster_spec", None)
        spec_mod = self._modifier_from_map(getattr(spec, "ability_mods", None) if spec is not None else None, ability)
        if spec_mod is not None:
            return int(spec_mod)

        raw_data = getattr(spec, "raw_data", None) if spec is not None else None
        abilities = raw_data.get("abilities") if isinstance(raw_data, dict) and isinstance(raw_data.get("abilities"), dict) else None
        if isinstance(abilities, dict):
            return int(self._ability_score_modifier(abilities, ability))
        return 0

    def _evaluate_spell_formula(self, formula: Any, variables: Dict[str, Any]) -> Optional[float]:
        if not isinstance(formula, str):
            return None
        trimmed = formula.strip()
        if not trimmed:
            return None
        if not re.fullmatch(r"[0-9+\-*/().,_ <>!=a-zA-Z]+", trimmed):
            return None
        expr = trimmed
        for key, value in variables.items():
            try:
                safe_value = float(value)
            except Exception:
                safe_value = 0.0
            if not math.isfinite(safe_value):
                safe_value = 0.0
            expr = re.sub(rf"\b{re.escape(str(key))}\b", str(int(safe_value)), expr)
        try:
            result = eval(
                expr,
                {"__builtins__": {}, "min": min, "max": max, "floor": math.floor, "ceil": math.ceil},
            )
        except Exception:
            return None
        try:
            result_value = float(result)
        except Exception:
            return None
        if not math.isfinite(result_value):
            return None
        return result_value

    def _compute_spell_save_dc(self, profile: Dict[str, Any]) -> Optional[int]:
        if not isinstance(profile, dict):
            return None
        spellcasting = profile.get("spellcasting")
        if not isinstance(spellcasting, dict):
            return None
        formula = spellcasting.get("save_dc_formula")
        if not isinstance(formula, str) or not formula.strip():
            return None
        abilities = profile.get("abilities") if isinstance(profile.get("abilities"), dict) else {}
        leveling = profile.get("leveling") if isinstance(profile.get("leveling"), dict) else {}
        proficiency = profile.get("proficiency") if isinstance(profile.get("proficiency"), dict) else {}
        level_value = self._coerce_level_value(leveling)
        if level_value > 0:
            prof_bonus = self._proficiency_bonus_for_level(level_value)
        else:
            prof_bonus_raw = proficiency.get("bonus")
            try:
                prof_bonus = int(prof_bonus_raw)
            except Exception:
                prof_bonus = 0
        casting_ability = self._normalize_spellcasting_ability(spellcasting.get("casting_ability"))
        casting_mod = self._ability_score_modifier(abilities, casting_ability)
        variables = {
            "prof": prof_bonus,
            "proficiency": prof_bonus,
            "casting_mod": casting_mod,
            "str_mod": self._ability_score_modifier(abilities, "str"),
            "dex_mod": self._ability_score_modifier(abilities, "dex"),
            "con_mod": self._ability_score_modifier(abilities, "con"),
            "int_mod": self._ability_score_modifier(abilities, "int"),
            "wis_mod": self._ability_score_modifier(abilities, "wis"),
            "cha_mod": self._ability_score_modifier(abilities, "cha"),
        }
        result = self._evaluate_spell_formula(formula, variables)
        if result is None:
            return None
        return int(math.floor(result))

    def _resolve_player_ac(self, profile: Dict[str, Any], defenses: Any) -> Optional[int]:
        def to_int(value: Any, fallback: Optional[int] = None) -> Optional[int]:
            try:
                return int(value)
            except Exception:
                return fallback

        if isinstance(defenses, dict):
            ac_data = defenses.get("ac")
        else:
            ac_data = defenses

        direct_value = to_int(ac_data, None)
        if direct_value is not None:
            return direct_value

        abilities = profile.get("abilities") if isinstance(profile.get("abilities"), dict) else {}
        variables = {
            "str_mod": self._ability_score_modifier(abilities, "str"),
            "dex_mod": self._ability_score_modifier(abilities, "dex"),
            "con_mod": self._ability_score_modifier(abilities, "con"),
            "int_mod": self._ability_score_modifier(abilities, "int"),
            "wis_mod": self._ability_score_modifier(abilities, "wis"),
            "cha_mod": self._ability_score_modifier(abilities, "cha"),
        }

        def eval_ac_value(value: Any) -> Optional[int]:
            parsed = to_int(value, None)
            if parsed is not None:
                return parsed
            if isinstance(value, dict):
                for key in ("value", "ac", "formula", "base_formula"):
                    nested = eval_ac_value(value.get(key))
                    if nested is not None:
                        return nested
                return None
            result = self._evaluate_spell_formula(value, variables)
            if result is None:
                return None
            return int(math.floor(result))

        def is_always(when_value: Any) -> bool:
            if when_value is None:
                return True
            if isinstance(when_value, bool):
                return when_value
            text = str(when_value).strip().lower()
            return text in {"", "always", "true"}

        if not isinstance(ac_data, dict):
            return eval_ac_value(ac_data)

        base_values: List[int] = []
        fallback_values: List[int] = []
        sources = ac_data.get("sources")
        if isinstance(sources, list):
            for source in sources:
                if not isinstance(source, dict):
                    continue
                source_value = eval_ac_value(source.get("base_formula"))
                if source_value is None:
                    source_value = eval_ac_value(source.get("value"))
                if source_value is None:
                    continue
                source_bonus = eval_ac_value(source.get("magic_bonus"))
                if source_bonus is None:
                    source_bonus = eval_ac_value(source.get("item_bonus"))
                if source_bonus is not None:
                    source_value += source_bonus
                fallback_values.append(source_value)
                if is_always(source.get("when")):
                    base_values.append(source_value)
        if not base_values:
            direct_base = eval_ac_value(ac_data)
            if direct_base is not None:
                base_values = [direct_base]
        if not base_values:
            base_values = fallback_values
        if not base_values:
            return None

        bonus_total = 0
        bonuses = ac_data.get("bonuses")
        if isinstance(bonuses, list):
            for bonus in bonuses:
                if isinstance(bonus, dict) and not is_always(bonus.get("when")):
                    continue
                bonus_value = eval_ac_value(bonus)
                if bonus_value is not None:
                    bonus_total += bonus_value
        return max(base_values) + bonus_total

    def _normalize_player_spell_config(
        self,
        data: Dict[str, Any],
        include_missing_prepared: bool = True,
    ) -> Dict[str, Any]:
        def normalize_limit(value: Any, fallback: int) -> int:
            try:
                num = int(value)
            except Exception:
                return fallback
            return max(0, num)

        def normalize_name(value: Any) -> Optional[str]:
            text = str(value or "").strip()
            return text or None

        source = data
        if isinstance(data.get("spellcasting"), dict):
            source = data.get("spellcasting", {})
        cantrip_list: List[str] = []
        cantrips_section = source.get("cantrips")
        if isinstance(cantrips_section, dict):
            cantrip_list = self._normalize_spell_slug_list(cantrips_section.get("known"))
        known_cantrips_source = source.get("known_cantrips")
        if known_cantrips_source is None and cantrip_list:
            known_cantrips_source = len(cantrip_list)
        known_cantrips = normalize_limit(known_cantrips_source, 0)
        known_spells = normalize_limit(source.get("known_spells", source.get("spells")), 15)
        raw_names = source.get("known_spell_names")
        names = self._normalize_spell_slug_list(raw_names)
        if cantrip_list:
            for cantrip in cantrip_list:
                if cantrip not in names:
                    names.append(cantrip)
        known_section = source.get("known_spells")
        known_limit = None
        known_list: List[str] = []
        if isinstance(known_section, dict):
            known_limit = known_section.get("max")
            known_list = self._normalize_spell_slug_list(known_section.get("known"))
        known_enabled = source.get("known_enabled")
        if known_enabled is None and isinstance(known_section, dict):
            known_enabled = True
        if isinstance(known_enabled, str):
            known_enabled = known_enabled.strip().lower() not in ("false", "0", "no", "off")
        known_enabled = bool(known_enabled)
        prepared_payload: Dict[str, Any] = {}
        prepared_spells = source.get("prepared_spells")
        prepared_names: List[str] = []
        prepared_formula = ""
        if isinstance(prepared_spells, dict):
            prepared_names = self._normalize_spell_slug_list(prepared_spells.get("prepared"))
            prepared_payload["prepared"] = prepared_names
            max_formula = prepared_spells.get("max_formula")
            if isinstance(max_formula, str) and max_formula.strip():
                prepared_payload["max_formula"] = max_formula.strip()
                prepared_formula = max_formula.strip()
            if "max" in prepared_spells:
                prepared_payload["max"] = normalize_limit(prepared_spells.get("max"), 0)
            if "max_spells" in prepared_spells:
                prepared_payload["max_spells"] = normalize_limit(
                    prepared_spells.get("max_spells"), 0
                )
            if "max_prepared" in prepared_spells:
                prepared_payload["max_prepared"] = normalize_limit(
                    prepared_spells.get("max_prepared"), 0
                )
        elif include_missing_prepared:
            prepared_payload["prepared"] = []
        payload = {
            "known_cantrips": known_cantrips,
            "known_spells": known_spells,
            "known_spell_names": names,
            "known_enabled": known_enabled,
            "known_limit": int(known_limit) if str(known_limit).isdigit() else None,
            "prepared_limit_formula": prepared_formula,
            "known_list": known_list,
            "prepared_list": prepared_names,
            "cantrips_list": cantrip_list,
        }
        if prepared_payload:
            payload["prepared_spells"] = prepared_payload
        spellcasting_payload: Dict[str, Any] = {
            "cantrips": known_cantrips,
            "known_spells": known_spells,
            "known_spell_names": names,
            "known_enabled": known_enabled,
            "known_limit": int(known_limit) if str(known_limit).isdigit() else None,
            "prepared_limit_formula": prepared_formula,
            "known_list": known_list,
            "prepared_list": prepared_names,
            "cantrips_list": cantrip_list,
        }
        if prepared_payload:
            spellcasting_payload["prepared_spells"] = prepared_payload
        pool_casts = self._player_pool_granted_spells(data)
        if pool_casts:
            spellcasting_payload["pool_granted_spells"] = copy.deepcopy(pool_casts)
            payload["pool_granted_spells"] = copy.deepcopy(pool_casts)
        payload["spellcasting"] = spellcasting_payload
        return payload

    def _normalize_player_resource_pools(self, data: Dict[str, Any]) -> List[Dict[str, Any]]:
        resources = data.get("resources") if isinstance(data.get("resources"), dict) else {}
        pools = resources.get("pools") if isinstance(resources.get("pools"), list) else []
        normalized: List[Dict[str, Any]] = []
        druid_level = self._druid_level_from_profile(data)
        fighter_level = self._fighter_level_from_profile(data)
        paladin_level = self._class_level_from_profile(data, "paladin")
        monk_level = self._class_level_from_profile(data, "monk")
        wild_shape_max = self._wild_shape_max_uses_for_level(druid_level)
        second_wind_max = self._second_wind_max_uses_for_level(fighter_level)
        lay_on_hands_max = max(0, int(paladin_level) * 5)
        seen_pool_ids: set[str] = set()
        for entry in pools:
            if not isinstance(entry, dict):
                continue
            pool_id = str(entry.get("id") or "").strip()
            if not pool_id:
                continue
            seen_pool_ids.add(pool_id.lower())
            label = str(entry.get("label") or pool_id).strip() or pool_id
            reset = str(entry.get("reset") or "manual").strip().lower() or "manual"
            max_formula = str(entry.get("max_formula") or "").strip()
            max_value = self._compute_resource_pool_max(data, max_formula, entry.get("max"))
            if pool_id.lower() == "wild_shape":
                label = "Wild Shape"
                reset = "long_rest"
                max_formula = "max(2, min(4, 2 + floor(druid_level / 3)))"
                max_value = wild_shape_max
            if pool_id.lower() == "second_wind":
                label = "Second Wind"
                reset = "short_rest"
                max_formula = "2 + (1 if fighter_level >= 4 else 0) + (1 if fighter_level >= 10 else 0)"
                max_value = second_wind_max
            if pool_id.lower() == "lay_on_hands":
                label = "Lay on Hands"
                reset = "long_rest"
                max_formula = "paladin_level * 5"
                max_value = lay_on_hands_max
            try:
                current_value = int(entry.get("current", max_value))
            except Exception:
                current_value = max_value
            current_value = max(0, min(current_value, max_value))
            payload = {
                "id": pool_id,
                "label": label,
                "current": current_value,
                "max": max_value,
                "max_formula": max_formula,
                "reset": reset,
            }
            if int(entry.get("gain_on_short") or 0) > 0:
                payload["gain_on_short"] = int(entry.get("gain_on_short") or 0)
            if pool_id.lower() == "wild_shape":
                payload["gain_on_short"] = 1
            if pool_id.lower() == "second_wind":
                payload["gain_on_short"] = 1
            normalized.append(payload)
        if druid_level >= 2 and "wild_shape" not in seen_pool_ids:
            normalized.append(
                {
                    "id": "wild_shape",
                    "label": "Wild Shape",
                    "current": wild_shape_max,
                    "max": wild_shape_max,
                    "max_formula": "max(2, min(4, 2 + floor(druid_level / 3)))",
                    "reset": "long_rest",
                    "gain_on_short": 1,
                }
            )
        if fighter_level >= 1 and "second_wind" not in seen_pool_ids:
            normalized.append(
                {
                    "id": "second_wind",
                    "label": "Second Wind",
                    "current": second_wind_max,
                    "max": second_wind_max,
                    "max_formula": "2 + (1 if fighter_level >= 4 else 0) + (1 if fighter_level >= 10 else 0)",
                    "reset": "short_rest",
                    "gain_on_short": 1,
                }
            )
        if monk_level >= 2 and "focus_points" not in seen_pool_ids:
            normalized.append(
                {
                    "id": "focus_points",
                    "label": "Focus Points",
                    "current": monk_level,
                    "max": monk_level,
                    "max_formula": "monk_level",
                    "reset": "short_rest",
                }
            )
        if paladin_level >= 1 and "lay_on_hands" not in seen_pool_ids:
            normalized.append(
                {
                    "id": "lay_on_hands",
                    "label": "Lay on Hands",
                    "current": lay_on_hands_max,
                    "max": lay_on_hands_max,
                    "max_formula": "paladin_level * 5",
                    "reset": "long_rest",
                }
            )
        return normalized

    def _compute_resource_pool_max(self, profile: Dict[str, Any], formula: Any, fallback: Any) -> int:
        try:
            fallback_value = int(fallback)
        except Exception:
            fallback_value = 0
        fallback_value = max(0, fallback_value)
        if not isinstance(formula, str) or not formula.strip():
            return fallback_value
        abilities = profile.get("abilities") if isinstance(profile.get("abilities"), dict) else {}
        leveling = profile.get("leveling") if isinstance(profile.get("leveling"), dict) else {}
        proficiency = profile.get("proficiency") if isinstance(profile.get("proficiency"), dict) else {}
        level_value = self._coerce_level_value(leveling)
        if level_value > 0:
            prof_bonus = self._proficiency_bonus_for_level(level_value)
        else:
            try:
                prof_bonus = int(proficiency.get("bonus"))
            except Exception:
                prof_bonus = 0
        variables = {
            "level": level_value,
            "druid_level": self._druid_level_from_profile(profile),
            "fighter_level": self._fighter_level_from_profile(profile),
            "barbarian_level": self._class_level_from_profile(profile, "barbarian"),
            "rogue_level": self._class_level_from_profile(profile, "rogue"),
            "monk_level": self._class_level_from_profile(profile, "monk"),
            "wizard_level": self._class_level_from_profile(profile, "wizard"),
            "cleric_level": self._class_level_from_profile(profile, "cleric"),
            "paladin_level": self._class_level_from_profile(profile, "paladin"),
            "prof": prof_bonus,
            "proficiency": prof_bonus,
            "str_mod": self._ability_score_modifier(abilities, "str"),
            "dex_mod": self._ability_score_modifier(abilities, "dex"),
            "con_mod": self._ability_score_modifier(abilities, "con"),
            "int_mod": self._ability_score_modifier(abilities, "int"),
            "wis_mod": self._ability_score_modifier(abilities, "wis"),
            "cha_mod": self._ability_score_modifier(abilities, "cha"),
        }
        result = self._evaluate_spell_formula(formula, variables)
        if result is None:
            return fallback_value
        return max(0, int(math.floor(result)))

    def _feature_runtime_from_profile(self, profile: Dict[str, Any]) -> Dict[str, Any]:
        features_raw = profile.get("features")
        features = features_raw if isinstance(features_raw, list) else []
        compiled_actions: Dict[str, List[Dict[str, Any]]] = {"actions": [], "bonus_actions": [], "reactions": []}
        feature_state: Dict[str, Dict[str, Any]] = {}
        effects: Dict[str, List[Dict[str, Any]]] = {"modifiers": [], "damage_riders": []}

        def _activation_bucket(value: Any, default_bucket: str = "actions") -> str:
            key = str(value or "").strip().lower()
            if key in ("reaction", "reactions"):
                return "reactions"
            if key in ("bonus", "bonus_action", "bonus actions", "bonus-action"):
                return "bonus_actions"
            return default_bucket

        for index, feature in enumerate(features):
            if not isinstance(feature, dict):
                continue
            feature_id = str(feature.get("id") or f"feature_{index + 1}").strip() or f"feature_{index + 1}"
            feature_name = str(feature.get("name") or feature_id).strip() or feature_id
            grants = feature.get("grants") if isinstance(feature.get("grants"), dict) else {}
            automation = feature.get("automation") if isinstance(feature.get("automation"), dict) else {}
            automation_grants = automation.get("grants") if isinstance(automation.get("grants"), dict) else {}
            state_entry: Dict[str, Any] = {}
            for key in ("selection", "enabled_if", "subclass", "source"):
                if key in feature:
                    state_entry[key] = copy.deepcopy(feature.get(key))
            if "enabled_if" in automation:
                state_entry["automation_enabled_if"] = copy.deepcopy(automation.get("enabled_if"))
            if state_entry:
                feature_state[feature_id] = state_entry

            for source_grants in (grants, automation_grants):
                action_entries = source_grants.get("actions") if isinstance(source_grants.get("actions"), list) else []
                reaction_entries = source_grants.get("reactions") if isinstance(source_grants.get("reactions"), list) else []
                for action_entry in action_entries:
                    if not isinstance(action_entry, dict):
                        continue
                    action_name = str(action_entry.get("name") or action_entry.get("id") or "").strip()
                    if not action_name:
                        self._oplog(
                            f"Player YAML {profile.get('name') or 'unknown'}: feature '{feature_name}' has grants.actions entry missing name.",
                            level="warning",
                        )
                        continue
                    bucket = _activation_bucket(action_entry.get("activation"), "actions")
                    payload = {
                        "id": str(action_entry.get("id") or "").strip(),
                        "name": action_name,
                        "description": str(action_entry.get("description") or action_entry.get("desc") or "").strip(),
                        "type": "reaction" if bucket == "reactions" else ("bonus_action" if bucket == "bonus_actions" else "action"),
                        "source_feature_id": feature_id,
                        "source_feature_name": feature_name,
                        "feature_state": copy.deepcopy(state_entry),
                    }
                    for key in ("effect", "slot_level", "consume_one_of", "automation"):
                        if key in action_entry:
                            payload[key] = copy.deepcopy(action_entry.get(key))
                    consumes = action_entry.get("consumes") if isinstance(action_entry.get("consumes"), dict) else {}
                    pool_id = str(consumes.get("pool") or consumes.get("id") or "").strip()
                    if pool_id:
                        try:
                            pool_cost = int(consumes.get("cost", 1))
                        except Exception:
                            pool_cost = 1
                        payload["uses"] = {"pool": pool_id, "cost": max(1, pool_cost)}
                    compiled_actions[bucket].append(payload)
                for reaction_entry in reaction_entries:
                    if not isinstance(reaction_entry, dict):
                        continue
                    reaction_name = str(reaction_entry.get("name") or reaction_entry.get("id") or "").strip()
                    if not reaction_name:
                        continue
                    payload = {
                        "id": str(reaction_entry.get("id") or "").strip(),
                        "name": reaction_name,
                        "description": str(reaction_entry.get("description") or reaction_entry.get("desc") or "").strip(),
                        "type": "reaction",
                        "source_feature_id": feature_id,
                        "source_feature_name": feature_name,
                        "feature_state": copy.deepcopy(state_entry),
                    }
                    consumes = reaction_entry.get("consumes") if isinstance(reaction_entry.get("consumes"), dict) else {}
                    pool_id = str(consumes.get("pool") or consumes.get("id") or "").strip()
                    if pool_id:
                        try:
                            pool_cost = int(consumes.get("cost", 1))
                        except Exception:
                            pool_cost = 1
                        payload["uses"] = {"pool": pool_id, "cost": max(1, pool_cost)}
                    compiled_actions["reactions"].append(payload)
                modifiers = source_grants.get("modifiers") if isinstance(source_grants.get("modifiers"), list) else []
                for modifier in modifiers:
                    if isinstance(modifier, dict):
                        effects["modifiers"].append({**copy.deepcopy(modifier), "source_feature_id": feature_id})
                riders = source_grants.get("damage_riders") if isinstance(source_grants.get("damage_riders"), list) else []
                for rider in riders:
                    if isinstance(rider, dict):
                        effects["damage_riders"].append({**copy.deepcopy(rider), "source_feature_id": feature_id})

            if isinstance(automation, dict) and isinstance(automation.get("extra_damage"), dict):
                converted = {
                    "id": str(feature.get("id") or feature.get("name") or "").strip().lower() or f"feature_{index + 1}",
                    "source_feature_id": feature_id,
                    "trigger": copy.deepcopy(automation.get("applies_to")),
                    "once_per_turn": bool(automation.get("once_per_turn")),
                    "requires_any": copy.deepcopy(automation.get("requires_any")),
                    "blocked_if": copy.deepcopy(automation.get("blocked_if")),
                    "damage_formula": copy.deepcopy((automation.get("extra_damage") or {}).get("formula")),
                    "dice_pool": copy.deepcopy((automation.get("extra_damage") or {}).get("dice_pool")),
                    "damage_type": copy.deepcopy((automation.get("extra_damage") or {}).get("damage_type")),
                }
                effects["damage_riders"].append(converted)
        return {
            "features": [dict(entry) for entry in features if isinstance(entry, dict)],
            "feature_state": feature_state,
            "feature_effects": effects,
            "compiled_actions": compiled_actions,
        }

    def _player_pool_granted_spells(self, profile: Dict[str, Any]) -> List[Dict[str, Any]]:
        pools = self._normalize_player_resource_pools(profile)
        pool_by_id = {str(pool.get("id") or "").strip().lower(): pool for pool in pools if isinstance(pool, dict)}
        features = profile.get("features") if isinstance(profile.get("features"), list) else []
        granted: List[Dict[str, Any]] = []
        seen: set[Tuple[str, str, int]] = set()
        player_name = str(profile.get("name") or "").strip() or "unknown"
        for feature in features:
            if not isinstance(feature, dict):
                continue
            feature_name = str(feature.get("name") or feature.get("id") or "feature").strip() or "feature"
            grants = feature.get("grants") if isinstance(feature.get("grants"), dict) else {}
            spells = grants.get("spells") if isinstance(grants.get("spells"), dict) else {}
            casts = spells.get("casts") if isinstance(spells.get("casts"), list) else []
            for cast in casts:
                if not isinstance(cast, dict):
                    continue
                spell_slug = str(cast.get("spell") or cast.get("slug") or cast.get("id") or "").strip().lower()
                if not spell_slug:
                    continue
                consumes = cast.get("consumes") if isinstance(cast.get("consumes"), dict) else {}
                pool_id = str(consumes.get("pool") or "").strip()
                if not pool_id:
                    continue
                pool = pool_by_id.get(pool_id.lower())
                if pool is None:
                    self._oplog(
                        f"Player YAML {player_name}: feature '{feature_name}' references unknown consumes.pool '{pool_id}' for spell '{spell_slug}'.",
                        level="warning",
                    )
                    continue
                try:
                    cost = int(consumes.get("cost", 1))
                except Exception:
                    cost = 1
                cost = max(1, cost)
                action_type = str(cast.get("action_type") or "action").strip().lower() or "action"
                key = (spell_slug, str(pool.get("id") or "").strip().lower(), cost)
                if key in seen:
                    continue
                seen.add(key)
                granted.append(
                    {
                        "spell": spell_slug,
                        "consumes_pool": {
                            "id": str(pool.get("id") or "").strip(),
                            "label": str(pool.get("label") or pool_id).strip() or pool_id,
                            "cost": cost,
                        },
                        "action_type": action_type,
                        "source": feature_name,
                        "always_available": True,
                    }
                )
        return granted

    def _player_resource_pools_payload(self) -> Dict[str, List[Dict[str, Any]]]:
        self._load_player_yaml_cache()
        payload: Dict[str, List[Dict[str, Any]]] = {}
        for name, data in self._player_yaml_data_by_name.items():
            if not isinstance(data, dict):
                continue
            payload[name] = self._normalize_player_resource_pools(data)
        return payload

    def _load_player_yaml_cache(self, force_refresh: bool = False) -> None:
        if not force_refresh:
            now = time.monotonic()
            if self._player_yaml_last_refresh and (
                now - self._player_yaml_last_refresh < self._player_yaml_refresh_interval_s
            ):
                return
        if yaml is None:
            self._player_yaml_cache_by_path = {}
            self._player_yaml_meta_by_path = {}
            self._player_yaml_data_by_name = {}
            self._player_yaml_name_map = {}
            self._player_yaml_dir_signature = None
            self._player_yaml_last_refresh = time.monotonic()
            return

        players_dir = self._players_dir()
        if not players_dir.exists():
            self._player_yaml_cache_by_path = {}
            self._player_yaml_meta_by_path = {}
            self._player_yaml_data_by_name = {}
            self._player_yaml_name_map = {}
            self._player_yaml_dir_signature = None
            self._player_yaml_last_refresh = time.monotonic()
            return

        try:
            files = sorted(list(players_dir.glob("*.yaml")) + list(players_dir.glob("*.yml")))
        except Exception:
            files = []
        index_entries = self._yaml_players_sync_index(files)
        enabled_files: List[Path] = []
        for path in files:
            key = self._yaml_player_key(path, players_dir)
            entry = index_entries.get(key, {})
            if isinstance(entry, dict) and not bool(entry.get("enabled", True)):
                continue
            enabled_files.append(path)
        dir_signature = _directory_signature(players_dir, files)
        enabled_signature = tuple(sorted(path.name for path in enabled_files))
        combined_signature = (dir_signature, enabled_signature)
        if (
            not force_refresh
            and self._player_yaml_cache_by_path
            and combined_signature == self._player_yaml_dir_signature
        ):
            self._player_yaml_last_refresh = time.monotonic()
            return

        data_by_path = dict(self._player_yaml_cache_by_path)
        meta_by_path = dict(self._player_yaml_meta_by_path)
        data_by_name = dict(self._player_yaml_data_by_name)
        name_map = dict(self._player_yaml_name_map)

        def purge_path_entries(target_path: Path) -> None:
            keys_to_remove = [key for key, value in name_map.items() if value == target_path]
            for key in keys_to_remove:
                name_map.pop(key, None)
            if keys_to_remove:
                keys_lower = set(keys_to_remove)
                for name in list(data_by_name.keys()):
                    if name.lower() in keys_lower:
                        data_by_name.pop(name, None)

        valid_paths = set(enabled_files)
        for cached_path in list(data_by_path.keys()):
            if cached_path not in valid_paths:
                data_by_path.pop(cached_path, None)
                meta_by_path.pop(cached_path, None)
                purge_path_entries(cached_path)

        for path in enabled_files:
            meta = _file_stat_metadata(path)
            cached_meta = meta_by_path.get(path)
            if cached_meta and _metadata_matches(cached_meta, meta):
                continue
            try:
                raw = path.read_text(encoding="utf-8")
                parsed = yaml.safe_load(raw)
            except Exception:
                parsed = None
            data_by_path[path] = parsed if isinstance(parsed, dict) else None
            meta_by_path[path] = meta
            purge_path_entries(path)
            if isinstance(parsed, dict):
                profile = self._normalize_player_profile(parsed, path.stem)
                name = str(profile.get("name") or path.stem).strip() or path.stem
                data_by_name[name] = profile
                name_map[self._normalize_character_lookup_key(name)] = path
                name_map[self._normalize_character_lookup_key(path.stem)] = path

        self._player_yaml_cache_by_path = data_by_path
        self._player_yaml_meta_by_path = meta_by_path
        self._player_yaml_data_by_name = data_by_name
        self._player_yaml_name_map = name_map
        self._player_yaml_dir_signature = combined_signature
        self._player_yaml_last_refresh = time.monotonic()
    def _player_spell_config_payload(self) -> Dict[str, Dict[str, Any]]:
        self._load_player_yaml_cache()
        payload: Dict[str, Dict[str, Any]] = {}
        for name, data in self._player_yaml_data_by_name.items():
            if not isinstance(data, dict):
                continue
            payload[name] = self._normalize_player_spell_config(data)
        return payload

    def _player_profiles_payload(self) -> Dict[str, Dict[str, Any]]:
        self._load_player_yaml_cache()
        payload: Dict[str, Dict[str, Any]] = {}
        available_cache = self.__dict__.get("_wild_shape_available_cache")
        if not isinstance(available_cache, dict):
            available_cache = {}
            self._wild_shape_available_cache = available_cache
        cache_source = self.__dict__.get("_wild_shape_available_cache_source")
        if cache_source is not self._wild_shape_beast_cache:
            available_cache.clear()
            self._wild_shape_available_cache_source = self._wild_shape_beast_cache
        for name, data in self._player_yaml_data_by_name.items():
            if not isinstance(data, dict):
                continue
            profile_payload = dict(data)
            spellcasting = profile_payload.get("spellcasting")
            if isinstance(spellcasting, dict):
                if "spell_slots" not in spellcasting:
                    spellcasting = dict(spellcasting)
                    spellcasting["spell_slots"] = self._normalize_spell_slots(None)
                save_dc = self._compute_spell_save_dc(profile_payload)
                if save_dc is not None:
                    spellcasting = dict(spellcasting)
                    spellcasting["save_dc"] = save_dc
                    profile_payload["spellcasting"] = spellcasting
            known_map = self.__dict__.get("_wild_shape_known_by_player", {})
            persisted_known = self._normalized_prepared_wild_shapes_from_profile(profile_payload)
            known_runtime = []
            if isinstance(known_map, dict):
                known_runtime = self._normalize_prepared_wild_shapes(
                    known_map.get(str(name).strip().lower(), []),
                    known_limit=None,
                )
            chosen_known = known_runtime if known_runtime else persisted_known
            druid_level = self._druid_level_from_profile(profile_payload)
            known_limit = self._wild_shape_known_limit(druid_level)
            available: List[Dict[str, Any]] = []
            if druid_level >= 2:
                cached_available = available_cache.get(druid_level)
                if not isinstance(cached_available, list):
                    raw_available = self._wild_shape_available_forms(
                        {
                            "leveling": {"class": "druid", "level": druid_level},
                            "learned_wild_shapes": [],
                        },
                        known_only=False,
                        include_locked=True,
                    )
                    trimmed: List[Dict[str, Any]] = []
                    # Keep LAN payload lightweight to avoid websocket snapshot lag.
                    for entry in raw_available:
                        if not isinstance(entry, dict):
                            continue
                        speed = entry.get("speed") if isinstance(entry.get("speed"), dict) else {}
                        trimmed.append(
                            {
                                "id": str(entry.get("id") or "").strip(),
                                "name": str(entry.get("name") or "").strip(),
                                "challenge_rating": float(entry.get("challenge_rating") or 0.0),
                                "size": str(entry.get("size") or "").strip(),
                                "speed": {
                                    "walk": int(speed.get("walk") or 0),
                                    "swim": int(speed.get("swim") or 0),
                                    "fly": int(speed.get("fly") or 0),
                                    "climb": int(speed.get("climb") or 0),
                                },
                                "allowed": bool(entry.get("allowed", False)),
                            }
                        )
                    available_cache[druid_level] = trimmed
                    cached_available = trimmed
                available = cached_available
            profile_payload["learned_wild_shapes"] = list(chosen_known)
            profile_payload["prepared_wild_shapes"] = list(chosen_known)
            profile_payload["wild_shape_known_limit"] = int(known_limit)
            profile_payload["wild_shape_available_forms"] = available
            payload[name] = profile_payload
        return payload

    def _consume_resource_pool_for_cast(
        self,
        caster_name: str,
        pool_id: Any,
        cost: Any,
    ) -> Tuple[bool, str]:
        player_name = str(caster_name or "").strip()
        target_pool = str(pool_id or "").strip()
        if not player_name or not target_pool:
            return False, "That spell pool be invalid, matey."
        try:
            spend_cost = int(cost)
        except Exception:
            spend_cost = 1
        spend_cost = max(1, spend_cost)

        self._load_player_yaml_cache()
        player_key = self._normalize_character_lookup_key(player_name)
        player_path = self._player_yaml_name_map.get(player_key)
        raw = self._player_yaml_cache_by_path.get(player_path) if player_path else None
        if not isinstance(raw, dict):
            return False, "No resource pools set up for that caster, matey."
        resources = raw.get("resources") if isinstance(raw.get("resources"), dict) else {}
        pools = resources.get("pools") if isinstance(resources.get("pools"), list) else []
        target_entry = None
        for entry in pools:
            if not isinstance(entry, dict):
                continue
            if str(entry.get("id") or "").strip().lower() == target_pool.lower():
                target_entry = entry
                break
        if target_entry is None:
            return False, "That spell pool could not be found, matey."
        try:
            current_value = int(target_entry.get("current", 0))
        except Exception:
            current_value = 0
        if current_value < spend_cost:
            return False, "That resource pool be exhausted, matey."
        target_entry["current"] = current_value - spend_cost
        resources = dict(resources)
        resources["pools"] = pools
        raw = dict(raw)
        raw["resources"] = resources
        try:
            self._store_character_yaml(player_path, raw)
        except Exception:
            return False, "Could not update resource pools, matey."
        return True, ""

    def _set_player_resource_pool_current(self, caster_name: str, pool_id: Any, new_current: Any) -> Tuple[bool, str]:
        player_name = str(caster_name or "").strip()
        target_pool = str(pool_id or "").strip()
        if not player_name or not target_pool:
            return False, "That spell pool be invalid, matey."
        try:
            current_value = max(0, int(new_current))
        except Exception:
            current_value = 0
        self._load_player_yaml_cache()
        player_key = self._normalize_character_lookup_key(player_name)
        player_path = self._player_yaml_name_map.get(player_key)
        raw = self._player_yaml_cache_by_path.get(player_path) if player_path else None
        if not isinstance(raw, dict):
            return False, "No resource pools set up for that caster, matey."
        resources = raw.get("resources") if isinstance(raw.get("resources"), dict) else {}
        pools = resources.get("pools") if isinstance(resources.get("pools"), list) else []
        target_entry = None
        for entry in pools:
            if not isinstance(entry, dict):
                continue
            if str(entry.get("id") or "").strip().lower() == target_pool.lower():
                target_entry = entry
                break
        if target_entry is None:
            return False, "That spell pool could not be found, matey."
        try:
            max_value = int(target_entry.get("max", current_value))
        except Exception:
            max_value = current_value
        if max_value > 0:
            current_value = min(current_value, max_value)
        target_entry["current"] = int(current_value)
        resources = dict(resources)
        resources["pools"] = pools
        raw = dict(raw)
        raw["resources"] = resources
        try:
            self._store_character_yaml(player_path, raw)
        except Exception:
            return False, "Could not update resource pools, matey."
        return True, ""

    def _library_rows_unified(
        self,
        categories: Optional[Iterable[str]] = None,
    ) -> List[Dict[str, Any]]:
        """Return unified reference rows for spells, monsters, and players."""
        allowed = {"spell", "monster", "player"}
        requested = {str(cat).strip().lower() for cat in (categories or allowed) if str(cat).strip()}
        if not requested:
            requested = set(allowed)
        requested &= allowed
        rows: List[Dict[str, Any]] = []

        if "spell" in requested:
            presets = self._spell_presets_payload()
            entries = self._load_spell_index_entries()
            spell_dir = self._resolve_spells_dir()
            for preset in presets:
                if not isinstance(preset, dict):
                    continue
                name = str(preset.get("name") or "").strip()
                if not name:
                    continue
                source_key = str(preset.get("id") or preset.get("slug") or "").strip()
                source_path = None
                slug = str(preset.get("slug") or "").strip()
                if slug:
                    for ext in ("yaml", "yml"):
                        filename = f"{slug}.{ext}"
                        if isinstance(entries.get(filename), dict):
                            source_path = str((spell_dir / filename) if spell_dir else filename)
                            break
                rows.append(
                    {
                        "category": "spell",
                        "name": name,
                        "subtype": str(preset.get("school") or "").strip() or None,
                        "level_or_cr": preset.get("level"),
                        "source_key": source_key or slug or None,
                        "source_path": source_path,
                    }
                )

        if "monster" in requested:
            if not self._monster_specs:
                self._load_monsters_index()
            for spec in self._monster_specs:
                if not isinstance(spec, MonsterSpec):
                    continue
                detailed = self._load_monster_details(spec.name)
                if not detailed:
                    continue
                rows.append(
                    {
                        "category": "monster",
                        "name": detailed.name,
                        "subtype": str(detailed.mtype or "").strip() or None,
                        "level_or_cr": self._monster_cr_display(detailed),
                        "source_key": Path(detailed.filename).stem if detailed.filename else None,
                        "source_path": str(self._monsters_dir_path() / detailed.filename)
                        if detailed.filename
                        else None,
                    }
                )

        if "player" in requested:
            self._load_player_yaml_cache()
            profiles = self._player_profiles_payload()
            for name, profile in profiles.items():
                if not isinstance(profile, dict):
                    continue
                leveling = profile.get("leveling") if isinstance(profile.get("leveling"), dict) else {}
                klass = str(leveling.get("class") or "").strip()
                level_value: Any = leveling.get("level")
                source_path = None
                source_key = str(name).strip().lower() or None
                path = self._find_player_profile_path(name)
                if path is not None:
                    source_key = path.stem
                    source_path = str(path)
                rows.append(
                    {
                        "category": "player",
                        "name": str(name).strip(),
                        "subtype": klass or None,
                        "level_or_cr": level_value,
                        "source_key": source_key,
                        "source_path": source_path,
                    }
                )

        rows.sort(key=lambda row: (str(row.get("category") or ""), str(row.get("name") or "").lower()))
        return rows

    def _spell_library_detail_text(self, preset: Dict[str, Any]) -> str:
        def fmt_bool(value: Any) -> str:
            if isinstance(value, bool):
                return "Yes" if value else "No"
            if value in (None, ""):
                return "Unknown"
            return str(value)

        lines: List[str] = []
        lines.append(str(preset.get("name") or "Unknown Spell"))
        lines.append("")
        lines.append("Spell")
        lines.append(f"Name: {str(preset.get('name') or '').strip() or 'Unknown'}")
        lines.append(f"Level: {preset.get('level') if preset.get('level') is not None else 'Unknown'}")
        lines.append(f"School: {str(preset.get('school') or '').strip() or 'Unknown'}")
        lines.append(f"Casting Time: {str(preset.get('casting_time') or '').strip() or 'Unknown'}")
        lines.append(f"Range: {str(preset.get('range') or '').strip() or 'Unknown'}")
        lines.append(f"Components: {str(preset.get('components') or '').strip() or 'Unknown'}")
        lines.append(f"Duration: {str(preset.get('duration') or '').strip() or 'Unknown'}")
        lines.append(f"Concentration: {fmt_bool(preset.get('concentration'))}")
        lines.append(f"Ritual: {fmt_bool(preset.get('ritual'))}")

        summary_fields = (
            ("Summary", preset.get("summary")),
            ("Rules Text", preset.get("description") or preset.get("rules_text") or preset.get("text")),
        )
        for title, value in summary_fields:
            lines.append("")
            lines.append(title)
            text = self._format_monster_text_block(value)
            if text:
                lines.append(text)
            else:
                lines.append(f"No {title.lower()} available.")

        return "\n".join(lines)

    def _player_library_detail_text(self, name: str, profile: Dict[str, Any]) -> str:
        identity = profile.get("identity") if isinstance(profile.get("identity"), dict) else {}
        leveling = profile.get("leveling") if isinstance(profile.get("leveling"), dict) else {}
        vitals = profile.get("vitals") if isinstance(profile.get("vitals"), dict) else {}
        spellcasting = profile.get("spellcasting") if isinstance(profile.get("spellcasting"), dict) else {}
        defenses = profile.get("defenses") if isinstance(profile.get("defenses"), dict) else {}

        lines: List[str] = []
        lines.append(name)
        lines.append("")
        lines.append("Player")
        lines.append(f"Name: {str(identity.get('name') or profile.get('name') or name).strip() or name}")
        lines.append(f"Race: {str(identity.get('race') or '').strip() or 'Unknown'}")
        lines.append(f"Background: {str(identity.get('background') or '').strip() or 'Unknown'}")
        lines.append(f"Level: {str(leveling.get('level') or '').strip() or 'Unknown'}")
        lines.append(f"Class: {str(leveling.get('class') or '').strip() or 'Unknown'}")
        lines.append(f"Subclass: {str(leveling.get('subclass') or '').strip() or 'Unknown'}")
        lines.append("")
        lines.append("Vitals")
        lines.append(f"HP: {str(vitals.get('current_hp') or defenses.get('hp') or 'Unknown')}")
        lines.append(f"Max HP: {str(vitals.get('max_hp') or 'Unknown')}")
        lines.append(f"Temp HP: {str(vitals.get('temp_hp') or 0)}")
        lines.append(f"Speed: {str(vitals.get('speed') or 'Unknown')}")

        lines.append("")
        lines.append("Spellcasting Highlights")
        ability = str(spellcasting.get("ability") or "").strip()
        lines.append(f"Ability: {ability.upper() if ability else 'Unknown'}")
        lines.append(f"Save DC: {str(spellcasting.get('save_dc') or 'Unknown')}")
        lines.append(f"Attack Bonus: {str(spellcasting.get('attack_bonus') or 'Unknown')}")
        slots = spellcasting.get("spell_slots") if isinstance(spellcasting.get("spell_slots"), dict) else {}
        if slots:
            slot_parts: List[str] = []
            for lvl in sorted(slots.keys(), key=lambda val: int(val) if str(val).isdigit() else 99):
                item = slots.get(lvl)
                if not isinstance(item, dict):
                    continue
                cur = item.get("current")
                maxv = item.get("max")
                slot_parts.append(f"L{lvl}: {cur}/{maxv}")
            lines.append("Spell Slots: " + (", ".join(slot_parts) if slot_parts else "Unknown"))
        else:
            lines.append("Spell Slots: None configured")

        prepared = spellcasting.get("prepared_spells")
        if isinstance(prepared, dict):
            known = prepared.get("known") if isinstance(prepared.get("known"), list) else []
            prepared_list = prepared.get("prepared") if isinstance(prepared.get("prepared"), list) else []
            lines.append(f"Known Spells: {len(known)}")
            lines.append(f"Prepared Spells: {len(prepared_list)}")

        return "\n".join(lines)

    def _open_monster_library(self) -> None:
        self._load_monsters_index()
        self._load_player_yaml_cache()

        win = tk.Toplevel(self)
        win.title("Library")
        win.geometry("960x640")
        win.minsize(900, 600)
        win.transient(self)
        win.after(0, win.lift)

        root = ttk.Frame(win, padding=10)
        root.pack(fill=tk.BOTH, expand=True)
        root.columnconfigure(0, weight=1)
        root.rowconfigure(1, weight=1)

        controls = ttk.Frame(root)
        controls.grid(row=0, column=0, sticky="ew", pady=(0, 8))
        for idx in range(10):
            controls.columnconfigure(idx, weight=0)
        controls.columnconfigure(7, weight=1)

        ttk.Label(controls, text="Category").grid(row=0, column=0, sticky="w")
        category_var = tk.StringVar(value="All")
        category_box = ttk.Combobox(
            controls,
            textvariable=category_var,
            values=["All", "Spell", "Monster", "Player"],
            width=10,
            state="readonly",
        )
        category_box.grid(row=0, column=1, sticky="w", padx=(6, 12))

        ttk.Label(controls, text="Sort").grid(row=0, column=2, sticky="w")
        sort_var = tk.StringVar(value="Name")
        sort_box = ttk.Combobox(
            controls,
            textvariable=sort_var,
            values=["Name", "Category", "Level/CR", "School/Type"],
            width=14,
            state="readonly",
        )
        sort_box.grid(row=0, column=3, sticky="w", padx=(6, 12))

        ttk.Label(controls, text="Search").grid(row=0, column=4, sticky="w")
        search_var = tk.StringVar()
        search_entry = ttk.Entry(controls, textvariable=search_var)
        search_entry.grid(row=0, column=5, columnspan=3, sticky="ew", padx=(6, 12))

        info_btn = ttk.Button(controls, text="Info")
        info_btn.grid(row=0, column=8, sticky="e", padx=(0, 6))
        ttk.Button(controls, text="Reload", command=lambda: self._monster_library_reload(win)).grid(
            row=0,
            column=9,
            sticky="e",
        )

        paned = ttk.PanedWindow(root, orient=tk.HORIZONTAL)
        paned.grid(row=1, column=0, sticky="nsew")

        left = ttk.Frame(paned)
        left.columnconfigure(0, weight=1)
        left.rowconfigure(0, weight=1)

        cols = ("category", "name", "level", "subtype")
        tree = ttk.Treeview(left, columns=cols, show="headings")
        tree.heading("category", text="Category")
        tree.heading("name", text="Name")
        tree.heading("level", text="Level/CR")
        tree.heading("subtype", text="School/Type/Class")
        tree.column("category", width=90, anchor="w")
        tree.column("name", width=280, anchor="w")
        tree.column("level", width=90, anchor="center")
        tree.column("subtype", width=170, anchor="w")
        y_scroll = ttk.Scrollbar(left, orient="vertical", command=tree.yview)
        tree.configure(yscrollcommand=y_scroll.set)
        tree.grid(row=0, column=0, sticky="nsew")
        y_scroll.grid(row=0, column=1, sticky="ns")

        right = ttk.Frame(paned)
        right.columnconfigure(0, weight=1)
        right.rowconfigure(0, weight=1)
        detail = tk.Text(right, wrap="word")
        detail_scroll = ttk.Scrollbar(right, orient="vertical", command=detail.yview)
        detail.configure(yscrollcommand=detail_scroll.set, state="disabled")
        detail.grid(row=0, column=0, sticky="nsew")
        detail_scroll.grid(row=0, column=1, sticky="ns")

        paned.add(left, weight=3)
        paned.add(right, weight=4)

        presets = [p for p in self._spell_presets_payload() if isinstance(p, dict)]
        spells_by_key: Dict[str, Dict[str, Any]] = {}
        for spell in presets:
            for key_name in (spell.get("id"), spell.get("slug"), spell.get("name")):
                key = str(key_name or "").strip().lower()
                if key and key not in spells_by_key:
                    spells_by_key[key] = spell

        profiles = self._player_profiles_payload()

        all_rows = self._library_rows_unified(categories=("spell", "monster", "player"))

        def parse_sort_num(value: Any) -> float:
            if value is None:
                return 1e9
            try:
                txt = str(value).strip()
                if "/" in txt:
                    num, den = txt.split("/", 1)
                    return float(num) / float(den)
                return float(txt)
            except Exception:
                return 1e9

        def filtered_rows() -> List[Dict[str, Any]]:
            cat_sel = category_var.get().strip().lower()
            query = search_var.get().strip().lower()
            rows = list(all_rows)
            if cat_sel and cat_sel != "all":
                rows = [r for r in rows if str(r.get("category") or "").lower() == cat_sel]
            if query:
                rows = [
                    r
                    for r in rows
                    if query in str(r.get("name") or "").lower()
                    or query in str(r.get("subtype") or "").lower()
                    or query in str(r.get("level_or_cr") or "").lower()
                    or query in str(r.get("category") or "").lower()
                ]

            sort_sel = sort_var.get().strip().lower()
            if sort_sel == "category":
                rows.sort(key=lambda r: (str(r.get("category") or ""), str(r.get("name") or "").lower()))
            elif sort_sel == "level/cr":
                rows.sort(
                    key=lambda r: (
                        parse_sort_num(r.get("level_or_cr")),
                        str(r.get("name") or "").lower(),
                    )
                )
            elif sort_sel == "school/type":
                rows.sort(
                    key=lambda r: (
                        str(r.get("subtype") or "").lower(),
                        str(r.get("name") or "").lower(),
                    )
                )
            else:
                rows.sort(key=lambda r: str(r.get("name") or "").lower())
            return rows

        item_map: Dict[str, Dict[str, Any]] = {}

        def render_detail_for_row(row: Dict[str, Any]) -> str:
            category = str(row.get("category") or "").lower()
            name = str(row.get("name") or "").strip()
            if category == "monster":
                spec = self._load_monster_details(name)
                if spec and spec.raw_data:
                    return self._monster_stat_block_text(spec)
                return f"No monster details available for {name}."

            if category == "spell":
                source_key = str(row.get("source_key") or "").strip().lower()
                spell = spells_by_key.get(source_key) or spells_by_key.get(name.lower())
                if isinstance(spell, dict):
                    return self._spell_library_detail_text(spell)
                return f"No spell details available for {name}."

            if category == "player":
                profile = profiles.get(name)
                if isinstance(profile, dict):
                    return self._player_library_detail_text(name, profile)
                return f"No player profile details available for {name}."

            return "Select a library entry to view details."

        def set_detail_text(text_value: str) -> None:
            detail.configure(state="normal")
            detail.delete("1.0", tk.END)
            detail.insert("1.0", text_value)
            detail.configure(state="disabled")

        def refresh_rows() -> None:
            item_map.clear()
            tree.delete(*tree.get_children())
            for idx, row in enumerate(filtered_rows()):
                iid = f"row-{idx}"
                item_map[iid] = row
                tree.insert(
                    "",
                    "end",
                    iid=iid,
                    values=(
                        str(row.get("category") or "").title(),
                        str(row.get("name") or ""),
                        "" if row.get("level_or_cr") is None else str(row.get("level_or_cr")),
                        str(row.get("subtype") or ""),
                    ),
                )
            items = tree.get_children()
            if items:
                tree.selection_set(items[0])
                tree.focus(items[0])
                on_select()
            else:
                set_detail_text("No library entries match the current filters.")

        def on_select(_event: Optional[tk.Event] = None) -> None:
            sel = tree.selection()
            if not sel:
                return
            row = item_map.get(sel[0])
            if not isinstance(row, dict):
                return
            set_detail_text(render_detail_for_row(row))

        def open_info() -> None:
            sel = tree.selection()
            if not sel:
                return
            row = item_map.get(sel[0])
            if not isinstance(row, dict):
                return
            if str(row.get("category") or "").lower() == "monster":
                spec = self._load_monster_details(str(row.get("name") or ""))
                self._open_monster_stat_block(spec)
            else:
                messagebox.showinfo("Library Info", render_detail_for_row(row), parent=win)

        def on_double_click(_event: Optional[tk.Event] = None) -> None:
            sel = tree.selection()
            if not sel:
                return
            row = item_map.get(sel[0])
            if not isinstance(row, dict):
                return
            if str(row.get("category") or "").lower() != "monster":
                return
            nm = str(row.get("name") or "").strip()
            if nm:
                self.name_var.set(nm)
                self._on_monster_selected()
                try:
                    win.destroy()
                except Exception:
                    pass

        info_btn.configure(command=open_info)
        tree.bind("<<TreeviewSelect>>", on_select)
        tree.bind("<Double-1>", on_double_click)
        category_box.bind("<<ComboboxSelected>>", lambda _e: refresh_rows())
        sort_box.bind("<<ComboboxSelected>>", lambda _e: refresh_rows())
        search_var.trace_add("write", lambda *_args: refresh_rows())

        refresh_rows()
        search_entry.focus_set()

    def _reset_player_character_resources(self) -> Dict[str, int]:
        def to_int(value: Any, fallback: Optional[int] = None) -> Optional[int]:
            try:
                return int(value)
            except Exception:
                return fallback

        self._load_player_yaml_cache()
        updated: Dict[str, int] = {}
        for name in list(self._player_yaml_data_by_name.keys()):
            if not isinstance(name, str):
                continue
            path = self._find_player_profile_path(name)
            if path is None:
                continue
            raw = self._player_yaml_cache_by_path.get(path)
            if not isinstance(raw, dict):
                raw = {}

            vitals = raw.get("vitals")
            if not isinstance(vitals, dict):
                vitals = {}
            max_hp_value = to_int(vitals.get("max_hp"), None)
            if max_hp_value is None:
                max_hp_value = to_int(vitals.get("current_hp"), 0)
            vitals["current_hp"] = max_hp_value
            vitals["temp_hp"] = 0
            raw["vitals"] = vitals

            spellcasting = raw.get("spellcasting")
            if not isinstance(spellcasting, dict):
                spellcasting = {}
            raw_spell_slots = None
            if "spell_slots" in spellcasting:
                raw_spell_slots = spellcasting.get("spell_slots")
            elif "spell_slots" in raw:
                raw_spell_slots = raw.get("spell_slots")
            slots = self._normalize_spell_slots(raw_spell_slots)
            for entry in slots.values():
                entry["current"] = int(entry.get("max", 0) or 0)
            spellcasting = dict(spellcasting)
            spellcasting["spell_slots"] = slots
            raw["spellcasting"] = spellcasting
            if "spell_slots" in raw:
                raw["spell_slots"] = slots

            resources = raw.get("resources")
            if isinstance(resources, dict):
                pools = resources.get("pools") if isinstance(resources.get("pools"), list) else []
                for pool in pools:
                    if not isinstance(pool, dict):
                        continue
                    reset = str(pool.get("reset") or "").strip().lower()
                    if reset not in ("short_rest", "long_rest", "dawn", "dusk"):
                        continue
                    pool_max = self._compute_resource_pool_max(raw, pool.get("max_formula"), pool.get("max"))
                    pool["current"] = pool_max
                resources = dict(resources)
                resources["pools"] = pools
                raw["resources"] = resources

            self._store_character_yaml(path, raw)
            updated[name.lower()] = int(max_hp_value or 0)
        for cid, combatant in list(self.combatants.items()):
            if bool(getattr(combatant, "is_wild_shaped", False)):
                self._revert_wild_shape(int(cid))
            setattr(combatant, "wild_resurgence_turn_used", False)
            setattr(combatant, "wild_resurgence_slot_used", False)
        return updated

    def _save_player_spell_config(self, name: str, payload: Dict[str, Any]) -> Dict[str, Any]:
        if yaml is None:
            raise RuntimeError("PyYAML is required for spell persistence.")
        player_name = str(name or "").strip()
        if not player_name:
            raise ValueError("Player name is required.")
        if not isinstance(payload, dict):
            raise ValueError("Payload must be a dictionary.")
        self._load_player_yaml_cache()
        path = self._find_player_profile_path(name)
        if path is None:
            players_dir = self._players_dir()
            players_dir.mkdir(parents=True, exist_ok=True)
            filename = f"{self._sanitize_player_filename(player_name)}.yaml"
            path = players_dir / filename

        existing = self._player_yaml_cache_by_path.get(path) or {}
        if not isinstance(existing, dict):
            existing = {}

        normalized = self._normalize_player_spell_config(payload, include_missing_prepared=False)
        prepared_payload = normalized.get("prepared_spells")
        spellcasting_payload = normalized.get("spellcasting")
        normalized_known = {
            k: v for k, v in normalized.items() if k not in ("prepared_spells", "spellcasting")
        }

        if int(existing.get("format_version") or 0) == 1:
            spellcasting = existing.get("spellcasting")
            if not isinstance(spellcasting, dict):
                spellcasting = {}
            spellcasting.update(normalized_known)
            if isinstance(spellcasting_payload, dict):
                spellcasting.update(spellcasting_payload)
            if prepared_payload is not None:
                existing_prepared = spellcasting.get("prepared_spells")
                if not isinstance(existing_prepared, dict):
                    existing_prepared = {}
                existing_prepared.update(prepared_payload)
                spellcasting["prepared_spells"] = existing_prepared
            existing["spellcasting"] = spellcasting
            identity = existing.get("identity")
            if not isinstance(identity, dict):
                identity = {}
            if "name" not in identity:
                identity["name"] = player_name
            existing["identity"] = identity
        else:
            if "name" not in existing:
                existing["name"] = player_name
            existing.update(normalized_known)
            if prepared_payload is not None:
                existing_prepared = existing.get("prepared_spells")
                if not isinstance(existing_prepared, dict):
                    existing_prepared = {}
                existing_prepared.update(prepared_payload)
                existing["prepared_spells"] = existing_prepared
            spellcasting = existing.get("spellcasting")
            if not isinstance(spellcasting, dict):
                spellcasting = {}
            spellcasting.update(normalized_known)
            if isinstance(spellcasting_payload, dict):
                spellcasting.update(spellcasting_payload)
            if prepared_payload is not None:
                existing_prepared = spellcasting.get("prepared_spells")
                if not isinstance(existing_prepared, dict):
                    existing_prepared = {}
                existing_prepared.update(prepared_payload)
                spellcasting["prepared_spells"] = existing_prepared
            existing["spellcasting"] = spellcasting

        self._write_player_yaml_atomic(path, existing)

        meta = _file_stat_metadata(path)
        self._player_yaml_cache_by_path[path] = existing
        self._player_yaml_meta_by_path[path] = meta
        profile = self._normalize_player_profile(existing, path.stem)
        profile_name = profile.get("name", player_name)
        self._player_yaml_data_by_name[profile_name] = profile
        self._player_yaml_name_map[self._normalize_character_lookup_key(player_name)] = path
        self._player_yaml_name_map[self._normalize_character_lookup_key(path.stem)] = path
        self._schedule_player_yaml_refresh()

        return normalized

    def _save_player_spell_slots(self, name: str, payload: Dict[str, Any]) -> Dict[str, Any]:
        if yaml is None:
            raise RuntimeError("PyYAML is required for spell persistence.")
        player_name = str(name or "").strip()
        if not player_name:
            raise ValueError("Player name is required.")
        if not isinstance(payload, dict):
            raise ValueError("Payload must be a dictionary.")

        self._load_player_yaml_cache()
        path = self._find_player_profile_path(name)
        if path is None:
            players_dir = self._players_dir()
            players_dir.mkdir(parents=True, exist_ok=True)
            filename = f"{self._sanitize_player_filename(player_name)}.yaml"
            path = players_dir / filename

        existing = self._player_yaml_cache_by_path.get(path) or {}
        if not isinstance(existing, dict):
            existing = {}

        normalized_slots = self._normalize_spell_slots(payload)
        if int(existing.get("format_version") or 0) == 1:
            spellcasting = existing.get("spellcasting")
            if not isinstance(spellcasting, dict):
                spellcasting = {}
            spellcasting["spell_slots"] = normalized_slots
            existing["spellcasting"] = spellcasting
            identity = existing.get("identity")
            if not isinstance(identity, dict):
                identity = {}
            if "name" not in identity:
                identity["name"] = player_name
            existing["identity"] = identity
        else:
            if "name" not in existing:
                existing["name"] = player_name
            spellcasting = existing.get("spellcasting")
            if not isinstance(spellcasting, dict):
                spellcasting = {}
            spellcasting["spell_slots"] = normalized_slots
            existing["spellcasting"] = spellcasting

        self._write_player_yaml_atomic(path, existing)

        meta = _file_stat_metadata(path)
        self._player_yaml_cache_by_path[path] = existing
        self._player_yaml_meta_by_path[path] = meta
        profile = self._normalize_player_profile(existing, path.stem)
        profile_name = profile.get("name", player_name)
        self._player_yaml_data_by_name[profile_name] = profile
        self._player_yaml_name_map[self._normalize_character_lookup_key(player_name)] = path
        self._player_yaml_name_map[self._normalize_character_lookup_key(path.stem)] = path
        self._schedule_player_yaml_refresh()

        return normalized_slots

    def _save_player_spellbook(self, name: str, payload: Dict[str, Any]) -> Dict[str, Any]:
        if yaml is None:
            raise RuntimeError("PyYAML is required for spell persistence.")
        player_name = str(name or "").strip()
        if not player_name:
            raise ValueError("Player name is required.")
        if not isinstance(payload, dict):
            raise ValueError("Payload must be a dictionary.")

        def normalize_slug_list(value: Any) -> List[str]:
            if isinstance(value, list):
                raw = [str(item).strip() for item in value if str(item or "").strip()]
            elif isinstance(value, str):
                raw = [value.strip()] if value.strip() else []
            else:
                raw = []
            seen = set()
            out: List[str] = []
            for item in raw:
                key = item.lower()
                if key in seen:
                    continue
                seen.add(key)
                out.append(item)
            return out

        known_enabled = payload.get("known_enabled")
        if isinstance(known_enabled, str):
            known_enabled = known_enabled.strip().lower() not in ("false", "0", "no", "off")
        known_enabled = bool(known_enabled)
        known_list = normalize_slug_list(payload.get("known_list"))
        prepared_list = normalize_slug_list(payload.get("prepared_list"))
        cantrips_list = normalize_slug_list(payload.get("cantrips_list"))

        self._load_player_yaml_cache()
        path = self._find_player_profile_path(name)
        if path is None:
            players_dir = self._players_dir()
            players_dir.mkdir(parents=True, exist_ok=True)
            filename = f"{self._sanitize_player_filename(player_name)}.yaml"
            path = players_dir / filename

        existing = self._player_yaml_cache_by_path.get(path) or {}
        if not isinstance(existing, dict):
            existing = {}

        spellcasting = existing.get("spellcasting")
        if not isinstance(spellcasting, dict):
            spellcasting = {}
        spellcasting["known_enabled"] = known_enabled

        cantrips = spellcasting.get("cantrips")
        if not isinstance(cantrips, dict):
            cantrips = {}
        cantrips["known"] = cantrips_list
        spellcasting["cantrips"] = cantrips

        prepared_spells = spellcasting.get("prepared_spells")
        if not isinstance(prepared_spells, dict):
            prepared_spells = {}
        prepared_spells["prepared"] = prepared_list
        prepared_set = {item.lower() for item in prepared_list}
        prepared_free = [item for item in normalize_slug_list(prepared_spells.get("free")) if item.lower() in prepared_set]
        if prepared_free:
            prepared_spells["free"] = prepared_free
        else:
            prepared_spells.pop("free", None)
        spellcasting["prepared_spells"] = prepared_spells

        known_spells = spellcasting.get("known_spells")
        if not isinstance(known_spells, dict):
            known_spells = {}
        if known_enabled:
            known_spells["known"] = known_list
        else:
            known_spells.pop("known", None)
        known_set = {item.lower() for item in known_list}
        known_free = [item for item in normalize_slug_list(known_spells.get("free")) if item.lower() in known_set]
        if known_free:
            known_spells["free"] = known_free
        else:
            known_spells.pop("free", None)
        spellcasting["known_spells"] = known_spells

        existing["spellcasting"] = spellcasting
        if "name" not in existing:
            existing["name"] = player_name
        identity = existing.get("identity")
        if not isinstance(identity, dict):
            identity = {}
        if "name" not in identity:
            identity["name"] = player_name
        existing["identity"] = identity

        self._write_player_yaml_atomic(path, existing)
        meta = _file_stat_metadata(path)
        self._player_yaml_cache_by_path[path] = existing
        self._player_yaml_meta_by_path[path] = meta
        profile = self._normalize_player_profile(existing, path.stem)
        profile_name = profile.get("name", player_name)
        self._player_yaml_data_by_name[profile_name] = profile
        self._player_yaml_name_map[self._normalize_character_lookup_key(player_name)] = path
        self._player_yaml_name_map[self._normalize_character_lookup_key(path.stem)] = path
        self._schedule_player_yaml_refresh()

        return profile

    def _save_player_token_color(self, name: str, color: str) -> str:
        if yaml is None:
            raise RuntimeError("PyYAML is required for token color persistence.")
        player_name = str(name or "").strip()
        if not player_name:
            raise ValueError("Player name is required.")
        normalized = self._normalize_token_color(color)
        if not normalized:
            raise ValueError("Token color must be a hex value.")

        self._load_player_yaml_cache()
        path = self._find_player_profile_path(name)
        if path is None:
            players_dir = self._players_dir()
            players_dir.mkdir(parents=True, exist_ok=True)
            filename = f"{self._sanitize_player_filename(player_name)}.yaml"
            path = players_dir / filename

        existing = self._player_yaml_cache_by_path.get(path) or {}
        if not isinstance(existing, dict):
            existing = {}

        identity = existing.get("identity")
        if not isinstance(identity, dict):
            identity = {}
        if "name" not in identity:
            identity["name"] = player_name
        identity["token_color"] = normalized
        existing["identity"] = identity

        self._write_player_yaml_atomic(path, existing)

        meta = _file_stat_metadata(path)
        self._player_yaml_cache_by_path[path] = existing
        self._player_yaml_meta_by_path[path] = meta
        profile = self._normalize_player_profile(existing, path.stem)
        profile_name = profile.get("name", player_name)
        self._player_yaml_data_by_name[profile_name] = profile
        self._player_yaml_name_map[self._normalize_character_lookup_key(player_name)] = path
        self._player_yaml_name_map[self._normalize_character_lookup_key(path.stem)] = path
        self._schedule_player_yaml_refresh()

        return normalized

    def _save_player_token_border_color(self, name: str, color: str) -> str:
        if yaml is None:
            raise RuntimeError("PyYAML is required for token border color persistence.")
        player_name = str(name or "").strip()
        if not player_name:
            raise ValueError("Player name is required.")
        normalized = self._normalize_token_color(color)
        if not normalized:
            raise ValueError("Token border color must be a hex value.")

        self._load_player_yaml_cache()
        path = self._find_player_profile_path(name)
        if path is None:
            players_dir = self._players_dir()
            players_dir.mkdir(parents=True, exist_ok=True)
            filename = f"{self._sanitize_player_filename(player_name)}.yaml"
            path = players_dir / filename

        existing = self._player_yaml_cache_by_path.get(path) or {}
        if not isinstance(existing, dict):
            existing = {}

        identity = existing.get("identity")
        if not isinstance(identity, dict):
            identity = {}
        if "name" not in identity:
            identity["name"] = player_name
        identity["token_border_color"] = normalized
        existing["identity"] = identity

        self._write_player_yaml_atomic(path, existing)

        meta = _file_stat_metadata(path)
        self._player_yaml_cache_by_path[path] = existing
        self._player_yaml_meta_by_path[path] = meta
        profile = self._normalize_player_profile(existing, path.stem)
        profile_name = profile.get("name", player_name)
        self._player_yaml_data_by_name[profile_name] = profile
        self._player_yaml_name_map[self._normalize_character_lookup_key(player_name)] = path
        self._player_yaml_name_map[self._normalize_character_lookup_key(path.stem)] = path
        self._schedule_player_yaml_refresh()

        return normalized

    def _save_spell_color(self, spell_id: str, color: Any) -> Dict[str, Any]:
        if yaml is None:
            raise RuntimeError("PyYAML is required for spell persistence.")
        slug = str(spell_id or "").strip()
        if not slug:
            raise ValueError("Spell id is required.")
        normalized = self._normalize_spell_color(color)
        if not normalized:
            raise ValueError("Spell color must be a hex value.")
        spells_dir = self._resolve_spells_dir()
        if spells_dir is None:
            raise FileNotFoundError("Spells directory not found.")
        path = spells_dir / f"{slug}.yaml"
        if not path.exists():
            raise FileNotFoundError("Spell not found.")
        try:
            parsed = yaml.safe_load(path.read_text(encoding="utf-8"))
        except Exception as exc:
            raise RuntimeError(f"Unable to read spell YAML: {exc}") from exc
        if not isinstance(parsed, dict):
            raise ValueError("Spell YAML did not parse to a dict.")
        parsed["color"] = normalized
        self._write_spell_yaml_atomic(path, parsed)
        self._invalidate_spell_index_cache()
        return {"slug": slug, "color": normalized}

    def _lan_seed_missing_positions(self, positions: Dict[int, Tuple[int, int]], cols: int, rows: int) -> Dict[int, Tuple[int, int]]:
        # place missing near center in a simple spiral, one square apart
        cx, cy = max(0, cols // 2), max(0, rows // 2)
        used = set(positions.values())
        def spiral_cells():
            yield (cx, cy)
            step = 1
            x, y = cx, cy
            while step < max(cols, rows) * 3:
                for _ in range(step):
                    x += 1
                    yield (x, y)
                for _ in range(step):
                    y += 1
                    yield (x, y)
                step += 1
                for _ in range(step):
                    x -= 1
                    yield (x, y)
                for _ in range(step):
                    y -= 1
                    yield (x, y)
                step += 1
        for c in self.combatants.values():
            if c.cid in positions:
                continue
            for (x, y) in spiral_cells():
                if not (0 <= x < cols and 0 <= y < rows):
                    continue
                if (x, y) in used:
                    continue
                positions[c.cid] = (x, y)
                used.add((x, y))
                break
        # persist
        self._lan_positions = dict(positions)
        return positions

    @staticmethod
    def _action_name_key(value: Any) -> str:
        return str(value or "").strip().lower()

    def _once_per_turn_key(self) -> Tuple[int, int]:
        return (
            int(getattr(self, "round_num", 0) or 0),
            int(getattr(self, "turn_num", 0) or 0),
        )

    def _once_per_turn_limiter_allows(self, cid: Any, feature_id: Any) -> bool:
        cid_value = _normalize_cid_value(cid, "feature.once_per_turn.cid")
        feature_key = str(feature_id or "").strip().lower()
        if cid_value is None or not feature_key:
            return False
        marker = self._once_per_turn_key()
        tracker = self.__dict__.get("_once_per_turn_feature_markers")
        if not isinstance(tracker, dict):
            tracker = {}
            self._once_per_turn_feature_markers = tracker
        return tuple(tracker.get((int(cid_value), feature_key)) or ()) != marker

    def _once_per_turn_limiter_mark(self, cid: Any, feature_id: Any) -> None:
        cid_value = _normalize_cid_value(cid, "feature.once_per_turn.mark_cid")
        feature_key = str(feature_id or "").strip().lower()
        if cid_value is None or not feature_key:
            return
        tracker = self.__dict__.get("_once_per_turn_feature_markers")
        if not isinstance(tracker, dict):
            tracker = {}
            self._once_per_turn_feature_markers = tracker
        tracker[(int(cid_value), feature_key)] = self._once_per_turn_key()

    def _register_combatant_turn_hook(self, c: Any, hook: Dict[str, Any]) -> None:
        if c is None or not isinstance(hook, dict):
            return
        hooks = list(getattr(c, "_feature_turn_hooks", []) or [])
        hooks.append(dict(hook))
        setattr(c, "_feature_turn_hooks", hooks)

    def _run_combatant_turn_hooks(self, c: Any, when: str) -> None:
        if c is None:
            return
        hooks = list(getattr(c, "_feature_turn_hooks", []) or [])
        if not hooks:
            return
        retained: List[Dict[str, Any]] = []
        for hook in hooks:
            if not isinstance(hook, dict):
                continue
            hook_when = str(hook.get("when") or "").strip().lower()
            if hook_when and hook_when != str(when or "").strip().lower():
                retained.append(dict(hook))
                continue
            hook_type = str(hook.get("type") or "").strip().lower()
            if hook_type == "rage_upkeep":
                if not bool(getattr(c, "rage_active", False)):
                    continue
                maintained = bool(getattr(c, "_rage_attack_made_this_turn", False)) or bool(getattr(c, "_rage_took_damage_this_turn", False))
                if not maintained:
                    setattr(c, "rage_active", False)
                    self._remove_condition_type(c, "rage")
                    self._log(f"{c.name}'s Rage ends.", cid=getattr(c, "cid", None))
                    continue
                retained.append(dict(hook))
                continue
            retained.append(dict(hook))
        setattr(c, "_feature_turn_hooks", retained)

    @staticmethod
    def _class_level_from_profile(profile: Dict[str, Any], class_name: str) -> int:
        key = str(class_name or "").strip().lower()
        if not key or not isinstance(profile, dict):
            return 0
        leveling = profile.get("leveling") if isinstance(profile.get("leveling"), dict) else {}
        classes = leveling.get("classes") if isinstance(leveling.get("classes"), list) else []
        total = 0
        for entry in classes:
            if not isinstance(entry, dict):
                continue
            if str(entry.get("name") or "").strip().lower() != key:
                continue
            try:
                total += int(entry.get("level") or 0)
            except Exception:
                continue
        if total > 0:
            return total
        if str(leveling.get("class") or "").strip().lower() == key:
            try:
                return max(0, int(leveling.get("level") or 0))
            except Exception:
                return 0
        return 0

    def _recover_spell_slots(
        self,
        player_name: str,
        profile: Dict[str, Any],
        recover_cfg: Dict[str, Any],
    ) -> Tuple[bool, str, List[int]]:
        if not isinstance(recover_cfg, dict):
            return False, "No spell slot recovery config found.", []
        spellcasting = profile.get("spellcasting") if isinstance(profile.get("spellcasting"), dict) else {}
        slots = self._normalize_spell_slots(spellcasting.get("spell_slots"))
        variables = {
            "level": self._coerce_level_value(profile.get("leveling") if isinstance(profile.get("leveling"), dict) else {}),
            "wizard_level": self._class_level_from_profile(profile, "wizard"),
            "druid_level": self._class_level_from_profile(profile, "druid"),
            "cleric_level": self._class_level_from_profile(profile, "cleric"),
            "fighter_level": self._class_level_from_profile(profile, "fighter"),
            "rogue_level": self._class_level_from_profile(profile, "rogue"),
            "monk_level": self._class_level_from_profile(profile, "monk"),
        }
        max_level = 9
        try:
            max_level = int(recover_cfg.get("max_slot_level", 9))
        except Exception:
            max_level = 9
        max_level = max(1, min(9, max_level))
        recover_budget = 1
        budget_formula = recover_cfg.get("max_total_levels_formula")
        if budget_formula is None:
            budget_formula = recover_cfg.get("max_combined_level_formula")
        if budget_formula is not None:
            evaluated = self._evaluate_spell_formula(str(budget_formula), variables)
            if evaluated is not None:
                recover_budget = max(1, int(math.floor(evaluated)))
        target_level = recover_cfg.get("slot_level")
        recovered_levels: List[int] = []
        if target_level is not None:
            try:
                target_level_int = int(target_level)
            except Exception:
                target_level_int = 0
            target_level_int = max(1, min(max_level, target_level_int))
            key = str(target_level_int)
            entry = slots.get(key, {"max": 0, "current": 0})
            current = max(0, int(entry.get("current", 0) or 0))
            maximum = max(0, int(entry.get("max", 0) or 0))
            if maximum > current and recover_budget >= target_level_int:
                entry["current"] = min(maximum, current + 1)
                slots[key] = entry
                recovered_levels.append(target_level_int)
        else:
            remaining_budget = recover_budget
            for level in range(max_level, 0, -1):
                key = str(level)
                entry = slots.get(key, {"max": 0, "current": 0})
                current = max(0, int(entry.get("current", 0) or 0))
                maximum = max(0, int(entry.get("max", 0) or 0))
                while maximum > current and remaining_budget >= level:
                    current += 1
                    remaining_budget -= level
                    recovered_levels.append(level)
                entry["current"] = current
                slots[key] = entry
        if not recovered_levels:
            return False, "No expended spell slots qualify for recovery.", []
        self._save_player_spell_slots(player_name, slots)
        return True, "", recovered_levels

    def _iter_combatant_actions(self, c: Any, spend: str) -> List[Dict[str, Any]]:
        if spend == "bonus":
            return self._normalize_action_entries(getattr(c, "bonus_actions", []), "bonus_action")
        if spend == "reaction":
            return self._normalize_action_entries(getattr(c, "reactions", []), "reaction")
        return self._normalize_action_entries(getattr(c, "actions", []), "action")

    def _find_action_entry(self, c: Any, spend: str, name: str) -> Optional[Dict[str, Any]]:
        key = self._action_name_key(name)
        if not key:
            return None
        for entry in self._iter_combatant_actions(c, spend):
            entry_name = self._action_name_key(entry.get("name"))
            if entry_name == key:
                return entry
        return None

    @staticmethod
    def _monster_attack_name_key(value: Any) -> str:
        text = str(value or "").strip().lower()
        text = re.sub(r"\([^)]*\)", "", text)
        text = re.sub(r"[^a-z0-9]+", " ", text)
        return re.sub(r"\s+", " ", text).strip()

    @staticmethod
    def _monster_attack_count_from_text(value: Any) -> int:
        raw = str(value or "").strip().lower()
        if not raw:
            return 0
        word_counts = {
            "one": 1,
            "two": 2,
            "three": 3,
            "four": 4,
            "five": 5,
            "six": 6,
            "seven": 7,
            "eight": 8,
            "nine": 9,
            "ten": 10,
        }
        if raw.isdigit():
            return max(0, min(10, int(raw)))
        return int(word_counts.get(raw, 0))

    def _monster_attack_options_for_map(self, attacker: Any) -> Tuple[List[Dict[str, Any]], Dict[str, int]]:
        spec = getattr(attacker, "monster_spec", None)
        raw_data = getattr(spec, "raw_data", None) if spec is not None else None
        if not isinstance(raw_data, dict):
            return [], {}
        actions = raw_data.get("actions")
        if not isinstance(actions, list):
            return [], {}

        options: List[Dict[str, Any]] = []
        for raw_action in actions:
            if not isinstance(raw_action, dict):
                continue
            name = str(raw_action.get("name") or "").strip()
            if not name:
                continue
            action_key = self._monster_attack_name_key(name)
            if action_key == "multiattack":
                continue
            desc_text = str(raw_action.get("description") or raw_action.get("desc") or "").strip()
            if not desc_text:
                continue
            to_hit: Optional[int] = None
            hit_match = re.search(r"\{@hit\s*([+\-]?\d+)\}", desc_text, flags=re.IGNORECASE)
            if hit_match:
                try:
                    to_hit = int(hit_match.group(1))
                except Exception:
                    to_hit = None
            if to_hit is None:
                plain_hit = re.search(r"([+\-]?\d+)\s*to hit", desc_text, flags=re.IGNORECASE)
                if plain_hit:
                    try:
                        to_hit = int(plain_hit.group(1))
                    except Exception:
                        to_hit = None
            if to_hit is None:
                attack_roll = re.search(r"attack roll\s*:\s*([+\-]?\d+)", desc_text, flags=re.IGNORECASE)
                if attack_roll:
                    try:
                        to_hit = int(attack_roll.group(1))
                    except Exception:
                        to_hit = None

            damage_entries: List[Dict[str, str]] = []
            for dmg in re.finditer(r"\{@damage\s+([^}]+)\}\)\s*([a-zA-Z]+)\s+damage", desc_text, flags=re.IGNORECASE):
                formula = str(dmg.group(1) or "").strip()
                dtype = str(dmg.group(2) or "").strip().lower()
                if formula and dtype:
                    damage_entries.append({"formula": formula, "type": dtype})
            if not damage_entries:
                normalized_desc = re.sub(r"\{@damage\s+([^}]+)\}", r"\1", desc_text, flags=re.IGNORECASE)
                normalized_desc = re.sub(r"\{@[^}]+\}", " ", normalized_desc)
                for dmg in re.finditer(r"\((\d*d\d+(?:\s*[+\-]\s*\d+)?)\)\s*([a-zA-Z]+)\s+damage", normalized_desc, flags=re.IGNORECASE):
                    formula = str(dmg.group(1) or "").strip()
                    dtype = str(dmg.group(2) or "").strip().lower()
                    if formula and dtype:
                        damage_entries.append({"formula": formula, "type": dtype})
            if to_hit is None or not damage_entries:
                continue
            options.append(
                {
                    "name": name,
                    "key": action_key or self._action_name_key(name),
                    "to_hit": int(to_hit),
                    "damage_entries": damage_entries,
                    "raw_desc": desc_text,
                }
            )

        if not options:
            return [], {}

        multiattack_counts: Dict[str, int] = {}
        for raw_action in actions:
            if not isinstance(raw_action, dict):
                continue
            if self._monster_attack_name_key(raw_action.get("name")) != "multiattack":
                continue
            text = str(raw_action.get("description") or raw_action.get("desc") or "").strip().lower()
            if not text:
                break
            total_match = re.search(r"\b(one|two|three|four|five|six|seven|eight|nine|ten|\d+)\b\s+attacks?\b", text)
            if total_match:
                total_count = self._monster_attack_count_from_text(total_match.group(1))
                if total_count > 0:
                    multiattack_counts["__total__"] = int(total_count)
            phrase_matches = list(
                re.finditer(
                    r"\b(one|two|three|four|five|six|seven|eight|nine|ten|\d+)\b\s+with\b\s+(?:its|his|her)?\s*([^.;]+?)(?=(?:\band\b\s+(?:one|two|three|four|five|six|seven|eight|nine|ten|\d+)\s+with\b)|[.;]|$)",
                    text,
                )
            )
            for option in options:
                key = str(option.get("key") or "")
                if not key:
                    continue
                tokens = [tok for tok in key.split(" ") if tok]
                tokens.insert(0, key)
                token_counts: List[int] = []
                for phrase in phrase_matches:
                    parsed = self._monster_attack_count_from_text(phrase.group(1))
                    if parsed <= 0:
                        continue
                    segment = str(phrase.group(2) or "")
                    for token in tokens:
                        if re.search(rf"\b{re.escape(token)}\b", segment):
                            token_counts.append(parsed)
                            break
                if token_counts:
                    multiattack_counts[key] = int(min(token_counts))
            break
        return options, multiattack_counts

    def _roll_monster_attack_formula(self, formula: Any, critical: bool = False) -> int:
        raw = str(formula or "").strip().lower()
        if not raw:
            return 0
        if not re.fullmatch(r"[0-9d+\-*/().\s]+", raw):
            return 0

        def _replace_dice(match: re.Match[str]) -> str:
            count = int(match.group(1) or 1)
            sides = int(match.group(2))
            if count <= 0 or count > 100 or sides <= 0 or sides > 1000:
                raise ValueError("invalid dice notation")
            if critical:
                count *= 2
            return str(sum(random.randint(1, sides) for _ in range(count)))

        try:
            expr = re.sub(r"(\d*)d(\d+)", _replace_dice, raw)
        except Exception:
            return 0
        evaluated = self._evaluate_spell_formula(expr, {})
        if evaluated is None:
            return 0
        return max(0, int(math.floor(evaluated)))

    def _map_attack_sequence_cache_key(self, attacker: Any) -> str:
        spec = getattr(attacker, "monster_spec", None)
        raw_data = getattr(spec, "raw_data", None) if spec is not None else None
        slug = ""
        if isinstance(raw_data, dict):
            slug = str(raw_data.get("slug") or raw_data.get("name") or "").strip().lower()
        if slug:
            return slug
        return self._monster_attack_name_key(getattr(attacker, "name", "")) or f"cid:{int(getattr(attacker, 'cid', 0) or 0)}"

    def _build_map_attack_sequence_defaults(
        self,
        attacker: Any,
        attack_options: List[Dict[str, Any]],
        multiattack_counts: Dict[str, int],
    ) -> List[Dict[str, Any]]:
        defaults: List[Dict[str, Any]] = []
        spec = getattr(attacker, "monster_spec", None)
        raw_data = getattr(spec, "raw_data", None) if spec is not None else None
        actions = raw_data.get("actions") if isinstance(raw_data, dict) else None
        if isinstance(actions, list):
            for raw_action in actions:
                if not isinstance(raw_action, dict):
                    continue
                if self._monster_attack_name_key(raw_action.get("name")) != "multiattack":
                    continue
                text = str(raw_action.get("description") or raw_action.get("desc") or "").strip().lower()
                phrase_matches = list(
                    re.finditer(
                        r"\b(one|two|three|four|five|six|seven|eight|nine|ten|\d+)\b\s+with\b\s+(?:its|his|her)?\s*([^.;]+?)(?=(?:\band\b\s+(?:one|two|three|four|five|six|seven|eight|nine|ten|\d+)\s+with\b)|[.;]|$)",
                        text,
                    )
                )
                for phrase in phrase_matches:
                    parsed_count = self._monster_attack_count_from_text(phrase.group(1))
                    if parsed_count <= 0:
                        continue
                    segment = str(phrase.group(2) or "").strip()
                    chosen_option = None
                    for clause in re.split(r"\bor\b", segment):
                        for option in attack_options:
                            if not isinstance(option, dict):
                                continue
                            option_key = str(option.get("key") or "")
                            if not option_key:
                                continue
                            tokens = [option_key] + [tok for tok in option_key.split(" ") if tok]
                            if any(re.search(rf"\b{re.escape(token)}\b", clause) for token in tokens):
                                chosen_option = option
                                break
                        if chosen_option is not None:
                            break
                    if chosen_option is not None:
                        defaults.append(
                            {
                                "attack_key": str(chosen_option.get("key") or ""),
                                "count": int(max(1, min(10, parsed_count))),
                                "roll_mode": "normal",
                            }
                        )
                break
        if defaults:
            return defaults
        for option in attack_options:
            if not isinstance(option, dict):
                continue
            key = str(option.get("key") or "")
            if not key:
                continue
            parsed_count = int(multiattack_counts.get(key) or 0)
            if parsed_count > 0:
                defaults.append({"attack_key": key, "count": int(max(1, min(10, parsed_count))), "roll_mode": "normal"})
        if defaults:
            return defaults
        if attack_options:
            first = attack_options[0]
            if isinstance(first, dict):
                return [{"attack_key": str(first.get("key") or ""), "count": 1, "roll_mode": "normal"}]
        return []

    def _resolve_map_attack_sequence(
        self,
        attacker_cid: int,
        target_cid: int,
        sequence_blocks: List[Dict[str, Any]],
    ) -> Dict[str, Any]:
        attacker = self.combatants.get(int(attacker_cid))
        target = self.combatants.get(int(target_cid))
        if attacker is None or target is None:
            return {"ok": False, "reason": "invalid_combatant"}
        self._clear_hide_state(int(attacker_cid), reason=f"{attacker.name} attacks and reveals themself.")
        normalized_blocks: List[Dict[str, Any]] = []
        for raw_block in sequence_blocks:
            if not isinstance(raw_block, dict):
                continue
            attack_option = raw_block.get("attack_option") if isinstance(raw_block.get("attack_option"), dict) else {}
            attack_name = str(raw_block.get("name") or attack_option.get("name") or "Attack").strip() or "Attack"
            try:
                to_hit = int(raw_block.get("to_hit") if raw_block.get("to_hit") is not None else attack_option.get("to_hit") or 0)
            except Exception:
                to_hit = 0
            damage_entries = attack_option.get("damage_entries") if isinstance(attack_option.get("damage_entries"), list) else []
            if raw_block.get("damage_entries") is not None and isinstance(raw_block.get("damage_entries"), list):
                damage_entries = raw_block.get("damage_entries")
            if not damage_entries:
                continue
            try:
                count = int(raw_block.get("count") or 1)
            except Exception:
                count = 1
            roll_mode = str(raw_block.get("roll_mode") or "normal").strip().lower()
            if roll_mode not in {"normal", "advantage", "disadvantage"}:
                roll_mode = "normal"
            normalized_blocks.append(
                {
                    "attack_key": str(raw_block.get("attack_key") or attack_option.get("key") or self._monster_attack_name_key(attack_name)),
                    "name": attack_name,
                    "to_hit": int(to_hit),
                    "count": int(max(1, min(10, count))),
                    "roll_mode": roll_mode,
                    "damage_entries": damage_entries,
                }
            )
        if not normalized_blocks:
            return {"ok": False, "reason": "no_attacks"}
        attacker_role = str(getattr(self, "_name_role_memory", {}).get(str(getattr(attacker, "name", "")), "enemy") or "enemy")
        hide_enemy_details = attacker_role == "enemy"
        target_name = str(getattr(target, "name", "Target") or "Target")
        block_results: List[Dict[str, Any]] = []
        damage_types: List[str] = []
        total_hits = 0
        total_crits = 0
        total_misses = 0
        target_removed = False
        for block in normalized_blocks:
            if int(target_cid) not in self.combatants:
                target_removed = True
                break
            target = self.combatants[int(target_cid)]
            if int(getattr(target, "hp", 0) or 0) <= 0:
                target_removed = True
                break
            target_name = str(getattr(target, "name", "Target") or "Target")
            try:
                target_ac = int(getattr(target, "ac", 10) or 10)
            except Exception:
                target_ac = 10
            block_hits = 0
            block_crits = 0
            block_misses = 0
            for attack_index in range(int(block["count"])):
                if int(target_cid) not in self.combatants:
                    target_removed = True
                    break
                target = self.combatants[int(target_cid)]
                if int(getattr(target, "hp", 0) or 0) <= 0:
                    target_removed = True
                    break
                roll_one = random.randint(1, 20)
                kept_roll = int(roll_one)
                dice_text = f"d20 {int(roll_one)}"
                if block["roll_mode"] in {"advantage", "disadvantage"}:
                    roll_two = random.randint(1, 20)
                    if block["roll_mode"] == "advantage":
                        kept_roll = max(int(roll_one), int(roll_two))
                    else:
                        kept_roll = min(int(roll_one), int(roll_two))
                    dice_text = f"d20s {int(roll_one)}/{int(roll_two)} ({block['roll_mode']}, kept {int(kept_roll)})"
                critical = kept_roll == 20
                auto_miss = kept_roll == 1
                total_to_hit = int(kept_roll) + int(block["to_hit"])
                hit = bool(not auto_miss and (critical or total_to_hit >= int(target_ac)))
                attack_prefix = f"{attacker.name} {block['name']} attack {attack_index + 1}/{int(block['count'])}"
                if not hit:
                    block_misses += 1
                    if hide_enemy_details:
                        self._log(f"{attacker.name} {block['name']}: misses {target_name}.", cid=int(target_cid))
                    else:
                        nat_note = " (nat 1 auto-miss)" if auto_miss else ""
                        self._log(
                            f"{attack_prefix}: misses {target_name}{nat_note} ({dice_text} + {int(block['to_hit'])} = {total_to_hit} vs AC {target_ac}).",
                            cid=int(target_cid),
                        )
                    continue
                block_hits += 1
                crit_note = " (CRIT)" if critical else ""
                if critical:
                    block_crits += 1
                if hide_enemy_details:
                    self._log(f"{attacker.name} {block['name']}: hits {target_name}{crit_note}.", cid=int(target_cid))
                else:
                    self._log(
                        f"{attack_prefix}: hits {target_name}{crit_note} ({dice_text} + {int(block['to_hit'])} = {total_to_hit} vs AC {target_ac}).",
                        cid=int(target_cid),
                    )
            normal_hits = max(0, int(block_hits) - int(block_crits))
            damage_rolls_normal: List[Dict[str, Any]] = []
            damage_rolls_crit: List[Dict[str, Any]] = []
            for template in block["damage_entries"]:
                if not isinstance(template, dict):
                    continue
                formula = str(template.get("formula") or "").strip()
                dtype = str(template.get("type") or "").strip().lower() or "damage"
                if not formula:
                    continue
                if normal_hits > 0:
                    damage_rolls_normal.append({"formula": formula, "type": dtype, "count": int(normal_hits)})
                if int(block_crits) > 0:
                    damage_rolls_crit.append({"formula": formula, "type": dtype, "count": int(block_crits)})
                if dtype not in damage_types:
                    damage_types.append(dtype)
            block_results.append(
                {
                    "attack_key": str(block["attack_key"]),
                    "attack_name": str(block["name"]),
                    "count": int(block["count"]),
                    "roll_mode": str(block["roll_mode"]),
                    "hits": int(block_hits),
                    "crit_hits": int(block_crits),
                    "misses": int(block_misses),
                    "damage_rolls_normal": damage_rolls_normal,
                    "damage_rolls_crit": damage_rolls_crit,
                }
            )
            total_hits += int(block_hits)
            total_crits += int(block_crits)
            total_misses += int(block_misses)
            if target_removed:
                break
        damage_rolls: List[Dict[str, Any]] = []
        damage_rolls_crit: List[Dict[str, Any]] = []
        for block_result in block_results:
            for entry in block_result.get("damage_rolls_normal") or []:
                damage_rolls.append(dict(entry))
            for entry in block_result.get("damage_rolls_crit") or []:
                damage_rolls_crit.append(dict(entry))
        if damage_rolls or damage_rolls_crit:
            normal_summary = ", ".join(
                f"{int(entry.get('count') or 0)}×({str(entry.get('formula') or '').strip()}) {str(entry.get('type') or 'damage').strip()}"
                for entry in damage_rolls
                if int(entry.get("count") or 0) > 0 and str(entry.get("formula") or "").strip()
            )
            crit_summary = ", ".join(
                f"{int(entry.get('count') or 0)}×({str(entry.get('formula') or '').strip()}) {str(entry.get('type') or 'damage').strip()}"
                for entry in damage_rolls_crit
                if int(entry.get("count") or 0) > 0 and str(entry.get("formula") or "").strip()
            )
            summary_parts: List[str] = []
            if normal_summary:
                summary_parts.append(f"normal {normal_summary}")
            if crit_summary:
                summary_parts.append(f"crit {crit_summary}")
            if summary_parts:
                if hide_enemy_details:
                    self._log(f"{attacker.name}: roll damage manually.", cid=int(target_cid))
                else:
                    self._log(
                        f"{attacker.name}: roll damage manually — {'; '.join(summary_parts)}.",
                        cid=int(target_cid),
                    )
        return {
            "ok": True,
            "attacker_cid": int(attacker_cid),
            "target_cid": int(target_cid),
            "target_name": target_name,
            "attack_name": "Attack Sequence",
            "hits": int(total_hits),
            "crit_hits": int(total_crits),
            "misses": int(total_misses),
            "total_damage": 0,
            "target_removed": bool(target_removed),
            "damage_rolls": damage_rolls,
            "damage_rolls_crit": damage_rolls_crit,
            "damage_types": damage_types,
            "sequence_blocks": block_results,
        }

    def _resolve_map_attack(
        self,
        attacker_cid: int,
        target_cid: int,
        attack_option: Dict[str, Any],
        attack_count: int = 1,
    ) -> Dict[str, Any]:
        try:
            count = int(attack_count or 1)
        except Exception:
            count = 1
        sequence_result = self._resolve_map_attack_sequence(
            int(attacker_cid),
            int(target_cid),
            [
                {
                    "attack_option": attack_option,
                    "attack_key": str(attack_option.get("key") or self._monster_attack_name_key(attack_option.get("name"))),
                    "name": str(attack_option.get("name") or "Attack"),
                    "to_hit": attack_option.get("to_hit"),
                    "damage_entries": attack_option.get("damage_entries"),
                    "count": int(max(1, min(10, count))),
                    "roll_mode": "normal",
                }
            ],
        )
        if not bool(sequence_result.get("ok")):
            return sequence_result
        return {
            "ok": True,
            "attacker_cid": int(attacker_cid),
            "target_cid": int(target_cid),
            "target_name": str(sequence_result.get("target_name") or ""),
            "attack_name": str(attack_option.get("name") or "Attack").strip() or "Attack",
            "attack_count": int(max(1, min(10, count))),
            "hits": int(sequence_result.get("hits") or 0),
            "crit_hits": int(sequence_result.get("crit_hits") or 0),
            "misses": int(sequence_result.get("misses") or 0),
            "total_damage": 0,
            "target_removed": bool(sequence_result.get("target_removed")),
            "damage_rolls": list(sequence_result.get("damage_rolls") or []) + list(sequence_result.get("damage_rolls_crit") or []),
            "damage_rolls_crit": list(sequence_result.get("damage_rolls_crit") or []),
            "damage_types": list(sequence_result.get("damage_types") or []),
            "sequence_blocks": list(sequence_result.get("sequence_blocks") or []),
        }

    def _apply_map_attack_manual_damage(
        self,
        attacker_cid: int,
        target_cid: int,
        attack_name: str,
        damage_entries: List[Dict[str, Any]],
    ) -> Dict[str, Any]:
        attacker = self.combatants.get(int(attacker_cid))
        target = self.combatants.get(int(target_cid))
        if attacker is None or target is None:
            return {"ok": False, "reason": "invalid_combatant"}
        normalized_entries: List[Dict[str, Any]] = []
        for entry in damage_entries:
            if not isinstance(entry, dict):
                continue
            try:
                amount = int(entry.get("amount") or 0)
            except Exception:
                amount = 0
            if amount <= 0:
                continue
            dtype = str(entry.get("type") or "").strip().lower() or "damage"
            normalized_entries.append({"amount": int(amount), "type": dtype})
        adjustment = self._adjust_damage_entries_for_target(target, normalized_entries)
        adjusted_entries = list(adjustment.get("entries") or [])
        adjustment_notes = list(adjustment.get("notes") or [])
        total_damage = int(sum(int(entry.get("amount", 0) or 0) for entry in adjusted_entries))

        target_name = str(getattr(target, "name", "Target") or "Target")
        attacker_role = str(getattr(self, "_name_role_memory", {}).get(str(getattr(attacker, "name", "")), "enemy") or "enemy")
        hide_enemy_details = attacker_role == "enemy"
        if total_damage <= 0:
            if adjustment_notes:
                if hide_enemy_details:
                    self._log(f"{attacker.name} {attack_name}: no damage dealt to {target_name}.", cid=int(target_cid))
                else:
                    note_text = "; ".join(
                        f"{int(note.get('original') or 0)} {str(note.get('type') or 'damage')}→{int(note.get('applied') or 0)} ({', '.join(note.get('reasons') or [])})"
                        for note in adjustment_notes
                    )
                    self._log(f"{attacker.name} {attack_name}: damage blocked for {target_name} ({note_text}).", cid=int(target_cid))
            else:
                self._log(f"{attacker.name} {attack_name}: no damage dealt to {target_name}.", cid=int(target_cid))
            return {
                "ok": True,
                "attacker_cid": int(attacker_cid),
                "target_cid": int(target_cid),
                "target_name": target_name,
                "attack_name": str(attack_name or "Attack"),
                "total_damage": 0,
                "target_removed": False,
            }

        old_hp = int(getattr(target, "hp", 0) or 0)
        target.hp = max(0, old_hp - int(total_damage))
        if int(target.hp) < old_hp:
            self._queue_concentration_save(target, "damage")
        removed_target = False
        if old_hp > 0 and int(target.hp) == 0:
            dtype_flavor = str((adjusted_entries[0].get("type") if adjusted_entries else "") or "")
            self._log(self._death_flavor_line(attacker.name, total_damage, dtype_flavor, target_name), cid=int(target_cid))
            lan = getattr(self, "_lan", None)
            if lan:
                try:
                    lan.play_ko(int(attacker_cid))
                except Exception:
                    pass
            pre_order: List[int] = []
            try:
                pre_order = [x.cid for x in self._display_order()]
            except Exception:
                pre_order = []
            self.combatants.pop(int(target_cid), None)
            if getattr(self, "start_cid", None) == int(target_cid):
                self.start_cid = None
            try:
                self._retarget_current_after_removal([int(target_cid)], pre_order=pre_order)
            except Exception:
                pass
            removed_target = True
        else:
            attack_label = str(attack_name or "Attack").strip() or "Attack"
            if hide_enemy_details:
                self._log(f"{attacker.name} {attack_label}: applies {total_damage} damage to {target_name}.", cid=int(target_cid))
            else:
                damage_desc = ", ".join(
                    f"{int(entry.get('amount', 0) or 0)} {str(entry.get('type') or '').strip() or 'damage'}"
                    for entry in adjusted_entries
                )
                self._log(
                    f"{attacker.name} {attack_label}: applies {total_damage} damage to {target_name}{f' ({damage_desc})' if damage_desc else ''}.",
                    cid=int(target_cid),
                )
        try:
            self._rebuild_table(scroll_to_current=True)
        except Exception:
            pass
        return {
            "ok": True,
            "attacker_cid": int(attacker_cid),
            "target_cid": int(target_cid),
            "target_name": target_name,
            "attack_name": str(attack_name or "Attack"),
            "total_damage": int(total_damage),
            "target_removed": bool(removed_target),
        }

    def _open_map_attack_tool(
        self,
        attacker_cid: Optional[int] = None,
        target_cid: Optional[int] = None,
        dialog_parent: Optional[tk.Misc] = None,
    ) -> bool:
        if attacker_cid is None or target_cid is None:
            return False
        attacker = self.combatants.get(int(attacker_cid))
        target = self.combatants.get(int(target_cid))
        if attacker is None or target is None:
            return False
        if bool(getattr(attacker, "ally", False)) or bool(getattr(attacker, "is_pc", False)):
            return False
        attack_options, multiattack_counts = self._monster_attack_options_for_map(attacker)
        if not attack_options:
            return False
        option_by_key = {
            str(entry.get("key") or ""): entry for entry in attack_options if isinstance(entry, dict) and str(entry.get("key") or "")
        }
        cache_key = self._map_attack_sequence_cache_key(attacker)
        sequence_cache = getattr(self, "_map_attack_sequence_cache", None)
        if not isinstance(sequence_cache, dict):
            sequence_cache = {}
            self._map_attack_sequence_cache = sequence_cache
        cached_blocks = sequence_cache.get(cache_key)

        def _open_manual_damage_prompt(result_payload: Dict[str, Any]) -> None:
            if int(result_payload.get("hits") or 0) <= 0:
                return
            damage_rolls = result_payload.get("damage_rolls") if isinstance(result_payload.get("damage_rolls"), list) else []
            damage_rolls_crit = (
                result_payload.get("damage_rolls_crit") if isinstance(result_payload.get("damage_rolls_crit"), list) else []
            )
            if not damage_rolls and not damage_rolls_crit:
                return
            damage_types = result_payload.get("damage_types") if isinstance(result_payload.get("damage_types"), list) else []
            if not damage_types:
                return
            prompt = tk.Toplevel(self)
            prompt.title("Apply Damage")
            prompt.transient(dialog_parent if dialog_parent is not None else self)
            prompt.resizable(False, False)
            body = ttk.Frame(prompt, padding=10)
            body.pack(fill=tk.BOTH, expand=True)
            ttk.Label(body, text=f"Manual damage for {result_payload.get('attack_name') or 'Attack'}").grid(
                row=0, column=0, columnspan=2, sticky="w"
            )
            sequence_blocks = result_payload.get("sequence_blocks") if isinstance(result_payload.get("sequence_blocks"), list) else []
            row = 1
            for block in sequence_blocks:
                if not isinstance(block, dict):
                    continue
                attack_name = str(block.get("attack_name") or "Attack")
                roll_mode = str(block.get("roll_mode") or "normal").strip().lower()
                mode_tag = "" if roll_mode == "normal" else f" [{roll_mode[:3]}]"
                ttk.Label(
                    body,
                    text=(
                        f"{attack_name}{mode_tag}: {int(block.get('hits') or 0)} hit "
                        f"({int(block.get('crit_hits') or 0)} crit), {int(block.get('misses') or 0)} miss"
                    ),
                ).grid(row=row, column=0, columnspan=2, sticky="w", pady=(4, 0))
                row += 1
            ttk.Label(body, text="Crit reminder: double damage dice, not flat modifiers.").grid(
                row=row, column=0, columnspan=2, sticky="w", pady=(6, 0)
            )
            row += 1
            normal_summary = ", ".join(
                f"{int(entry.get('count') or 0)}×({str(entry.get('formula') or '').strip()}) {str(entry.get('type') or 'damage').strip()}"
                for entry in damage_rolls
                if int(entry.get("count") or 0) > 0 and str(entry.get("formula") or "").strip()
            )
            if normal_summary:
                ttk.Label(body, text=f"Normal hits: {normal_summary}").grid(row=row, column=0, columnspan=2, sticky="w", pady=(4, 0))
                row += 1
            crit_summary = ", ".join(
                f"{int(entry.get('count') or 0)}×({str(entry.get('formula') or '').strip()}) {str(entry.get('type') or 'damage').strip()}"
                for entry in damage_rolls_crit
                if int(entry.get("count") or 0) > 0 and str(entry.get("formula") or "").strip()
            )
            if crit_summary:
                ttk.Label(body, text=f"Crit hits: {crit_summary}").grid(row=row, column=0, columnspan=2, sticky="w", pady=(4, 0))
                row += 1
            amount_vars: Dict[str, tk.StringVar] = {}
            for dtype in damage_types:
                label = str(dtype or "damage").strip() or "damage"
                ttk.Label(body, text=f"{label.title()} damage:").grid(row=row, column=0, sticky="w", pady=(8, 0))
                var = tk.StringVar(value="")
                ttk.Entry(body, textvariable=var, width=10).grid(row=row, column=1, sticky="w", pady=(8, 0))
                amount_vars[label] = var
                row += 1
            btns = ttk.Frame(body)
            btns.grid(row=row, column=0, columnspan=2, sticky="e", pady=(12, 0))

            def _apply_damage() -> None:
                entries: List[Dict[str, Any]] = []
                for dtype, var in amount_vars.items():
                    raw = str(var.get() or "").strip()
                    if not raw:
                        continue
                    evaluated = self._evaluate_spell_formula(raw, {})
                    if evaluated is None:
                        amount = 0
                    else:
                        amount = int(math.floor(evaluated))
                    if amount <= 0:
                        continue
                    entries.append({"amount": int(amount), "type": dtype})
                self._apply_map_attack_manual_damage(
                    int(result_payload.get("attacker_cid") or attacker_cid),
                    int(result_payload.get("target_cid") or target_cid),
                    str(result_payload.get("attack_name") or "Attack"),
                    entries,
                )
                prompt.destroy()

            ttk.Button(btns, text="Skip", command=prompt.destroy).pack(side=tk.RIGHT)
            ttk.Button(btns, text="Apply Damage", command=_apply_damage).pack(side=tk.RIGHT, padx=(0, 8))

        dlg = tk.Toplevel(self)
        dlg.title(f"Attack Sequence: {target.name}")
        dlg.transient(dialog_parent if dialog_parent is not None else self)
        dlg.resizable(False, False)
        outer = ttk.Frame(dlg, padding=10)
        outer.pack(fill=tk.BOTH, expand=True)
        ttk.Label(outer, text=f"{attacker.name} attacks {target.name}").grid(row=0, column=0, columnspan=3, sticky="w")
        ttk.Label(outer, text="Available Attacks").grid(row=1, column=0, sticky="w", pady=(8, 2))
        ttk.Label(outer, text="Attack Sequence").grid(row=1, column=2, sticky="w", pady=(8, 2))

        available_list = tk.Listbox(outer, height=8, exportselection=False, width=38)
        available_list.grid(row=2, column=0, sticky="nsew")
        available_scroll = ttk.Scrollbar(outer, orient=tk.VERTICAL, command=available_list.yview)
        available_scroll.grid(row=2, column=1, sticky="ns")
        available_list.configure(yscrollcommand=available_scroll.set)
        for option in attack_options:
            available_list.insert(tk.END, str(option.get("name") or "Attack"))

        sequence_list = tk.Listbox(outer, height=8, exportselection=False, width=44)
        sequence_list.grid(row=2, column=2, sticky="nsew", padx=(8, 0))
        sequence_scroll = ttk.Scrollbar(outer, orient=tk.VERTICAL, command=sequence_list.yview)
        sequence_scroll.grid(row=2, column=3, sticky="ns")
        sequence_list.configure(yscrollcommand=sequence_scroll.set)

        details_var = tk.StringVar(value="")
        ttk.Label(outer, textvariable=details_var, wraplength=640, justify=tk.LEFT).grid(
            row=3, column=0, columnspan=4, sticky="w", pady=(6, 0)
        )

        sequence_blocks: List[Dict[str, Any]] = []

        def _block_summary(block: Dict[str, Any]) -> str:
            mode = str(block.get("roll_mode") or "normal").strip().lower()
            mode_tag = "" if mode == "normal" else f" ({'Adv' if mode == 'advantage' else 'Dis'})"
            return f"{str(block.get('name') or 'Attack')} ×{int(block.get('count') or 1)}{mode_tag}"

        def _refresh_sequence_list(select_index: Optional[int] = None) -> None:
            sequence_list.delete(0, tk.END)
            for block in sequence_blocks:
                sequence_list.insert(tk.END, _block_summary(block))
            if select_index is None:
                if sequence_blocks:
                    sequence_list.selection_set(0)
            elif sequence_blocks:
                bounded = max(0, min(int(select_index), len(sequence_blocks) - 1))
                sequence_list.selection_set(bounded)
                sequence_list.see(bounded)
            _refresh_editor()

        def _selected_sequence_index() -> Optional[int]:
            selection = sequence_list.curselection()
            if not selection:
                return None
            idx = int(selection[0])
            if idx < 0 or idx >= len(sequence_blocks):
                return None
            return idx

        def _add_selected_attack(*_args: Any) -> None:
            selection = available_list.curselection()
            if not selection:
                return
            idx = int(selection[0])
            if idx < 0 or idx >= len(attack_options):
                return
            selected = attack_options[idx]
            key = str(selected.get("key") or "")
            suggested = int(multiattack_counts.get(key) or 1)
            sequence_blocks.append(
                {
                    "attack_key": key,
                    "name": str(selected.get("name") or "Attack"),
                    "count": int(max(1, min(10, suggested))),
                    "roll_mode": "normal",
                    "attack_option": selected,
                }
            )
            _refresh_sequence_list(len(sequence_blocks) - 1)

        def _remove_selected_block() -> None:
            idx = _selected_sequence_index()
            if idx is None:
                return
            sequence_blocks.pop(idx)
            _refresh_sequence_list(max(0, idx - 1))

        def _move_selected(delta: int) -> None:
            idx = _selected_sequence_index()
            if idx is None:
                return
            swap = idx + int(delta)
            if swap < 0 or swap >= len(sequence_blocks):
                return
            sequence_blocks[idx], sequence_blocks[swap] = sequence_blocks[swap], sequence_blocks[idx]
            _refresh_sequence_list(swap)

        count_var = tk.StringVar(value="1")
        roll_mode_var = tk.StringVar(value="normal")

        def _refresh_editor(*_args: Any) -> None:
            idx = _selected_sequence_index()
            if idx is None:
                count_var.set("1")
                roll_mode_var.set("normal")
                return
            block = sequence_blocks[idx]
            count_var.set(str(int(max(1, min(10, int(block.get("count") or 1))))))
            roll_mode_var.set(str(block.get("roll_mode") or "normal"))

        def _apply_editor(*_args: Any) -> None:
            idx = _selected_sequence_index()
            if idx is None:
                return
            try:
                parsed_count = int(str(count_var.get() or "1").strip())
            except Exception:
                parsed_count = 1
            mode = str(roll_mode_var.get() or "normal").strip().lower()
            if mode not in {"normal", "advantage", "disadvantage"}:
                mode = "normal"
            sequence_blocks[idx]["count"] = int(max(1, min(10, parsed_count)))
            sequence_blocks[idx]["roll_mode"] = mode
            _refresh_sequence_list(idx)

        editor = ttk.Frame(outer)
        editor.grid(row=4, column=2, columnspan=2, sticky="w", pady=(8, 0), padx=(8, 0))
        ttk.Label(editor, text="Count").grid(row=0, column=0, sticky="w")
        ttk.Spinbox(editor, from_=1, to=10, width=6, textvariable=count_var).grid(row=1, column=0, sticky="w", pady=(4, 0))
        ttk.Label(editor, text="Roll mode").grid(row=0, column=1, sticky="w", padx=(10, 0))
        mode_box = ttk.Combobox(editor, values=["normal", "advantage", "disadvantage"], width=14, state="readonly", textvariable=roll_mode_var)
        mode_box.grid(row=1, column=1, sticky="w", padx=(10, 0), pady=(4, 0))
        ttk.Button(editor, text="Apply", command=_apply_editor).grid(row=1, column=2, sticky="w", padx=(10, 0), pady=(4, 0))

        controls = ttk.Frame(outer)
        controls.grid(row=4, column=0, columnspan=2, sticky="w", pady=(8, 0))
        ttk.Button(controls, text="Add →", command=_add_selected_attack).pack(side=tk.LEFT)
        ttk.Button(controls, text="Remove", command=_remove_selected_block).pack(side=tk.LEFT, padx=(8, 0))
        ttk.Button(controls, text="Up", command=lambda: _move_selected(-1)).pack(side=tk.LEFT, padx=(8, 0))
        ttk.Button(controls, text="Down", command=lambda: _move_selected(1)).pack(side=tk.LEFT, padx=(8, 0))

        def _load_defaults() -> None:
            sequence_blocks.clear()
            defaults = self._build_map_attack_sequence_defaults(attacker, attack_options, multiattack_counts)
            for block in defaults:
                if not isinstance(block, dict):
                    continue
                key = str(block.get("attack_key") or "")
                option = option_by_key.get(key)
                if not isinstance(option, dict):
                    continue
                sequence_blocks.append(
                    {
                        "attack_key": key,
                        "name": str(option.get("name") or block.get("name") or "Attack"),
                        "count": int(max(1, min(10, int(block.get("count") or 1)))),
                        "roll_mode": str(block.get("roll_mode") or "normal").strip().lower(),
                        "attack_option": option,
                    }
                )
            _refresh_sequence_list(0)

        ttk.Button(controls, text="Load Multiattack Defaults", command=_load_defaults).pack(side=tk.LEFT, padx=(12, 0))

        def _show_available_details(_event: Optional[tk.Event] = None) -> None:
            idx: Optional[int] = None
            if _event is not None and isinstance(getattr(_event, "y", None), (int, float)):
                nearest = int(available_list.nearest(int(_event.y)))
                if 0 <= nearest < len(attack_options):
                    idx = nearest
            if idx is None:
                selection = available_list.curselection()
                if selection:
                    idx = int(selection[0])
            if idx is None or idx < 0 or idx >= len(attack_options):
                details_var.set("")
                return
            option = attack_options[idx]
            damage_text = ", ".join(
                f"{str(entry.get('formula') or '').strip()} {str(entry.get('type') or '').strip()}"
                for entry in option.get("damage_entries") or []
                if isinstance(entry, dict) and str(entry.get("formula") or "").strip()
            )
            raw_desc = str(option.get("raw_desc") or "").strip()
            if len(raw_desc) > 180:
                raw_desc = raw_desc[:177].rstrip() + "..."
            details_var.set(
                f"{str(option.get('name') or 'Attack')}: to hit +{int(option.get('to_hit') or 0)}"
                f"{f' | damage {damage_text}' if damage_text else ''}"
                f"{f' | {raw_desc}' if raw_desc else ''}"
            )

        available_list.bind("<<ListboxSelect>>", _show_available_details)
        available_list.bind("<Motion>", _show_available_details)
        available_list.bind("<Double-Button-1>", _add_selected_attack)
        sequence_list.bind("<<ListboxSelect>>", _refresh_editor)

        if isinstance(cached_blocks, list):
            for raw_block in cached_blocks:
                if not isinstance(raw_block, dict):
                    continue
                key = str(raw_block.get("attack_key") or "")
                option = option_by_key.get(key)
                if not isinstance(option, dict):
                    continue
                sequence_blocks.append(
                    {
                        "attack_key": key,
                        "name": str(option.get("name") or "Attack"),
                        "count": int(max(1, min(10, int(raw_block.get("count") or 1)))),
                        "roll_mode": str(raw_block.get("roll_mode") or "normal").strip().lower(),
                        "attack_option": option,
                    }
                )
        if not sequence_blocks:
            _load_defaults()
        else:
            _refresh_sequence_list(0)
        if attack_options:
            available_list.selection_set(0)
            _show_available_details()

        btns = ttk.Frame(outer)
        btns.grid(row=5, column=0, columnspan=4, sticky="e", pady=(12, 0))

        def _resolve_and_close() -> None:
            if not sequence_blocks:
                messagebox.showinfo("Attack Sequence", "Add at least one attack block first.", parent=dlg)
                return
            result = self._resolve_map_attack_sequence(int(attacker_cid), int(target_cid), list(sequence_blocks))
            sequence_cache[cache_key] = [
                {
                    "attack_key": str(block.get("attack_key") or ""),
                    "count": int(max(1, min(10, int(block.get("count") or 1)))),
                    "roll_mode": str(block.get("roll_mode") or "normal").strip().lower(),
                }
                for block in sequence_blocks
                if str(block.get("attack_key") or "")
            ]
            dlg.destroy()
            if isinstance(result, dict):
                _open_manual_damage_prompt(result)

        ttk.Button(btns, text="Cancel", command=dlg.destroy).pack(side=tk.RIGHT)
        ttk.Button(btns, text="Attack", command=_resolve_and_close).pack(side=tk.RIGHT, padx=(0, 8))
        return True

    def _combatant_can_cast_spell(self, c: Any, spend: str) -> bool:
        if spend == "reaction":
            return True
        spend_list = self._iter_combatant_actions(c, spend)
        if spend == "bonus":
            spend_list = spend_list + self._iter_combatant_actions(c, "action")
        if not spend_list:
            return False
        allowed = {"magic", "cast a spell", "cast spell", "spellcasting"}
        for entry in spend_list:
            name = self._action_name_key(entry.get("name"))
            if name in allowed:
                return True
        return False

    def _resolve_spell_slot_profile(self, caster_name: str) -> Tuple[str, Dict[str, Dict[str, int]]]:
        player_name = str(caster_name or "").strip()
        if not player_name or player_name.startswith("cid:"):
            raise ValueError("No spell slots set up for that caster, matey.")
        profile = self._profile_for_player_name(player_name)
        if not isinstance(profile, dict):
            profile = {}
        spellcasting = profile.get("spellcasting", {})
        slots = self._normalize_spell_slots(spellcasting.get("spell_slots") if isinstance(spellcasting, dict) else None)
        return player_name, slots

    def _consume_spell_slot_for_cast(
        self,
        caster_name: str,
        slot_level: Optional[int],
        minimum_level: Optional[int],
    ) -> Tuple[bool, str, Optional[int]]:
        if slot_level is None:
            return True, "", None
        if slot_level == 0:
            return True, "", 0
        if slot_level < 1 or slot_level > 9:
            return False, "Pick a valid spell slot level, matey.", None
        if minimum_level is not None and slot_level < minimum_level:
            return False, "Ye can't downcast that spell, matey.", None
        try:
            player_name, slots = self._resolve_spell_slot_profile(caster_name)
        except ValueError as exc:
            return False, str(exc), None
        except Exception:
            return False, "No spell slots set up for that caster, matey.", None

        spend_level = None
        for lvl in range(slot_level, 10):
            key = str(lvl)
            current_slots = int(slots.get(key, {}).get("current", 0) or 0)
            if current_slots > 0:
                spend_level = lvl
                break
        if spend_level is None:
            return False, "No spell slots left for that level, matey.", None

        spend_key = str(spend_level)
        slots[spend_key]["current"] = max(0, int(slots[spend_key].get("current", 0) or 0) - 1)
        try:
            self._save_player_spell_slots(player_name, slots)
        except Exception:
            return False, "Could not update spell slots, matey.", None
        return True, "", spend_level

    def _set_wild_shape_pool_current(self, player_name: str, current_value: int) -> Tuple[bool, str, Optional[int]]:
        self._load_player_yaml_cache()
        player_path = self._find_player_profile_path(player_name)
        raw = self._player_yaml_cache_by_path.get(player_path) if player_path else None
        if not isinstance(raw, dict):
            return False, "No resource pools set up for that caster, matey.", None
        normalized = self._normalize_player_resource_pools(raw)
        wild_entry = next((entry for entry in normalized if str(entry.get("id") or "").lower() == "wild_shape"), None)
        if not isinstance(wild_entry, dict):
            return False, "No Wild Shape uses remain, matey.", None
        max_value = int(wild_entry.get("max") or 0)
        clamped = max(0, min(int(current_value), max_value))

        resources = raw.get("resources") if isinstance(raw.get("resources"), dict) else {}
        pools = resources.get("pools") if isinstance(resources.get("pools"), list) else []
        found = False
        for entry in pools:
            if not isinstance(entry, dict):
                continue
            if str(entry.get("id") or "").strip().lower() != "wild_shape":
                continue
            entry["id"] = "wild_shape"
            entry["label"] = "Wild Shape"
            entry["max_formula"] = "max(2, min(4, 2 + floor(druid_level / 3)))"
            entry["reset"] = "long_rest"
            entry["gain_on_short"] = 1
            entry["current"] = clamped
            found = True
            break
        if not found:
            pools.append(
                {
                    "id": "wild_shape",
                    "label": "Wild Shape",
                    "current": clamped,
                    "max_formula": "max(2, min(4, 2 + floor(druid_level / 3)))",
                    "reset": "long_rest",
                    "gain_on_short": 1,
                }
            )
        resources = dict(resources)
        resources["pools"] = pools
        raw = dict(raw)
        raw["resources"] = resources
        try:
            self._store_character_yaml(player_path, raw)
            self._load_player_yaml_cache(force_refresh=True)
        except Exception:
            return False, "Could not update Wild Shape pool, matey.", None
        return True, "", clamped

    def _consume_spell_slot_for_wild_shape_regain(self, caster_name: str) -> Tuple[bool, str, Optional[int]]:
        try:
            player_name, slots = self._resolve_spell_slot_profile(caster_name)
        except ValueError as exc:
            return False, str(exc), None
        except Exception:
            return False, "No spell slots set up for that caster, matey.", None
        spend_level = None
        for lvl in range(1, 10):
            if int(slots.get(str(lvl), {}).get("current", 0) or 0) > 0:
                spend_level = lvl
                break
        if spend_level is None:
            return False, "No spell slots left to fuel Wild Shape, matey.", None
        slots[str(spend_level)]["current"] = max(0, int(slots[str(spend_level)].get("current", 0) or 0) - 1)
        try:
            self._save_player_spell_slots(player_name, slots)
        except Exception:
            return False, "Could not update spell slots, matey.", None
        return True, "", spend_level

    def _regain_first_level_spell_slot(self, caster_name: str) -> Tuple[bool, str]:
        try:
            player_name, slots = self._resolve_spell_slot_profile(caster_name)
        except ValueError as exc:
            return False, str(exc)
        except Exception:
            return False, "No spell slots set up for that caster, matey."
        level_one = slots.get("1") if isinstance(slots, dict) else None
        if not isinstance(level_one, dict) or int(level_one.get("max", 0) or 0) <= 0:
            return False, "No level 1 spell slots available for that caster, matey."
        cur = int(level_one.get("current", 0) or 0)
        max_value = int(level_one.get("max", 0) or 0)
        if cur >= max_value:
            return False, "Level 1 spell slots already full, matey."
        level_one["current"] = min(max_value, cur + 1)
        try:
            self._save_player_spell_slots(player_name, slots)
        except Exception:
            return False, "Could not update spell slots, matey."
        return True, ""

    def _apply_wild_shape(self, cid: int, beast_id: str) -> Tuple[bool, str]:
        c = self.combatants.get(int(cid))
        if c is None:
            return False, "That scallywag ain’t in combat no more."
        if bool(getattr(c, "is_wild_shaped", False)):
            return False, "Already Wild Shaped, matey."
        player_name = self._pc_name_for(int(cid))
        profile = self._profile_for_player_name(player_name)
        if not isinstance(profile, dict):
            return False, "No player profile found for Wild Shape, matey."
        known_map = self.__dict__.get("_wild_shape_known_by_player", {})
        runtime_known = known_map.get(player_name.strip().lower(), []) if isinstance(known_map, dict) else []
        if not runtime_known:
            runtime_known = self._normalized_prepared_wild_shapes_from_profile(profile)
        known_forms = self._wild_shape_available_forms(
            {**profile, "prepared_wild_shapes": runtime_known, "learned_wild_shapes": runtime_known},
            known_only=True,
        )
        forms = {
            self._wild_shape_identifier_key(entry.get("id")): entry
            for entry in known_forms
            if isinstance(entry, dict)
        }
        aliases = self._wild_shape_alias_lookup(known_forms)
        resolved_id = aliases.get(self._wild_shape_identifier_key(beast_id))
        form = forms.get(resolved_id or "")
        if not isinstance(form, dict):
            return False, "That beast form be unavailable, matey."
        current_pool = next((p for p in self._normalize_player_resource_pools(profile) if str(p.get("id") or "").lower() == "wild_shape"), None)
        if not isinstance(current_pool, dict) or int(current_pool.get("current", 0) or 0) <= 0:
            return False, "No Wild Shape uses remain, matey."
        ok_pool, pool_err, new_cur = self._set_wild_shape_pool_current(player_name, int(current_pool.get("current", 0)) - 1)
        if not ok_pool:
            return False, pool_err or "Could not consume Wild Shape use, matey."

        base_snapshot = {
            "name": str(getattr(c, "name", "") or ""),
            "speed": int(getattr(c, "speed", 0) or 0),
            "swim_speed": int(getattr(c, "swim_speed", 0) or 0),
            "fly_speed": int(getattr(c, "fly_speed", 0) or 0),
            "climb_speed": int(getattr(c, "climb_speed", 0) or 0),
            "burrow_speed": int(getattr(c, "burrow_speed", 0) or 0),
            "movement_mode": str(getattr(c, "movement_mode", "Normal") or "Normal"),
            "dex": int(getattr(c, "dex", 10) or 10),
            "con": int(getattr(c, "con", 10) or 10),
            "str": int(getattr(c, "str", 10) or 10),
            "is_spellcaster": bool(getattr(c, "is_spellcaster", False)),
            "temp_hp": int(getattr(c, "temp_hp", 0) or 0),
            "actions": copy.deepcopy(getattr(c, "actions", [])),
            "bonus_actions": copy.deepcopy(getattr(c, "bonus_actions", [])),
        }
        setattr(c, "wild_shape_base", base_snapshot)
        setattr(c, "wild_shape_prev_temp_hp", int(getattr(c, "temp_hp", 0) or 0))
        setattr(c, "wild_shape_applied_temp_hp", int(self._druid_level_from_profile(profile)))
        setattr(c, "wild_shape_form_id", str(form.get("id") or ""))
        setattr(c, "wild_shape_form_name", str(form.get("name") or ""))
        setattr(c, "wild_shape_pool_current", int(new_cur if new_cur is not None else 0))
        setattr(c, "wild_resurgence_turn_used", False)
        setattr(c, "wild_resurgence_slot_used", bool(getattr(c, "wild_resurgence_slot_used", False)))

        speed = form.get("speed") if isinstance(form.get("speed"), dict) else {}
        setattr(c, "speed", int(speed.get("walk") or 0))
        setattr(c, "swim_speed", int(speed.get("swim") or 0))
        setattr(c, "fly_speed", int(speed.get("fly") or 0))
        setattr(c, "climb_speed", int(speed.get("climb") or 0))
        setattr(c, "str", int((form.get("abilities") or {}).get("str") or getattr(c, "str", 10) or 10))
        setattr(c, "dex", int((form.get("abilities") or {}).get("dex") or getattr(c, "dex", 10) or 10))
        setattr(c, "con", int((form.get("abilities") or {}).get("con") or getattr(c, "con", 10) or 10))
        setattr(c, "movement_mode", "Fly" if int(speed.get("fly") or 0) > 0 else ("Swim" if int(speed.get("swim") or 0) > 0 else "Normal"))
        mode_speed = int(self._mode_speed(c) or 0)
        setattr(c, "move_total", mode_speed)
        setattr(c, "move_remaining", mode_speed)
        setattr(c, "temp_hp", int(getattr(c, "wild_shape_applied_temp_hp", 0) or 0))
        setattr(c, "is_spellcaster", False)
        setattr(c, "is_wild_shaped", True)
        setattr(c, "name", f"{base_snapshot['name']} ({str(form.get('name') or '').strip()})")
        role_memory = self.__dict__.get("_name_role_memory", {})
        if isinstance(role_memory, dict):
            base_name = str(base_snapshot.get("name") or "")
            display_name = str(getattr(c, "name", "") or "")
            role = role_memory.get(base_name)
            if role in ("pc", "ally", "enemy"):
                role_memory[display_name] = role
            elif bool(getattr(c, "is_pc", False)):
                role_memory[display_name] = "pc"
        raw_form_actions = form.get("actions") if isinstance(form.get("actions"), list) else []
        beast_actions = self._normalize_action_entries(raw_form_actions, "action")
        multiattack_count = 1
        for raw_action in raw_form_actions:
            if not isinstance(raw_action, dict):
                continue
            if self._action_name_key(raw_action.get("name")) != "multiattack":
                continue
            multi_text = str(raw_action.get("description") or raw_action.get("desc") or "").strip().lower()
            if not multi_text:
                break
            word_counts = {"one": 1, "two": 2, "three": 3, "four": 4, "five": 5}
            count = 0
            for word, value in word_counts.items():
                count += len(re.findall(rf"\b{word}\b[^.]*?\battack\b", multi_text))
            for match in re.finditer(r"\b(\d+)\b[^.]*?\battack\b", multi_text):
                try:
                    count += int(match.group(1))
                except Exception:
                    continue
            if count > 0:
                multiattack_count = max(1, min(10, int(count)))
            break
        for entry in beast_actions:
            if not isinstance(entry, dict):
                continue
            desc_text = str(entry.get("description") or "").strip()
            lowered = desc_text.lower()
            if "attack roll" not in lowered or "hit" not in lowered:
                continue
            to_hit_match = re.search(r"attack roll\s*:\s*([+\-]?\d+)", desc_text, flags=re.IGNORECASE)
            range_match = re.search(r"(?:reach|range)\s*(\d+)\s*ft", desc_text, flags=re.IGNORECASE)
            damage_match = re.search(
                r"hit\s*:\s*[^.]*?\(([^)]+)\)\s*([a-zA-Z]+)\s+damage",
                desc_text,
                flags=re.IGNORECASE,
            )
            weapon_name = str(entry.get("name") or "").strip()
            weapon_id = str(entry.get("id") or "").strip()
            if not weapon_id:
                weapon_id = re.sub(r"[^a-z0-9]+", "-", weapon_name.lower()).strip("-")
            weapon_payload: Dict[str, Any] = {
                "id": weapon_id or "wild-shape-attack",
                "name": weapon_name or "Wild Shape Attack",
                "category": "ranged_weapon" if "ranged attack roll" in lowered else "melee_weapon",
                "range": f"{int(range_match.group(1))} ft"
                if range_match
                else ("60 ft" if "ranged attack roll" in lowered else "5 ft"),
            }
            if to_hit_match:
                try:
                    weapon_payload["to_hit"] = int(to_hit_match.group(1))
                except Exception:
                    pass
            if damage_match:
                weapon_payload["one_handed"] = {
                    "damage_formula": str(damage_match.group(1)).strip(),
                    "damage_type": str(damage_match.group(2)).strip().lower(),
                }
            entry["attack_overlay_mode"] = "attack_request"
            entry["attack_weapon"] = weapon_payload
            if multiattack_count > 1:
                entry["attack_count"] = int(multiattack_count)
            entry["resolve_prompt"] = f"Attack target with {weapon_payload['name']}."
        if beast_actions:
            setattr(c, "actions", beast_actions)
        base_bonus_actions = base_snapshot.get("bonus_actions") if isinstance(base_snapshot.get("bonus_actions"), list) else []
        retained_bonus_actions = []
        for entry in base_bonus_actions:
            if not isinstance(entry, dict):
                retained_bonus_actions.append(copy.deepcopy(entry))
                continue
            if self._wild_shape_identifier_key(entry.get("id")) == "wild-shape":
                continue
            if self._wild_shape_identifier_key(entry.get("name")) == "wild-shape":
                continue
            retained_bonus_actions.append(copy.deepcopy(entry))
        retained_bonus_actions.append(
            {
                "name": "End Wildshape Early",
                "description": "Revert to your normal form.",
                "type": "bonus_action",
            }
        )
        setattr(c, "bonus_actions", retained_bonus_actions)
        return True, ""

    def _revert_wild_shape(self, cid: int) -> Tuple[bool, str]:
        c = self.combatants.get(int(cid))
        if c is None:
            return False, "That scallywag ain’t in combat no more."
        if not bool(getattr(c, "is_wild_shaped", False)):
            return False, "Ye ain't Wild Shaped, matey."
        base_snapshot = getattr(c, "wild_shape_base", None)
        if not isinstance(base_snapshot, dict):
            return False, "Could not restore Wild Shape state, matey."
        for key in ("name", "speed", "swim_speed", "fly_speed", "climb_speed", "burrow_speed", "movement_mode", "dex", "con", "str", "is_spellcaster"):
            if key in base_snapshot:
                setattr(c, key, base_snapshot[key])
        setattr(c, "actions", copy.deepcopy(base_snapshot.get("actions") if isinstance(base_snapshot.get("actions"), list) else []))
        setattr(c, "bonus_actions", copy.deepcopy(base_snapshot.get("bonus_actions") if isinstance(base_snapshot.get("bonus_actions"), list) else []))
        if int(getattr(c, "temp_hp", 0) or 0) == int(getattr(c, "wild_shape_applied_temp_hp", 0) or 0):
            setattr(c, "temp_hp", int(getattr(c, "wild_shape_prev_temp_hp", 0) or 0))
        setattr(c, "is_wild_shaped", False)
        setattr(c, "wild_shape_form_id", None)
        setattr(c, "wild_shape_form_name", None)
        setattr(c, "wild_shape_base", None)
        setattr(c, "wild_shape_applied_temp_hp", 0)
        setattr(c, "wild_shape_prev_temp_hp", 0)
        return True, ""

    def _sorted_combatants(self) -> List[base.Combatant]:
        ordered = list(self.combatants.values())

        def key(c: Any) -> Tuple[int, int, int, int, str, str]:
            anchor_after = _normalize_cid_value(getattr(c, "summon_anchor_after_cid", None), "summon.anchor")
            anchor_seq = int(getattr(c, "summon_anchor_seq", 0) or 0)
            if anchor_after is not None and anchor_after in self.combatants:
                anchor = self.combatants[anchor_after]
                init_key = -int(getattr(anchor, "initiative", 0) or 0)
                nat_key = -(1 if getattr(anchor, "nat20", False) else 0)
                dex_key = -(int(getattr(anchor, "dex", 0) or 0))
                anchor_name = str(getattr(anchor, "name", "")).lower()
                return (
                    init_key,
                    nat_key,
                    dex_key,
                    0,
                    f"{anchor_name}\x00{anchor_seq:06d}",
                    str(getattr(c, "name", "")).lower(),
                )
            return (
                -int(getattr(c, "initiative", 0) or 0),
                -(1 if getattr(c, "nat20", False) else 0),
                -(int(getattr(c, "dex", 0) or 0)),
                0,
                str(getattr(c, "name", "")).lower(),
                "",
            )

        ordered.sort(key=key)
        return ordered

    def _spell_preset_lookup(self) -> Tuple[Dict[str, Dict[str, Any]], Dict[str, Dict[str, Any]]]:
        by_slug: Dict[str, Dict[str, Any]] = {}
        by_id: Dict[str, Dict[str, Any]] = {}
        for preset in self._spell_presets_payload():
            if not isinstance(preset, dict):
                continue
            slug = str(preset.get("slug") or "").strip().lower()
            sid = str(preset.get("id") or "").strip().lower()
            if slug and slug not in by_slug:
                by_slug[slug] = preset
            if sid and sid not in by_id:
                by_id[sid] = preset
        return by_slug, by_id

    @staticmethod
    def _spell_label_from_identifiers(*values: Any) -> str:
        for value in values:
            raw = str(value or "").strip()
            if not raw:
                continue
            pretty = raw.replace("-", " ").replace("_", " ")
            pretty = " ".join(pretty.split())
            if pretty:
                return pretty
        return "a spell"

    def _spell_cast_log_message(self, caster_name: str, spell_name: str, slot_level: Optional[int]) -> str:
        caster = str(caster_name or "").strip() or "Someone"
        name = self._spell_label_from_identifiers(spell_name)
        level_text = ""
        try:
            lvl = int(slot_level) if slot_level is not None else None
        except Exception:
            lvl = None
        if lvl is not None and lvl >= 0:
            level_text = f" at level {lvl}"
        return f"{caster} cast {name}{level_text}"

    @staticmethod
    def _smite_slug_from_preset(preset: Any) -> str:
        if not isinstance(preset, dict):
            return ""
        candidates = (
            str(preset.get("slug") or "").strip().lower(),
            str(preset.get("id") or "").strip().lower(),
        )
        for candidate in candidates:
            if candidate in _SMITE_SPELL_CONFIG:
                return candidate
        tags = preset.get("tags")
        has_smite_tag = isinstance(tags, list) and any(str(tag).strip().lower() == "smite" for tag in tags)
        if not has_smite_tag:
            return ""
        for candidate in candidates:
            if candidate.endswith("-smite"):
                return candidate
        return ""

    @staticmethod
    def _smite_damage_dice(config: Dict[str, Any], slot_level: Optional[int]) -> Optional[str]:
        base_dice = str(config.get("base_dice") or "").strip().lower()
        match_base = re.fullmatch(r"(\d+)d(\d+)", base_dice)
        if not match_base:
            return None
        count = int(match_base.group(1))
        sides = int(match_base.group(2))
        add_count = 0
        add_die = str(config.get("upcast_die") or "").strip().lower()
        match_add = re.fullmatch(r"(\d+)d(\d+)", add_die)
        if match_add and int(match_add.group(2)) == sides:
            base_slot = int(config.get("base_slot") or 0)
            effective_slot = int(slot_level or base_slot or 0)
            if base_slot > 0 and effective_slot > base_slot:
                add_count = int(match_add.group(1)) * int(effective_slot - base_slot)
        total_count = count + add_count
        if total_count <= 0:
            return None
        return f"{int(total_count)}d{int(sides)}"

    def _find_spell_preset(self, spell_slug: Any, spell_id: Any) -> Optional[Dict[str, Any]]:
        by_slug, by_id = self._spell_preset_lookup()
        slug = str(spell_slug or "").strip().lower()
        sid = str(spell_id or "").strip().lower()
        if slug and slug in by_slug:
            return by_slug[slug]
        if sid and sid in by_id:
            return by_id[sid]
        return None

    def _find_monster_spec_by_slug(self, monster_slug: Any) -> Optional[MonsterSpec]:
        normalized = self._normalize_monster_slug_value(monster_slug)
        if not normalized:
            return None
        if not self._monster_specs:
            self._load_monsters_index()
        direct_spec: Optional[MonsterSpec] = None
        basename_spec: Optional[MonsterSpec] = None
        for spec in self._monster_specs:
            rel = Path(str(spec.filename or "")).with_suffix("").as_posix().strip().lower().replace("\\", "/")
            base = Path(str(spec.filename or "")).stem.strip().lower()
            if rel == normalized:
                direct_spec = spec
                break
            if basename_spec is None and base == normalized:
                basename_spec = spec
        chosen = direct_spec or basename_spec
        if chosen is None:
            return None
        detailed = self._load_monster_details(chosen.name)
        return detailed or chosen

    def _normalize_monster_slug_value(self, monster_slug: Any) -> Optional[str]:
        slug = str(monster_slug or "").strip().lower().replace("\\", "/")
        if not slug:
            return None
        normalized = slug.strip("/")
        if normalized.endswith(".yaml"):
            normalized = normalized[:-5]
        elif normalized.endswith(".yml"):
            normalized = normalized[:-4]
        if normalized.startswith("monsters/"):
            normalized = normalized[len("monsters/"):]
        normalized = normalized.strip("/")
        return normalized or None

    @staticmethod
    def _normalize_summon_controller_mode(summon_cfg: Dict[str, Any]) -> str:
        mode = str(summon_cfg.get("control") or "summoner").strip().lower()
        if mode == "dm":
            return "dm"
        if mode in ("shared_turn", "summoner"):
            return mode
        return "summoner"

    @staticmethod
    def _resolve_summon_choice(
        summon_cfg: Dict[str, Any], summon_choice: Any, slot_level: Optional[int]
    ) -> Tuple[Optional[Dict[str, Any]], Optional[int], Optional[str]]:
        choices = summon_cfg.get("choices") if isinstance(summon_cfg.get("choices"), list) else []
        normalized_choice = str(summon_choice or "").strip().lower()
        selected_choice: Optional[Dict[str, Any]] = None
        if choices:
            def entry_matches(entry: Dict[str, Any], key: str) -> bool:
                if not key:
                    return False
                values = [entry.get("monster_slug"), entry.get("name"), entry.get("slug"), entry.get("id")]
                return any(str(value or "").strip().lower() == key for value in values)

            for entry in choices:
                if isinstance(entry, dict) and entry_matches(entry, normalized_choice):
                    selected_choice = entry
                    break
            if selected_choice is None and not normalized_choice:
                for entry in choices:
                    if isinstance(entry, dict) and entry.get("monster_slug"):
                        selected_choice = entry
                        break

        count_cfg = summon_cfg.get("count") if isinstance(summon_cfg.get("count"), dict) else {}
        kind = str(count_cfg.get("kind") or "fixed").strip().lower()
        if kind == "variable_by_slot":
            effective_slot = int(slot_level or 0)
            base_cfg = count_cfg.get("base") if isinstance(count_cfg.get("base"), dict) else {}
            active_cfg: Dict[str, Any] = dict(base_cfg)
            for override in count_cfg.get("slot_overrides") if isinstance(count_cfg.get("slot_overrides"), list) else []:
                if not isinstance(override, dict):
                    continue
                try:
                    override_level = int(override.get("slot_level"))
                except Exception:
                    continue
                if override_level == effective_slot:
                    active_cfg = dict(override)
                    break

            if isinstance(active_cfg.get("options"), list):
                options = [opt for opt in active_cfg.get("options") if isinstance(opt, dict)]
                picked = None
                if normalized_choice:
                    for opt in options:
                        creature_options = [str(v).strip().lower() for v in opt.get("creature_options", [])]
                        if normalized_choice in creature_options:
                            picked = opt
                            break
                if picked is None and options:
                    picked = options[0]
                if isinstance(picked, dict):
                    active_cfg = dict(picked)

            chosen_slug = None
            if selected_choice is not None:
                chosen_slug = str(selected_choice.get("monster_slug") or "").strip().lower() or None
            if chosen_slug is None:
                creature_options = active_cfg.get("creature_options")
                if isinstance(creature_options, list) and creature_options:
                    chosen_slug = str(creature_options[0] or "").strip().lower() or None
            try:
                quantity = int(active_cfg.get("quantity"))
            except Exception:
                quantity = None
            return selected_choice, quantity, chosen_slug

        quantity = None
        if isinstance(count_cfg.get("value"), (int, float)):
            quantity = int(count_cfg.get("value"))
        elif isinstance(count_cfg.get("min"), (int, float)):
            quantity = int(count_cfg.get("min"))
        elif isinstance(count_cfg.get("max"), (int, float)):
            quantity = int(count_cfg.get("max"))
        chosen_slug = None
        if selected_choice is not None:
            chosen_slug = str(selected_choice.get("monster_slug") or "").strip().lower() or None
        return selected_choice, quantity, chosen_slug

    def _summon_can_be_controlled_by(self, claimed_cid: Optional[int], target_cid: Optional[int]) -> bool:
        if claimed_cid is None or target_cid is None:
            return False
        combatant = self.combatants.get(int(target_cid))
        if combatant is None:
            return False
        owner = _normalize_cid_value(getattr(combatant, "summoned_by_cid", None), "summon.owner")
        if owner != int(claimed_cid):
            return False
        mode = str(getattr(combatant, "summon_controller_mode", "") or "").strip().lower()
        if mode == "summoner":
            return True
        return bool(getattr(combatant, "summon_shared_turn", False))

    def _is_valid_summon_turn_for_controller(
        self, controlling_cid: Optional[int], target_cid: Optional[int], current_cid: Optional[int]
    ) -> bool:
        if target_cid is None or current_cid is None:
            return False
        if int(current_cid) == int(target_cid):
            return True
        combatant = self.combatants.get(int(target_cid))
        if combatant is None:
            return False
        owner = _normalize_cid_value(getattr(combatant, "summoned_by_cid", None), "summon.owner")
        return bool(
            getattr(combatant, "summon_shared_turn", False)
            and controlling_cid is not None
            and owner == int(controlling_cid)
            and int(current_cid) == int(controlling_cid)
        )

    def _mount_rider_is_incapacitated(self, mount: Any) -> bool:
        rider_cid = _normalize_cid_value(getattr(mount, "mounted_by_cid", None), "mount.rider")
        if rider_cid is None:
            return True
        rider = self.combatants.get(int(rider_cid))
        if rider is None:
            return True
        return bool(self._has_condition(rider, "incapacitated"))

    def _mount_action_is_restricted(self, mount: Any, action_name: str) -> bool:
        if not bool(getattr(mount, "is_mount", False)):
            return False
        rider_cid = _normalize_cid_value(getattr(mount, "mounted_by_cid", None), "mount.rider")
        if rider_cid is None:
            return False
        rider = self.combatants.get(int(rider_cid))
        if rider is None:
            return False
        if self._mount_rider_is_incapacitated(mount):
            setattr(mount, "mount_controller_mode", "independent")
            return False
        if str(getattr(mount, "mount_controller_mode", "") or "").strip().lower() != "rider":
            return False
        allowed = {"dash", "disengage", "dodge"}
        return self._action_name_key(action_name) not in allowed

    def _mount_uses_rider_movement(self, mount: Any) -> bool:
        if mount is None:
            return False
        if not bool(getattr(mount, "mount_shared_turn", False)):
            return False
        mode = str(getattr(mount, "mount_controller_mode", "") or "").strip().lower()
        return mode == "rider"

    def _apply_mount_initiative(self, rider_cid: int, mount_cid: int) -> None:
        rider = self.combatants.get(int(rider_cid))
        mount = self.combatants.get(int(mount_cid))
        if rider is None or mount is None:
            return
        mount.initiative = int(getattr(rider, "initiative", 0) or 0)
        setattr(mount, "mount_shared_turn", True)
        setattr(mount, "summon_anchor_after_cid", int(rider_cid))
        setattr(mount, "summon_anchor_seq", 1)

    def _restore_mount_initiative(self, rider_cid: int, mount_cid: int) -> None:
        mount = self.combatants.get(int(mount_cid))
        if mount is None:
            return
        setattr(mount, "mount_shared_turn", False)
        setattr(mount, "summon_anchor_after_cid", None)
        setattr(mount, "summon_anchor_seq", 0)

    def _mount_cost(self, rider: Any) -> int:
        return max(0, int(getattr(rider, "speed", 0) or 0) // 2)

    def _find_ws_for_cid(self, cid: Optional[int]) -> List[int]:
        if cid is None:
            return []
        try:
            with self._lan._clients_lock:
                return list(self._lan._cid_to_ws.get(int(cid), set()))
        except Exception:
            return []

    def _accept_mount(self, rider_cid: int, mount_cid: int, ws_id: Optional[int], auto: bool = False) -> None:
        rider = self.combatants.get(int(rider_cid))
        mount = self.combatants.get(int(mount_cid))
        if rider is None or mount is None:
            return
        if bool(getattr(rider, "has_mounted_this_turn", False)):
            if ws_id is not None:
                self._lan.toast(ws_id, "Ye already mounted this turn.")
            return
        cost = self._mount_cost(rider)
        if int(getattr(rider, "move_remaining", 0) or 0) < cost:
            if ws_id is not None:
                self._lan.toast(ws_id, f"Not enough movement to mount (need {cost} ft).")
            return
        rider.move_remaining = max(0, int(getattr(rider, "move_remaining", 0) or 0) - cost)
        setattr(rider, "has_mounted_this_turn", True)
        setattr(rider, "rider_cid", int(mount_cid))
        setattr(mount, "mounted_by_cid", int(rider_cid))
        true_mount = bool(getattr(mount, "can_be_mounted", False) or getattr(mount, "is_mount", False))
        if true_mount:
            setattr(mount, "mount_controller_mode", "rider")
            self._apply_mount_initiative(int(rider_cid), int(mount_cid))
        else:
            setattr(mount, "mount_controller_mode", "independent")
            self._restore_mount_initiative(int(rider_cid), int(mount_cid))
        self._log(f"{rider.name} mounts {mount.name}.", cid=rider.cid)
        if auto and ws_id is not None:
            self._lan.toast(ws_id, f"You mount your {mount.name}.")
        self._lan_force_state_broadcast()

    def _apply_summon_initiative(self, caster_cid: int, spawned_cids: List[int], summon_cfg: Dict[str, Any]) -> None:
        initiative_cfg = summon_cfg.get("initiative") if isinstance(summon_cfg.get("initiative"), dict) else {}
        mode = str(initiative_cfg.get("mode") or "rolled_per_creature").strip().lower()
        caster = self.combatants.get(caster_cid)
        if caster is None:
            return
        if mode in ("shared", "shared_with_caster"):
            caster_init = int(getattr(caster, "initiative", 0) or 0)
            base_anchor = int(getattr(caster, "summon_anchor_seq", 0) or 0)
            for offset, scid in enumerate(spawned_cids, start=1):
                summoned = self.combatants.get(scid)
                if summoned is None:
                    continue
                summoned.initiative = caster_init
                setattr(summoned, "summon_shared_turn", True)
                setattr(summoned, "summon_anchor_after_cid", caster_cid)
                setattr(summoned, "summon_anchor_seq", base_anchor + offset)
            setattr(caster, "summon_anchor_seq", base_anchor + len(spawned_cids))
            return

        for scid in spawned_cids:
            summoned = self.combatants.get(scid)
            if summoned is None:
                continue
            dex_mod = int(getattr(summoned, "dex", 0) or 0)
            summoned.initiative = int(random.randint(1, 20) + dex_mod)
            setattr(summoned, "summon_shared_turn", False)

    def _evaluate_dynamic_formula(self, formula: Any, variables: Dict[str, Any]) -> Any:
        if not isinstance(formula, str):
            return formula
        trimmed = formula.strip()
        if not trimmed:
            return formula
        if not re.fullmatch(r"[0-9+\-*/(). _a-zA-Z]+", trimmed):
            return formula
        expr = trimmed
        flattened: Dict[str, float] = {}
        for key, value in (variables or {}).items():
            if isinstance(value, dict):
                for nested_key, nested_val in value.items():
                    try:
                        safe_value = float(nested_val)
                    except Exception:
                        safe_value = 0.0
                    if not math.isfinite(safe_value):
                        safe_value = 0.0
                    flattened[f"{key}.{nested_key}"] = safe_value
            else:
                try:
                    safe_value = float(value)
                except Exception:
                    safe_value = 0.0
                if not math.isfinite(safe_value):
                    safe_value = 0.0
                flattened[str(key)] = safe_value
        for key in sorted(flattened.keys(), key=len, reverse=True):
            expr = re.sub(rf"\b{re.escape(str(key))}\b", str(flattened[key]), expr)
        if re.search(r"[a-zA-Z]", expr):
            return formula
        try:
            result = eval(expr, {"__builtins__": {}})
        except Exception:
            return formula
        try:
            result_value = float(result)
        except Exception:
            return formula
        if not math.isfinite(result_value):
            return formula
        if abs(result_value - round(result_value)) < 1e-9:
            return int(round(result_value))
        return result_value

    def _apply_monster_variant(self, spec: MonsterSpec, variant_name: Optional[str], slot_level: Optional[int]) -> MonsterSpec:
        if not isinstance(getattr(spec, "raw_data", None), dict):
            return spec
        raw_data = copy.deepcopy(spec.raw_data)
        variables = {"var": {"slot_level": int(slot_level or 0)}}
        for key in ("ac", "hp"):
            if key in raw_data:
                raw_data[key] = self._evaluate_dynamic_formula(raw_data.get(key), variables)
        hp_value = raw_data.get("hp")
        hp = spec.hp
        if isinstance(hp_value, (int, float)):
            hp = int(hp_value)
        selected_variant = None
        variants = raw_data.get("variants") if isinstance(raw_data.get("variants"), list) else []
        normalized_variant = str(variant_name or "").strip().lower()
        if normalized_variant:
            for variant in variants:
                if not isinstance(variant, dict):
                    continue
                if str(variant.get("name") or "").strip().lower() == normalized_variant:
                    selected_variant = variant
                    break
        if isinstance(selected_variant, dict):
            bonus_action = selected_variant.get("bonus_action")
            if isinstance(bonus_action, dict):
                bonus_name = str(bonus_action.get("name") or "").strip()
                bonus_desc = str(bonus_action.get("desc") or "").strip()
                if bonus_name:
                    existing_bonus = raw_data.get("bonus_actions") if isinstance(raw_data.get("bonus_actions"), list) else []
                    raw_data["bonus_actions"] = list(existing_bonus) + [{"name": bonus_name, "desc": bonus_desc}]
            raw_data["selected_variant"] = str(selected_variant.get("name") or "").strip() or None
            damage_type = str(selected_variant.get("damage_type") or "").strip()
            if damage_type:
                raw_data["selected_damage_type"] = damage_type
        return MonsterSpec(
            filename=spec.filename,
            name=spec.name,
            mtype=spec.mtype,
            cr=spec.cr,
            hp=hp,
            speed=spec.speed,
            swim_speed=spec.swim_speed,
            fly_speed=spec.fly_speed,
            burrow_speed=spec.burrow_speed,
            climb_speed=spec.climb_speed,
            dex=spec.dex,
            init_mod=spec.init_mod,
            saving_throws=dict(spec.saving_throws or {}),
            ability_mods=dict(spec.ability_mods or {}),
            raw_data=raw_data,
        )

    def _apply_startup_summon_overrides(self, spec: MonsterSpec, overrides: Dict[str, Any]) -> MonsterSpec:
        raw_data = copy.deepcopy(spec.raw_data) if isinstance(spec.raw_data, dict) else {}
        abilities = raw_data.get("abilities") if isinstance(raw_data.get("abilities"), dict) else {}
        abilities = dict(abilities)
        raw_data["abilities"] = abilities

        updated_name = spec.name
        updated_hp = spec.hp
        updated_speed = spec.speed
        updated_swim = spec.swim_speed
        updated_fly = spec.fly_speed
        updated_burrow = spec.burrow_speed
        updated_climb = spec.climb_speed
        updated_dex = spec.dex
        updated_init_mod = spec.init_mod
        updated_ability_mods = dict(spec.ability_mods or {})

        ability_key_map = {
            "str": "Str",
            "strength": "Str",
            "dex": "Dex",
            "dexterity": "Dex",
            "con": "Con",
            "constitution": "Con",
            "int": "Int",
            "intelligence": "Int",
            "wis": "Wis",
            "wisdom": "Wis",
            "cha": "Cha",
            "charisma": "Cha",
        }

        for key, value in (overrides or {}).items():
            original_key = str(key or "")
            normalized_key = original_key.strip().lower()
            if normalized_key in {"ac"}:
                raw_data["ac"] = value
                continue
            if normalized_key in {"hp"}:
                raw_data["hp"] = value
                hp_value = self._monster_int_from_value(value)
                if hp_value is not None:
                    updated_hp = hp_value
                continue
            if normalized_key == "name":
                updated_name = str(value or "").strip() or spec.name
                raw_data["name"] = updated_name
                continue
            if normalized_key in ability_key_map:
                ability_label = ability_key_map[normalized_key]
                ability_value = self._monster_int_from_value(value)
                if ability_value is None:
                    continue
                abilities[ability_label] = ability_value
                short = ability_label.lower()[:3]
                updated_ability_mods[short] = (ability_value - 10) // 2
                if short == "dex":
                    updated_dex = ability_value
                continue
            if normalized_key == "speed":
                raw_data["speed"] = value
                parsed_speed = base._parse_speed_data(value)
                if parsed_speed[0] is not None:
                    updated_speed = int(parsed_speed[0])
                if parsed_speed[1] is not None:
                    updated_swim = int(parsed_speed[1])
                if parsed_speed[2] is not None:
                    updated_fly = int(parsed_speed[2])
                if parsed_speed[3] is not None:
                    updated_burrow = int(parsed_speed[3])
                if parsed_speed[4] is not None:
                    updated_climb = int(parsed_speed[4])
                continue
            if normalized_key == "initiative":
                raw_data["initiative"] = value
                init_value = None
                if isinstance(value, dict):
                    init_value = self._monster_int_from_value(value.get("modifier"))
                else:
                    init_value = self._monster_int_from_value(value)
                if init_value is not None:
                    updated_init_mod = init_value
                continue
            if original_key in raw_data:
                raw_data[original_key] = value
            else:
                raw_data[normalized_key] = value

        return MonsterSpec(
            filename=spec.filename,
            name=updated_name,
            mtype=spec.mtype,
            cr=spec.cr,
            hp=updated_hp,
            speed=updated_speed,
            swim_speed=updated_swim,
            fly_speed=updated_fly,
            burrow_speed=updated_burrow,
            climb_speed=updated_climb,
            dex=updated_dex,
            init_mod=updated_init_mod,
            saving_throws=dict(spec.saving_throws or {}),
            ability_mods=updated_ability_mods,
            raw_data=raw_data,
        )

    def _spawn_startup_summons_for_pc(self, caster_cid: int, summon_entries: List[Dict[str, Any]]) -> List[int]:
        caster = self.combatants.get(int(caster_cid))
        if caster is None:
            return []
        source_spell = "summon_on_start"
        spawned_all: List[int] = []
        for entry_idx, raw_entry in enumerate(summon_entries):
            entry = dict(raw_entry) if isinstance(raw_entry, dict) else {}
            monster_ref = str(entry.get("monster") or "").strip()
            if not monster_ref:
                self._oplog(
                    f"Player {caster.name} (cid={caster_cid}): summon_on_start entry missing monster.",
                    level="warning",
                )
                continue
            slug = Path(monster_ref).stem.strip().lower()
            if not slug:
                self._oplog(
                    f"Player {caster.name} (cid={caster_cid}): invalid summon_on_start monster '{monster_ref}'.",
                    level="warning",
                )
                continue
            spec = self._find_monster_spec_by_slug(slug)
            if spec is None:
                self._oplog(
                    f"Player {caster.name} (cid={caster_cid}): summon_on_start monster '{monster_ref}' not found.",
                    level="warning",
                )
                continue
            count_raw = entry.get("count", 1)
            try:
                quantity = max(0, int(count_raw))
            except Exception:
                quantity = 1
            if quantity <= 0:
                continue
            overrides = entry.get("overrides") if isinstance(entry.get("overrides"), dict) else {}
            summon_spec = self._apply_startup_summon_overrides(spec, dict(overrides))
            group_id = f"startup:{int(time.time() * 1000)}:{caster_cid}:{entry_idx}:{len(self._summon_groups) + 1}"
            spawned_group: List[int] = []
            for _ in range(quantity):
                init_roll = int(random.randint(1, 20) + int(summon_spec.init_mod or 0))
                cid = self._create_combatant(
                    name=self._unique_name(summon_spec.name),
                    hp=int(summon_spec.hp or 1),
                    speed=int(summon_spec.speed or 30),
                    swim_speed=int(summon_spec.swim_speed or 0),
                    fly_speed=int(summon_spec.fly_speed or 0),
                    burrow_speed=int(summon_spec.burrow_speed or 0),
                    climb_speed=int(summon_spec.climb_speed or 0),
                    movement_mode="Normal",
                    initiative=init_roll,
                    dex=summon_spec.dex,
                    ally=True,
                    is_pc=False,
                    is_spellcaster=None,
                    saving_throws=dict(summon_spec.saving_throws or {}),
                    ability_mods=dict(summon_spec.ability_mods or {}),
                    monster_spec=summon_spec,
                )
                summoned = self.combatants.get(cid)
                if summoned is None:
                    continue
                setattr(summoned, "summoned_by_cid", int(caster_cid))
                setattr(summoned, "summon_source_spell", source_spell)
                setattr(summoned, "summon_group_id", group_id)
                setattr(summoned, "summon_controller_mode", "summoner")
                spawned_group.append(cid)
                spawned_all.append(cid)
            if spawned_group:
                self._summon_groups[group_id] = list(spawned_group)
                self._summon_group_meta[group_id] = {
                    "caster_cid": int(caster_cid),
                    "spell": source_spell,
                    "created_at": time.time(),
                    "concentration": False,
                }
        return spawned_all

    @staticmethod
    def _extract_recharge_text(raw_data: Dict[str, Any]) -> List[str]:
        if not isinstance(raw_data, dict):
            return []
        texts: List[str] = []
        seen: set[str] = set()

        def add_text(value: Any) -> None:
            text = str(value or "").strip()
            if not text:
                return
            key = text.lower()
            if key in seen:
                return
            seen.add(key)
            texts.append(text)

        for entry in raw_data.get("actions") if isinstance(raw_data.get("actions"), list) else []:
            if not isinstance(entry, dict):
                continue
            for field in ("name", "desc", "recharge", "recharge_time"):
                value = entry.get(field)
                if not value:
                    continue
                text = str(value)
                if "recharge" in text.lower():
                    add_text(text)

        for field in ("recharge", "recharge_time"):
            value = raw_data.get(field)
            if value:
                add_text(value)

        return texts

    def _monster_stat_block_payload(self, spec: MonsterSpec) -> Dict[str, Any]:
        raw_data = spec.raw_data if isinstance(spec.raw_data, dict) else {}
        abilities = raw_data.get("abilities") if isinstance(raw_data.get("abilities"), dict) else {}
        speed_data = raw_data.get("speed")
        speed = speed_data if isinstance(speed_data, (dict, list, str, int, float)) else spec.speed

        slug = self._monster_slug_from_spec(spec)
        payload: Dict[str, Any] = {
            "slug": slug,
            "name": raw_data.get("name") or spec.name,
            "size": raw_data.get("size"),
            "type": raw_data.get("type") or spec.mtype,
            "alignment": raw_data.get("alignment"),
            "armor_class": raw_data.get("ac"),
            "hit_points": raw_data.get("hp") if raw_data.get("hp") is not None else spec.hp,
            "speed": speed,
            "ability_scores": {
                "str": abilities.get("Str"),
                "dex": abilities.get("Dex"),
                "con": abilities.get("Con"),
                "int": abilities.get("Int"),
                "wis": abilities.get("Wis"),
                "cha": abilities.get("Cha"),
            },
            "senses": raw_data.get("senses"),
            "languages": raw_data.get("languages"),
            "damage_vulnerabilities": raw_data.get("damage_vulnerabilities")
            if isinstance(raw_data.get("damage_vulnerabilities"), list)
            else raw_data.get("vulnerabilities")
            if isinstance(raw_data.get("vulnerabilities"), list)
            else [],
            "damage_resistances": raw_data.get("damage_resistances")
            if isinstance(raw_data.get("damage_resistances"), list)
            else raw_data.get("resistances")
            if isinstance(raw_data.get("resistances"), list)
            else [],
            "damage_immunities": raw_data.get("damage_immunities")
            if isinstance(raw_data.get("damage_immunities"), list)
            else raw_data.get("immunities")
            if isinstance(raw_data.get("immunities"), list)
            else [],
            "traits": raw_data.get("traits") if isinstance(raw_data.get("traits"), list) else [],
            "actions": raw_data.get("actions") if isinstance(raw_data.get("actions"), list) else [],
            "bonus_actions": raw_data.get("bonus_actions") if isinstance(raw_data.get("bonus_actions"), list) else [],
            "legendary_actions": raw_data.get("legendary_actions") if isinstance(raw_data.get("legendary_actions"), list) else [],
            "spellcasting": raw_data.get("spellcasting"),
            "recharge": self._extract_recharge_text(raw_data),
            "selected_variant": raw_data.get("selected_variant"),
            "selected_damage_type": raw_data.get("selected_damage_type"),
        }
        image_url = self._local_monster_image_url(slug)
        if image_url:
            payload["image_url"] = image_url
        return payload

    def _local_monster_image_url(self, slug: str) -> Optional[str]:
        image_path = self._resolve_local_monster_image_path(slug)
        if image_path is None:
            return None
        return f"/monsters/images/{urllib.parse.quote(image_path.name)}"

    def _monster_slug_from_spec(self, spec: Optional[MonsterSpec]) -> str:
        if spec is None:
            return ""
        filename = str(getattr(spec, "filename", "") or "").strip()
        if filename:
            slug = Path(filename).stem.strip().lower()
            if slug:
                return slug
        name = str(getattr(spec, "name", "") or "").strip().lower()
        return re.sub(r"[^a-z0-9]+", "-", name).strip("-")

    def _resolve_local_monster_image_path(self, slug: str) -> Optional[Path]:
        safe_slug = str(slug or "").strip().lower()
        if not safe_slug:
            return None
        image_dirs = [
            _app_data_dir() / "Monsters" / "Images",
            _app_base_dir() / "Monsters" / "Images",
        ]
        for image_dir in image_dirs:
            for ext in (".jpg", ".jpeg", ".png", ".webp"):
                image_path = image_dir / f"{safe_slug}{ext}"
                try:
                    if image_path.is_file():
                        return image_path
                except Exception:
                    continue
        return None

    def _spawn_mount(
        self,
        caster_cid: int,
        preset: Dict[str, Any],
        summon_cfg: Dict[str, Any],
        chosen_slug: str,
        slot_level: Optional[int],
        variant_name: Optional[str],
        summon_positions: Optional[List[Dict[str, Any]]] = None,
    ) -> List[int]:
        spec = self._find_monster_spec_by_slug(chosen_slug)
        if spec is None:
            return []
        mod_spec = self._apply_monster_variant(spec, variant_name, slot_level)
        source_spell = str(preset.get("slug") or preset.get("id") or "").strip()
        group_id = f"summon:{int(time.time() * 1000)}:{caster_cid}:{len(self._summon_groups) + 1}"
        side_raw = str(summon_cfg.get("side") or "caster").strip().lower()
        ally_flag = False if side_raw == "enemy" else True
        color_override = self._normalize_token_color(summon_cfg.get("color") or summon_cfg.get("token_color"))
        hp = int(mod_spec.hp or 1)
        speed = int(mod_spec.speed or 60)
        init_mod = int(mod_spec.init_mod or 0)
        init_roll = int(random.randint(1, 20) + init_mod)
        display_variant = str(variant_name or "").strip()
        name = mod_spec.name if not display_variant else f"{mod_spec.name} ({display_variant})"
        cid = self._create_combatant(
            name=self._unique_name(name),
            hp=hp,
            speed=speed,
            swim_speed=int(mod_spec.swim_speed or 0),
            fly_speed=int(mod_spec.fly_speed or 0),
            burrow_speed=int(mod_spec.burrow_speed or 0),
            climb_speed=int(mod_spec.climb_speed or 0),
            movement_mode="Normal",
            initiative=init_roll,
            dex=mod_spec.dex,
            ally=ally_flag,
            is_pc=False,
            is_spellcaster=None,
            saving_throws=dict(mod_spec.saving_throws or {}),
            ability_mods=dict(mod_spec.ability_mods or {}),
            monster_spec=mod_spec,
        )
        summoned = self.combatants.get(cid)
        if summoned is None:
            return []
        setattr(summoned, "summoned_by_cid", int(caster_cid))
        setattr(summoned, "summon_source_spell", source_spell)
        setattr(summoned, "summon_group_id", group_id)
        setattr(summoned, "summon_controller_mode", "shared_turn")
        setattr(summoned, "is_mount", True)
        setattr(summoned, "can_be_mounted", True)
        setattr(summoned, "mounted_by_cid", None)
        setattr(summoned, "rider_cid", None)
        setattr(summoned, "mount_shared_turn", True)
        setattr(summoned, "mount_controller_mode", "summon_auto")
        setattr(summoned, "summon_variant", display_variant or None)
        setattr(summoned, "summon_slot_level", int(slot_level) if isinstance(slot_level, int) else None)
        if color_override:
            setattr(summoned, "token_color", color_override)
        spawned = [cid]
        self._apply_summon_initiative(int(caster_cid), spawned, summon_cfg)
        if summon_positions:
            pos = summon_positions[0] if isinstance(summon_positions[0], dict) else {}
            try:
                col = int(pos.get("col"))
                row = int(pos.get("row"))
                self._lan_positions[cid] = (col, row)
            except Exception:
                pass
        if spawned:
            self._summon_groups[group_id] = list(spawned)
            self._summon_group_meta[group_id] = {
                "caster_cid": int(caster_cid),
                "spell": source_spell,
                "created_at": time.time(),
                "concentration": bool(preset.get("concentration")),
                "mount": True,
            }
        return spawned

    def _spawn_summons_from_cast(
        self,
        caster_cid: int,
        spell_slug: Any,
        spell_id: Any,
        slot_level: Optional[int],
        summon_choice: Any,
        summon_quantity: Optional[int] = None,
        summon_positions: Optional[List[Dict[str, Any]]] = None,
        summon_variant: Optional[str] = None,
    ) -> List[int]:
        preset = self._find_spell_preset(spell_slug=spell_slug, spell_id=spell_id)
        if not isinstance(preset, dict):
            return []
        summon_cfg = preset.get("summon") if isinstance(preset.get("summon"), dict) else {}
        if not summon_cfg:
            return []

        selected_choice, quantity, chosen_slug = self._resolve_summon_choice(summon_cfg, summon_choice, slot_level)
        if summon_quantity is not None:
            try:
                quantity = int(summon_quantity)
            except Exception:
                quantity = quantity
        if quantity is None:
            quantity = 1
        quantity = max(0, int(quantity))
        if quantity <= 0:
            return []
        if not chosen_slug and isinstance(selected_choice, dict):
            chosen_slug = str(selected_choice.get("monster_slug") or "").strip().lower() or None
        if not chosen_slug:
            return []

        caster = self.combatants.get(int(caster_cid))
        if caster is None:
            return []

        if bool(summon_cfg.get("mount")):
            return self._spawn_mount(
                caster_cid=int(caster_cid),
                preset=preset,
                summon_cfg=summon_cfg,
                chosen_slug=str(chosen_slug),
                slot_level=slot_level,
                variant_name=summon_variant,
                summon_positions=summon_positions,
            )

        spec = self._find_monster_spec_by_slug(chosen_slug)
        if spec is None:
            return []
        spec = self._apply_monster_variant(spec, summon_variant, slot_level)

        group_id = f"summon:{int(time.time() * 1000)}:{caster_cid}:{len(self._summon_groups) + 1}"
        controller_mode = self._normalize_summon_controller_mode(summon_cfg)
        source_spell = str(preset.get("slug") or preset.get("id") or spell_slug or spell_id or "").strip()
        side_raw = str(summon_cfg.get("side") or "caster").strip().lower()
        ally_flag = False if side_raw == "enemy" else True
        color_override = self._normalize_token_color(summon_cfg.get("color") or summon_cfg.get("token_color"))

        spawned: List[int] = []
        for _ in range(quantity):
            hp = int(spec.hp or 1)
            speed = int(spec.speed or 30)
            swim = int(spec.swim_speed or 0)
            fly_speed = int(spec.fly_speed or 0)
            burrow_speed = int(spec.burrow_speed or 0)
            climb_speed = int(spec.climb_speed or 0)
            init_mod = int(spec.init_mod or 0)
            init_roll = int(random.randint(1, 20) + init_mod)
            cid = self._create_combatant(
                name=self._unique_name(spec.name),
                hp=hp,
                speed=speed,
                swim_speed=swim,
                fly_speed=fly_speed,
                burrow_speed=burrow_speed,
                climb_speed=climb_speed,
                movement_mode="Normal",
                initiative=init_roll,
                dex=spec.dex,
                ally=ally_flag,
                is_pc=False,
                is_spellcaster=None,
                saving_throws=dict(spec.saving_throws or {}),
                ability_mods=dict(spec.ability_mods or {}),
                monster_spec=spec,
            )
            summoned = self.combatants.get(cid)
            if summoned is None:
                continue
            setattr(summoned, "summoned_by_cid", int(caster_cid))
            setattr(summoned, "summon_source_spell", source_spell)
            setattr(summoned, "summon_group_id", group_id)
            setattr(summoned, "summon_controller_mode", controller_mode)
            setattr(summoned, "summon_variant", str(summon_variant or "").strip() or None)
            setattr(summoned, "summon_slot_level", int(slot_level) if isinstance(slot_level, int) else None)
            if color_override:
                setattr(summoned, "token_color", color_override)
            spawned.append(cid)

        self._apply_summon_initiative(int(caster_cid), spawned, summon_cfg)
        if spawned and summon_positions:
            for idx, scid in enumerate(spawned):
                if idx >= len(summon_positions):
                    break
                pos = summon_positions[idx] if isinstance(summon_positions[idx], dict) else {}
                try:
                    col = int(pos.get("col"))
                    row = int(pos.get("row"))
                except Exception:
                    continue
                self._lan_positions[scid] = (col, row)
                mw = getattr(self, "_map_window", None)
                try:
                    if mw is not None and mw.winfo_exists():
                        x, y = mw._grid_to_pixel(col, row)
                        mw._place_unit_at_pixel(scid, x, y)
                except Exception:
                    pass
        if spawned:
            self._summon_groups[group_id] = list(spawned)
            self._summon_group_meta[group_id] = {
                "caster_cid": int(caster_cid),
                "spell": source_spell,
                "created_at": time.time(),
                "concentration": bool(preset.get("concentration")),
            }
        return spawned

    @staticmethod
    def _normalize_custom_monster_slug(name: Any) -> str:
        raw = str(name or "").strip().lower()
        slug = re.sub(r"[^a-z0-9]+", "-", raw).strip("-")
        return slug or "custom-summon"

    def _write_temp_monster_yaml(self, payload: Dict[str, Any]) -> Tuple[bool, str, Optional[Path]]:
        if yaml is None:
            return False, "Monster YAML support requires PyYAML.", None
        if not isinstance(payload, dict):
            return False, "Invalid custom summon payload.", None
        name = str(payload.get("name") or "").strip()
        if not name:
            return False, "Custom summon needs a name.", None
        safe_name = " ".join(name.split())[:80]
        if not safe_name:
            return False, "Custom summon needs a valid name.", None
        monster_data = {
            "name": safe_name,
            "type": str(payload.get("type") or "construct").strip() or "construct",
            "hp": int(payload.get("hp") or 1),
            "speed": {
                "walk": int(payload.get("speeds", {}).get("walk", 30) or 0),
                "swim": int(payload.get("speeds", {}).get("swim", 0) or 0),
                "fly": int(payload.get("speeds", {}).get("fly", 0) or 0),
                "burrow": int(payload.get("speeds", {}).get("burrow", 0) or 0),
                "climb": int(payload.get("speeds", {}).get("climb", 0) or 0),
            },
            "abilities": {
                "str": int(payload.get("abilities", {}).get("str", 10) or 10),
                "dex": int(payload.get("abilities", {}).get("dex", 10) or 10),
                "con": int(payload.get("abilities", {}).get("con", 10) or 10),
                "int": int(payload.get("abilities", {}).get("int", 10) or 10),
                "wis": int(payload.get("abilities", {}).get("wis", 10) or 10),
                "cha": int(payload.get("abilities", {}).get("cha", 10) or 10),
            },
            "ac": int(payload.get("ac") or 10),
            "challenge_rating": payload.get("challenge_rating") if payload.get("challenge_rating") is not None else 0,
            "traits": payload.get("traits") if isinstance(payload.get("traits"), list) else [],
            "actions": payload.get("actions") if isinstance(payload.get("actions"), list) else [],
        }

        temp_dir = self._monsters_dir_path() / "temp"
        temp_dir.mkdir(parents=True, exist_ok=True)
        try:
            base_dir = temp_dir.resolve()
        except Exception:
            return False, "Could not access monster temp directory.", None

        base_slug = self._normalize_custom_monster_slug(safe_name)
        target: Optional[Path] = None
        for _ in range(100):
            suffix = "" if target is None else f"-{secrets.token_hex(2)}"
            candidate = temp_dir / f"{base_slug}{suffix}.yaml"
            try:
                resolved = candidate.resolve()
            except Exception:
                continue
            if base_dir not in resolved.parents:
                continue
            if resolved.exists():
                target = resolved
                continue
            target = resolved
            break
        if target is None:
            return False, "Could not allocate temp monster file.", None

        if target.exists():
            target = base_dir / f"{base_slug}-{secrets.token_hex(4)}.yaml"

        data = {"monster": monster_data}
        try:
            text = yaml.safe_dump(data, sort_keys=False, allow_unicode=True)
            target.write_text(text, encoding="utf-8")
        except Exception:
            return False, "Failed to write temp monster file.", None
        return True, target.stem, target

    def _spawn_custom_summons_from_payload(
        self,
        caster_cid: int,
        payload: Dict[str, Any],
    ) -> Tuple[bool, str, List[int]]:
        if not isinstance(payload, dict):
            return False, "Invalid summon payload.", []
        source_slug = str(payload.get("monster_slug") or payload.get("source_monster_slug") or "").strip()
        source_spec: Optional[MonsterSpec] = None
        source_raw: Dict[str, Any] = {}
        if source_slug:
            source_spec = self._find_monster_spec_by_slug(source_slug)
            if source_spec is not None and isinstance(source_spec.raw_data, dict):
                source_raw = dict(source_spec.raw_data)

        def _int_value(value: Any, fallback: Optional[int] = None) -> Optional[int]:
            try:
                if value is None:
                    return fallback
                if isinstance(value, bool):
                    return int(value)
                if isinstance(value, (int, float)):
                    return int(value)
                text = str(value).strip()
                if not text:
                    return fallback
                return int(float(text))
            except Exception:
                return fallback

        source_name = str(getattr(source_spec, "name", "")).strip()
        name = str(payload.get("name") or source_name or "").strip()
        if not name:
            return False, "Custom summon needs a name.", []
        hp = _int_value(payload.get("hp"), _int_value(getattr(source_spec, "hp", None), None))
        if hp is None:
            return False, "Custom summon needs valid HP.", []
        if hp <= 0:
            return False, "Custom summon HP must be above 0.", []

        source_abilities = source_raw.get("abilities") if isinstance(source_raw.get("abilities"), dict) else {}
        abilities = payload.get("abilities") if isinstance(payload.get("abilities"), dict) else payload.get("ability_scores") if isinstance(payload.get("ability_scores"), dict) else source_abilities
        normalized_abilities: Dict[str, int] = {}
        for ability in ("str", "dex", "con", "int", "wis", "cha"):
            val = _int_value(abilities.get(ability) if isinstance(abilities, dict) else None, 10)
            if val is None:
                return False, "Custom summon ability scores are invalid.", []
            if val < 1 or val > 30:
                return False, "Custom summon ability scores must be between 1 and 30.", []
            normalized_abilities[ability] = val

        source_speeds = {
            "walk": _int_value(getattr(source_spec, "speed", None), None),
            "swim": _int_value(getattr(source_spec, "swim_speed", None), None),
            "fly": _int_value(getattr(source_spec, "fly_speed", None), None),
            "burrow": _int_value(getattr(source_spec, "burrow_speed", None), None),
            "climb": _int_value(getattr(source_spec, "climb_speed", None), None),
        }
        speeds = payload.get("speeds") if isinstance(payload.get("speeds"), dict) else payload.get("speed") if isinstance(payload.get("speed"), dict) else source_raw.get("speed") if isinstance(source_raw.get("speed"), dict) else {}
        normalized_speeds: Dict[str, int] = {}
        for key in ("walk", "swim", "fly", "burrow", "climb"):
            fallback = source_speeds.get(key, None)
            default_value = 30 if key == "walk" else 0
            val = _int_value(speeds.get(key) if isinstance(speeds, dict) else None, fallback if fallback is not None else default_value)
            if val is None:
                return False, "Custom summon speeds are invalid.", []
            if val < 0:
                return False, "Custom summon speeds cannot be negative.", []
            normalized_speeds[key] = val
        if normalized_speeds.get("walk", 0) <= 0:
            return False, "Custom summon walk speed is required.", []

        try:
            quantity = int(payload.get("summon_quantity") if payload.get("summon_quantity") is not None else payload.get("quantity"))
        except Exception:
            return False, "Custom summon quantity is required.", []
        if quantity <= 0:
            return False, "Custom summon quantity must be above 0.", []

        try:
            summon_range_ft = float(payload.get("summon_range_ft") if payload.get("summon_range_ft") is not None else payload.get("range_ft"))
        except Exception:
            return False, "Custom summon range is required.", []
        if summon_range_ft < 0:
            return False, "Custom summon range cannot be negative.", []

        positions_raw = payload.get("summon_positions")
        if not isinstance(positions_raw, list) or len(positions_raw) < quantity:
            return False, "Custom summon positions are required for each summon.", []
        positions: List[Dict[str, int]] = []
        for entry in positions_raw[:quantity]:
            if not isinstance(entry, dict):
                return False, "Custom summon positions are invalid.", []
            try:
                col = int(entry.get("col"))
                row = int(entry.get("row"))
            except Exception:
                return False, "Custom summon positions are invalid.", []
            positions.append({"col": col, "row": row})

        caster = self.combatants.get(int(caster_cid))
        if caster is None:
            return False, "Could not find caster.", []
        caster_pos = self._lan_positions.get(int(caster_cid))
        if caster_pos is not None and summon_range_ft >= 0:
            for pos in positions:
                dist_ft = math.hypot(float(pos["col"]) - float(caster_pos[0]), float(pos["row"]) - float(caster_pos[1])) * 5.0
                if dist_ft - summon_range_ft > 1e-6:
                    return False, "Summon position is out of range.", []

        write_ok, slug, _path = self._write_temp_monster_yaml(
            {
                "name": name,
                "hp": hp,
                "abilities": normalized_abilities,
                "speeds": normalized_speeds,
                "ac": _int_value(payload.get("ac"), _int_value(source_raw.get("ac"), 10)),
                "type": str(payload.get("type") or source_raw.get("type") or "construct"),
                "challenge_rating": payload.get("challenge_rating", 0),
                "traits": payload.get("traits"),
                "actions": payload.get("actions"),
            }
        )
        if not write_ok or not slug:
            return False, "Could not save custom summon monster.", []

        self._load_monsters_index()
        spec = self._find_monster_spec_by_slug(f"temp/{slug}") or self._find_monster_spec_by_slug(slug)
        if spec is None:
            return False, "Saved custom monster could not be loaded.", []

        group_id = f"custom_summon:{int(time.time() * 1000)}:{caster_cid}:{len(self._summon_groups) + 1}"
        spawned: List[int] = []
        for idx in range(quantity):
            initiative = int(getattr(caster, "initiative", 10) or 10)
            cid = self._create_combatant(
                name=self._unique_name(spec.name),
                hp=int(spec.hp or hp),
                speed=int(spec.speed or normalized_speeds.get("walk", 30)),
                swim_speed=int(spec.swim_speed or normalized_speeds.get("swim", 0)),
                fly_speed=int(spec.fly_speed or normalized_speeds.get("fly", 0)),
                burrow_speed=int(spec.burrow_speed or normalized_speeds.get("burrow", 0)),
                climb_speed=int(spec.climb_speed or normalized_speeds.get("climb", 0)),
                movement_mode="Normal",
                initiative=initiative,
                dex=int(spec.dex or normalized_abilities.get("dex", 10)),
                ally=True,
                is_pc=False,
                is_spellcaster=None,
                saving_throws=dict(spec.saving_throws or {}),
                ability_mods=dict(spec.ability_mods or {}),
                monster_spec=spec,
            )
            summoned = self.combatants.get(cid)
            if summoned is None:
                continue
            setattr(summoned, "summoned_by_cid", int(caster_cid))
            setattr(summoned, "summon_source_spell", "custom_summon")
            setattr(summoned, "summon_group_id", group_id)
            setattr(summoned, "summon_controller_mode", "shared_turn")
            pos = positions[idx]
            self._lan_positions[int(cid)] = (int(pos["col"]), int(pos["row"]))
            spawned.append(int(cid))

        if not spawned:
            return False, "No custom summons were created.", []

        self._summon_groups[group_id] = list(spawned)
        self._summon_group_meta[group_id] = {
            "caster_cid": int(caster_cid),
            "spell": "custom_summon",
            "created_at": time.time(),
            "concentration": False,
            "custom": True,
            "monster_slug": f"temp/{slug}",
        }
        return True, "", spawned

    def _dismiss_summon_group(self, summon_group_id: str) -> int:
        group_key = str(summon_group_id or "").strip()
        if not group_key:
            return 0
        cids = list(self._summon_groups.get(group_key) or [])
        if not cids:
            return 0
        self._remove_combatants_with_lan_cleanup(cids)
        self._summon_groups.pop(group_key, None)
        self._summon_group_meta.pop(group_key, None)
        self._rebuild_table(scroll_to_current=True)
        self._lan_force_state_broadcast()
        return len(cids)

    def _dismiss_summons_for_caster(self, caster_cid: int) -> int:
        to_remove: List[str] = []
        for group_id, meta in list(self._summon_group_meta.items()):
            if int(meta.get("caster_cid") or -1) == int(caster_cid):
                to_remove.append(group_id)
        removed = 0
        for group_id in to_remove:
            removed += self._dismiss_summon_group(group_id)
        return removed

    def _find_echo_for_caster(self, caster_cid: int) -> Tuple[Optional[int], Any]:
        group_key = f"echo:{int(caster_cid)}"
        for ecid, unit in self.combatants.items():
            owner = _normalize_cid_value(getattr(unit, "summoned_by_cid", None), "echo.owner")
            if owner != int(caster_cid):
                continue
            if str(getattr(unit, "summon_group_id", "") or "").strip() == group_key:
                return int(ecid), unit
        for ecid, unit in self.combatants.items():
            owner = _normalize_cid_value(getattr(unit, "summoned_by_cid", None), "echo.owner")
            if owner != int(caster_cid):
                continue
            source = str(getattr(unit, "summon_source_spell", "") or "").strip().lower()
            if source == "echo_knight":
                return int(ecid), unit
        return None, None

    def _johns_echo_tether_move_details(self, mover_cid: Optional[int], dest_col: int, dest_row: int) -> Tuple[Optional[int], Optional[int], bool]:
        if mover_cid is None:
            return None, None, False
        mover = self.combatants.get(int(mover_cid))
        if mover is None:
            return None, None, False

        owner_cid: Optional[int] = None
        mover_name_key = self._action_name_key(getattr(mover, "name", ""))
        if mover_name_key == "john twilight":
            owner_cid = int(mover_cid)
        else:
            source = str(getattr(mover, "summon_source_spell", "") or "").strip().lower()
            group_id = str(getattr(mover, "summon_group_id", "") or "").strip().lower()
            if source == "echo_knight" or group_id.startswith("echo:"):
                owner_cid = _normalize_cid_value(getattr(mover, "summoned_by_cid", None), "echo.owner")

        if owner_cid is None:
            return None, None, False
        owner = self.combatants.get(int(owner_cid))
        if owner is None or self._action_name_key(getattr(owner, "name", "")) != "john twilight":
            return None, None, False

        echo_cid, _echo = self._find_echo_for_caster(int(owner_cid))
        if echo_cid is None:
            return int(owner_cid), None, False

        john_pos = self._lan_positions.get(int(owner_cid)) or self._lan_current_position(int(owner_cid))
        echo_pos = self._lan_positions.get(int(echo_cid)) or self._lan_current_position(int(echo_cid))
        if john_pos is None or echo_pos is None:
            return int(owner_cid), int(echo_cid), False

        next_john_pos = (int(dest_col), int(dest_row)) if int(mover_cid) == int(owner_cid) else (int(john_pos[0]), int(john_pos[1]))
        next_echo_pos = (int(dest_col), int(dest_row)) if int(mover_cid) == int(echo_cid) else (int(echo_pos[0]), int(echo_pos[1]))

        feet_per_square = 5.0
        try:
            mw = getattr(self, "_map_window", None)
            if mw is not None and mw.winfo_exists():
                feet_per_square = float(getattr(mw, "feet_per_square", feet_per_square) or feet_per_square)
        except Exception:
            pass
        feet_per_square = max(1.0, feet_per_square)
        dist_ft = math.hypot(int(next_john_pos[0]) - int(next_echo_pos[0]), int(next_john_pos[1]) - int(next_echo_pos[1])) * feet_per_square
        return int(owner_cid), int(echo_cid), bool(dist_ft - 20.0 > 1e-6)

    def _enforce_johns_echo_tether(self, moved_cid: Optional[int]) -> bool:
        if moved_cid is None:
            return False
        moved = self.combatants.get(int(moved_cid))
        if moved is None:
            return False

        owner_cid: Optional[int] = None
        moved_name_key = self._action_name_key(getattr(moved, "name", ""))
        if moved_name_key == "john twilight":
            owner_cid = int(moved_cid)
        else:
            source = str(getattr(moved, "summon_source_spell", "") or "").strip().lower()
            group_id = str(getattr(moved, "summon_group_id", "") or "").strip().lower()
            if source == "echo_knight" or group_id.startswith("echo:"):
                owner_cid = _normalize_cid_value(getattr(moved, "summoned_by_cid", None), "echo.owner")

        if owner_cid is None:
            return False
        owner = self.combatants.get(int(owner_cid))
        if owner is None or self._action_name_key(getattr(owner, "name", "")) != "john twilight":
            return False

        echo_cid, _echo = self._find_echo_for_caster(int(owner_cid))
        if echo_cid is None:
            return False

        john_pos = self._lan_positions.get(int(owner_cid)) or self._lan_current_position(int(owner_cid))
        echo_pos = self._lan_positions.get(int(echo_cid)) or self._lan_current_position(int(echo_cid))
        if john_pos is None or echo_pos is None:
            return False

        feet_per_square = 5.0
        try:
            mw = getattr(self, "_map_window", None)
            if mw is not None and mw.winfo_exists():
                feet_per_square = float(getattr(mw, "feet_per_square", feet_per_square) or feet_per_square)
        except Exception:
            pass
        feet_per_square = max(1.0, feet_per_square)
        dist_ft = math.hypot(int(john_pos[0]) - int(echo_pos[0]), int(john_pos[1]) - int(echo_pos[1])) * feet_per_square
        if dist_ft - 20.0 <= 1e-6:
            return False

        removed = self._dismiss_summon_group(f"echo:{int(owner_cid)}")
        if removed <= 0 and int(echo_cid) in self.combatants:
            self._remove_combatants_with_lan_cleanup([int(echo_cid)])
            self._rebuild_table(scroll_to_current=True)
            self._lan_force_state_broadcast()
            removed = 1
        return bool(removed)

    def _lan_apply_action(self, msg: Dict[str, Any]) -> None:
        """Apply client actions on the Tk thread."""
        tracker: Optional["InitiativeTracker"]
        if isinstance(self, InitiativeTracker):
            tracker = self
        else:
            tracker = getattr(self, "_tracker", None) or getattr(self, "app", None)
        log_warning = None
        def _resolve_pc_name(cid_value: Optional[int]) -> str:
            if cid_value is None:
                return ""
            if tracker is None or not hasattr(tracker, "_pc_name_for"):
                if log_warning is not None:
                    log_warning(f"LAN action missing pc name resolver for cid {cid_value}.")
                return ""
            try:
                return tracker._pc_name_for(int(cid_value))
            except Exception as exc:
                if log_warning is not None:
                    log_warning(f"LAN action failed to resolve pc name for cid {cid_value}: {exc}")
                return ""
        if not isinstance(self, InitiativeTracker) or not hasattr(self, "_pc_name_for"):
            if os.getenv("LAN_BIND_DEBUG") == "1":
                log_fn = getattr(self, "_oplog", None)
                if log_fn is None and hasattr(self, "app"):
                    log_fn = getattr(self.app, "_oplog", None)
                if log_fn is not None:
                    log_fn(
                        "LAN_BIND_DEBUG _lan_apply_action bad binding: "
                        f"self_type={type(self)} self_id={id(self)} "
                        f"has_pc_name_for={hasattr(self, '_pc_name_for')}",
                        level="warning",
                    )
        if os.getenv("LAN_BIND_DEBUG") == "1":
            log_fn = getattr(self, "_oplog", None)
            if log_fn is None and hasattr(self, "app"):
                log_fn = getattr(self.app, "_oplog", None)
            if log_fn is not None:
                debug_message = (
                    "LAN_BIND_DEBUG _lan_apply_action entry: "
                    f"self_type={type(self)} self_id={id(self)} "
                    f"has_pc_name_for={hasattr(self, '_pc_name_for')}"
                )
                if hasattr(self, "app"):
                    debug_message += f" app_type={type(self.app)} app_id={id(self.app)}"
                log_fn(debug_message, level="debug")
        typ = str(msg.get("type") or "")
        ws_id = msg.get("_ws_id")
        try:
            log_warning = lambda message: self._lan._append_lan_log(message, level="warning")
        except Exception:
            log_warning = None
        claimed = _normalize_cid_value(msg.get("_claimed_cid"), "lan_action.claimed_cid", log_fn=log_warning)
        admin_token = str(msg.get("admin_token") or "").strip()
        is_admin = bool(admin_token and self._is_admin_token_valid(admin_token))
        is_move = typ == "move"
        move_debugger = getattr(self, "_lan", None)
        def _move_log(event: str, **fields: Any) -> None:
            if not is_move or move_debugger is None:
                return
            log_fn = getattr(move_debugger, "_move_debug_log", None)
            if not log_fn:
                return
            payload = {"event": event, "type": typ, "ws_id": ws_id, **fields}
            log_fn(payload, level="info")

        def _echo_group_id(caster_cid: int) -> str:
            return f"echo:{int(caster_cid)}"

        def _set_token_position(target_cid: int, col: int, row: int) -> None:
            self._lan_set_token_position(int(target_cid), int(col), int(row))

        # Basic sanity: claimed cid must match the action cid (if provided)
        cid = _normalize_cid_value(msg.get("cid"), "lan_action.cid", log_fn=log_warning)
        current_cid = None
        in_combat = bool(getattr(self, "in_combat", False))
        if is_move:
            current_cid = _normalize_cid_value(
                getattr(self, "current_cid", None), "lan_action.current_cid", log_fn=log_warning
            )
            _move_log(
                "lan_move_apply_start",
                cid=cid,
                claimed=claimed,
                is_admin=is_admin,
                in_combat=in_combat,
                current_cid=current_cid,
            )
        if cid is not None:
            can_control_summon = self._summon_can_be_controlled_by(claimed, cid)
            if not is_admin and claimed is not None and cid != claimed and not can_control_summon:
                if is_move:
                    msg["_move_applied"] = False
                    msg["_move_reject_reason"] = "cid_mismatch"
                    _move_log("lan_move_reject", reason="cid_mismatch", cid=cid, claimed=claimed)
                self._lan.toast(ws_id, "Arrr, that token ain’t yers.")
                return
        else:
            cid = claimed

        if cid is None and not is_admin and typ not in ("set_auras_enabled",):
            if is_move:
                msg["_move_applied"] = False
                msg["_move_reject_reason"] = "no_claim"
                _move_log("lan_move_reject", reason="no_claim")
            self._lan.toast(ws_id, "Claim a character first, matey.")
            return

        # Must exist
        if cid is not None and cid not in self.combatants and typ not in ("set_auras_enabled",):
            if is_move:
                msg["_move_applied"] = False
                msg["_move_reject_reason"] = "combatant_missing"
                _move_log("lan_move_reject", reason="combatant_missing", cid=cid)
            self._lan.toast(ws_id, "That scallywag ain’t in combat no more.")
            return
        if is_move:
            _move_log(
                "lan_move_gate_status",
                cid=cid,
                claimed=claimed,
                is_admin=is_admin,
                in_combat=in_combat,
                current_cid=current_cid,
                gate_claim_match=not (cid is not None and not is_admin and claimed is not None and cid != claimed),
                gate_has_cid=bool(cid is not None or is_admin),
                gate_combatant_present=bool(cid is None or cid in self.combatants),
                gate_turn=(not in_combat or is_admin or (cid is not None and current_cid == cid)),
            )

        if typ == "set_color":
            color = self._normalize_token_color(msg.get("color"))
            if not color:
                self._lan.toast(ws_id, "Pick a valid hex color, matey.")
                return
            border_color = self._normalize_token_color(msg.get("border_color")) or "#ffffff"
            c = self.combatants.get(cid)
            if not c:
                return
            if _normalize_cid_value(getattr(c, "rider_cid", None), "dash.rider_cid") is not None:
                self._lan.toast(ws_id, "Rider movement uses the mount, matey.")
                return
            setattr(c, "token_color", color)
            setattr(c, "token_border_color", border_color)
            player_name = _resolve_pc_name(cid)
            if player_name and not player_name.startswith("cid:"):
                try:
                    self._save_player_token_color(player_name, color)
                    self._save_player_token_border_color(player_name, border_color)
                except Exception as exc:
                    self._oplog(f"Could not save token color for {player_name}: {exc}", level="warning")
            mw = getattr(self, "_map_window", None)
            if mw is not None and hasattr(mw, "update_unit_token_colors"):
                try:
                    if mw.winfo_exists():
                        mw.update_unit_token_colors()
                except Exception:
                    pass
            return

        if typ == "set_facing":
            if not is_admin and (
                claimed is None
                or (int(cid) != int(claimed) and not self._summon_can_be_controlled_by(claimed, cid))
            ):
                self._lan.toast(ws_id, "Arrr, that token ain’t yers.")
                return
            c = self.combatants.get(cid)
            if not c:
                return
            facing = int(self._normalize_facing_degrees(msg.get("facing_deg")))
            setattr(c, "facing_deg", facing)
            self._sync_owned_rotatable_aoes_with_facing(int(cid), getattr(c, "facing_deg", 0))
            mw = getattr(self, "_map_window", None)
            if mw is not None and hasattr(mw, "winfo_exists"):
                try:
                    if mw.winfo_exists() and hasattr(mw, "_token_facing"):
                        mw._token_facing[int(cid)] = float(facing)
                        if hasattr(mw, "_layout_unit"):
                            mw._layout_unit(int(cid))
                except Exception:
                    pass
            self._lan_force_state_broadcast()
            return

        if typ == "set_auras_enabled":
            enabled_raw = msg.get("enabled")
            enabled = True
            if isinstance(enabled_raw, str):
                enabled = enabled_raw.strip().lower() in ("1", "true", "yes", "on")
            elif isinstance(enabled_raw, (int, float)):
                enabled = bool(enabled_raw)
            else:
                enabled = bool(enabled_raw)
            self._lan_auras_enabled = bool(enabled)
            self._lan_force_state_broadcast()
            return

        if typ == "reset_player_characters":
            if not is_admin:
                self._lan.toast(ws_id, "Admin access required, matey.")
                return
            updated = self._reset_player_character_resources()
            if updated:
                for c in self.combatants.values():
                    role = self._name_role_memory.get(str(c.name), "enemy")
                    if role != "pc":
                        continue
                    key = str(c.name or "").strip().lower()
                    if key in updated:
                        try:
                            c.hp = int(updated[key])
                        except Exception:
                            pass
            forced_moves_applied: List[str] = []
            if isinstance(resolved_bucket, list):
                for effect in resolved_bucket:
                    effect_name = str(effect.get("effect") or "").strip().lower()
                    if effect_name not in ("movement", "forced_movement"):
                        continue
                    mode = str(effect.get("kind") or effect.get("mode") or effect.get("direction") or "").strip().lower()
                    if mode not in ("push", "pull"):
                        continue
                    try:
                        distance_ft = float(effect.get("distance_ft") or 0)
                    except Exception:
                        distance_ft = 0.0
                    if distance_ft <= 0:
                        continue
                    origin = str(effect.get("origin") or "caster").strip().lower()
                    source_cid = int(cid)
                    source_cell = None
                    direction_step = None
                    if origin == "aoe_direction":
                        direction_step = self._lan_direction_step_from_angle(effect.get("angle_deg", getattr(c, "facing_deg", 0)))
                        source_cid = None
                    moved = self._lan_apply_forced_movement(
                        source_cid,
                        int(target_cid),
                        mode,
                        float(distance_ft),
                        source_cell=source_cell,
                        direction_step=direction_step,
                    )
                    if moved:
                        forced_moves_applied.append(f"{mode} {int(distance_ft)}ft")
            if forced_moves_applied:
                self._log(f"{spell_name} moves {result_payload['target_name']}: {', '.join(forced_moves_applied)}.", cid=int(target_cid))

            try:
                self._rebuild_table(scroll_to_current=True)
            except Exception:
                pass
            self._lan_force_state_broadcast()
            self._lan.toast(ws_id, "Player characters reset.")
            return

        # Only allow controlling on your turn (POC)
        opportunity_attack_requested = str(msg.get("opportunity_attack") or "").strip().lower() in (
            "1",
            "true",
            "yes",
            "on",
        )
        if not is_admin and typ not in ("cast_aoe", "cast_spell", "aoe_move", "aoe_remove", "dismiss_summons"):
            if in_combat:
                if typ == "attack_request" and opportunity_attack_requested:
                    pass
                else:
                    valid_turn = self._is_valid_summon_turn_for_controller(claimed, cid, current_cid)
                    if not valid_turn:
                        if is_move:
                            msg["_move_applied"] = False
                            msg["_move_reject_reason"] = "not_your_turn"
                            _move_log(
                                "lan_move_reject",
                                reason="not_your_turn",
                                cid=cid,
                                current_cid=current_cid,
                                in_combat=in_combat,
                            )
                        self._lan.toast(ws_id, "Not yer turn yet, matey.")
                        return

        if typ == "echo_summon":
            c = self.combatants.get(cid) if cid is not None else None
            if c is None:
                self._lan.toast(ws_id, "That scallywag ain’t in combat no more.")
                return
            name_key = self._action_name_key(getattr(c, "name", ""))
            player_name_key = self._action_name_key(_resolve_pc_name(cid))
            if name_key != "john twilight" and player_name_key != "john twilight":
                self._lan.toast(ws_id, "Only John Twilight can summon Johns Echo.")
                return
            target = msg.get("to") if isinstance(msg.get("to"), dict) else {}
            if not target:
                payload = msg.get("payload") if isinstance(msg.get("payload"), dict) else {}
                target = payload.get("to") if isinstance(payload.get("to"), dict) else payload
            try:
                col = int(target.get("col"))
                row = int(target.get("row"))
            except Exception:
                self._lan.toast(ws_id, "Pick a valid square for Johns Echo, matey.")
                return
            cols, rows, obstacles, _rough, positions = self._lan_live_map_data()
            if col < 0 or row < 0 or col >= cols or row >= rows or (col, row) in obstacles:
                self._lan.toast(ws_id, "That summon square be invalid, matey.")
                return
            caster_pos = positions.get(int(cid))
            if caster_pos is None:
                caster_pos = self._lan_current_position(int(cid))
            if caster_pos is None:
                self._lan.toast(ws_id, "Could not find caster position, matey.")
                return
            feet_per_square = 5.0
            try:
                mw = getattr(self, "_map_window", None)
                if mw is not None and mw.winfo_exists():
                    feet_per_square = float(getattr(mw, "feet_per_square", feet_per_square) or feet_per_square)
            except Exception:
                pass
            feet_per_square = max(1.0, feet_per_square)
            dist_ft = math.hypot(col - caster_pos[0], row - caster_pos[1]) * feet_per_square
            if dist_ft - 15.0 > 1e-6:
                self._lan.toast(ws_id, "That square be out of echo range, matey.")
                return
            if not is_admin and not self._use_bonus_action(c):
                self._lan.toast(ws_id, "No bonus actions left, matey.")
                return
            group_id = _echo_group_id(int(cid))
            echo_cid, echo = self._find_echo_for_caster(int(cid))
            if echo is None:
                spec = self._find_monster_spec_by_slug("johns-echo")
                if spec is None:
                    self._lan.toast(ws_id, "Johns Echo template is missing, matey.")
                    return
                init_mod = int(spec.init_mod or 0)
                init_roll = int(random.randint(1, 20) + init_mod)
                echo_cid = self._create_combatant(
                    name=self._unique_name(spec.name),
                    hp=int(spec.hp or 1),
                    speed=int(spec.speed or 30),
                    swim_speed=int(spec.swim_speed or 0),
                    fly_speed=int(spec.fly_speed or 0),
                    burrow_speed=int(spec.burrow_speed or 0),
                    climb_speed=int(spec.climb_speed or 0),
                    movement_mode="Normal",
                    initiative=init_roll,
                    dex=spec.dex,
                    ally=True,
                    is_pc=False,
                    is_spellcaster=None,
                    saving_throws=dict(spec.saving_throws or {}),
                    ability_mods=dict(spec.ability_mods or {}),
                    monster_spec=spec,
                )
                echo = self.combatants.get(int(echo_cid))
            if echo is None or echo_cid is None:
                self._lan.toast(ws_id, "Could not summon Johns Echo, matey.")
                return
            setattr(echo, "summoned_by_cid", int(cid))
            setattr(echo, "summon_source_spell", "echo_knight")
            setattr(echo, "summon_group_id", group_id)
            setattr(echo, "summon_controller_mode", "shared_turn")
            setattr(echo, "summon_shared_turn", True)
            color_override = self._normalize_token_color("#7ec8ff")
            if color_override:
                setattr(echo, "token_color", color_override)
            self._apply_summon_initiative(int(cid), [int(echo_cid)], {"initiative": {"mode": "shared_with_caster"}})
            _set_token_position(int(echo_cid), col, row)
            self._summon_groups[group_id] = [int(echo_cid)]
            self._summon_group_meta[group_id] = {
                "caster_cid": int(cid),
                "spell": "echo_knight",
                "created_at": time.time(),
                "concentration": False,
            }
            self._rebuild_table(scroll_to_current=True)
            self._lan_force_state_broadcast()
            self._lan.toast(ws_id, "Johns Echo is ready.")
            return

        if typ == "echo_swap":
            c = self.combatants.get(cid) if cid is not None else None
            if c is None:
                self._lan.toast(ws_id, "That scallywag ain’t in combat no more.")
                return
            name_key = self._action_name_key(getattr(c, "name", ""))
            player_name_key = self._action_name_key(_resolve_pc_name(cid))
            if name_key != "john twilight" and player_name_key != "john twilight":
                self._lan.toast(ws_id, "Only John Twilight can swap with Johns Echo.")
                return
            echo_cid, _echo = self._find_echo_for_caster(int(cid))
            if echo_cid is None:
                self._lan.toast(ws_id, "Summon Johns Echo first, matey.")
                return
            _cols, _rows, _obstacles, _rough, positions = self._lan_live_map_data()
            john_pos = positions.get(int(cid))
            if john_pos is None:
                john_pos = self._lan_current_position(int(cid))
            echo_pos = positions.get(int(echo_cid))
            if echo_pos is None:
                echo_pos = self._lan_current_position(int(echo_cid))
            if john_pos is None or echo_pos is None:
                self._lan.toast(ws_id, "Both John and Johns Echo need map positions, matey.")
                return
            feet_per_square = 5.0
            try:
                mw = getattr(self, "_map_window", None)
                if mw is not None and mw.winfo_exists():
                    feet_per_square = float(getattr(mw, "feet_per_square", feet_per_square) or feet_per_square)
            except Exception:
                pass
            feet_per_square = max(1.0, feet_per_square)
            dist_ft = math.hypot(john_pos[0] - echo_pos[0], john_pos[1] - echo_pos[1]) * feet_per_square
            if dist_ft - 15.0 > 1e-6:
                self._lan.toast(ws_id, "Johns Echo be too far to swap, matey.")
                return
            if not is_admin and not self._use_bonus_action(c):
                self._lan.toast(ws_id, "No bonus actions left, matey.")
                return
            _set_token_position(int(cid), int(echo_pos[0]), int(echo_pos[1]))
            _set_token_position(int(echo_cid), int(john_pos[0]), int(john_pos[1]))
            self._rebuild_table(scroll_to_current=True)
            self._lan_force_state_broadcast()
            self._lan.toast(ws_id, "Swapped with Johns Echo.")
            return

        if typ == "cast_aoe":
            payload = msg.get("payload") or {}
            shape = str(payload.get("shape") or payload.get("kind") or "").strip().lower()
            if shape not in ("circle", "square", "line", "sphere", "cube", "cone", "cylinder", "wall", "summon"):
                self._lan.toast(ws_id, "Pick a valid spell shape, matey.")
                return
            spend_raw = str(msg.get("action_type") or "").strip().lower()
            if spend_raw in ("bonus", "bonus_action"):
                spend = "bonus"
            elif spend_raw == "reaction":
                spend = "reaction"
            else:
                spend = "action"
            slot_level = None
            try:
                slot_level = int(msg.get("slot_level"))
            except Exception:
                slot_level = None
            if slot_level is not None and slot_level < 0:
                slot_level = None
            spell_slug = str(msg.get("spell_slug") or payload.get("spell_slug") or "").strip()
            spell_id = str(msg.get("spell_id") or payload.get("spell_id") or "").strip()
            summon_choice = msg.get("summon_choice") if msg.get("summon_choice") not in (None, "") else payload.get("summon_choice")
            manual_damage_entries: List[Dict[str, Any]] = []
            raw_damage_entries = msg.get("damage_entries")
            if isinstance(raw_damage_entries, list):
                for entry in raw_damage_entries:
                    if not isinstance(entry, dict):
                        continue
                    amount_raw = entry.get("amount")
                    if isinstance(amount_raw, bool):
                        continue
                    if isinstance(amount_raw, float) and not math.isfinite(amount_raw):
                        continue
                    try:
                        amount = int(amount_raw)
                    except Exception:
                        continue
                    if amount <= 0:
                        continue
                    dtype = str(entry.get("type") or "").strip().lower()
                    if not dtype:
                        continue
                    manual_damage_entries.append({"amount": int(amount), "type": dtype})
            c = self.combatants.get(cid) if cid is not None else None
            if shape == "summon":
                if cid is None:
                    self._lan.toast(ws_id, "Pick a valid caster first, matey.")
                    return
                if c is None:
                    self._lan.toast(ws_id, "That scallywag ain’t in combat no more.")
                    return
                if not is_admin:
                    if spend == "bonus":
                        if not self._use_bonus_action(c):
                            self._lan.toast(ws_id, "No bonus actions left, matey.")
                            return
                    elif spend == "reaction":
                        if not self._use_reaction(c):
                            self._lan.toast(ws_id, "No reactions left, matey.")
                            return
                    else:
                        if not self._use_action(c):
                            self._lan.toast(ws_id, "No actions left, matey.")
                            return
                ok_custom, err_custom, spawned_custom = self._spawn_custom_summons_from_payload(
                    caster_cid=int(cid),
                    payload=payload,
                )
                if not ok_custom:
                    self._lan.toast(ws_id, err_custom or "Custom summon failed, matey.")
                    return
                self._rebuild_table(scroll_to_current=True)
                self._lan_force_state_broadcast()
                self._lan.toast(ws_id, f"Summoned {len(spawned_custom)} custom creature(s).")
                return
            preset = self._find_spell_preset(spell_slug=spell_slug, spell_id=spell_id)
            preset_dict = preset if isinstance(preset, dict) else {}
            centered_shapes = {"circle", "sphere", "cylinder", "square", "cube"}
            preset_mechanics = preset_dict.get("mechanics") if isinstance(preset_dict.get("mechanics"), dict) else {}
            preset_aoe_behavior = (
                preset_mechanics.get("aoe_behavior")
                if isinstance(preset_mechanics.get("aoe_behavior"), dict)
                else {}
            )
            preset_targeting = preset_mechanics.get("targeting") if isinstance(preset_mechanics.get("targeting"), dict) else {}
            preset_range_data = preset_targeting.get("range") if isinstance(preset_targeting.get("range"), dict) else {}
            range_text = str(preset_dict.get("range") or "").strip().lower()
            range_kind = str((preset_range_data.get("kind") if isinstance(preset_range_data, dict) else "") or "").strip().lower()
            targeting_origin = str(preset_targeting.get("origin") or "").strip().lower()
            preset_self_range = range_text.startswith("self") or range_kind == "self" or targeting_origin == "self"
            requested_fixed_to_caster = payload.get("fixed_to_caster") is True
            force_fixed_to_caster = shape in centered_shapes and (preset_self_range or requested_fixed_to_caster)
            if requested_fixed_to_caster and not (preset_self_range and shape in centered_shapes):
                force_fixed_to_caster = False
            summon_cfg = preset.get("summon") if isinstance(preset, dict) and isinstance(preset.get("summon"), dict) else None
            if summon_cfg and not is_admin:
                self._lan.toast(ws_id, "Summon spawning is DM-only for now, matey.")
                return
            if c is not None and not is_admin:
                preset_level = None
                try:
                    preset_level = int(preset.get("level")) if isinstance(preset, dict) else None
                except Exception:
                    preset_level = None
                if slot_level is None and preset_level is not None and preset_level > 0:
                    slot_level = preset_level
                if slot_level is not None:
                    player_name = _resolve_pc_name(cid)
                    ok_slot, slot_err, _spent_level = self._consume_spell_slot_for_cast(
                        caster_name=player_name,
                        slot_level=slot_level,
                        minimum_level=preset_level,
                    )
                    if not ok_slot:
                        self._lan.toast(ws_id, slot_err)
                        return
                if spend != "reaction" and int(getattr(c, "spell_cast_remaining", 0) or 0) <= 0:
                    self._lan.toast(ws_id, "Already cast a spell this turn, matey.")
                    return
                if not self._combatant_can_cast_spell(c, spend):
                    self._lan.toast(ws_id, "No spellcasting action available, matey.")
                    return
                spell_name = self._spell_label_from_identifiers(
                    preset.get("name") if isinstance(preset, dict) else "",
                    preset.get("slug") if isinstance(preset, dict) else "",
                    spell_slug,
                    spell_id,
                )
                cast_log = self._spell_cast_log_message(c.name, spell_name, slot_level)
                if spend == "bonus":
                    if not self._use_bonus_action(c, log_message=cast_log):
                        self._lan.toast(ws_id, "No bonus actions left, matey.")
                        return
                elif spend == "reaction":
                    if not self._use_reaction(c, log_message=cast_log):
                        self._lan.toast(ws_id, "No reactions left, matey.")
                        return
                else:
                    if not self._use_action(c, log_message=cast_log):
                        self._lan.toast(ws_id, "No actions left, matey.")
                        return
                c.spell_cast_remaining = max(0, int(getattr(c, "spell_cast_remaining", 0) or 0) - 1)
                self._rebuild_table(scroll_to_current=True)
            def parse_positive_float(value: Any) -> Optional[float]:
                try:
                    num = float(value)
                except Exception:
                    return None
                if num <= 0:
                    return None
                return num

            def parse_nonnegative_float(value: Any) -> Optional[float]:
                try:
                    num = float(value)
                except Exception:
                    return None
                if num < 0:
                    return None
                return num

            def parse_bool(value: Any) -> Optional[bool]:
                if isinstance(value, bool):
                    return value
                if isinstance(value, str):
                    raw = value.strip().lower()
                    if raw in ("true", "yes", "y", "1"):
                        return True
                    if raw in ("false", "no", "n", "0"):
                        return False
                return None

            def parse_trigger(value: Any) -> Optional[str]:
                if not isinstance(value, str):
                    return None
                raw = value.strip().lower().replace("-", "_").replace("/", "_")
                while "__" in raw:
                    raw = raw.replace("__", "_")
                aliases = {
                    "start": "start",
                    "enter": "enter",
                    "end": "end",
                    "start_or_enter": "start_or_enter",
                    "enter_or_end": "enter_or_end",
                }
                return aliases.get(raw)

            def parse_default_damage(value: Any) -> Optional[str]:
                if value in (None, ""):
                    return None
                if isinstance(value, (int, float)):
                    return str(int(value))
                if isinstance(value, str):
                    raw = value.strip()
                    return raw or None
                return None

            def parse_dice(value: Any) -> Optional[str]:
                if not isinstance(value, str):
                    return None
                raw = value.strip().lower()
                match = re.fullmatch(r"(\\d+)d(4|6|8|10|12)", raw)
                if not match:
                    return None
                count = int(match.group(1))
                if count <= 0:
                    return None
                return f"{count}d{match.group(2)}"

            size = parse_positive_float(payload.get("size"))
            radius_ft = parse_positive_float(payload.get("radius_ft"))
            side_ft = parse_positive_float(payload.get("side_ft"))
            length_ft = parse_positive_float(payload.get("length_ft"))
            width_ft = parse_positive_float(payload.get("width_ft"))
            thickness_ft = parse_positive_float(payload.get("thickness_ft"))
            height_ft = parse_positive_float(payload.get("height_ft"))
            angle_deg = parse_nonnegative_float(payload.get("angle_deg"))
            caster_facing_deg = (
                float(self._normalize_facing_degrees(getattr(c, "facing_deg", 0)))
                if c is not None
                else 0.0
            )
            duration_turns = payload.get("duration_turns")
            over_time = parse_bool(payload.get("over_time"))
            concentration_flag = parse_bool(payload.get("concentration"))
            move_per_turn_ft = parse_nonnegative_float(payload.get("move_per_turn_ft"))
            if move_per_turn_ft is not None and move_per_turn_ft <= 0:
                move_per_turn_ft = None
            trigger_on_start_or_enter = parse_trigger(payload.get("trigger_on_start_or_enter"))
            move_action_type = str(payload.get("move_action_type") or "").strip().lower()
            if move_action_type not in ("bonus_action", "magic_action", "action", "free", "none"):
                move_action_type = ""
            persistent = parse_bool(payload.get("persistent"))
            pinned_default = parse_bool(payload.get("pinned_default"))

            if "over_time" not in payload and over_time is None:
                over_time = parse_bool(preset_aoe_behavior.get("over_time_default"))
            if "persistent" not in payload and persistent is None:
                persistent = parse_bool(preset_aoe_behavior.get("persistent_default"))
            if "trigger_on_start_or_enter" not in payload and trigger_on_start_or_enter is None:
                trigger_on_start_or_enter = parse_trigger(preset_aoe_behavior.get("trigger_on_start_or_enter"))
            if "move_per_turn_ft" not in payload and move_per_turn_ft is None:
                move_per_turn_ft = parse_nonnegative_float(preset_aoe_behavior.get("move_per_turn_ft"))
                if move_per_turn_ft is not None and move_per_turn_ft <= 0:
                    move_per_turn_ft = None
            if "pinned_default" not in payload and pinned_default is None:
                pinned_default = parse_bool(preset_aoe_behavior.get("pinned_default"))
            if "move_action_type" not in payload and not move_action_type:
                move_action_type = str(preset_aoe_behavior.get("move_action_type") or "").strip().lower()
                if move_action_type not in ("bonus_action", "magic_action", "action", "free", "none"):
                    move_action_type = ""
            spell_level = None
            try:
                spell_level = int(payload.get("level"))
            except Exception:
                spell_level = None
            if spell_level is not None and spell_level < 0:
                spell_level = None
            color = self._normalize_token_color(payload.get("color")) or ""
            name = str(payload.get("name") or "").strip()
            save_type = str(payload.get("save_type") or "").strip().lower()
            damage_type = str(payload.get("damage_type") or "").strip()
            raw_damage_types = payload.get("damage_types")
            damage_types: List[str] = []
            if isinstance(raw_damage_types, (list, tuple)):
                for entry in raw_damage_types:
                    dtype = str(entry or "").strip()
                    if dtype:
                        damage_types.append(dtype)
            if damage_types and not damage_type:
                damage_type = damage_types[0]
            half_on_pass = payload.get("half_on_pass")
            default_damage = parse_default_damage(payload.get("default_damage"))
            dice = parse_dice(payload.get("dice"))
            try:
                dc_val = int(payload.get("dc"))
            except Exception:
                dc_val = None
            over_time_flag = bool(over_time) if over_time is not None else False
            persistent_flag = bool(persistent) if persistent is not None else over_time_flag
            pinned_flag = bool(pinned_default) if pinned_default is not None else False
            duration_turns_val: Optional[int]
            if duration_turns in (None, ""):
                duration_turns_val = None
            else:
                try:
                    duration_turns_val = int(duration_turns)
                except Exception:
                    duration_turns_val = None
                if duration_turns_val is not None and duration_turns_val < 0:
                    duration_turns_val = None
            mw = getattr(self, "_map_window", None)
            map_ready = mw is not None and mw.winfo_exists()
            if map_ready:
                try:
                    self._lan_sync_aoes_to_map(mw)
                except Exception:
                    pass
            try:
                feet_per_square = float(getattr(mw, "feet_per_square", 5.0) or 5.0) if map_ready else 5.0
            except Exception:
                feet_per_square = 5.0
            if feet_per_square <= 0:
                feet_per_square = 5.0
            try:
                if map_ready:
                    cols = int(getattr(mw, "cols", 0))
                    rows = int(getattr(mw, "rows", 0))
                else:
                    cols = int(self._lan_grid_cols)
                    rows = int(self._lan_grid_rows)
            except Exception:
                cols = 0
                rows = 0
            try:
                cx = float(payload.get("cx"))
                cy = float(payload.get("cy"))
            except Exception:
                cx = None
                cy = None
            anchor_cid = None
            if cid is not None and claimed is not None:
                anchor_cid = cid
            anchor_ax = None
            anchor_ay = None
            _, _, _, _, positions = self._lan_live_map_data()
            if cid in positions:
                anchor_ax = float(positions[cid][0])
                anchor_ay = float(positions[cid][1])
            if cx is None or cy is None:
                if cid in positions:
                    cx = float(positions[cid][0])
                    cy = float(positions[cid][1])
                else:
                    cx = max(0.0, (cols - 1) / 2.0) if cols else 0.0
                    cy = max(0.0, (rows - 1) / 2.0) if rows else 0.0
            if anchor_ax is None or anchor_ay is None:
                anchor_ax = float(cx)
                anchor_ay = float(cy)
            if force_fixed_to_caster and cid is not None:
                anchor_cid = cid
                cx = float(anchor_ax)
                cy = float(anchor_ay)
            if map_ready:
                aid = int(getattr(mw, "_next_aoe_id", 1))
                setattr(mw, "_next_aoe_id", aid + 1)
            else:
                aid = int(getattr(self, "_lan_next_aoe_id", 1))
                store = getattr(self, "_lan_aoes", {}) or {}
                if store:
                    max_aid = max(int(a) for a in store.keys())
                    if aid <= max_aid:
                        aid = max_aid + 1
                self._lan_next_aoe_id = aid + 1
            if cid is not None and cid in self.combatants:
                owner = str(self.combatants[cid].name)
                if not is_admin and claimed is not None:
                    owner_cid = claimed
                else:
                    owner_cid = cid
            else:
                owner = "DM"
                owner_cid = None
            owner_ws_id = ws_id if isinstance(ws_id, int) else None
            aoe: Dict[str, Any] = {
                "kind": shape,
                "cx": float(cx),
                "cy": float(cy),
                "pinned": pinned_flag,
                "color": color
                or (
                    mw._aoe_default_color(shape)
                    if map_ready and hasattr(mw, "_aoe_default_color")
                    else ""
                ),
                "name": name or f"AoE {aid}",
                "shape": None,
                "label": None,
                "owner": owner,
                "owner_cid": owner_cid,
                "owner_ws_id": owner_ws_id,
                "duration_turns": duration_turns_val,
                "remaining_turns": duration_turns_val if (duration_turns_val or 0) > 0 else None,
                "spell_slug": spell_slug,
                "spell_id": spell_id,
                "slot_level": slot_level,
            }
            if concentration_flag is True:
                aoe["concentration_bound"] = True
            if anchor_cid is not None:
                aoe["anchor_cid"] = anchor_cid
            if force_fixed_to_caster:
                aoe["fixed_to_caster"] = True
            if over_time_flag:
                aoe["over_time"] = True
            if persistent_flag:
                aoe["persistent"] = True
            if trigger_on_start_or_enter:
                aoe["trigger_on_start_or_enter"] = trigger_on_start_or_enter
            if move_per_turn_ft is not None:
                aoe["move_per_turn_ft"] = move_per_turn_ft
                aoe["move_remaining_ft"] = move_per_turn_ft
            if move_action_type:
                aoe["move_action_type"] = move_action_type
            if dc_val is not None:
                aoe["dc"] = int(dc_val)
            if save_type:
                aoe["save_type"] = save_type
            if damage_types:
                aoe["damage_types"] = list(damage_types)
            if damage_type:
                aoe["damage_type"] = damage_type
            if half_on_pass is not None:
                aoe["half_on_pass"] = bool(half_on_pass)
            if dice:
                aoe["dice"] = dice
                if default_damage is None:
                    default_damage = dice
            if default_damage is not None:
                aoe["default_damage"] = default_damage
            if shape == "circle":
                if radius_ft is None and size is None:
                    self._lan.toast(ws_id, "Pick a valid spell radius, matey.")
                    return
                if radius_ft is not None:
                    aoe["radius_sq"] = max(0.5, float(radius_ft) / feet_per_square)
                    aoe["radius_ft"] = float(radius_ft)
                else:
                    aoe["radius_sq"] = float(size)
            elif shape in ("sphere", "cylinder"):
                if radius_ft is None and size is None:
                    self._lan.toast(ws_id, "Pick a valid spell radius, matey.")
                    return
                if radius_ft is not None:
                    aoe["radius_sq"] = max(0.5, float(radius_ft) / feet_per_square)
                    aoe["radius_ft"] = float(radius_ft)
                else:
                    aoe["radius_sq"] = float(size)
                if height_ft is not None:
                    aoe["height_ft"] = float(height_ft)
            elif shape == "square":
                if side_ft is None and size is None:
                    self._lan.toast(ws_id, "Pick a valid spell side length, matey.")
                    return
                if side_ft is not None:
                    aoe["side_sq"] = max(1.0, float(side_ft) / feet_per_square)
                    aoe["side_ft"] = float(side_ft)
                else:
                    aoe["side_sq"] = float(size)
                aoe["angle_deg"] = float(angle_deg) if angle_deg is not None else float(caster_facing_deg)
            elif shape == "cube":
                if side_ft is None and size is None:
                    self._lan.toast(ws_id, "Pick a valid spell side length, matey.")
                    return
                if side_ft is not None:
                    aoe["side_sq"] = max(1.0, float(side_ft) / feet_per_square)
                    aoe["side_ft"] = float(side_ft)
                else:
                    aoe["side_sq"] = float(size)
                aoe["angle_deg"] = float(angle_deg) if angle_deg is not None else float(caster_facing_deg)
            elif shape == "cone":
                if length_ft is None and size is None:
                    self._lan.toast(ws_id, "Pick a valid spell length, matey.")
                    return
                if angle_deg is None or angle_deg <= 0:
                    self._lan.toast(ws_id, "Pick a valid spell cone angle, matey.")
                    return
                if length_ft is not None:
                    aoe["length_sq"] = max(1.0, float(length_ft) / feet_per_square)
                    aoe["length_ft"] = float(length_ft)
                else:
                    aoe["length_sq"] = float(size)
                aoe["angle_deg"] = float(angle_deg)
                aoe["orient"] = str(payload.get("orient") or "vertical")
                aoe["ax"] = float(anchor_ax)
                aoe["ay"] = float(anchor_ay)
            elif shape == "wall":
                if length_ft is None and size is None:
                    self._lan.toast(ws_id, "Pick a valid spell length, matey.")
                    return
                if length_ft is not None:
                    aoe["length_sq"] = max(1.0, float(length_ft) / feet_per_square)
                    aoe["length_ft"] = float(length_ft)
                else:
                    aoe["length_sq"] = float(size)
                if width_ft is not None:
                    aoe["width_sq"] = max(1.0, float(width_ft) / feet_per_square)
                    aoe["width_ft"] = float(width_ft)
                    if height_ft is not None:
                        aoe["height_ft"] = float(height_ft)
                elif thickness_ft is not None and height_ft is not None:
                    aoe["width_sq"] = max(1.0, float(thickness_ft) / feet_per_square)
                    aoe["thickness_ft"] = float(thickness_ft)
                    aoe["height_ft"] = float(height_ft)
                else:
                    self._lan.toast(ws_id, "Pick a valid wall thickness and height, matey.")
                    return
                aoe["orient"] = str(payload.get("orient") or "vertical")
                aoe["angle_deg"] = float(angle_deg) if angle_deg is not None else float(caster_facing_deg)
                aoe["ax"] = float(anchor_ax)
                aoe["ay"] = float(anchor_ay)
            else:
                if length_ft is None and size is None:
                    self._lan.toast(ws_id, "Pick a valid spell length, matey.")
                    return
                if length_ft is not None:
                    aoe["length_sq"] = max(1.0, float(length_ft) / feet_per_square)
                    aoe["length_ft"] = float(length_ft)
                else:
                    aoe["length_sq"] = float(size)
                if width_ft is not None:
                    aoe["width_sq"] = max(1.0, float(width_ft) / feet_per_square)
                    aoe["width_ft"] = float(width_ft)
                else:
                    width = parse_positive_float(payload.get("width")) or 1.0
                    aoe["width_sq"] = max(1.0, float(width))
                aoe["orient"] = str(payload.get("orient") or "vertical")
                aoe["angle_deg"] = float(angle_deg) if angle_deg is not None else float(caster_facing_deg)
                aoe["ax"] = float(anchor_ax)
                aoe["ay"] = float(anchor_ay)
            if map_ready:
                mw.aoes[aid] = aoe
                try:
                    if hasattr(mw, "_create_aoe_items"):
                        mw._create_aoe_items(aid)
                    if hasattr(mw, "_refresh_aoe_list"):
                        mw._refresh_aoe_list(select=aid)
                except Exception:
                    pass
                try:
                    self._lan_aoes = dict(getattr(mw, "aoes", {}) or {})
                    self._lan_next_aoe_id = max(self._lan_next_aoe_id, aid + 1)
                except Exception:
                    pass
            else:
                store = getattr(self, "_lan_aoes", {}) or {}
                store[int(aid)] = aoe
                self._lan_aoes = store
            if concentration_flag is True and c is not None:
                c.concentrating = True
                c.concentration_spell_level = spell_level
                c.concentration_started_turn = (int(self.round_num), int(self.turn_num))
                aoe_ids = list(getattr(c, "concentration_aoe_ids", []) or [])
                if aid not in aoe_ids:
                    aoe_ids.append(aid)
                c.concentration_aoe_ids = aoe_ids
            spawned_cids: List[int] = []
            if summon_cfg and cid is not None:
                spawned_cids = self._spawn_summons_from_cast(
                    caster_cid=cid,
                    spell_slug=spell_slug,
                    spell_id=spell_id,
                    slot_level=slot_level,
                    summon_choice=summon_choice,
                )
                if spawned_cids:
                    self._rebuild_table(scroll_to_current=True)
                    self._lan_force_state_broadcast()
            resolved = self._lan_auto_resolve_cast_aoe(
                aid,
                aoe,
                caster=c,
                spell_slug=spell_slug,
                spell_id=spell_id,
                slot_level=slot_level,
                preset=preset_dict,
                manual_damage_entries=manual_damage_entries,
            )
            if resolved:
                self._lan.toast(ws_id, f"Casted {aoe['name']} (auto-resolved).")
            else:
                self._lan.toast(ws_id, f"Casted {aoe['name']}.")
            return

        if typ == "cast_spell":
            payload = msg.get("payload") or {}
            spend_raw = str(msg.get("action_type") or payload.get("action_type") or "").strip().lower()
            if spend_raw in ("bonus", "bonus_action"):
                spend = "bonus"
            elif spend_raw == "reaction":
                spend = "reaction"
            else:
                spend = "action"
            spell_slug = str(msg.get("spell_slug") or payload.get("spell_slug") or "").strip()
            spell_id = str(msg.get("spell_id") or payload.get("spell_id") or "").strip()
            summon_choice = msg.get("summon_choice") if msg.get("summon_choice") not in (None, "") else payload.get("summon_choice")
            summon_quantity = msg.get("summon_quantity") if msg.get("summon_quantity") is not None else payload.get("summon_quantity")
            summon_variant = msg.get("variant") if msg.get("variant") not in (None, "") else payload.get("variant")
            if summon_variant is not None:
                summon_variant = str(summon_variant).strip() or None
            raw_positions = payload.get("summon_positions")
            summon_positions: List[Dict[str, Any]] = []
            if isinstance(raw_positions, list):
                for entry in raw_positions:
                    if not isinstance(entry, dict):
                        continue
                    try:
                        col = int(entry.get("col"))
                        row = int(entry.get("row"))
                    except Exception:
                        continue
                    summon_positions.append({"col": col, "row": row})
            preset = self._find_spell_preset(spell_slug=spell_slug, spell_id=spell_id)
            if not isinstance(preset, dict):
                self._lan.toast(ws_id, "That spell could not be found, matey.")
                return
            summon_cfg = preset.get("summon") if isinstance(preset.get("summon"), dict) else None
            try:
                slot_level = int(msg.get("slot_level") if msg.get("slot_level") is not None else payload.get("slot_level"))
            except Exception:
                slot_level = None
            if slot_level is not None and slot_level < 0:
                slot_level = None
            preset_level = None
            try:
                preset_level = int(preset.get("level"))
            except Exception:
                preset_level = None
            if preset_level is not None and preset_level > 0 and slot_level is None:
                slot_level = preset_level
            if slot_level is not None and preset_level is not None and slot_level < preset_level:
                self._lan.toast(ws_id, "Ye can't downcast that spell, matey.")
                return

            if summon_cfg:
                selected_choice, quantity_from_cfg, chosen_slug = self._resolve_summon_choice(
                    summon_cfg, summon_choice, slot_level
                )
                if summon_quantity is not None:
                    try:
                        quantity_from_cfg = int(summon_quantity)
                    except Exception:
                        quantity_from_cfg = quantity_from_cfg
                if quantity_from_cfg is None:
                    quantity_from_cfg = 1
                quantity_from_cfg = max(0, int(quantity_from_cfg))
                if not chosen_slug and isinstance(selected_choice, dict):
                    chosen_slug = str(selected_choice.get("monster_slug") or "").strip().lower() or None
                if not chosen_slug:
                    self._lan.toast(ws_id, "Pick a summon creature first, matey.")
                    return
                if self._find_monster_spec_by_slug(chosen_slug) is None:
                    self._lan.toast(ws_id, "That summon creature does not exist, matey.")
                    return
                if summon_positions and len(summon_positions) < quantity_from_cfg:
                    self._lan.toast(ws_id, "Pick a valid square for each summon, matey.")
                    return
                if summon_positions:
                    cols, rows, obstacles, _rough, positions = self._lan_live_map_data()
                    caster_pos = positions.get(cid) if cid is not None else None
                    if caster_pos is None and cid is not None:
                        caster_pos = self._lan_current_position(cid)
                    range_text = str(preset.get("range") or "")
                    range_match = re.search(r"(\d+(?:\.\d+)?)\s*(?:ft|feet)", range_text, flags=re.IGNORECASE)
                    max_range_ft = float(range_match.group(1)) if range_match else None
                    feet_per_square = 5.0
                    try:
                        mw = getattr(self, "_map_window", None)
                        if mw is not None and mw.winfo_exists():
                            feet_per_square = float(getattr(mw, "feet_per_square", feet_per_square) or feet_per_square)
                    except Exception:
                        pass
                    for pos in summon_positions[:quantity_from_cfg]:
                        col = int(pos.get("col"))
                        row = int(pos.get("row"))
                        if col < 0 or row < 0 or col >= cols or row >= rows or (col, row) in obstacles:
                            self._lan.toast(ws_id, "That summon square be invalid, matey.")
                            return
                        if caster_pos is not None and max_range_ft is not None:
                            dist_ft = math.hypot(col - caster_pos[0], row - caster_pos[1]) * max(1.0, feet_per_square)
                            if dist_ft - max_range_ft > 1e-6:
                                self._lan.toast(ws_id, "That square be out of spell range, matey.")
                                return
            c = self.combatants.get(cid) if cid is not None else None
            if c is not None and not is_admin:
                player_name = _resolve_pc_name(cid)
                consumes_pool = payload.get("consumes_pool") if isinstance(payload.get("consumes_pool"), dict) else {}
                pool_id = str(
                    msg.get("consumes_pool_id")
                    or payload.get("consumes_pool_id")
                    or consumes_pool.get("id")
                    or consumes_pool.get("pool")
                    or ""
                ).strip()
                try:
                    pool_cost = int(
                        msg.get("consumes_pool_cost")
                        if msg.get("consumes_pool_cost") is not None
                        else payload.get("consumes_pool_cost")
                        if payload.get("consumes_pool_cost") is not None
                        else consumes_pool.get("cost", 1)
                    )
                except Exception:
                    pool_cost = 1
                pool_cost = max(1, pool_cost)
                if pool_id:
                    ok_pool, pool_err = self._consume_resource_pool_for_cast(
                        caster_name=player_name,
                        pool_id=pool_id,
                        cost=pool_cost,
                    )
                    if not ok_pool:
                        self._lan.toast(ws_id, pool_err)
                        return
                else:
                    ok_slot, slot_err, _spent_level = self._consume_spell_slot_for_cast(
                        caster_name=player_name,
                        slot_level=slot_level,
                        minimum_level=preset_level,
                    )
                    if not ok_slot:
                        self._lan.toast(ws_id, slot_err)
                        return
                if spend != "reaction" and int(getattr(c, "spell_cast_remaining", 0) or 0) <= 0:
                    self._lan.toast(ws_id, "Already cast a spell this turn, matey.")
                    return
                if not self._combatant_can_cast_spell(c, spend):
                    self._lan.toast(ws_id, "No spellcasting action available, matey.")
                    return
                spell_name = self._spell_label_from_identifiers(
                    preset.get("name"),
                    preset.get("slug"),
                    spell_slug,
                    spell_id,
                )
                cast_log = self._spell_cast_log_message(c.name, spell_name, slot_level)
                if spend == "bonus":
                    if not self._use_bonus_action(c, log_message=cast_log):
                        self._lan.toast(ws_id, "No bonus actions left, matey.")
                        return
                elif spend == "reaction":
                    if not self._use_reaction(c, log_message=cast_log):
                        self._lan.toast(ws_id, "No reactions left, matey.")
                        return
                else:
                    if not self._use_action(c, log_message=cast_log):
                        self._lan.toast(ws_id, "No actions left, matey.")
                        return
                c.spell_cast_remaining = max(0, int(getattr(c, "spell_cast_remaining", 0) or 0) - 1)
                smite_slug = self._smite_slug_from_preset(preset)
                if smite_slug and smite_slug in _SMITE_SPELL_CONFIG:
                    setattr(
                        c,
                        "pending_smite_charge",
                        {
                            "slug": smite_slug,
                            "name": str(preset.get("name") or smite_slug.replace("-", " ").title()),
                            "slot_level": slot_level,
                        },
                    )
                    self._lan.toast(ws_id, f"{str(getattr(c, 'name', 'Caster') or 'Caster')} readies {str(preset.get('name') or 'a smite')}.")
                if summon_cfg and cid is not None:
                    spawned_cids = self._spawn_summons_from_cast(
                        caster_cid=cid,
                        spell_slug=spell_slug,
                        spell_id=spell_id,
                        slot_level=slot_level,
                        summon_choice=summon_choice,
                        summon_quantity=summon_quantity,
                        summon_positions=summon_positions,
                        summon_variant=summon_variant,
                    )
                    if not spawned_cids:
                        self._lan.toast(ws_id, "Summoning failed, matey.")
                        return
                    if bool(preset.get("concentration")):
                        c.concentrating = True
                        c.concentration_spell = str(preset.get("slug") or preset.get("id") or "")
                        c.concentration_target = list(spawned_cids)
                self._rebuild_table(scroll_to_current=True)
            elif summon_cfg and cid is not None:
                spawned_cids = self._spawn_summons_from_cast(
                    caster_cid=cid,
                    spell_slug=spell_slug,
                    spell_id=spell_id,
                    slot_level=slot_level,
                    summon_choice=summon_choice,
                    summon_quantity=summon_quantity,
                    summon_positions=summon_positions,
                    summon_variant=summon_variant,
                )
                if not spawned_cids:
                    self._lan.toast(ws_id, "Summoning failed, matey.")
                    return
                if bool(preset.get("concentration")) and c is not None:
                    c.concentrating = True
                    c.concentration_spell = str(preset.get("slug") or preset.get("id") or "")
                    c.concentration_target = list(spawned_cids)
            if c is not None:
                smite_slug = self._smite_slug_from_preset(preset)
                if smite_slug and smite_slug in _SMITE_SPELL_CONFIG:
                    setattr(
                        c,
                        "pending_smite_charge",
                        {
                            "slug": smite_slug,
                            "name": str(preset.get("name") or smite_slug.replace("-", " ").title()),
                            "slot_level": slot_level,
                        },
                    )
            self._lan_force_state_broadcast()
            self._lan.toast(ws_id, f"Casted {preset.get('name') or 'spell'}.")
            return

        elif typ == "dismiss_summons":
            target_caster = _normalize_cid_value(msg.get("target_caster_cid"), "dismiss_summons.target")
            if target_caster is None:
                target_caster = claimed
            if target_caster is None:
                self._lan.toast(ws_id, "Pick a summoner first, matey.")
                return
            if not is_admin and (claimed is None or int(claimed) != int(target_caster)):
                self._lan.toast(ws_id, "Ye can only dismiss yer own summons.")
                return
            removed = self._dismiss_summons_for_caster(int(target_caster))
            self._lan.toast(ws_id, f"Dismissed {removed} summoned creature(s).")
            return
        elif typ == "assign_pre_summon":
            if not is_admin:
                self._lan.toast(ws_id, "Only the DM can assign pre-summons, matey.")
                return
            target_cid = _normalize_cid_value(msg.get("target_cid"), "assign_pre_summon.target")
            if target_cid is None or int(target_cid) not in self.combatants:
                self._lan.toast(ws_id, "Pick a valid character for pre-summon, matey.")
                return
            spell_slug = str(msg.get("spell_slug") or "").strip().lower()
            monster_slug = str(msg.get("monster_slug") or "").strip().lower()
            variant = str(msg.get("variant") or "").strip() or None
            try:
                slot_level = int(msg.get("slot_level")) if msg.get("slot_level") is not None else None
            except Exception:
                slot_level = None
            if not spell_slug or not monster_slug:
                self._lan.toast(ws_id, "Pre-summon needs spell and monster slugs.")
                return
            self._pending_pre_summons[int(target_cid)] = {
                "spell_slug": spell_slug,
                "monster_slug": monster_slug,
                "slot_level": slot_level,
                "variant": variant,
            }
            self._lan.toast(ws_id, "Pre-summon assigned.")
            return
        elif typ == "aoe_move":
            aid = msg.get("aid")
            to = msg.get("to") or {}
            def _typed(value: Any) -> Dict[str, Any]:
                return {"value": value, "type": type(value).__name__}

            def _send_aoe_move_ack(ok: bool, reason_code: Optional[str] = None, extra: Optional[Dict[str, Any]] = None) -> None:
                if ws_id is None:
                    return
                lan = getattr(self, "_lan", None)
                loop = getattr(lan, "_loop", None) if lan else None
                if not lan or not loop:
                    return
                payload: Dict[str, Any] = {"type": "aoe_move_ack", "ok": ok}
                if reason_code:
                    payload["reason_code"] = reason_code
                if extra:
                    payload.update(extra)
                coro = lan._send_async(ws_id, payload)
                try:
                    asyncio.run_coroutine_threadsafe(coro, loop)
                except Exception:
                    pass

            def _log_aoe_move(decision: str, extra: Optional[Dict[str, Any]] = None) -> None:
                payload: Dict[str, Any] = {
                    "event": "aoe_move_permission",
                    "decision": decision,
                    "claimedCid": _typed(claimed),
                    "active_cid": _typed(getattr(self, "current_cid", None)),
                    "in_combat": _typed(getattr(self, "in_combat", None)),
                    "turn_enforced": not is_admin,
                    "cid": _typed(cid),
                    "aid": _typed(aid),
                }
                if extra:
                    payload.update(extra)
                try:
                    self._append_lan_log(self._json_dumps(payload), level="info")
                except Exception:
                    pass

            if not isinstance(aid, int):
                decision = "reject_invalid_aid"
                _log_aoe_move(decision)
                _send_aoe_move_ack(False, reason_code=decision)
                self._lan.toast(ws_id, "Pick a spell first, matey.")
                return
            try:
                cx = float(to.get("cx"))
                cy = float(to.get("cy"))
            except Exception:
                decision = "reject_invalid_destination"
                _log_aoe_move(decision)
                _send_aoe_move_ack(False, reason_code=decision)
                return
            def _to_float(value: Any) -> Optional[float]:
                try:
                    return float(value)
                except Exception:
                    return None
            angle_deg = _to_float(to.get("angle_deg"))
            ax = _to_float(to.get("ax"))
            ay = _to_float(to.get("ay"))
            spread_deg = _to_float(to.get("spread_deg"))
            mw = getattr(self, "_map_window", None)
            map_ready = mw is not None and mw.winfo_exists()
            aoe_store = getattr(mw, "aoes", {}) if map_ready else (getattr(self, "_lan_aoes", {}) or {})
            d = (aoe_store or {}).get(aid)
            if not d and map_ready:
                d = (getattr(self, "_lan_aoes", {}) or {}).get(aid)
                if d:
                    mw_aoes = getattr(mw, "aoes", None)
                    if mw_aoes is None:
                        mw_aoes = {}
                        setattr(mw, "aoes", mw_aoes)
                    mw_aoes[aid] = dict(d)
                    aoe_store = mw_aoes
            if not d:
                decision = "reject_missing_aoe"
                _log_aoe_move(decision)
                _send_aoe_move_ack(False, reason_code=decision)
                return
            if bool(d.get("fixed_to_caster")):
                decision = "reject_fixed_to_caster"
                _log_aoe_move(decision)
                _send_aoe_move_ack(False, reason_code=decision)
                self._lan.toast(ws_id, "That self-range spell is fixed to its caster.")
                return
            if bool(d.get("pinned")) and not is_admin:
                decision = "reject_pinned"
                _log_aoe_move(
                    decision,
                    extra={
                        "owner_cid": _typed(d.get("owner_cid")),
                        "anchor_cid": _typed(d.get("anchor_cid")),
                    },
                )
                _send_aoe_move_ack(False, reason_code=decision)
                self._lan.toast(ws_id, "That spell be pinned.")
                return
            owner_cid_raw = d.get("owner_cid")
            anchor_cid_raw = d.get("anchor_cid")
            owner_cid = _normalize_cid_value(
                owner_cid_raw, "aoe_move.owner_cid", log_fn=log_warning
            )
            anchor_cid = _normalize_cid_value(
                anchor_cid_raw, "aoe_move.anchor_cid", log_fn=log_warning
            )
            if owner_cid_raw is not None and owner_cid_raw != owner_cid:
                d["owner_cid"] = owner_cid
            if anchor_cid_raw is not None and anchor_cid_raw != anchor_cid:
                d["anchor_cid"] = anchor_cid
            if not is_admin:
                if owner_cid is None:
                    decision = "reject_missing_owner"
                    _log_aoe_move(
                        decision,
                        extra={
                            "owner_cid": _typed(owner_cid),
                            "anchor_cid": _typed(anchor_cid),
                        },
                    )
                    _send_aoe_move_ack(False, reason_code=decision)
                    self._lan.toast(ws_id, "That spell be not yers.")
                    return
                if cid is None or owner_cid != cid:
                    decision = "reject_owner_mismatch"
                    _log_aoe_move(
                        decision,
                        extra={
                            "owner_cid": _typed(owner_cid),
                            "anchor_cid": _typed(anchor_cid),
                        },
                    )
                    _send_aoe_move_ack(False, reason_code=decision)
                    self._lan.toast(ws_id, "That spell be not yers.")
                    return
            move_per_turn_ft = d.get("move_per_turn_ft")
            move_remaining_ft = d.get("move_remaining_ft")
            move_action_type = str(d.get("move_action_type") or "").strip().lower()
            if not is_admin:
                current_cid = _normalize_cid_value(
                    getattr(self, "current_cid", None), "aoe_move.current_cid", log_fn=log_warning
                )
                on_turn = current_cid is not None and cid is not None and current_cid == cid
                owner_override = owner_cid is not None and claimed is not None and owner_cid == claimed
                if not on_turn and not owner_override:
                    decision = "reject_not_turn"
                    _log_aoe_move(
                        decision,
                        extra={
                            "owner_cid": _typed(owner_cid),
                            "anchor_cid": _typed(anchor_cid),
                        },
                    )
                    _send_aoe_move_ack(False, reason_code=decision)
                    self._lan.toast(ws_id, "Not yer turn yet, matey.")
                    return
                owner_combatant = self.combatants.get(int(owner_cid)) if owner_cid in self.combatants else None
                if move_action_type == "none":
                    decision = "reject_move_action_none"
                    _log_aoe_move(decision)
                    _send_aoe_move_ack(False, reason_code=decision)
                    self._lan.toast(ws_id, "That spell cannot be moved.")
                    return
                if move_action_type in ("bonus_action", "action", "magic_action"):
                    if owner_combatant is None:
                        decision = "reject_missing_owner_combatant"
                        _log_aoe_move(decision)
                        _send_aoe_move_ack(False, reason_code=decision)
                        return
                    if move_action_type == "bonus_action":
                        if int(getattr(owner_combatant, "bonus_action_remaining", 0) or 0) <= 0:
                            decision = "reject_no_bonus_action"
                            _log_aoe_move(decision)
                            _send_aoe_move_ack(False, reason_code=decision)
                            self._lan.toast(ws_id, "No bonus action left to move that spell.")
                            return
                        owner_combatant.bonus_action_remaining = 0
                    else:
                        # magic_action maps to consuming the standard action resource.
                        if int(getattr(owner_combatant, "action_remaining", 0) or 0) <= 0:
                            decision = "reject_no_action"
                            _log_aoe_move(decision)
                            _send_aoe_move_ack(False, reason_code=decision)
                            self._lan.toast(ws_id, "No action left to move that spell.")
                            return
                        owner_combatant.action_remaining = 0
                move_limit = None
                if move_per_turn_ft not in (None, ""):
                    try:
                        move_limit = float(move_per_turn_ft)
                    except Exception:
                        move_limit = None
                    if move_limit is not None and move_limit <= 0:
                        move_limit = None
                if move_limit is not None:
                    if not on_turn:
                        decision = "reject_move_not_turn"
                        _log_aoe_move(
                            decision,
                            extra={
                                "owner_cid": _typed(owner_cid),
                                "anchor_cid": _typed(anchor_cid),
                                "move_per_turn_ft": move_per_turn_ft,
                            },
                        )
                        _send_aoe_move_ack(False, reason_code=decision)
                        self._lan.toast(ws_id, "That spell moves only on yer turn.")
                        return
                    try:
                        remaining = float(move_remaining_ft)
                    except Exception:
                        remaining = move_limit
                    try:
                        feet_per_square = float(getattr(mw, "feet_per_square", 5.0) or 5.0)
                    except Exception:
                        feet_per_square = 5.0
                    if feet_per_square <= 0:
                        feet_per_square = 5.0
                    dx = float(cx) - float(d.get("cx") or 0.0)
                    dy = float(cy) - float(d.get("cy") or 0.0)
                    dist_ft = (dx * dx + dy * dy) ** 0.5 * feet_per_square
                    if dist_ft > remaining + 0.01:
                        decision = "reject_move_distance"
                        _log_aoe_move(
                            decision,
                            extra={
                                "owner_cid": _typed(owner_cid),
                                "anchor_cid": _typed(anchor_cid),
                                "move_remaining_ft": remaining,
                                "move_distance_ft": dist_ft,
                            },
                        )
                        _send_aoe_move_ack(False, reason_code=decision)
                        self._lan.toast(ws_id, f"That spell can only move {remaining:.1f} ft this turn.")
                        return
                    d["move_remaining_ft"] = max(0.0, float(remaining) - dist_ft)
            _log_aoe_move(
                "allow",
                extra={
                    "owner_cid": _typed(owner_cid),
                    "anchor_cid": _typed(anchor_cid),
                },
            )
            try:
                if map_ready:
                    cols = int(getattr(mw, "cols", 0))
                    rows = int(getattr(mw, "rows", 0))
                else:
                    cols = int(getattr(self, "_lan_grid_cols", 0))
                    rows = int(getattr(self, "_lan_grid_rows", 0))
            except Exception:
                cols = 0
                rows = 0
            before_included = self._lan_compute_included_units_for_aoe(d)
            d["cx"] = float(cx)
            d["cy"] = float(cy)
            kind = str(d.get("kind") or "")
            if kind in ("line", "cone", "cube", "wall", "square"):
                if angle_deg is not None:
                    d["angle_deg"] = float(angle_deg)
                if ax is not None:
                    d["ax"] = float(ax)
                if ay is not None:
                    d["ay"] = float(ay)
                if kind == "cone" and spread_deg is not None:
                    d["spread_deg"] = float(spread_deg)
            facing_synced = False
            if angle_deg is not None:
                facing_synced = self._sync_owner_facing_from_rotatable_aoe(d, angle_deg)
            try:
                if map_ready and hasattr(mw, "_layout_aoe"):
                    mw._layout_aoe(aid)
            except Exception:
                pass
            try:
                if map_ready:
                    self._lan_aoes = dict(getattr(mw, "aoes", {}) or {})
                else:
                    store = getattr(self, "_lan_aoes", {}) or {}
                    store[aid] = dict(d)
                    self._lan_aoes = store
            except Exception:
                pass
            self._lan_handle_aoe_enter_triggers_for_aoe_move(int(aid), d, before_included)
            self._rebuild_table(scroll_to_current=True)
            if facing_synced:
                try:
                    self._lan_force_state_broadcast()
                except Exception:
                    pass
            _send_aoe_move_ack(
                True,
                extra={
                    "aid": aid,
                    "cx": d.get("cx"),
                    "cy": d.get("cy"),
                    "ax": d.get("ax"),
                    "ay": d.get("ay"),
                    "angle_deg": d.get("angle_deg"),
                    "spread_deg": d.get("spread_deg"),
                },
            )
            return
        elif typ == "aoe_remove":
            aid = msg.get("aid")
            if not isinstance(aid, int):
                self._lan.toast(ws_id, "Pick a spell first, matey.")
                return
            mw = getattr(self, "_map_window", None)
            map_ready = mw is not None and mw.winfo_exists()
            aoe_store = getattr(mw, "aoes", {}) if map_ready else (getattr(self, "_lan_aoes", {}) or {})
            d = (aoe_store or {}).get(aid)
            if not d and map_ready:
                d = (getattr(self, "_lan_aoes", {}) or {}).get(aid)
            if not d:
                return
            if bool(d.get("pinned")) and not is_admin:
                self._lan.toast(ws_id, "That spell be pinned.")
                return
            owner_cid_raw = d.get("owner_cid")
            owner_cid = _normalize_cid_value(
                owner_cid_raw, "aoe_remove.owner_cid", log_fn=log_warning
            )
            if owner_cid_raw is not None and owner_cid_raw != owner_cid:
                d["owner_cid"] = owner_cid
            if not is_admin:
                if owner_cid is None:
                    self._lan.toast(ws_id, "That spell be not yers.")
                    return
                if cid is None or owner_cid != cid:
                    self._lan.toast(ws_id, "That spell be not yers.")
                    return
            if map_ready:
                try:
                    if hasattr(mw, "aoes") and isinstance(mw.aoes, dict):
                        mw.aoes.pop(aid, None)
                    if hasattr(mw, "_refresh_aoe_list"):
                        mw._refresh_aoe_list()
                except Exception:
                    pass
                try:
                    self._lan_aoes = dict(getattr(mw, "aoes", {}) or {})
                except Exception:
                    pass
            else:
                store = getattr(self, "_lan_aoes", {}) or {}
                store.pop(aid, None)
                self._lan_aoes = store
            if owner_cid is not None and owner_cid in self.combatants:
                caster = self.combatants[owner_cid]
                aoe_ids = list(getattr(caster, "concentration_aoe_ids", []) or [])
                if aid in aoe_ids:
                    caster.concentration_aoe_ids = [entry for entry in aoe_ids if entry != aid]
            return

        if typ == "mount_request":
            rider_cid = _normalize_cid_value(msg.get("rider_cid"), "mount_request.rider")
            mount_cid = _normalize_cid_value(msg.get("mount_cid"), "mount_request.mount")
            if mount_cid is None:
                self._lan.toast(ws_id, "Pick rider and mount first, matey.")
                return
            if not is_admin:
                if cid is None:
                    self._lan.toast(ws_id, "Claim a character first, matey.")
                    return
                if rider_cid is not None and int(rider_cid) != int(cid):
                    self._lan.toast(ws_id, "Ye can only mount with yer own token.")
                    return
                rider_cid = int(cid)
            if rider_cid is None:
                self._lan.toast(ws_id, "Pick rider and mount first, matey.")
                return
            rider = self.combatants.get(int(rider_cid))
            mount = self.combatants.get(int(mount_cid))
            if rider is None or mount is None:
                self._lan.toast(ws_id, "Invalid mount target.")
                return
            if int(rider_cid) == int(mount_cid):
                self._lan.toast(ws_id, "Ye cannot mount yerself.")
                return
            if bool(getattr(rider, "rider_cid", None)) or bool(getattr(rider, "mounted_by_cid", None)):
                self._lan.toast(ws_id, "Ye be already mounted.")
                return
            if bool(getattr(mount, "mounted_by_cid", None)) or bool(getattr(mount, "rider_cid", None)):
                self._lan.toast(ws_id, "That creature be already tied up in a mount.")
                return
            _, _, _, _, positions = self._lan_live_map_data()
            rider_pos = positions.get(int(rider_cid))
            mount_pos = positions.get(int(mount_cid))
            if rider_pos is None or mount_pos is None or tuple(rider_pos) != tuple(mount_pos):
                self._lan.toast(ws_id, "Rider and mount must share a square.")
                return
            auto_accept = _normalize_cid_value(getattr(mount, "summoned_by_cid", None), "mount_request.summoned_by") == int(rider_cid)
            req_id = f"mount:{int(time.time()*1000)}:{rider_cid}:{mount_cid}"
            self._pending_mount_requests[req_id] = {"rider_cid": int(rider_cid), "mount_cid": int(mount_cid), "requester_ws": ws_id}
            if auto_accept:
                self._accept_mount(int(rider_cid), int(mount_cid), ws_id, auto=True)
                self._pending_mount_requests.pop(req_id, None)
                return
            if not bool(getattr(mount, "is_pc", False)):
                self._pending_mount_requests.pop(req_id, None)
                approved = messagebox.askyesno(
                    "Mount Request",
                    f"{getattr(rider, 'name', 'A rider')} is trying to mount {getattr(mount, 'name', 'a creature')}. Allow?",
                )
                if approved:
                    self._accept_mount(int(rider_cid), int(mount_cid), ws_id, auto=False)
                    return
                passed = messagebox.askyesno(
                    "Mount Request",
                    f"{getattr(rider, 'name', 'Rider')} vs {getattr(mount, 'name', 'Creature')}: Pass or Fail?\n\nYes = Pass (allow mount)\nNo = Fail (deny mount)",
                )
                if passed:
                    self._accept_mount(int(rider_cid), int(mount_cid), ws_id, auto=False)
                elif ws_id is not None:
                    self._lan.toast(int(ws_id), "Mount request declined.")
                return
            target_ws_ids = self._find_ws_for_cid(int(mount_cid)) if bool(getattr(mount, "is_pc", False)) else []
            payload = {"type": "mount_prompt", "request_id": req_id, "rider_cid": int(rider_cid), "mount_cid": int(mount_cid), "rider_name": str(getattr(rider, "name", "Rider"))}
            if target_ws_ids and self._lan._loop:
                for tws in target_ws_ids:
                    asyncio.run_coroutine_threadsafe(self._lan._send_async(tws, payload), self._lan._loop)
            else:
                self._lan._broadcast_payload({**payload, "to_admin": True})
            self._lan.toast(ws_id, "Mount request sent.")
            return

        if typ == "mount_response":
            request_id = str(msg.get("request_id") or "").strip()
            pending = self._pending_mount_requests.pop(request_id, None)
            if not pending:
                self._lan.toast(ws_id, "Mount request expired.")
                return
            if bool(msg.get("accept")):
                self._accept_mount(int(pending.get("rider_cid")), int(pending.get("mount_cid")), pending.get("requester_ws"), auto=False)
            else:
                requester_ws = pending.get("requester_ws")
                if requester_ws is not None:
                    self._lan.toast(int(requester_ws), "Mount request declined.")
            return

        if typ == "echo_tether_response":
            request_id = str(msg.get("request_id") or "").strip()
            pending = self._pending_echo_tether_confirms.pop(request_id, None)
            if not pending:
                return
            pending_ws = pending.get("ws_id")
            if pending_ws is not None and ws_id is not None and int(pending_ws) != int(ws_id):
                return
            if not bool(msg.get("accept")):
                return
            target_cid = _normalize_cid_value(pending.get("cid"), "echo_tether_response.cid")
            target_col = _normalize_cid_value(pending.get("col"), "echo_tether_response.col")
            target_row = _normalize_cid_value(pending.get("row"), "echo_tether_response.row")
            if target_cid is None or target_col is None or target_row is None:
                return
            ok, reason, cost = self._lan_try_move(int(target_cid), int(target_col), int(target_row))
            if not ok:
                self._lan.toast(ws_id, reason or "Can’t move there.")
                return
            self._enforce_johns_echo_tether(int(target_cid))
            self._lan.toast(ws_id, f"Moved ({cost} ft).")
            return

        if typ == "dismount":
            rider = self.combatants.get(cid)
            if rider is None:
                return
            mount_cid = _normalize_cid_value(getattr(rider, "rider_cid", None), "dismount.rider_cid")
            if mount_cid is None:
                self._lan.toast(ws_id, "Ye are not mounted.")
                return
            mount = self.combatants.get(int(mount_cid))
            if mount is None:
                setattr(rider, "rider_cid", None)
                return
            cost = self._mount_cost(rider)
            if int(getattr(rider, "move_remaining", 0) or 0) < cost:
                self._lan.toast(ws_id, f"Not enough movement to dismount (need {cost} ft).")
                return
            rider.move_remaining = max(0, int(getattr(rider, "move_remaining", 0) or 0) - cost)
            setattr(rider, "rider_cid", None)
            setattr(mount, "mounted_by_cid", None)
            setattr(mount, "mount_shared_turn", False)
            setattr(mount, "mount_controller_mode", "independent")
            self._restore_mount_initiative(int(rider.cid), int(mount.cid))
            self._log(f"{rider.name} dismounts from {mount.name}.", cid=rider.cid)
            self._lan_force_state_broadcast()
            return

        if typ == "initiative_roll":
            roll_value = msg.get("initiative")
            try:
                roll_total = int(roll_value)
            except Exception:
                self._lan.toast(ws_id, "Enter a valid initiative number, matey.")
                return
            if roll_total < -99 or roll_total > 999:
                self._lan.toast(ws_id, "Initiative total be out of range.")
                return
            target = self.combatants.get(int(cid)) if cid is not None else None
            if target is None:
                self._lan.toast(ws_id, "That scallywag ain’t in combat no more.")
                return
            self._set_initiative(int(cid), int(roll_total))
            self._rebuild_table(scroll_to_current=True)
            self._lan_force_state_broadcast()
            self._lan.toast(ws_id, f"Initiative set to {int(roll_total)}.")
            return

        if typ == "move":
            to = msg.get("to") or {}
            try:
                col = int(to.get("col"))
                row = int(to.get("row"))
            except Exception:
                if is_move:
                    msg["_move_applied"] = False
                    msg["_move_reject_reason"] = "invalid_target"
                    _move_log("lan_move_reject", reason="invalid_target", to=to)
                self._lan.toast(ws_id, "Pick a valid square, matey.")
                return

            mover = self.combatants.get(cid)
            if mover is not None and _normalize_cid_value(getattr(mover, "rider_cid", None), "move.rider_cid") is not None:
                self._lan.toast(ws_id, "Rider movement uses the mount, matey.")
                return
            cols, rows, obstacles, rough_terrain, positions = self._lan_live_map_data()
            before_pos = positions.get(cid)
            mw = getattr(self, "_map_window", None)
            map_ready = mw is not None and mw.winfo_exists()
            map_token_pos = None
            if map_ready:
                try:
                    tok = (getattr(mw, "unit_tokens", {}) or {}).get(int(cid))
                    if isinstance(tok, dict):
                        map_token_pos = {"col": tok.get("col"), "row": tok.get("row")}
                except Exception:
                    map_token_pos = None
            _move_log(
                "lan_move_attempt",
                cid=cid,
                to={"col": col, "row": row},
                before_pos=before_pos,
                map_ready=map_ready,
                map_token_pos=map_token_pos,
                move_remaining=getattr(self.combatants.get(cid), "move_remaining", None) if cid else None,
            )

            owner_cid, echo_cid, breaks_echo_tether = self._johns_echo_tether_move_details(cid, int(col), int(row))
            is_owner_turn = bool(owner_cid is not None and current_cid is not None and int(owner_cid) == int(current_cid))
            should_prompt_echo_warning = bool(
                not is_admin
                and breaks_echo_tether
                and ws_id is not None
                and owner_cid is not None
                and echo_cid is not None
                and int(cid) in (int(owner_cid), int(echo_cid))
                and is_owner_turn
            )
            if should_prompt_echo_warning:
                request_id = f"echo_tether:{int(time.time()*1000)}:{int(cid)}:{int(col)}:{int(row)}"
                self._pending_echo_tether_confirms[request_id] = {
                    "cid": int(cid),
                    "col": int(col),
                    "row": int(row),
                    "ws_id": int(ws_id),
                }
                try:
                    self._lan.send_echo_tether_prompt(int(ws_id), request_id)
                except Exception:
                    if getattr(self._lan, "_loop", None):
                        asyncio.run_coroutine_threadsafe(
                            self._lan._send_async(int(ws_id), {
                                "type": "echo_tether_prompt",
                                "request_id": request_id,
                                "text": "Warning. Moving here will destroy your echo. Proceed?",
                            }),
                            self._lan._loop,
                        )
                return

            ok, reason, cost = self._lan_try_move(cid, col, row)
            if not ok:
                if is_move:
                    msg["_move_applied"] = False
                    msg["_move_reject_reason"] = str(reason or "move_rejected")
                    cols_after, rows_after, _, _, positions_after = self._lan_live_map_data()
                    after_pos = positions_after.get(cid)
                    _move_log(
                        "lan_move_result",
                        ok=False,
                        reason=reason,
                        cost=cost,
                        before_pos=before_pos,
                        after_pos=after_pos,
                        grid={"cols": cols_after, "rows": rows_after},
                    )
                self._lan.toast(ws_id, reason or "Can’t move there.")
            else:
                msg["_move_applied"] = True
                msg["_move_reject_reason"] = None
                cols_after, rows_after, _, _, positions_after = self._lan_live_map_data()
                after_pos = positions_after.get(cid)
                map_token_pos_after = None
                if map_ready:
                    try:
                        tok = (getattr(mw, "unit_tokens", {}) or {}).get(int(cid))
                        if isinstance(tok, dict):
                            map_token_pos_after = {"col": tok.get("col"), "row": tok.get("row")}
                    except Exception:
                        map_token_pos_after = None
                _move_log(
                    "lan_move_result",
                    ok=True,
                    reason=None,
                    cost=cost,
                    before_pos=before_pos,
                    after_pos=after_pos,
                    map_token_pos_before=map_token_pos,
                    map_token_pos_after=map_token_pos_after,
                    grid={"cols": cols_after, "rows": rows_after},
                )
                if breaks_echo_tether:
                    self._enforce_johns_echo_tether(int(cid))
                self._lan.toast(ws_id, f"Moved ({cost} ft).")
        elif typ == "cycle_movement_mode":
            c = self.combatants.get(cid)
            if not c:
                return
            modes: List[str] = ["normal"]
            if int(getattr(c, "swim_speed", 0) or 0) > 0:
                modes.append("swim")
            if int(getattr(c, "fly_speed", 0) or 0) > 0:
                modes.append("fly")
            if int(getattr(c, "burrow_speed", 0) or 0) > 0:
                modes.append("burrow")
            current_mode = self._normalize_movement_mode(getattr(c, "movement_mode", "normal"))
            try:
                idx = modes.index(current_mode)
            except ValueError:
                idx = 0
            next_mode = modes[(idx + 1) % len(modes)]
            self._set_movement_mode(int(cid), next_mode)
            self._rebuild_table(scroll_to_current=True)
            self._lan.toast(ws_id, f"Movement mode: {self._movement_mode_label(next_mode)}.")
        elif typ == "dash":
            c = self.combatants.get(cid)
            if not c:
                return
            spend = str(msg.get("spend") or "").lower()
            if spend not in ("action", "bonus"):
                self._lan.toast(ws_id, "Choose action or bonus action, matey.")
                return
            if spend == "action":
                if not self._use_action(c):
                    self._lan.toast(ws_id, "No actions left, matey.")
                    return
                spend_label = "action"
            else:
                if not self._use_bonus_action(c):
                    self._lan.toast(ws_id, "No bonus actions left, matey.")
                    return
                spend_label = "bonus action"
            try:
                base_speed = int(self._mode_speed(c))
            except Exception:
                base_speed = int(getattr(c, "speed", 30) or 30)
            try:
                # Match map dash logic: add 30 to both numerator/denominator
                total = int(getattr(c, "move_total", 0) or 0)
                rem = int(getattr(c, "move_remaining", 0) or 0)
                setattr(c, "move_total", total + base_speed)
                setattr(c, "move_remaining", rem + base_speed)
                self._log(f"{c.name} dashed (move {rem}/{total} -> {c.move_remaining}/{c.move_total})", cid=cid)
                self._lan.toast(ws_id, f"Dashed ({spend_label}).")
                self._rebuild_table(scroll_to_current=True)
            except Exception:
                pass
        elif typ == "perform_action":
            c = self.combatants.get(cid)
            if not c:
                return
            spend_raw = str(msg.get("spend") or "action").lower()
            if spend_raw in ("bonus", "bonus_action"):
                spend = "bonus"
            elif spend_raw == "reaction":
                spend = "reaction"
            else:
                spend = "action"
            action_name = str(msg.get("action") or msg.get("name") or "").strip()
            action_entry = self._find_action_entry(c, spend, action_name)
            if not action_entry:
                self._lan.toast(ws_id, "That action ain't in yer sheet, matey.")
                return
            if self._mount_action_is_restricted(c, action_name):
                self._lan.toast(ws_id, "Mounted steed can only Dash, Disengage, or Dodge while rider is active.")
                return

            action_key = self._action_name_key(action_name)
            action_uses = action_entry.get("uses") if isinstance(action_entry.get("uses"), dict) else {}
            action_pool_id = str(action_uses.get("pool") or action_uses.get("id") or "").strip()
            try:
                action_pool_cost = int(action_uses.get("cost", 1))
            except Exception:
                action_pool_cost = 1
            action_pool_cost = max(1, action_pool_cost)
            player_name = _resolve_pc_name(cid)
            if action_pool_id:
                ok_pool, pool_err = self._consume_resource_pool_for_cast(
                    caster_name=player_name,
                    pool_id=action_pool_id,
                    cost=action_pool_cost,
                )
                if not ok_pool:
                    self._lan.toast(ws_id, pool_err)
                    return
            consume_one_of = action_entry.get("consume_one_of") if isinstance(action_entry.get("consume_one_of"), list) else []
            if consume_one_of:
                one_of_ok = False
                one_of_errors: List[str] = []
                for choice in consume_one_of:
                    if not isinstance(choice, dict):
                        continue
                    choice_type = str(choice.get("type") or "").strip().lower()
                    if choice_type == "spell_slot":
                        min_level = _parse_int(choice.get("min_level"), 1) or 1
                        ok_slot, slot_err, _spent_slot = self._consume_spell_slot_for_cast(player_name, min_level, min_level)
                        if ok_slot:
                            one_of_ok = True
                            break
                        one_of_errors.append(slot_err)
                    elif choice_type == "pool":
                        choice_pool = str(choice.get("pool") or "").strip()
                        choice_cost = _parse_int(choice.get("cost"), 1) or 1
                        ok_pool, pool_err = self._consume_resource_pool_for_cast(player_name, choice_pool, choice_cost)
                        if ok_pool:
                            one_of_ok = True
                            break
                        one_of_errors.append(pool_err)
                if not one_of_ok:
                    self._lan.toast(ws_id, next((msg for msg in one_of_errors if msg), "No valid resource option available, matey."))
                    return

            grant_extra_action = action_key == "action surge"
            if grant_extra_action:
                c.action_remaining = int(getattr(c, "action_remaining", 0) or 0) + 1
                c.action_total = int(getattr(c, "action_total", 1) or 1) + 1
                spend_label = "free action"
            elif spend == "bonus":
                if not self._use_bonus_action(c):
                    self._lan.toast(ws_id, "No bonus actions left, matey.")
                    return
                spend_label = "bonus action"
            elif spend == "reaction":
                if not self._use_reaction(c):
                    self._lan.toast(ws_id, "No reactions left, matey.")
                    return
                spend_label = "reaction"
            else:
                if not self._use_action(c):
                    self._lan.toast(ws_id, "No actions left, matey.")
                    return
                spend_label = "action"

            if action_key == "dash":
                try:
                    base_speed = int(self._mode_speed(c))
                except Exception:
                    base_speed = int(getattr(c, "speed", 30) or 30)
                try:
                    total = int(getattr(c, "move_total", 0) or 0)
                    rem = int(getattr(c, "move_remaining", 0) or 0)
                    setattr(c, "move_total", total + base_speed)
                    setattr(c, "move_remaining", rem + base_speed)
                    self._log(
                        f"{c.name} dashed (move {rem}/{total} -> {c.move_remaining}/{c.move_total})",
                        cid=cid,
                    )
                    self._lan.toast(ws_id, f"Dashed ({spend_label}).")
                    self._rebuild_table(scroll_to_current=True)
                except Exception:
                    pass
            elif grant_extra_action:
                self._log(
                    f"{c.name} used {action_name} ({spend_label}) and gained 1 extra action",
                    cid=cid,
                )
                self._lan.toast(ws_id, "Action Surge used: +1 action.")
                self._rebuild_table(scroll_to_current=True)
            else:
                if action_key == "rage":
                    setattr(c, "rage_active", True)
                    stacks = getattr(c, "condition_stacks", None)
                    if not isinstance(stacks, list):
                        stacks = []
                        setattr(c, "condition_stacks", stacks)
                    if not self._has_condition(c, "rage"):
                        next_sid = int(self.__dict__.get("_next_stack_id", 1) or 1)
                        setattr(self, "_next_stack_id", int(next_sid) + 1)
                        stacks.append(base.ConditionStack(sid=int(next_sid), ctype="rage", remaining_turns=None))
                    if not any(
                        isinstance(hook, dict)
                        and str(hook.get("type") or "").strip().lower() == "rage_upkeep"
                        for hook in list(getattr(c, "_feature_turn_hooks", []) or [])
                    ):
                        self._register_combatant_turn_hook(
                            c,
                            {"type": "rage_upkeep", "when": "end_turn", "source": "rage"},
                        )
                action_effect = str(action_entry.get("effect") or "").strip().lower()
                if action_effect in ("recover_spell_slots", "recover_spell_slot") or action_key in ("arcane recovery", "natural recovery (recover spell slots)"):
                    recover_cfg: Dict[str, Any] = {}
                    if action_effect in ("recover_spell_slots", "recover_spell_slot"):
                        recover_cfg = dict(action_entry)
                    if not recover_cfg:
                        profile = self._profile_for_player_name(player_name)
                        feature_name_key = self._action_name_key(action_name)
                        if isinstance(profile, dict):
                            for feature in profile.get("features") if isinstance(profile.get("features"), list) else []:
                                if not isinstance(feature, dict):
                                    continue
                                if self._action_name_key(feature.get("name")) != feature_name_key:
                                    continue
                                automation = feature.get("automation") if isinstance(feature.get("automation"), dict) else {}
                                if isinstance(automation.get("recover_spell_slots"), dict):
                                    recover_cfg = dict(automation.get("recover_spell_slots") or {})
                                    break
                    if recover_cfg:
                        profile = self._profile_for_player_name(player_name)
                        if isinstance(profile, dict):
                            ok_recover, recover_err, recovered_levels = self._recover_spell_slots(player_name, profile, recover_cfg)
                            if ok_recover:
                                recovered_text = ", ".join(f"L{lvl}" for lvl in recovered_levels)
                                self._log(f"{c.name} recovers spell slots ({recovered_text}).", cid=cid)
                                self._lan.toast(ws_id, f"Recovered spell slots: {recovered_text}.")
                            else:
                                self._lan.toast(ws_id, recover_err or "Could not recover spell slots, matey.")
                self._log(f"{c.name} used {action_name} ({spend_label})", cid=cid)
                self._lan.toast(ws_id, f"Used {action_name}.")
                self._rebuild_table(scroll_to_current=True)
        elif typ == "spell_target_request":
            c = self.combatants.get(cid)
            if not c:
                return

            def _parse_int(value: Any, fallback: Optional[int] = None) -> Optional[int]:
                try:
                    return int(value)
                except Exception:
                    return fallback

            def _parse_non_negative_manual_damage(value: Any) -> Optional[int]:
                if isinstance(value, bool):
                    return None
                if isinstance(value, int):
                    return value if value >= 0 else None
                if isinstance(value, float):
                    if not value.is_integer():
                        return None
                    return int(value) if value >= 0 else None
                if isinstance(value, str):
                    text = value.strip()
                    if not text or not re.fullmatch(r"\+?\d+", text):
                        return None
                    try:
                        parsed = int(text)
                    except Exception:
                        return None
                    return parsed if parsed >= 0 else None
                return None

            def _parse_bool(value: Any, fallback: bool = False) -> bool:
                if isinstance(value, bool):
                    return value
                if isinstance(value, str):
                    lowered = value.strip().lower()
                    if lowered in ("1", "true", "yes", "y", "hit"):
                        return True
                    if lowered in ("0", "false", "no", "n", "miss"):
                        return False
                return bool(fallback)

            def _save_mod_for_target(target_obj: Any, ability_key: str) -> int:
                key = str(ability_key or "").strip().lower()
                if not key:
                    return 0
                aura_bonus = int((self._lan_aura_effects_for_target(target_obj) or {}).get("save_bonus") or 0)
                saves = getattr(target_obj, "saving_throws", None)
                if isinstance(saves, dict):
                    val = saves.get(key)
                    try:
                        return int(val) + aura_bonus
                    except Exception:
                        pass
                mods = getattr(target_obj, "ability_mods", None)
                if isinstance(mods, dict):
                    val = mods.get(key)
                    try:
                        return int(val) + aura_bonus
                    except Exception:
                        pass
                return aura_bonus

            target_cid = _normalize_cid_value(msg.get("target_cid"), "spell_target_request.target_cid", log_fn=log_warning)
            target = self.combatants.get(int(target_cid)) if target_cid is not None else None
            if target is None:
                self._lan.toast(ws_id, "Pick a valid target, matey.")
                return

            spell_name = str(msg.get("spell_name") or msg.get("name") or "Spell").strip() or "Spell"
            preset = self._find_spell_preset(msg.get("spell_slug"), msg.get("spell_id"))
            preset_slug = str((preset or {}).get("slug") or "").strip().lower()
            preset_id = str((preset or {}).get("id") or "").strip().lower()
            is_haste = preset_slug == "haste" or preset_id == "haste"
            haste_duration_turns = 10
            haste_ac_bonus = 2
            if is_haste and isinstance(preset, dict):
                ui_cfg = (
                    ((preset.get("mechanics") or {}).get("ui") or {}).get("spell_targeting")
                    if isinstance((preset.get("mechanics") or {}).get("ui"), dict)
                    else None
                )
                if isinstance(ui_cfg, dict):
                    try:
                        parsed_turns = int(ui_cfg.get("duration_turns"))
                        if parsed_turns > 0:
                            haste_duration_turns = parsed_turns
                    except Exception:
                        pass
                    try:
                        parsed_bonus = int(ui_cfg.get("ac_bonus"))
                        if parsed_bonus >= 0:
                            haste_ac_bonus = parsed_bonus
                    except Exception:
                        pass
            spell_mode = str(msg.get("spell_mode") or msg.get("mode") or "attack").strip().lower()
            if spell_mode not in ("attack", "auto_hit", "save", "effect"):
                spell_mode = "attack"
            hit = _parse_bool(msg.get("hit"), fallback=spell_mode == "auto_hit")
            critical = _parse_bool(msg.get("critical"), fallback=False)
            save_type = str(msg.get("save_type") or "").strip().lower()
            save_dc = max(0, _parse_int(msg.get("save_dc"), 0) or 0)
            roll_save = _parse_bool(msg.get("roll_save"), fallback=spell_mode == "save")
            damage_entries: List[Dict[str, Any]] = []
            raw_damage_entries = msg.get("damage_entries")
            if isinstance(raw_damage_entries, list):
                for entry in raw_damage_entries:
                    if not isinstance(entry, dict):
                        continue
                    amount = _parse_non_negative_manual_damage(entry.get("amount"))
                    if amount is None:
                        continue
                    amount = int(amount)
                    if amount <= 0:
                        continue
                    dtype = str(entry.get("type") or "").strip().lower()
                    damage_entries.append({"amount": amount, "type": dtype})

            damage_dice_text = str(msg.get("damage_dice") or "").strip().lower()
            damage_type_hint = str(msg.get("damage_type") or "").strip().lower() or "damage"
            auto_spell_damage = bool(hit and not damage_entries and damage_dice_text)
            if auto_spell_damage:
                dice_match = re.fullmatch(r"\s*(\d+)d(\d+)\s*([+\-]\s*\d+)?\s*", damage_dice_text)
                if dice_match:
                    dice_count = max(0, int(dice_match.group(1)))
                    dice_sides = max(0, int(dice_match.group(2)))
                    mod_text = str(dice_match.group(3) or "").replace(" ", "")
                    flat_mod = _parse_int(mod_text, 0) or 0
                    amount = 0
                    if dice_count > 0 and dice_sides > 0:
                        if critical and spell_mode in ("attack", "auto_hit"):
                            amount = int(dice_count) * int(dice_sides) + int(flat_mod)
                        else:
                            amount = sum(random.randint(1, int(dice_sides)) for _ in range(int(dice_count))) + int(flat_mod)
                    else:
                        amount = int(flat_mod)
                    if amount > 0:
                        damage_entries.append({"amount": int(amount), "type": damage_type_hint})
            result_payload: Dict[str, Any] = {
                "type": "spell_target_result",
                "ok": True,
                "attacker_cid": int(cid),
                "target_cid": int(target_cid),
                "target_name": str(getattr(target, "name", "Target") or "Target"),
                "spell_name": spell_name,
                "spell_mode": spell_mode,
            }

            if spell_mode == "effect":
                if bool((preset or {}).get("concentration")) and c is not None:
                    if bool(getattr(c, "concentrating", False)):
                        self._end_concentration(c)
                    c.concentrating = True
                    c.concentration_spell = str((preset or {}).get("slug") or (preset or {}).get("id") or spell_name)
                    c.concentration_spell_level = int((preset or {}).get("level") or 0) or None
                    c.concentration_started_turn = (int(self.round_num), int(self.turn_num))
                    current_targets = list(getattr(c, "concentration_target", []) or [])
                    if int(target.cid) not in current_targets:
                        current_targets.append(int(target.cid))
                    c.concentration_target = current_targets
                self._log(f"{c.name} targets {result_payload['target_name']} with {spell_name}.", cid=int(target_cid))
                try:
                    self._rebuild_table(scroll_to_current=True)
                except Exception:
                    pass
                msg["_spell_target_result"] = dict(result_payload)
                loop = getattr(self._lan, "_loop", None)
                if ws_id is not None and loop:
                    try:
                        asyncio.run_coroutine_threadsafe(self._lan._send_async(ws_id, result_payload), loop)
                    except Exception:
                        pass
                return
            mechanics = preset.get("mechanics") if isinstance(preset, dict) and isinstance(preset.get("mechanics"), dict) else {}
            sequence = mechanics.get("sequence") if isinstance(mechanics.get("sequence"), list) else []
            resolved_bucket: List[Dict[str, Any]] = []
            def _bucket_for_outcome(outcomes: Dict[str, Any], passed: bool, key_hint: str) -> List[Dict[str, Any]]:
                keys = [key_hint] if key_hint else []
                if passed:
                    keys.extend(["success", "pass", "saved", "save"])
                else:
                    keys.extend(list(FAIL_OUTCOME_LABELS))
                for key in keys:
                    bucket = outcomes.get(key)
                    if isinstance(bucket, list):
                        return [entry for entry in bucket if isinstance(entry, dict)]
                return []

            if spell_mode == "save" and save_type and save_dc > 0 and roll_save:
                save_roll = random.randint(1, 20)
                save_mod = _save_mod_for_target(target, save_type)
                save_total = int(save_roll) + int(save_mod)
                save_passed = bool(save_roll != 1 and save_total >= int(save_dc))
                result_payload["save_result"] = {
                    "ability": save_type,
                    "dc": int(save_dc),
                    "roll": int(save_roll),
                    "modifier": int(save_mod),
                    "total": int(save_total),
                    "passed": bool(save_passed),
                }
                self._log(
                    f"{target.name} makes a {save_type.upper()} save vs {spell_name} "
                    f"(DC {int(save_dc)}): {int(save_roll)} + {int(save_mod)} = {int(save_total)} "
                    f"({'PASS' if save_passed else 'FAIL'}).",
                    cid=int(target_cid),
                )
                seq_step = next((step for step in sequence if isinstance(step, dict)), None)
                if isinstance(seq_step, dict):
                    outcomes = seq_step.get("outcomes") if isinstance(seq_step.get("outcomes"), dict) else {}
                    resolved_bucket = _bucket_for_outcome(outcomes, bool(save_passed), "")
                if save_passed:
                    result_payload["hit"] = False
                    result_payload["damage_total"] = 0
                    msg["_spell_target_result"] = dict(result_payload)
                    loop = getattr(self._lan, "_loop", None)
                    if ws_id is not None and loop:
                        try:
                            asyncio.run_coroutine_threadsafe(self._lan._send_async(ws_id, result_payload), loop)
                        except Exception:
                            pass
                    self._lan.toast(ws_id, "Target passed the save.")
                    return
                damage_intent = bool(damage_entries) or bool(damage_dice_text) or bool(msg.get("prompt_for_damage"))
                if not damage_entries and damage_intent:
                    result_payload["needs_damage_prompt"] = True
                    msg["_spell_target_result"] = dict(result_payload)
                    loop = getattr(self._lan, "_loop", None)
                    if ws_id is not None and loop:
                        try:
                            asyncio.run_coroutine_threadsafe(self._lan._send_async(ws_id, result_payload), loop)
                        except Exception:
                            pass
                    self._lan.toast(ws_id, "Target failed the save.")
                    return
                if not damage_intent:
                    hit = True

            if not resolved_bucket and sequence:
                seq_step = next((step for step in sequence if isinstance(step, dict)), None)
                if isinstance(seq_step, dict):
                    outcomes = seq_step.get("outcomes") if isinstance(seq_step.get("outcomes"), dict) else {}
                    if spell_mode == "save":
                        passed = bool((result_payload.get("save_result") or {}).get("passed"))
                        resolved_bucket = _bucket_for_outcome(outcomes, passed, "")
                    else:
                        resolved_bucket = _bucket_for_outcome(outcomes, False, "hit" if hit else "miss")

            adjustment = self._adjust_damage_entries_for_target(target, damage_entries)
            damage_entries = list(adjustment.get("entries") or [])
            adjustment_notes = list(adjustment.get("notes") or [])
            total_damage = int(sum(int(entry.get("amount", 0) or 0) for entry in damage_entries))
            if spell_mode == "auto_hit":
                hit = True
            result_payload["hit"] = bool(hit)
            result_payload["critical"] = bool(hit and critical)
            result_payload["damage_entries"] = list(damage_entries if hit else [])
            result_payload["damage_total"] = int(total_damage if hit else 0)
            haste_applied = False
            if hit and is_haste and c is not None:
                if bool(getattr(c, "concentrating", False)):
                    self._end_concentration(c)
                c.concentrating = True
                c.concentration_spell = "haste"
                c.concentration_spell_level = int((preset or {}).get("level") or 0) or None
                c.concentration_started_turn = (int(self.round_num), int(self.turn_num))
                current_targets = list(getattr(c, "concentration_target", []) or [])
                if int(target.cid) not in current_targets:
                    current_targets.append(int(target.cid))
                c.concentration_target = current_targets
                haste_applied = bool(
                    self._apply_haste_effect(c, target, duration_turns=haste_duration_turns, ac_bonus=haste_ac_bonus)
                )
                if haste_applied:
                    result_payload["haste_applied"] = True

            if hit and total_damage > 0:
                before_hp = _parse_int(getattr(target, "hp", None), None)
                if before_hp is not None:
                    after_hp = max(0, int(before_hp) - int(total_damage))
                    setattr(target, "hp", int(after_hp))
                    if int(before_hp) > 0 and int(after_hp) <= 0:
                        pre_order: List[int] = []
                        try:
                            pre_order = [x.cid for x in self._display_order()]
                        except Exception:
                            pre_order = []
                        removed_target = False
                        try:
                            self._remove_combatants_with_lan_cleanup([int(target_cid)])
                            removed_target = int(target_cid) not in self.combatants
                        except Exception:
                            removed_target = self.combatants.pop(int(target_cid), None) is not None
                        if removed_target:
                            if getattr(self, "start_cid", None) == int(target_cid):
                                self.start_cid = None
                            try:
                                self._retarget_current_after_removal([int(target_cid)], pre_order=pre_order)
                            except Exception:
                                pass
                            self._log(f"{target.name} dropped to 0 -> removed", cid=int(target_cid))
                        try:
                            self._lan.play_ko(int(cid))
                        except Exception:
                            pass
                damage_desc = ", ".join(
                    f"{int(entry.get('amount', 0) or 0)} {str(entry.get('type') or '').strip() or 'damage'}"
                    for entry in damage_entries
                )
                self._log(
                    f"{c.name} deals {int(total_damage)} damage to {result_payload['target_name']} with {spell_name}"
                    f"{f' ({damage_desc})' if damage_desc else ''}"
                    f"{' (CRIT)' if result_payload.get('critical') else ''}.",
                    cid=int(target_cid),
                )
            elif hit:
                if haste_applied:
                    self._log(
                        f"{c.name} applies Haste to {result_payload['target_name']} ({haste_duration_turns} turns).",
                        cid=int(target_cid),
                    )
                else:
                    self._log(
                        f"{c.name} hits {result_payload['target_name']} with {spell_name}"
                        f"{' (CRIT)' if result_payload.get('critical') else ''}.",
                        cid=int(target_cid),
                    )
            else:
                self._log(f"{c.name} misses {result_payload['target_name']} with {spell_name}.", cid=int(target_cid))

            forced_moves_applied: List[str] = []
            if isinstance(resolved_bucket, list):
                for effect in resolved_bucket:
                    effect_name = str(effect.get("effect") or "").strip().lower()
                    if effect_name not in ("movement", "forced_movement"):
                        continue
                    mode = str(effect.get("kind") or effect.get("mode") or effect.get("direction") or "").strip().lower()
                    if mode not in ("push", "pull"):
                        continue
                    try:
                        distance_ft = float(effect.get("distance_ft") or 0)
                    except Exception:
                        distance_ft = 0.0
                    if distance_ft <= 0:
                        continue
                    origin = str(effect.get("origin") or "caster").strip().lower()
                    source_cid = int(cid)
                    source_cell = None
                    direction_step = None
                    if origin == "aoe_direction":
                        direction_step = self._lan_direction_step_from_angle(effect.get("angle_deg", getattr(c, "facing_deg", 0)))
                        source_cid = None
                    moved = self._lan_apply_forced_movement(
                        source_cid,
                        int(target_cid),
                        mode,
                        float(distance_ft),
                        source_cell=source_cell,
                        direction_step=direction_step,
                    )
                    if moved:
                        forced_moves_applied.append(f"{mode} {int(distance_ft)}ft")
            if forced_moves_applied:
                self._log(f"{spell_name} moves {result_payload['target_name']}: {', '.join(forced_moves_applied)}.", cid=int(target_cid))

            try:
                self._rebuild_table(scroll_to_current=True)
            except Exception:
                pass
            msg["_spell_target_result"] = dict(result_payload)
            loop = getattr(self._lan, "_loop", None)
            if ws_id is not None and loop:
                try:
                    asyncio.run_coroutine_threadsafe(self._lan._send_async(ws_id, result_payload), loop)
                except Exception:
                    pass
            if not hit:
                self._lan.toast(ws_id, "Spell misses.")
            elif total_damage > 0:
                self._lan.toast(ws_id, "Spell hits.")
            else:
                self._lan.toast(ws_id, "Spell resolved.")
        elif typ == "attack_request":
            c = self.combatants.get(cid)
            if not c:
                return
            self._clear_hide_state(int(cid), reason=f"{c.name} attacks and reveals themself.")
            resource_c = c
            try:
                summoned_by_cid = int(getattr(c, "summoned_by_cid", 0) or 0)
            except Exception:
                summoned_by_cid = 0
            if (
                summoned_by_cid > 0
                and str(getattr(c, "summon_source_spell", "") or "").strip().lower() == "echo_knight"
            ):
                owner = self.combatants.get(int(summoned_by_cid))
                if owner is not None:
                    resource_c = owner
            max_damage_dice_count = 100
            max_damage_die_sides = 1000
            min_damage_type_length = 3
            def _parse_int(value: Any, fallback: Optional[int] = None) -> Optional[int]:
                try:
                    return int(value)
                except Exception:
                    return fallback

            def _parse_non_negative_manual_damage(value: Any) -> Optional[int]:
                if isinstance(value, bool):
                    return None
                if isinstance(value, int):
                    return value if value >= 0 else None
                if isinstance(value, float):
                    if not value.is_integer():
                        return None
                    return int(value) if value >= 0 else None
                if isinstance(value, str):
                    text = value.strip()
                    if not text or not re.fullmatch(r"\+?\d+", text):
                        return None
                    try:
                        parsed = int(text)
                    except Exception:
                        return None
                    return parsed if parsed >= 0 else None
                return None
            def _parse_bool(value: Any) -> Optional[bool]:
                if isinstance(value, bool):
                    return value
                if isinstance(value, str):
                    text = value.strip().lower()
                    if text in ("true", "1", "yes", "y", "hit"):
                        return True
                    if text in ("false", "0", "no", "n", "miss"):
                        return False
                return None
            def _weapon_has_property(entry: Any, prop_id: str) -> bool:
                if not isinstance(entry, dict):
                    return False
                target = str(prop_id or "").strip().lower()
                if not target:
                    return False
                properties = entry.get("properties")
                if isinstance(properties, list):
                    for token in properties:
                        normalized = str(token or "").strip().lower()
                        if normalized == target:
                            return True
                mastery = str(entry.get("mastery") or "").strip().lower()
                return bool(mastery and mastery == target)
            def _weapon_mastery_damage_ability_mod(entry: Any, profile_data: Any, variables: Dict[str, int]) -> int:
                if not isinstance(entry, dict):
                    return int(variables.get("str_mod", 0) or 0)
                formula = ""
                mode_block = entry.get("one_handed") if isinstance(entry.get("one_handed"), dict) else {}
                if isinstance(mode_block, dict):
                    formula = str(mode_block.get("damage_formula") or "").strip().lower()
                if not formula and isinstance(entry.get("two_handed"), dict):
                    formula = str((entry.get("two_handed") or {}).get("damage_formula") or "").strip().lower()
                str_mod = int(variables.get("str_mod", 0) or 0)
                dex_mod = int(variables.get("dex_mod", 0) or 0)
                if "dex_mod" in formula and "str_mod" not in formula:
                    return dex_mod
                if "str_mod" in formula and "dex_mod" not in formula:
                    return str_mod
                if _weapon_has_property(entry, "finesse"):
                    return max(str_mod, dex_mod)
                return str_mod
            def _mastery_save_dc(entry: Any, profile_data: Any, variables: Dict[str, int]) -> int:
                if isinstance(entry, dict):
                    explicit_dc = _parse_int(entry.get("mastery_save_dc"), None)
                    if explicit_dc is not None and explicit_dc > 0:
                        return int(explicit_dc)
                prof_bonus = 2
                if isinstance(profile_data, dict):
                    prof_block = profile_data.get("proficiency") if isinstance(profile_data.get("proficiency"), dict) else {}
                    prof_bonus = max(2, _parse_int(prof_block.get("bonus"), 2) or 2)
                return int(8 + int(prof_bonus) + int(_weapon_mastery_damage_ability_mod(entry, profile_data, variables)))
            def _damage_formula_variables(profile_data: Any) -> Dict[str, int]:
                if not isinstance(profile_data, dict):
                    profile_data = {}
                abilities = profile_data.get("abilities") if isinstance(profile_data.get("abilities"), dict) else {}
                return {
                    "str_mod": self._ability_score_modifier(abilities, "str"),
                    "dex_mod": self._ability_score_modifier(abilities, "dex"),
                    "con_mod": self._ability_score_modifier(abilities, "con"),
                    "int_mod": self._ability_score_modifier(abilities, "int"),
                    "wis_mod": self._ability_score_modifier(abilities, "wis"),
                    "cha_mod": self._ability_score_modifier(abilities, "cha"),
                }
            def _roll_damage_formula(formula: Any, variables: Dict[str, int], dice_multiplier: int = 1) -> Optional[int]:
                if not isinstance(formula, str):
                    return None
                raw = formula.strip().lower()
                if not raw:
                    return None
                if not re.fullmatch(r"[0-9d+\-*/(). _a-zA-Z]+", raw):
                    return None
                identifiers = {token.lower() for token in re.findall(r"\b[a-zA-Z_][a-zA-Z0-9_]*\b", raw)}
                if not identifiers.issubset({str(key).lower() for key in variables.keys()}):
                    return None
                try:
                    def _replace_die(match: re.Match[str]) -> str:
                        count = int(match.group(1) or 1)
                        sides = int(match.group(2))
                        multiplier = max(1, int(dice_multiplier or 1))
                        effective_count = int(count) * int(multiplier)
                        if effective_count <= 0 or effective_count > max_damage_dice_count or sides <= 0 or sides > max_damage_die_sides:
                            raise ValueError("invalid dice notation")
                        return str(sum(random.randint(1, sides) for _ in range(effective_count)))
                    expr = re.sub(
                        r"(\d*)d(\d+)",
                        _replace_die,
                        raw,
                    )
                except Exception:
                    return None
                evaluated = self._evaluate_spell_formula(expr, variables)
                if evaluated is None:
                    return None
                return max(0, int(math.floor(evaluated)))
            def _ensure_condition(target_obj: Any, ctype: str, remaining_turns: Optional[int] = None) -> bool:
                ctype_key = str(ctype or "").strip().lower()
                if not ctype_key:
                    return False
                if self._condition_is_immune_for_target(target_obj, ctype_key):
                    return False
                stacks = getattr(target_obj, "condition_stacks", None)
                if not isinstance(stacks, list):
                    stacks = []
                    setattr(target_obj, "condition_stacks", stacks)
                for st in stacks:
                    if getattr(st, "ctype", None) == ctype_key:
                        if remaining_turns is not None:
                            setattr(st, "remaining_turns", int(remaining_turns))
                        return False
                next_sid = int(getattr(self, "_next_stack_id", 1) or 1)
                setattr(self, "_next_stack_id", int(next_sid) + 1)
                stacks.append(base.ConditionStack(sid=int(next_sid), ctype=ctype_key, remaining_turns=remaining_turns))
                return True
            def _parse_effect_damage_entries(effect_text: Any, variables: Dict[str, int], dice_multiplier: int = 1) -> List[Dict[str, Any]]:
                if not isinstance(effect_text, str):
                    return []
                entries: List[Dict[str, Any]] = []
                for match in re.finditer(r"(\d*d\d+(?:\s*[+\-]\s*\d+)?)\s+([a-zA-Z]+)\s+damage", effect_text.lower()):
                    dtype = str(match.group(2) or "").strip().lower()
                    if len(dtype) < min_damage_type_length:
                        continue
                    amount = _roll_damage_formula(match.group(1), variables, dice_multiplier=dice_multiplier)
                    if amount is None or amount <= 0:
                        continue
                    entries.append({"amount": int(amount), "type": dtype})
                return entries
            def _save_mod_for_target(target_obj: Any, ability_key: str) -> int:
                key = str(ability_key or "").strip().lower()
                if not key:
                    return 0
                aura_bonus = int((self._lan_aura_effects_for_target(target_obj) or {}).get("save_bonus") or 0)
                saves = getattr(target_obj, "saving_throws", None)
                if isinstance(saves, dict):
                    val = saves.get(key)
                    try:
                        return int(val) + aura_bonus
                    except Exception:
                        pass
                mods = getattr(target_obj, "ability_mods", None)
                if isinstance(mods, dict):
                    val = mods.get(key)
                    try:
                        return int(val) + aura_bonus
                    except Exception:
                        pass
                return aura_bonus
            def _set_prone_if_needed(target_obj: Any) -> bool:
                if self._condition_is_immune_for_target(target_obj, "prone"):
                    return False
                stacks = getattr(target_obj, "condition_stacks", None)
                if not isinstance(stacks, list):
                    stacks = []
                    setattr(target_obj, "condition_stacks", stacks)
                for st in stacks:
                    if getattr(st, "ctype", None) == "prone":
                        return False
                next_sid = int(getattr(self, "_next_stack_id", 1) or 1)
                setattr(self, "_next_stack_id", int(next_sid) + 1)
                stacks.append(base.ConditionStack(sid=int(next_sid), ctype="prone", remaining_turns=None))
                return True
            def _is_enemy_of_attacker(attacker_obj: Any, target_obj: Any) -> bool:
                attacker_role = str(self.__dict__.get("_name_role_memory", {}).get(str(getattr(attacker_obj, "name", "")), "enemy") or "enemy")
                target_role = str(self.__dict__.get("_name_role_memory", {}).get(str(getattr(target_obj, "name", "")), "enemy") or "enemy")
                return bool(attacker_role in ("pc", "ally") and target_role not in ("pc", "ally"))
            target_cid = _normalize_cid_value(msg.get("target_cid"), "attack_request.target_cid", log_fn=log_warning)
            target = self.combatants.get(int(target_cid)) if target_cid is not None else None
            if target is None:
                self._lan.toast(ws_id, "Pick a valid target, matey.")
                return
            requested_hit = _parse_bool(msg.get("hit"))
            requested_critical = _parse_bool(msg.get("critical"))
            attack_roll_raw = msg.get("attack_roll")
            if attack_roll_raw is None:
                attack_roll_raw = msg.get("roll")
            attack_roll = _parse_int(attack_roll_raw, None)
            if requested_hit is None and (attack_roll is None or attack_roll < 1 or attack_roll > 20):
                self._lan.toast(ws_id, "Enter a valid d20 roll, matey.")
                return
            weapon_id = str(msg.get("weapon_id") or "").strip()
            weapon_name = str(msg.get("weapon_name") or "").strip()
            profile_cid = int(getattr(resource_c, "cid", cid) or cid)
            player_name = self._pc_name_for(int(profile_cid))
            profile = self._profile_for_player_name(player_name)
            configured_attack_count = 1
            leveling = profile.get("leveling") if isinstance(profile, dict) else {}
            classes = leveling.get("classes") if isinstance(leveling, dict) else []
            if isinstance(classes, list):
                for entry in classes:
                    if not isinstance(entry, dict):
                        continue
                    class_attack_count = _parse_int(entry.get("attacks_per_action"), None)
                    if class_attack_count is None:
                        continue
                    configured_attack_count = max(1, min(10, max(configured_attack_count, class_attack_count)))
            attacks = profile.get("attacks") if isinstance(profile, dict) else {}
            weapons = attacks.get("weapons") if isinstance(attacks, dict) else []
            selected_weapon: Dict[str, Any] = {}
            def _weapon_equipped_flag(entry: Dict[str, Any]) -> bool:
                raw = entry.get("equipped")
                if isinstance(raw, bool):
                    return raw
                if isinstance(raw, (int, float)):
                    return bool(raw)
                if isinstance(raw, str):
                    return raw.strip().lower() in ("1", "true", "yes", "on")
                return False
            if isinstance(weapons, list):
                target_weapon_id = weapon_id.lower()
                target_weapon_name = weapon_name.lower()
                for entry in weapons:
                    if not isinstance(entry, dict):
                        continue
                    entry_id = str(entry.get("id") or "").strip().lower()
                    entry_name = str(entry.get("name") or "").strip().lower()
                    if target_weapon_id and entry_id == target_weapon_id:
                        selected_weapon = entry
                        break
                    if target_weapon_name and entry_name and entry_name == target_weapon_name:
                        selected_weapon = entry
                if not selected_weapon and not target_weapon_id and not target_weapon_name:
                    for entry in weapons:
                        if isinstance(entry, dict) and _weapon_equipped_flag(entry):
                            selected_weapon = entry
                            break
                    if not selected_weapon:
                        for entry in weapons:
                            if isinstance(entry, dict):
                                selected_weapon = entry
                                break
            if not selected_weapon:
                inline_weapon = msg.get("weapon") if isinstance(msg.get("weapon"), dict) else {}
                if bool(getattr(c, "is_wild_shaped", False)) and isinstance(inline_weapon, dict):
                    inline_name = str(inline_weapon.get("name") or "").strip()
                    if inline_name:
                        selected_weapon = copy.deepcopy(inline_weapon)
            if not selected_weapon:
                self._lan.toast(ws_id, "Pick one of yer configured weapons first, matey.")
                return
            is_unarmed_strike = self._is_unarmed_strike_weapon(selected_weapon)
            attunement_active = self._elemental_attunement_active(c)
            monk_level = self._class_level_from_profile(profile, "monk") if isinstance(profile, dict) else 0
            empowered_strikes_active = bool(is_unarmed_strike and int(monk_level) >= 6)
            allowed_elemental_overrides = {"acid", "cold", "fire", "lightning", "thunder"}
            damage_type_override = str(msg.get("damage_type_override") or "").strip().lower()
            override_honored = bool(
                damage_type_override in allowed_elemental_overrides
                and attunement_active
                and is_unarmed_strike
            )
            setattr(c, "_rage_attack_made_this_turn", True)
            turn_marker = (
                int(getattr(self, "round_num", 0) or 0),
                int(getattr(self, "turn_num", 0) or 0),
                int(cid),
            )
            weapon_mastery_enabled = _parse_bool(attacks.get("weapon_mastery_enabled") if isinstance(attacks, dict) else None)
            if weapon_mastery_enabled is None:
                weapon_mastery_enabled = _parse_bool(attacks.get("weapon_mastery") if isinstance(attacks, dict) else None)
            if weapon_mastery_enabled is None:
                weapon_mastery_enabled = False
            nick_turn_marker = tuple(getattr(resource_c, "_nick_mastery_turn_marker", ()) or ())
            nick_already_used_this_turn = bool(
                len(nick_turn_marker) == len(turn_marker) and nick_turn_marker == turn_marker
            )
            nick_extra_attack_available = False
            if weapon_mastery_enabled and not nick_already_used_this_turn and _weapon_has_property(selected_weapon, "light"):
                other_light_weapon = False
                has_nick_mastery = _weapon_has_property(selected_weapon, "nick")
                if isinstance(weapons, list):
                    selected_key = (
                        str(selected_weapon.get("id") or "").strip().lower(),
                        str(selected_weapon.get("name") or "").strip().lower(),
                    )
                    for entry in weapons:
                        if not isinstance(entry, dict):
                            continue
                        entry_key = (
                            str(entry.get("id") or "").strip().lower(),
                            str(entry.get("name") or "").strip().lower(),
                        )
                        if entry_key == selected_key and entry is selected_weapon:
                            continue
                        if not _weapon_has_property(entry, "light"):
                            continue
                        other_light_weapon = True
                        if _weapon_has_property(entry, "nick"):
                            has_nick_mastery = True
                        if has_nick_mastery:
                            break
                nick_extra_attack_available = bool(other_light_weapon and has_nick_mastery)
            mastery_free_attack = str(msg.get("mastery_free_attack") or "").strip().lower()
            is_cleave_followup = mastery_free_attack == "cleave"
            opportunity_attack = str(msg.get("opportunity_attack") or "").strip().lower() in (
                "1",
                "true",
                "yes",
                "on",
            )
            attack_spend = str(msg.get("attack_spend") or msg.get("spend") or "").strip().lower()
            if nick_extra_attack_available:
                configured_attack_count = min(10, int(configured_attack_count) + 1)
            attack_count = max(
                1,
                min(10, _parse_int(msg.get("attack_count"), configured_attack_count) or configured_attack_count),
            )
            if bool(getattr(c, "is_wild_shaped", False)) and attack_count > configured_attack_count:
                configured_attack_count = int(attack_count)
            if is_cleave_followup:
                attack_count = 1
            consumes_pool_raw = msg.get("consumes_pool") if isinstance(msg.get("consumes_pool"), dict) else {}
            consumes_pool_id = str(
                msg.get("consumes_pool_id")
                or consumes_pool_raw.get("id")
                or consumes_pool_raw.get("pool")
                or ""
            ).strip()
            try:
                consumes_pool_cost = int(msg.get("consumes_pool_cost") if msg.get("consumes_pool_cost") is not None else consumes_pool_raw.get("cost", 1))
            except Exception:
                consumes_pool_cost = 1
            consumes_pool_cost = max(1, consumes_pool_cost)
            consumes_pool_key = consumes_pool_id.strip().lower()
            is_unleash_incarnation_attack = consumes_pool_key == "unleash_incarnation"
            if is_unleash_incarnation_attack:
                echo_cid, _echo = _find_echo_for_caster(int(profile_cid))
                if echo_cid is None:
                    self._lan.toast(ws_id, "Arr... I dont be seeing no echo, matey")
                    return
            attack_resources = max(0, _parse_int(getattr(resource_c, "attack_resource_remaining", 0), 0) or 0)
            is_bonus_spend_attack = bool(attack_spend == "bonus" and not opportunity_attack and not is_cleave_followup)
            if is_bonus_spend_attack:
                bonus_seq_id = str(msg.get("bonus_sequence_id") or "").strip().lower() or "bonus_attack"
                try:
                    bonus_sequence_total = int(msg.get("bonus_sequence_total") if msg.get("bonus_sequence_total") is not None else 1)
                except Exception:
                    bonus_sequence_total = 1
                bonus_sequence_total = max(1, min(10, int(bonus_sequence_total)))
                bonus_sequence_start = bool(msg.get("bonus_sequence_start") is True)
                active_seq_marker = tuple(getattr(resource_c, "_bonus_attack_seq_turn_marker", ()) or ())
                active_seq_id = str(getattr(resource_c, "_bonus_attack_seq_id", "") or "").strip().lower()
                try:
                    active_seq_remaining = int(getattr(resource_c, "_bonus_attack_seq_remaining", 0) or 0)
                except Exception:
                    active_seq_remaining = 0
                matching_seq = len(active_seq_marker) == len(turn_marker) and active_seq_marker == turn_marker and active_seq_id == bonus_seq_id
                should_start_sequence = bool(bonus_sequence_start or not matching_seq)
                if should_start_sequence:
                    if not self._use_bonus_action(resource_c):
                        self._lan.toast(ws_id, "No bonus actions left, matey.")
                        return
                    setattr(resource_c, "_bonus_attack_seq_turn_marker", turn_marker)
                    setattr(resource_c, "_bonus_attack_seq_id", bonus_seq_id)
                    setattr(resource_c, "_bonus_attack_seq_remaining", max(0, int(bonus_sequence_total) - 1))
                else:
                    if active_seq_remaining <= 0:
                        self._lan.toast(ws_id, "No bonus actions left, matey.")
                        return
                    next_remaining = max(0, int(active_seq_remaining) - 1)
                    setattr(resource_c, "_bonus_attack_seq_remaining", int(next_remaining))
                    if next_remaining <= 0:
                        setattr(resource_c, "_bonus_attack_seq_turn_marker", ())
                        setattr(resource_c, "_bonus_attack_seq_id", "")
                        setattr(resource_c, "_bonus_attack_seq_remaining", 0)
            elif not is_cleave_followup:
                if opportunity_attack:
                    if not self._use_reaction(resource_c):
                        self._lan.toast(ws_id, "No reactions left, matey.")
                        return
                elif not is_unleash_incarnation_attack:
                    if attack_resources <= 0:
                        if not self._use_action(resource_c):
                            self._lan.toast(ws_id, "No attacks left, matey.")
                            return
                        attack_resources = int(configured_attack_count)
                        if nick_extra_attack_available:
                            setattr(resource_c, "_nick_mastery_turn_marker", turn_marker)
                    attack_resources = max(0, int(attack_resources) - 1)
                    setattr(resource_c, "attack_resource_remaining", int(attack_resources))
            attacker_pos = dict(self.__dict__.get("_lan_positions", {}) or {}).get(int(cid))
            target_pos = dict(self.__dict__.get("_lan_positions", {}) or {}).get(int(target_cid))
            if isinstance(attacker_pos, tuple) and len(attacker_pos) == 2 and isinstance(target_pos, tuple) and len(target_pos) == 2:
                feet_per_square = 5.0
                try:
                    mw = getattr(self, "_map_window", None)
                    if mw is not None and hasattr(mw, "winfo_exists") and mw.winfo_exists():
                        feet_per_square = float(getattr(mw, "feet_per_square", feet_per_square) or feet_per_square)
                except Exception:
                    feet_per_square = 5.0
                if feet_per_square <= 0:
                    feet_per_square = 5.0
                weapon_range = str(selected_weapon.get("range") or selected_weapon.get("normal_range") or selected_weapon.get("reach") or "").strip().lower()
                range_match = re.search(r"(\d+(?:\.\d+)?)", weapon_range.split("/")[0])
                range_ft = float(range_match.group(1)) if range_match else 5.0
                if attunement_active and is_unarmed_strike:
                    range_ft += 10.0
                distance_ft = math.hypot(
                    int(target_pos[0]) - int(attacker_pos[0]),
                    int(target_pos[1]) - int(attacker_pos[1]),
                ) * float(feet_per_square)
                if float(distance_ft) - float(range_ft) > 1e-6:
                    self._lan.toast(ws_id, "Target be out of attack range.")
                    return
            to_hit = _parse_int(selected_weapon.get("to_hit"), _parse_int(attacks.get("weapon_to_hit"), 0) or 0) or 0
            magic_bonus = _parse_int(selected_weapon.get("magic_bonus"), _parse_int(selected_weapon.get("item_bonus"), 0) or 0) or 0
            to_hit += int(magic_bonus)
            roll_total = int(attack_roll) if attack_roll is not None else 0
            total_to_hit = int(roll_total) + int(to_hit)
            target_ac = _parse_int(getattr(target, "ac", None), 10) or 10
            hit = bool(requested_hit) if requested_hit is not None else bool(total_to_hit >= int(target_ac))
            damage_entries: List[Dict[str, Any]] = []
            raw_damage_entries = msg.get("damage_entries")
            if isinstance(raw_damage_entries, list):
                for entry in raw_damage_entries:
                    if not isinstance(entry, dict):
                        continue
                    amount = _parse_non_negative_manual_damage(entry.get("amount"))
                    if amount is None:
                        continue
                    amount = int(amount)
                    if amount <= 0:
                        continue
                    dtype = str(entry.get("type") or "").strip().lower()
                    damage_entries.append({"amount": amount, "type": dtype})
            auto_roll = bool(hit and not damage_entries)
            auto_crit = bool(auto_roll and requested_critical is True)

            def _weapon_formula_already_includes_magic_bonus(weapon_entry: Any, damage_formula: Any, bonus: int) -> bool:
                if not isinstance(weapon_entry, dict):
                    return False
                if not isinstance(damage_formula, str):
                    return False
                bonus_val = int(bonus or 0)
                if bonus_val == 0:
                    return False
                formula_text = str(damage_formula or "").strip().lower()
                if not formula_text:
                    return False
                if re.search(r"\b(?:magic_bonus|item_bonus)\b", formula_text):
                    return True
                bonus_abs = abs(int(bonus_val))
                has_plus_marker = False
                weapon_name = str(weapon_entry.get("name") or "").strip().lower()
                weapon_id = str(weapon_entry.get("id") or "").strip().lower()
                if bonus_val > 0:
                    has_plus_marker = bool(
                        re.search(rf"\(\+\s*{bonus_abs}\)", weapon_name)
                        or re.search(rf"\+\s*{bonus_abs}\b", weapon_name)
                        or f"plus_{bonus_abs}" in weapon_id
                        or f"plus{bonus_abs}" in weapon_id
                    )
                if bonus_val < 0:
                    has_plus_marker = bool(
                        re.search(rf"\(-\s*{bonus_abs}\)", weapon_name)
                        or re.search(rf"-\s*{bonus_abs}\b", weapon_name)
                        or f"minus_{bonus_abs}" in weapon_id
                        or f"minus{bonus_abs}" in weapon_id
                    )
                if not has_plus_marker:
                    return False
                numeric_terms = [
                    int(token)
                    for token in re.findall(r"(?<![a-z0-9_])[+\-]?\d+(?![a-z0-9_])", formula_text)
                ]
                if bonus_val > 0:
                    return int(bonus_abs) in numeric_terms
                return -int(bonus_abs) in numeric_terms
            effect_block = selected_weapon.get("effect") if isinstance(selected_weapon.get("effect"), dict) else {}
            mastery_notes: List[str] = []
            variables = _damage_formula_variables(profile)
            graze_applied = False
            if auto_roll:
                mode_block = selected_weapon.get("one_handed") if isinstance(selected_weapon.get("one_handed"), dict) else {}
                if not str(mode_block.get("damage_formula") or "").strip() and isinstance(selected_weapon.get("two_handed"), dict):
                    mode_block = selected_weapon.get("two_handed")
                mode_formula = mode_block.get("damage_formula") if isinstance(mode_block, dict) else ""
                mode_damage = _roll_damage_formula(mode_formula, variables, dice_multiplier=2 if auto_crit else 1)
                mode_type = str((mode_block or {}).get("damage_type") or "").strip().lower() if isinstance(mode_block, dict) else ""
                if override_honored:
                    mode_type = damage_type_override
                if mode_damage is not None and mode_damage > 0:
                    entry_payload: Dict[str, Any] = {"amount": int(mode_damage), "type": mode_type}
                    if empowered_strikes_active and mode_type in ("bludgeoning", "piercing", "slashing"):
                        entry_payload["magical"] = True
                    damage_entries.append(entry_payload)
                if (
                    mode_damage is not None
                    and mode_damage > 0
                    and int(magic_bonus) != 0
                    and not _weapon_formula_already_includes_magic_bonus(selected_weapon, mode_formula, magic_bonus)
                ):
                    damage_entries.append({"amount": int(magic_bonus), "type": mode_type or "damage"})
                damage_entries.extend(_parse_effect_damage_entries(effect_block.get("on_hit"), variables, dice_multiplier=2 if auto_crit else 1))
            if weapon_mastery_enabled and _weapon_has_property(selected_weapon, "graze") and not hit:
                mode_block = selected_weapon.get("one_handed") if isinstance(selected_weapon.get("one_handed"), dict) else {}
                if not str(mode_block.get("damage_formula") or "").strip() and isinstance(selected_weapon.get("two_handed"), dict):
                    mode_block = selected_weapon.get("two_handed")
                graze_damage = max(0, _weapon_mastery_damage_ability_mod(selected_weapon, profile, variables))
                mode_type = str((mode_block or {}).get("damage_type") or "").strip().lower() if isinstance(mode_block, dict) else ""
                if override_honored:
                    mode_type = damage_type_override
                if graze_damage > 0:
                    entry_payload = {"amount": int(graze_damage), "type": mode_type}
                    if empowered_strikes_active and mode_type in ("bludgeoning", "piercing", "slashing"):
                        entry_payload["magical"] = True
                    damage_entries.append(entry_payload)
                    graze_applied = True
                    mastery_notes.append(f"Graze deals {int(graze_damage)} damage on the miss.")
            damage_riders = []
            feature_effects = getattr(c, "feature_effects", None)
            if not isinstance(feature_effects, dict) and isinstance(profile, dict):
                feature_effects = profile.get("feature_effects")
            if isinstance(feature_effects, dict):
                damage_riders = feature_effects.get("damage_riders") if isinstance(feature_effects.get("damage_riders"), list) else []
            if hit and isinstance(damage_riders, list):
                trigger_tags: set[str] = {"weapon_attack_hit", "weapon_or_beast_attack_hit"}
                if _weapon_has_property(selected_weapon, "finesse"):
                    trigger_tags.add("finesse_weapon_attack")
                weapon_range_text = str(selected_weapon.get("range") or "").strip().lower()
                if "/" in weapon_range_text or "ranged" in weapon_range_text:
                    trigger_tags.add("ranged_weapon_attack")
                advantage_flag = bool(_parse_bool(msg.get("attack_has_advantage")))
                disadvantage_flag = bool(_parse_bool(msg.get("attack_has_disadvantage")))
                ally_near_flag = bool(_parse_bool(msg.get("ally_within_5ft")))
                for rider in damage_riders:
                    if not isinstance(rider, dict):
                        continue
                    rider_id = str(rider.get("id") or rider.get("source_feature_id") or "").strip().lower()
                    rider_trigger = rider.get("trigger")
                    rider_triggers = rider_trigger if isinstance(rider_trigger, list) else [rider_trigger]
                    normalized_triggers = {str(entry or "").strip().lower() for entry in rider_triggers if str(entry or "").strip()}
                    if normalized_triggers and normalized_triggers.isdisjoint(trigger_tags):
                        continue
                    requires_any = rider.get("requires_any") if isinstance(rider.get("requires_any"), list) else []
                    if requires_any:
                        require_flags: Dict[str, bool] = {
                            "attack_has_advantage": advantage_flag,
                            "ally_within_5ft_of_target_and_not_incapacitated": ally_near_flag,
                        }
                        if not any(require_flags.get(str(flag or "").strip().lower(), False) for flag in requires_any):
                            continue
                    blocked_if = {str(flag or "").strip().lower() for flag in (rider.get("blocked_if") if isinstance(rider.get("blocked_if"), list) else [])}
                    if "attack_has_disadvantage" in blocked_if and disadvantage_flag:
                        continue
                    if bool(rider.get("once_per_turn")) and not self._once_per_turn_limiter_allows(cid, rider_id):
                        continue
                    rider_formula = str(rider.get("damage_formula") or "").strip()
                    dice_pool = str(rider.get("dice_pool") or "").strip().lower()
                    if not rider_formula and dice_pool and isinstance(profile, dict):
                        pools = self._normalize_player_resource_pools(profile)
                        for pool in pools:
                            if str(pool.get("id") or "").strip().lower() == dice_pool:
                                rider_formula = f"{max(1, int(pool.get('current', 0) or 0))}d6"
                                break
                    rider_amount = _roll_damage_formula(rider_formula, variables, dice_multiplier=2 if auto_crit else 1) if rider_formula else None
                    if rider_amount is None or rider_amount <= 0:
                        continue
                    rider_type = str(rider.get("damage_type") or "").strip().lower()
                    if rider_type in ("", "same_as_attack"):
                        rider_type = str((damage_entries[0] if damage_entries else {}).get("type") or "").strip().lower()
                    damage_entries.append({"amount": int(rider_amount), "type": rider_type})
                    if bool(rider.get("once_per_turn")):
                        self._once_per_turn_limiter_mark(profile_cid, rider_id)
                    mastery_notes.append(f"{str(rider.get('id') or 'rider').strip() or 'rider'} adds {int(rider_amount)} damage.")
            smite_result: Optional[Dict[str, Any]] = None
            smite_save_cfg: Optional[Dict[str, Any]] = None
            smite_cfg: Optional[Dict[str, Any]] = None
            smite_start_turn_rider_cfg: Optional[Dict[str, Any]] = None
            is_melee_attack = True
            weapon_category = str(selected_weapon.get("category") or "").strip().lower()
            weapon_range_text = str(selected_weapon.get("range") or "").strip().lower()
            if "ranged" in weapon_category or "/" in weapon_range_text or "ranged" in weapon_range_text:
                is_melee_attack = False
            pending_smite = getattr(c, "pending_smite_charge", None)
            if hit and is_melee_attack and isinstance(pending_smite, dict):
                smite_slug = str(pending_smite.get("slug") or "").strip().lower()
                smite_cfg = _SMITE_SPELL_CONFIG.get(smite_slug)
                if isinstance(smite_cfg, dict):
                    smite_dice = self._smite_damage_dice(smite_cfg, pending_smite.get("slot_level"))
                    smite_type = str(smite_cfg.get("damage_type") or "").strip().lower() or "damage"
                    smite_amount = _roll_damage_formula(smite_dice, {}, dice_multiplier=2 if auto_crit else 1) if smite_dice else None
                    if smite_amount is not None and smite_amount > 0:
                        damage_entries.append({"amount": int(smite_amount), "type": smite_type})
                    smite_result = {
                        "slug": smite_slug,
                        "name": str(pending_smite.get("name") or smite_slug.replace("-", " ").title()),
                        "damage": {"amount": int(max(0, smite_amount or 0)), "type": smite_type},
                    }
                    smite_save_cfg = smite_cfg.get("save") if isinstance(smite_cfg.get("save"), dict) else None
                    smite_start_turn_rider_cfg = smite_cfg.get("start_turn_rider") if isinstance(smite_cfg.get("start_turn_rider"), dict) else None
                    setattr(c, "pending_smite_charge", None)
                    if smite_result.get("damage", {}).get("amount", 0):
                        self._log(
                            f"{c.name}'s {smite_result['name']} adds {smite_result['damage']['amount']} "
                            f"{smite_type} damage.",
                            cid=cid,
                        )
            if override_honored and isinstance(damage_entries, list):
                for entry in damage_entries:
                    if not isinstance(entry, dict):
                        continue
                    raw_type = str(entry.get("type") or "").strip().lower()
                    if raw_type in ("", "damage", "bludgeoning"):
                        entry["type"] = damage_type_override
            if not resolved_bucket and sequence:
                seq_step = next((step for step in sequence if isinstance(step, dict)), None)
                if isinstance(seq_step, dict):
                    outcomes = seq_step.get("outcomes") if isinstance(seq_step.get("outcomes"), dict) else {}
                    if spell_mode == "save":
                        passed = bool((result_payload.get("save_result") or {}).get("passed"))
                        resolved_bucket = _bucket_for_outcome(outcomes, passed, "")
                    else:
                        resolved_bucket = _bucket_for_outcome(outcomes, False, "hit" if hit else "miss")

            adjustment = self._adjust_damage_entries_for_target(target, damage_entries)
            damage_entries = list(adjustment.get("entries") or [])
            adjustment_notes = list(adjustment.get("notes") or [])
            total_damage = int(sum(int(entry.get("amount", 0) or 0) for entry in damage_entries))
            damage_applied = bool(hit or graze_applied)
            deflect_attacks_result: Optional[Dict[str, Any]] = None
            if damage_applied and total_damage > 0:
                target_monk_level = 0
                target_profile = None
                if bool(getattr(target, "is_pc", False)):
                    try:
                        target_player_name = self._pc_name_for(int(getattr(target, "cid", 0) or 0))
                        target_profile = self._profile_for_player_name(target_player_name)
                        if isinstance(target_profile, dict):
                            target_monk_level = self._class_level_from_profile(target_profile, "monk")
                    except Exception:
                        target_monk_level = 0
                if int(target_monk_level) >= 3 and int(getattr(target, "reaction_remaining", 0) or 0) > 0:
                    dex_mod = 0
                    mods = getattr(target, "ability_mods", None)
                    if isinstance(mods, dict):
                        try:
                            dex_mod = int(mods.get("dex") or 0)
                        except Exception:
                            dex_mod = 0
                    if dex_mod == 0 and isinstance(target_profile, dict):
                        abilities = target_profile.get("abilities") if isinstance(target_profile.get("abilities"), dict) else {}
                        try:
                            dex_score = int(abilities.get("dex"))
                            dex_mod = math.floor((int(dex_score) - 10) / 2)
                        except Exception:
                            dex_mod = 0
                    if self._use_reaction(target):
                        reduction = int(random.randint(1, 10) + max(0, int(dex_mod)) + int(target_monk_level))
                        prevented = min(int(total_damage), max(0, int(reduction)))
                        if int(total_damage) > 0:
                            remaining_reduce = int(prevented)
                            reduced_entries: List[Dict[str, Any]] = []
                            for entry in damage_entries:
                                if not isinstance(entry, dict):
                                    continue
                                amount = int(entry.get("amount", 0) or 0)
                                if amount <= 0:
                                    continue
                                cut = min(amount, max(0, int(remaining_reduce)))
                                new_amount = max(0, amount - cut)
                                remaining_reduce = max(0, int(remaining_reduce) - cut)
                                if new_amount > 0:
                                    new_entry = dict(entry)
                                    new_entry["amount"] = int(new_amount)
                                    reduced_entries.append(new_entry)
                            damage_entries = reduced_entries
                            total_damage = int(sum(int(entry.get("amount", 0) or 0) for entry in damage_entries))
                        deflect_attacks_result = {
                            "reduction_roll_total": int(reduction),
                            "prevented_damage": int(prevented),
                            "remaining_damage": int(total_damage),
                        }
            mastery_cleave_candidates: List[Dict[str, Any]] = []
            mastery_vex_advantage = bool(
                hit
                and weapon_mastery_enabled
                and _weapon_has_property(selected_weapon, "vex")
                and _parse_int(getattr(target, "_vexed_by_cid", None), None) == int(profile_cid)
            )
            if mastery_vex_advantage:
                mastery_notes.append("Vex: Advantage applies to this attack.")
                setattr(target, "_vexed_by_cid", None)
            if damage_applied and total_damage > 0:
                setattr(target, "_rage_took_damage_this_turn", True)
                before_hp = _parse_int(getattr(target, "hp", None), None)
                if before_hp is not None:
                    after_hp = max(0, int(before_hp) - int(total_damage))
                    setattr(target, "hp", int(after_hp))
                    if int(before_hp) > 0 and int(after_hp) <= 0:
                        pre_order: List[int] = []
                        try:
                            pre_order = [x.cid for x in self._display_order()]
                        except Exception as exc:
                            self._oplog(f"attack_request: failed to snapshot turn order before KO cleanup ({exc})", level="warning")
                            pre_order = []
                        removed_target = False
                        try:
                            self._remove_combatants_with_lan_cleanup([int(target_cid)])
                            removed_target = int(target_cid) not in self.combatants
                        except Exception as exc:
                            self._oplog(f"attack_request: LAN cleanup remove failed for cid={int(target_cid)} ({exc})", level="warning")
                            # Fallback for partial test stubs or degraded LAN cleanup paths.
                            removed_target = self.combatants.pop(int(target_cid), None) is not None
                        if removed_target:
                            if getattr(self, "start_cid", None) == int(target_cid):
                                self.start_cid = None
                            try:
                                self._retarget_current_after_removal([int(target_cid)], pre_order=pre_order)
                            except Exception as exc:
                                self._oplog(
                                    f"attack_request: failed to retarget after removing cid={int(target_cid)} ({exc})",
                                    level="warning",
                                )
                            self._log(f"{target.name} dropped to 0 -> removed", cid=int(target_cid))
                        try:
                            self._lan.play_ko(int(cid))
                        except Exception:
                            pass
            if hit and isinstance(selected_weapon.get("riders"), list):
                for rider in selected_weapon.get("riders"):
                    if not isinstance(rider, dict):
                        continue
                    if str(rider.get("trigger") or "").strip().lower() != "on_hit":
                        continue
                    rider_effect = str(rider.get("effect") or "").strip().lower()
                    if rider_effect not in ("push", "pull"):
                        continue
                    save_ability = str(rider.get("save_ability") or "").strip().lower()[:3]
                    raw_dc = rider.get("save_dc")
                    rider_dc = 0
                    if isinstance(raw_dc, str) and raw_dc.strip().lower() == "wielder_spell_save_dc":
                        rider_dc = int(self._compute_spell_save_dc(profile)) if isinstance(profile, dict) else 0
                    else:
                        try:
                            rider_dc = int(raw_dc)
                        except Exception:
                            rider_dc = 0
                    try:
                        distance_ft = float(rider.get("distance_feet") or rider.get("distance_ft") or 0)
                    except Exception:
                        distance_ft = 0.0
                    if rider_dc <= 0 or save_ability not in ("str","dex","con","int","wis","cha") or distance_ft <= 0:
                        continue
                    rider_roll = int(random.randint(1, 20))
                    rider_mod = int(_save_mod_for_target(target, save_ability))
                    rider_total = int(rider_roll + rider_mod)
                    rider_passed = bool(rider_roll != 1 and rider_total >= int(rider_dc))
                    moved = False
                    if not rider_passed:
                        moved = bool(self._lan_apply_forced_movement(int(cid), int(target_cid), rider_effect, float(distance_ft)))
                    self._log(
                        f"{result_payload['weapon_name']} rider {rider_effect}: {result_payload['target_name']} {save_ability.upper()} "
                        f"{int(rider_roll)}+{int(rider_mod)}={int(rider_total)} vs DC {int(rider_dc)} "
                        f"({'PASS' if rider_passed else 'FAIL'}){' moved' if moved else ''}.",
                        cid=int(target_cid),
                    )

            if weapon_mastery_enabled and hit:
                if _weapon_has_property(selected_weapon, "cleave"):
                    mastery_notes.append("Cleave: ye can make a second attack against another nearby target.")
                if _weapon_has_property(selected_weapon, "push"):
                    mastery_notes.append("Push: move that Large-or-smaller target up to 10 ft away.")
                if _weapon_has_property(selected_weapon, "sap"):
                    mastery_notes.append("Sap: target has disadvantage on its next attack roll.")
                if _weapon_has_property(selected_weapon, "slow"):
                    mastery_notes.append("Slow: target speed is reduced by 10 ft until start of yer next turn.")
                if _weapon_has_property(selected_weapon, "topple"):
                    mastery_notes.append("Topple: have target make a Constitution save or fall prone.")
                if _weapon_has_property(selected_weapon, "vex"):
                    mastery_notes.append("Vex: gain advantage on yer next attack against this target.")
                if _weapon_has_property(selected_weapon, "sap") and _ensure_condition(target, "sapped"):
                    mastery_notes.append("Sap applied: target is Sapped.")
                if _weapon_has_property(selected_weapon, "slow"):
                    move_rem = max(0, _parse_int(getattr(target, "move_remaining", 0), 0) or 0)
                    move_total = max(0, _parse_int(getattr(target, "move_total", move_rem), move_rem) or move_rem)
                    setattr(target, "move_remaining", max(0, int(move_rem) - 10))
                    setattr(target, "move_total", max(0, int(move_total) - 10))
                    mastery_notes.append("Slow applied: target movement reduced by 10 ft.")
                if _weapon_has_property(selected_weapon, "push"):
                    origin = dict(self.__dict__.get("_lan_positions", {}) or {}).get(int(target_cid))
                    if isinstance(origin, tuple) and len(origin) == 2:
                        moved = self._lan_apply_forced_movement(int(cid), int(target_cid), "push", 10.0)
                        if moved:
                            mastery_notes.append("Push applied: target moved up to 10 ft.")
                if _weapon_has_property(selected_weapon, "topple"):
                    topple_dc = _mastery_save_dc(selected_weapon, profile, variables)
                    topple_roll = random.randint(1, 20)
                    topple_mod = _save_mod_for_target(target, "con")
                    topple_total = int(topple_roll) + int(topple_mod)
                    topple_passed = bool(topple_roll != 1 and topple_total >= int(topple_dc))
                    if not topple_passed and _set_prone_if_needed(target):
                        mastery_notes.append("Topple applied: target is Prone.")
                if _weapon_has_property(selected_weapon, "vex"):
                    _ensure_condition(target, "vexed")
                    setattr(target, "_vexed_by_cid", int(profile_cid))
                    mastery_notes.append("Vex applied: next attack by ye has advantage.")
                if (
                    _weapon_has_property(selected_weapon, "cleave")
                    and not is_cleave_followup
                    and total_damage > 0
                ):
                    positions = dict(self.__dict__.get("_lan_positions", {}) or {})
                    attacker_pos = positions.get(int(cid))
                    if isinstance(attacker_pos, tuple) and len(attacker_pos) == 2:
                        ac, ar = int(attacker_pos[0]), int(attacker_pos[1])
                        for enemy_cid, enemy in self.combatants.items():
                            try:
                                ecid = int(enemy_cid)
                            except Exception:
                                continue
                            if ecid in (int(cid), int(target_cid)):
                                continue
                            if not _is_enemy_of_attacker(c, enemy):
                                continue
                            epos = positions.get(ecid)
                            if not (isinstance(epos, tuple) and len(epos) == 2):
                                continue
                            if abs(int(epos[0]) - ac) <= 1 and abs(int(epos[1]) - ar) <= 1:
                                mastery_cleave_candidates.append({"cid": ecid, "name": str(getattr(enemy, "name", "Enemy") or "Enemy")})
                    if mastery_cleave_candidates:
                        mastery_notes.append("Cleave ready: choose one nearby enemy for a free attack.")
            stunning_strike_result: Optional[Dict[str, Any]] = None
            wants_stunning_strike = bool(_parse_bool(msg.get("stunning_strike")))
            if (
                hit
                and wants_stunning_strike
                and int(monk_level) >= 5
                and is_melee_attack
                and not is_admin
            ):
                owner_name = self._pc_name_for(int(getattr(resource_c, "cid", cid) or cid))
                ok_pool, pool_err = self._consume_resource_pool_for_cast(owner_name, "focus_points", 1)
                if ok_pool:
                    stun_dc = self._monk_save_dc_for_profile(profile) if isinstance(profile, dict) else 8
                    save_roll = int(random.randint(1, 20))
                    save_mod = int(_save_mod_for_target(target, "con"))
                    save_total = int(save_roll + save_mod)
                    save_passed = bool(save_roll != 1 and save_total >= int(stun_dc))
                    applied = False
                    if not save_passed and not self._condition_is_immune_for_target(target, "stunned"):
                        stacks = getattr(target, "condition_stacks", None)
                        if not isinstance(stacks, list):
                            stacks = []
                            setattr(target, "condition_stacks", stacks)
                        stacks = [st for st in stacks if getattr(st, "ctype", None) != "stunned"]
                        setattr(target, "condition_stacks", stacks)
                        next_sid = int(getattr(self, "_next_stack_id", 1) or 1)
                        setattr(self, "_next_stack_id", int(next_sid) + 1)
                        stacks.append(base.ConditionStack(sid=int(next_sid), ctype="stunned", remaining_turns=1))
                        applied = True
                    stunning_strike_result = {
                        "dc": int(stun_dc),
                        "roll": int(save_roll),
                        "modifier": int(save_mod),
                        "total": int(save_total),
                        "passed": bool(save_passed),
                        "applied": bool(applied),
                    }
                    self._log(
                        f"{c.name} uses Stunning Strike: {target.name} CON save DC {int(stun_dc)} "
                        f"({int(save_roll)} + {int(save_mod)} = {int(save_total)}) "
                        f"{'PASS' if save_passed else 'FAIL'}.",
                        cid=int(target_cid),
                    )
                else:
                    self._lan.toast(ws_id, pool_err or "No Focus Points remain, matey.")
            is_critical = bool(hit and bool(requested_critical))
            if consumes_pool_id and not is_admin:
                consumes_pool_always = bool(msg.get("consumes_pool_always") is True)
                should_consume_pool = bool(consumes_pool_always or (not hit) or (int(total_damage) > 0))
                if should_consume_pool:
                    owner_name = self._pc_name_for(int(getattr(resource_c, "cid", cid) or cid))
                    ok_pool, pool_err = self._consume_resource_pool_for_cast(owner_name, consumes_pool_id, consumes_pool_cost)
                    if not ok_pool:
                        self._lan.toast(ws_id, pool_err)
                        return
            result_payload: Dict[str, Any] = {
                "type": "attack_result",
                "ok": True,
                "attacker_cid": int(cid),
                "target_cid": int(target_cid),
                "target_name": str(getattr(target, "name", "Target") or "Target"),
                "weapon_id": str(selected_weapon.get("id") or "").strip(),
                "weapon_name": str(selected_weapon.get("name") or "").strip() or "Weapon",
                "attack_count": int(attack_count),
                "attack_roll": int(roll_total),
                "to_hit": int(to_hit),
                "total_to_hit": int(total_to_hit),
                "hit": hit,
                "critical": is_critical,
                "damage_total": int(total_damage if damage_applied else 0),
                "damage_entries": list(damage_entries if damage_applied else []),
                "action_remaining": int(getattr(resource_c, "action_remaining", 0) or 0),
                "bonus_action_remaining": int(getattr(resource_c, "bonus_action_remaining", 0) or 0),
                "attack_resource_remaining": int(getattr(resource_c, "attack_resource_remaining", 0) or 0),
                "mastery_advantage": bool(mastery_vex_advantage),
                "damage_type_override": damage_type_override if override_honored else None,
            }
            if mastery_cleave_candidates:
                result_payload["cleave_candidates"] = list(mastery_cleave_candidates)
            if mastery_notes:
                result_payload["weapon_property_notes"] = list(mastery_notes)
            if isinstance(smite_result, dict):
                result_payload["smite"] = dict(smite_result)
            if isinstance(deflect_attacks_result, dict):
                result_payload["deflect_attacks"] = dict(deflect_attacks_result)
            if isinstance(stunning_strike_result, dict):
                result_payload["stunning_strike"] = dict(stunning_strike_result)
            save_ability = str(effect_block.get("save_ability") or "").strip().lower()
            save_dc = _parse_int(effect_block.get("save_dc"), 0) or 0
            if hit and save_ability and save_dc > 0:
                result_payload["on_hit_save"] = {"ability": save_ability, "dc": int(save_dc)}
            smite_save_ability = str((smite_save_cfg or {}).get("ability") or "").strip().lower()
            smite_save_dc = 0
            if smite_save_ability:
                try:
                    smite_save_dc = int((pending_smite or {}).get("save_dc"))
                except Exception:
                    smite_save_dc = 0
                if smite_save_dc <= 0:
                    aura_bonus = int((self._lan_aura_effects_for_target(c) or {}).get("save_bonus") or 0)
                    smite_save_dc = int(8 + max(2, int((pending_smite or {}).get("proficiency_bonus") or 2)) + max(0, aura_bonus))
                hp_threshold = (smite_save_cfg or {}).get("hp_threshold_max")
                hp_threshold_pass = True
                if hp_threshold is not None:
                    try:
                        hp_threshold_pass = int(getattr(target, "hp", 0) or 0) <= int(hp_threshold)
                    except Exception:
                        hp_threshold_pass = False
                if hp_threshold_pass:
                    result_payload["smite_save"] = {"ability": smite_save_ability, "dc": int(smite_save_dc)}
            msg["_attack_result"] = dict(result_payload)
            if attack_roll is not None:
                self._log(
                    f"{c.name} attacks {result_payload['target_name']} with {result_payload['weapon_name']} "
                    f"(roll {attack_roll} + {to_hit} = {total_to_hit}) and {'hits' if hit else 'misses'}"
                    f"{' (CRIT)' if is_critical else ''}.",
                    cid=cid,
                )
            else:
                self._log(
                    f"{c.name} attacks {result_payload['target_name']} with {result_payload['weapon_name']} "
                    f"and {'hits' if hit else 'misses'}"
                    f"{' (CRIT)' if is_critical else ''}.",
                    cid=cid,
                )
            if damage_applied and total_damage > 0:
                def _adjustment_note_text(reasons: List[str]) -> str:
                    items = [str(reason or "").strip().lower() for reason in reasons if str(reason or "").strip()]
                    if not items:
                        return ""
                    if "immune" in items:
                        return " (immune!)"
                    if "vulnerable" in items:
                        return " (vulnerable!)"
                    if "resistant" in items:
                        return " (resist!)"
                    return ""

                adjustment_lookup: Dict[Tuple[str, int], Dict[str, Any]] = {}
                for note in adjustment_notes:
                    if not isinstance(note, dict):
                        continue
                    key = (
                        str(note.get("type") or "").strip().lower(),
                        int(note.get("applied", 0) or 0),
                    )
                    if key not in adjustment_lookup:
                        adjustment_lookup[key] = note
                damage_desc = ", ".join(
                    (
                        f"{int(entry.get('amount', 0) or 0)} {str(entry.get('type') or '').strip() or 'damage'}"
                        f"{_adjustment_note_text(list((adjustment_lookup.get((str(entry.get('type') or '').strip().lower(), int(entry.get('amount', 0) or 0))) or {}).get('reasons') or []))}"
                    )
                    for entry in damage_entries
                )
                self._log(
                    f"{c.name} deals {int(total_damage)} total damage "
                    f"with {result_payload['weapon_name']}"
                    f" to {result_payload['target_name']}"
                    f"{f' ({damage_desc})' if damage_desc else ''}"
                    f"{' (CRIT)' if is_critical else ''}.",
                    cid=cid,
                )
                if hit and save_ability and save_dc > 0:
                    save_roll = random.randint(1, 20)
                    save_mod = _save_mod_for_target(target, save_ability)
                    save_total = int(save_roll) + int(save_mod)
                    save_passed = bool(save_roll != 1 and save_total >= int(save_dc))
                    result_payload["on_hit_save_result"] = {
                        "ability": save_ability,
                        "dc": int(save_dc),
                        "roll": int(save_roll),
                        "modifier": int(save_mod),
                        "total": int(save_total),
                        "passed": bool(save_passed),
                    }
                    self._log(
                        f"{c.name} forces {result_payload['target_name']} to make a {save_ability.upper()} save "
                        f"(DC {int(save_dc)}): {int(save_roll)} + {int(save_mod)} = {int(save_total)} "
                        f"({'PASS' if save_passed else 'FAIL'}).",
                        cid=int(target_cid),
                    )
                    if not save_passed and _set_prone_if_needed(target):
                        self._log(f"{c.name} knocks {result_payload['target_name']} prone.", cid=int(target_cid))
                if hit and smite_save_ability and smite_save_dc > 0:
                    hp_threshold = (smite_save_cfg or {}).get("hp_threshold_max")
                    hp_threshold_pass = True
                    if hp_threshold is not None:
                        try:
                            hp_threshold_pass = int(getattr(target, "hp", 0) or 0) <= int(hp_threshold)
                        except Exception:
                            hp_threshold_pass = False
                    if hp_threshold_pass:
                        save_roll = random.randint(1, 20)
                        save_mod = _save_mod_for_target(target, smite_save_ability)
                        save_total = int(save_roll) + int(save_mod)
                        save_passed = bool(save_roll != 1 and save_total >= int(smite_save_dc))
                        smite_save_result = {
                            "ability": smite_save_ability,
                            "dc": int(smite_save_dc),
                            "roll": int(save_roll),
                            "modifier": int(save_mod),
                            "total": int(save_total),
                            "passed": bool(save_passed),
                        }
                        result_payload["smite_save_result"] = smite_save_result
                        self._log(
                            f"{result_payload.get('smite', {}).get('name', 'Smite')} forces "
                            f"{result_payload['target_name']} to make a {smite_save_ability.upper()} save "
                            f"(DC {int(smite_save_dc)}): {int(save_roll)} + {int(save_mod)} = {int(save_total)} "
                            f"({'PASS' if save_passed else 'FAIL'}).",
                            cid=int(target_cid),
                        )
                        if not save_passed:
                            if bool((smite_save_cfg or {}).get("apply_prone")) and _set_prone_if_needed(target):
                                self._log(f"{c.name} knocks {result_payload['target_name']} prone.", cid=int(target_cid))
                            if bool((smite_save_cfg or {}).get("push_10ft")):
                                self._lan_apply_forced_movement(int(cid), int(target_cid), "push", 10.0)
                            smite_condition = str((smite_save_cfg or {}).get("condition") or "").strip().lower()
                            if smite_condition:
                                duration_turns = (smite_save_cfg or {}).get("duration_turns")
                                turns = None
                                try:
                                    turns = int(duration_turns) if duration_turns is not None else None
                                except Exception:
                                    turns = None
                                _ensure_condition(target, smite_condition, turns)
                                if bool((smite_save_cfg or {}).get("repeat_each_turn")):
                                    group = f"smite_{str((smite_result or {}).get('slug') or '')}_{int(cid)}"
                                    riders = list(getattr(target, "start_turn_save_riders", []) or [])
                                    riders.append(
                                        {
                                            "clear_group": group,
                                            "save_ability": smite_save_ability,
                                            "save_dc": int(smite_save_dc),
                                            "condition": smite_condition,
                                        }
                                    )
                                    setattr(target, "start_turn_save_riders", riders)
                            if isinstance(smite_start_turn_rider_cfg, dict):
                                rider_dice = self._smite_damage_dice(
                                    {"base_dice": smite_start_turn_rider_cfg.get("dice"), "base_slot": smite_cfg.get("base_slot"), "upcast_die": smite_cfg.get("upcast_die")},
                                    (pending_smite or {}).get("slot_level"),
                                )
                                group = f"smite_{str((smite_result or {}).get('slug') or '')}_{int(cid)}"
                                riders = list(getattr(target, "start_turn_damage_riders", []) or [])
                                riders.append(
                                    {
                                        "dice": rider_dice or str(smite_start_turn_rider_cfg.get("dice") or "1d6"),
                                        "type": str(smite_start_turn_rider_cfg.get("type") or "damage"),
                                        "source": str((smite_result or {}).get("name") or "Smite"),
                                        "save_ability": str(smite_start_turn_rider_cfg.get("save_ability") or "").strip().lower(),
                                        "save_dc": int(smite_save_dc),
                                        "clear_group": group,
                                    }
                                )
                                setattr(target, "start_turn_damage_riders", riders)
                if hit and isinstance(smite_start_turn_rider_cfg, dict) and not smite_save_ability:
                    rider_dc = int((pending_smite or {}).get("save_dc") or 0)
                    if rider_dc <= 0:
                        aura_bonus = int((self._lan_aura_effects_for_target(c) or {}).get("save_bonus") or 0)
                        rider_dc = int(8 + max(2, int((pending_smite or {}).get("proficiency_bonus") or 2)) + max(0, aura_bonus))
                    rider_dice = self._smite_damage_dice(
                        {
                            "base_dice": smite_start_turn_rider_cfg.get("dice"),
                            "base_slot": (smite_cfg or {}).get("base_slot"),
                            "upcast_die": (smite_cfg or {}).get("upcast_die"),
                        },
                        (pending_smite or {}).get("slot_level"),
                    )
                    riders = list(getattr(target, "start_turn_damage_riders", []) or [])
                    riders.append(
                        {
                            "dice": rider_dice or str(smite_start_turn_rider_cfg.get("dice") or "1d6"),
                            "type": str(smite_start_turn_rider_cfg.get("type") or "damage"),
                            "source": str((smite_result or {}).get("name") or "Smite"),
                            "save_ability": str(smite_start_turn_rider_cfg.get("save_ability") or "").strip().lower(),
                            "save_dc": int(rider_dc),
                            "clear_group": f"smite_{str((smite_result or {}).get('slug') or '')}_{int(cid)}",
                        }
                    )
                    setattr(target, "start_turn_damage_riders", riders)
                effect_text = str(effect_block.get("on_hit") or "")
                if "hellfire stack" in effect_text.lower():
                    marker = (int(getattr(self, "round_num", 0) or 0), int(getattr(self, "turn_num", 0) or 0))
                    stack_map = getattr(target, "_hellfire_last_applied_by_attacker", None)
                    if not isinstance(stack_map, dict):
                        stack_map = {}
                    attacker_key = str(int(cid))
                    if tuple(stack_map.get(attacker_key) or ()) != marker:
                        stack_map[attacker_key] = marker
                        setattr(target, "_hellfire_last_applied_by_attacker", stack_map)
                        riders = list(getattr(target, "end_turn_damage_riders", []) or [])
                        riders.append(
                            {
                                "dice": "1d6",
                                "type": "hellfire",
                                "remaining_turns": 1,
                                "source": f"{result_payload['weapon_name']} ({c.name})",
                            }
                        )
                        setattr(target, "end_turn_damage_riders", riders)
                        self._log(
                            f"{c.name} applies Hellfire to {result_payload['target_name']} "
                            f"(1d6 at end of target turn).",
                            cid=int(target_cid),
                        )
                weapon_id_key = str(selected_weapon.get("id") or "").strip().lower()
                weapon_name_key = str(selected_weapon.get("name") or "").strip().lower()
                if (
                    weapon_id_key == "sword_of_wounding"
                    or weapon_name_key == "sword of wounding"
                    or "start of each of the wounded creature's turns" in effect_text.lower()
                ):
                    marker = (int(getattr(self, "round_num", 0) or 0), int(getattr(self, "turn_num", 0) or 0))
                    stack_map = getattr(target, "_wounding_last_applied_by_attacker", None)
                    if not isinstance(stack_map, dict):
                        stack_map = {}
                    attacker_key = str(int(cid))
                    if tuple(stack_map.get(attacker_key) or ()) != marker:
                        stack_map[attacker_key] = marker
                        setattr(target, "_wounding_last_applied_by_attacker", stack_map)
                        riders = list(getattr(target, "start_turn_damage_riders", []) or [])
                        riders.append(
                            {
                                "dice": "1d4",
                                "type": "necrotic",
                                "source": f"{result_payload['weapon_name']} ({c.name})",
                                "save_ability": "con",
                                "save_dc": 15,
                                "clear_group": "sword_of_wounding",
                            }
                        )
                        setattr(target, "start_turn_damage_riders", riders)
                        self._log(
                            f"{c.name} wounds {result_payload['target_name']} "
                            f"(1d4 necrotic at start of target turn; CON save DC 15 ends wounds).",
                            cid=int(target_cid),
                        )
                try:
                    self._rebuild_table(scroll_to_current=True)
                except Exception:
                    pass
            msg["_attack_result"] = dict(result_payload)
            loop = getattr(self._lan, "_loop", None)
            if ws_id is not None and loop:
                try:
                    asyncio.run_coroutine_threadsafe(self._lan._send_async(ws_id, result_payload), loop)
                except Exception:
                    pass
            self._lan.toast(ws_id, "Attack hits." if hit else "Attack misses.")
        elif typ == "wild_shape_apply":
            beast_id = str(msg.get("beast_id") or "").strip()
            if not beast_id:
                self._lan.toast(ws_id, "Pick a beast form first, matey.")
                return
            c = self.combatants.get(cid)
            if not c:
                return
            require_bonus_action = bool(getattr(self, "in_combat", False))
            if require_bonus_action and int(getattr(c, "bonus_action_remaining", 0)) <= 0:
                self._lan.toast(ws_id, "No bonus actions left, matey.")
                return
            ok, err = self._apply_wild_shape(int(cid), beast_id)
            if not ok:
                self._lan.toast(ws_id, err or "Could not Wild Shape, matey.")
                return
            if require_bonus_action and not self._use_bonus_action(c):
                self._lan.toast(ws_id, "Could not spend bonus action for Wild Shape, matey.")
                return
            if require_bonus_action:
                setattr(c, "bonus_action_remaining", 0)
            self._lan.toast(ws_id, "Wild Shape activated.")
            self._rebuild_table(scroll_to_current=True)
        elif typ == "wild_shape_pool_set_current":
            player_name = self._pc_name_for(int(cid))
            try:
                desired_current = int(msg.get("current"))
            except Exception:
                self._lan.toast(ws_id, "Pick a valid Wild Shape uses value, matey.")
                return
            ok_pool, pool_err, new_cur = self._set_wild_shape_pool_current(player_name, desired_current)
            if not ok_pool:
                self._lan.toast(ws_id, pool_err or "Could not update Wild Shape uses, matey.")
                return
            c = self.combatants.get(cid)
            if c:
                setattr(c, "wild_shape_pool_current", int(new_cur if new_cur is not None else 0))
            self._lan.toast(ws_id, "Wild Shape uses updated.")
            self._rebuild_table(scroll_to_current=True)
        elif typ == "wild_shape_revert":
            c = self.combatants.get(cid)
            if not c:
                return
            require_bonus_action = bool(getattr(self, "in_combat", False))
            if require_bonus_action and int(getattr(c, "bonus_action_remaining", 0)) <= 0:
                self._lan.toast(ws_id, "No bonus actions left, matey.")
                return
            ok, err = self._revert_wild_shape(int(cid))
            if not ok:
                self._lan.toast(ws_id, err or "Could not revert Wild Shape, matey.")
                return
            setattr(c, "temp_hp", 0)
            if require_bonus_action:
                setattr(c, "bonus_action_remaining", max(0, int(getattr(c, "bonus_action_remaining", 0)) - 1))
                self._log(f"{getattr(c, 'name', 'Player')} used a bonus action to revert Wild Shape.", cid=cid)
            self._lan.toast(ws_id, "Reverted Wild Shape.")
            self._rebuild_table(scroll_to_current=True)
        elif typ == "wild_shape_regain_use":
            c = self.combatants.get(cid)
            if not c:
                return
            if bool(getattr(c, "wild_resurgence_turn_used", False)):
                self._lan.toast(ws_id, "Wild Resurgence already used this turn, matey.")
                return
            player_name = self._pc_name_for(int(cid))
            ok_slot, err_slot, spent_level = self._consume_spell_slot_for_wild_shape_regain(player_name)
            if not ok_slot:
                self._lan.toast(ws_id, err_slot)
                return
            profile = self._profile_for_player_name(player_name)
            pools = self._normalize_player_resource_pools(profile if isinstance(profile, dict) else {})
            wild = next((p for p in pools if str(p.get("id") or "").lower() == "wild_shape"), None)
            if not isinstance(wild, dict):
                self._lan.toast(ws_id, "No Wild Shape pool found, matey.")
                return
            ok_pool, pool_err, _ = self._set_wild_shape_pool_current(player_name, int(wild.get("current", 0) or 0) + 1)
            if not ok_pool:
                self._lan.toast(ws_id, pool_err)
                return
            setattr(c, "wild_resurgence_turn_used", True)
            self._log(f"{getattr(c, 'name', 'Player')} recovered one Wild Shape use via Wild Resurgence.", cid=cid)
            self._lan.toast(ws_id, f"Recovered one Wild Shape use (spent level {int(spent_level or 1)} slot).")
            self._rebuild_table(scroll_to_current=True)
        elif typ == "wild_shape_regain_spell":
            c = self.combatants.get(cid)
            if not c:
                return
            if bool(getattr(c, "wild_resurgence_slot_used", False)):
                self._lan.toast(ws_id, "Wild Shape spell-slot exchange already used this long rest, matey.")
                return
            player_name = self._pc_name_for(int(cid))
            profile = self._profile_for_player_name(player_name)
            pools = self._normalize_player_resource_pools(profile if isinstance(profile, dict) else {})
            wild = next((p for p in pools if str(p.get("id") or "").lower() == "wild_shape"), None)
            if not isinstance(wild, dict) or int(wild.get("current", 0) or 0) <= 0:
                self._lan.toast(ws_id, "No Wild Shape uses to spend, matey.")
                return
            ok_spell, err_spell = self._regain_first_level_spell_slot(player_name)
            if not ok_spell:
                self._lan.toast(ws_id, err_spell)
                return
            ok_pool, pool_err, _ = self._set_wild_shape_pool_current(player_name, int(wild.get("current", 0) or 0) - 1)
            if not ok_pool:
                self._lan.toast(ws_id, pool_err)
                return
            setattr(c, "wild_resurgence_slot_used", True)
            self._log(f"{getattr(c, 'name', 'Player')} recovered one level 1 spell slot via Wild Resurgence.", cid=cid)
            self._lan.toast(ws_id, "Recovered one level 1 spell slot.")
            self._rebuild_table(scroll_to_current=True)
        elif typ == "wild_shape_set_known":
            player_name = self._pc_name_for(int(cid))
            profile = self._profile_for_player_name(player_name)
            if not isinstance(profile, dict):
                self._lan.toast(ws_id, "No player profile found, matey.")
                return
            druid_level = self._druid_level_from_profile(profile)
            if druid_level < 2:
                self._lan.toast(ws_id, "Only druids can manage Wild Shapes, matey.")
                return
            known_limit = self._wild_shape_known_limit(druid_level)
            requested = msg.get("known")
            if not isinstance(requested, list):
                requested = []
            available_forms = [
                entry
                for entry in self._wild_shape_available_forms(profile, known_only=False, include_locked=True)
                if isinstance(entry, dict)
            ]
            allowed_ids = {
                self._wild_shape_identifier_key(entry.get("id"))
                for entry in available_forms
            }
            allowed_ids.discard("")
            alias_map = self._wild_shape_alias_lookup(available_forms)
            deduped: List[str] = []
            for raw in requested:
                beast_id = alias_map.get(self._wild_shape_identifier_key(raw))
                if not beast_id or beast_id in deduped:
                    continue
                if beast_id not in allowed_ids:
                    continue
                deduped.append(beast_id)
                if len(deduped) >= known_limit:
                    break
            known_map = self.__dict__.get("_wild_shape_known_by_player")
            if not isinstance(known_map, dict):
                known_map = {}
                self._wild_shape_known_by_player = known_map
            known_map[player_name.strip().lower()] = deduped

            player_path = self._find_player_profile_path(player_name)
            if not isinstance(player_path, Path):
                c = self.combatants.get(cid)
                if c is not None:
                    player_path = self._find_player_profile_path(getattr(c, "name", ""))
            if not isinstance(player_path, Path):
                self._load_player_yaml_cache(force_refresh=True)
                player_path = self._find_player_profile_path(player_name)
            raw_payload = self._player_yaml_cache_by_path.get(player_path) if isinstance(player_path, Path) else None
            if not (isinstance(player_path, Path) and isinstance(raw_payload, dict)):
                self._lan.toast(ws_id, "Could not locate yer player file for Wild Shape save, matey.")
                return
            updated_payload = dict(raw_payload)
            updated_payload["learned_wild_shapes"] = list(deduped)
            updated_payload["prepared_wild_shapes"] = list(deduped)
            self._store_character_yaml(player_path, updated_payload)
            self._load_player_yaml_cache(force_refresh=True)

            self._lan.toast(ws_id, "Wild Shape forms updated.")
            self._rebuild_table(scroll_to_current=True)
        elif typ == "second_wind_use":
            c = self.combatants.get(cid)
            if not c:
                return
            player_name = self._pc_name_for(int(cid))
            profile = self._profile_for_player_name(player_name)
            if not isinstance(profile, dict):
                self._lan.toast(ws_id, "No player profile found, matey.")
                return
            fighter_level = self._fighter_level_from_profile(profile)
            if fighter_level < 1:
                self._lan.toast(ws_id, "Only fighters can use Second Wind, matey.")
                return
            ok_pool, pool_err = self._consume_resource_pool_for_cast(player_name, "second_wind", 1)
            if not ok_pool:
                self._lan.toast(ws_id, pool_err or "No Second Wind uses remain, matey.")
                return
            healing_roll = None
            for key in ("healing_roll", "roll", "rolled"):
                value = msg.get(key)
                if value in (None, ""):
                    continue
                try:
                    healing_roll = int(value)
                except Exception:
                    healing_roll = None
                break
            if healing_roll is None:
                hp_gain = int(sum(random.randint(1, 10) for _ in range(1)) + fighter_level)
            else:
                hp_gain = int(max(1, healing_roll) + fighter_level)
            cur_hp = int(getattr(c, "hp", 0) or 0)
            max_hp = int(getattr(c, "max_hp", cur_hp) or cur_hp)
            setattr(c, "hp", max(0, min(max_hp, cur_hp + hp_gain)))
            if bool(getattr(self, "in_combat", False)) and int(getattr(c, "bonus_action_remaining", 0)) > 0:
                self._use_bonus_action(c)
            self._log(f"{getattr(c, 'name', 'Player')} uses Second Wind and regains {hp_gain} HP.", cid=cid)
            self._lan.toast(ws_id, f"Second Wind: regained {hp_gain} HP.")
            self._rebuild_table(scroll_to_current=True)
        elif typ == "action_surge_use":
            c = self.combatants.get(cid)
            if not c:
                return
            player_name = self._pc_name_for(int(cid))
            profile = self._profile_for_player_name(player_name)
            if not isinstance(profile, dict):
                self._lan.toast(ws_id, "No player profile found, matey.")
                return
            fighter_level = self._fighter_level_from_profile(profile)
            if fighter_level < 2:
                self._lan.toast(ws_id, "Only fighters level 2+ can use Action Surge, matey.")
                return
            ok_pool, pool_err = self._consume_resource_pool_for_cast(player_name, "action_surge", 1)
            if not ok_pool:
                self._lan.toast(ws_id, pool_err or "No Action Surge uses remain, matey.")
                return
            c.action_remaining = int(getattr(c, "action_remaining", 0) or 0) + 1
            c.action_total = int(getattr(c, "action_total", 1) or 1) + 1
            self._log(f"{getattr(c, 'name', 'Player')} uses Action Surge and gains 1 action.", cid=cid)
            self._lan.toast(ws_id, "Action Surge used: +1 action.")
            self._rebuild_table(scroll_to_current=True)
        elif typ == "lay_on_hands_use":
            c = self.combatants.get(cid)
            if not c:
                return
            player_name = self._pc_name_for(int(cid))
            profile = self._profile_for_player_name(player_name)
            if not isinstance(profile, dict):
                self._lan.toast(ws_id, "No player profile found, matey.")
                return
            paladin_level = self._class_level_from_profile(profile, "paladin")
            if paladin_level < 1:
                self._lan.toast(ws_id, "Only paladins can use Lay on Hands, matey.")
                return
            target_cid = _normalize_cid_value(msg.get("target_cid"), "lay_on_hands_use.target_cid", log_fn=log_warning)
            target = self.combatants.get(int(target_cid)) if target_cid is not None else None
            if target is None:
                self._lan.toast(ws_id, "Pick a valid target, matey.")
                return
            try:
                heal_amount = int(msg.get("amount", 0))
            except Exception:
                heal_amount = 0
            if heal_amount <= 0:
                self._lan.toast(ws_id, "Healing amount must be at least 1, matey.")
                return
            ok_pool, pool_err = self._consume_resource_pool_for_cast(player_name, "lay_on_hands", heal_amount)
            if not ok_pool:
                self._lan.toast(ws_id, pool_err or "No Lay on Hands points remain, matey.")
                return
            cur_hp = int(getattr(target, "hp", 0) or 0)
            max_hp = int(getattr(target, "max_hp", cur_hp) or cur_hp)
            actual_heal = max(0, min(heal_amount, max_hp - cur_hp))
            setattr(target, "hp", max(0, min(max_hp, cur_hp + heal_amount)))
            if bool(getattr(self, "in_combat", False)) and int(getattr(c, "action_remaining", 0) or 0) > 0:
                self._use_action(c)
            self._log(
                f"{getattr(c, 'name', 'Player')} uses Lay on Hands on {getattr(target, 'name', 'Target')} "
                f"for {actual_heal} HP ({heal_amount} points spent).",
                cid=int(target.cid),
            )
            self._lan.toast(ws_id, f"Lay on Hands: healed {actual_heal} HP.")
            self._rebuild_table(scroll_to_current=True)
        elif typ == "monk_patient_defense":
            c = self.combatants.get(cid)
            if not c:
                return
            if not bool(getattr(c, "is_pc", False)):
                self._lan.toast(ws_id, "Only player characters can use Monk Focus actions, matey.")
                return
            player_name = _resolve_pc_name(cid)
            profile = self._profile_for_player_name(player_name)
            if not isinstance(profile, dict):
                self._lan.toast(ws_id, "No player profile found, matey.")
                return
            monk_level = self._class_level_from_profile(profile, "monk")
            if monk_level < 2:
                self._lan.toast(ws_id, "Only monks level 2+ can use Patient Defense, matey.")
                return
            mode = str(msg.get("mode") or "free").strip().lower()
            if mode not in ("free", "focus"):
                mode = "free"
            if not self._use_bonus_action(c):
                self._lan.toast(ws_id, "No bonus actions left, matey.")
                return
            if mode == "focus":
                ok_pool, pool_err = self._consume_resource_pool_for_cast(player_name, "focus_points", 1)
                if not ok_pool:
                    self._lan.toast(ws_id, pool_err or "No Focus Points remain, matey.")
                    return
                self._log(
                    f"{c.name} used Patient Defense (Disengage + Dodge) (bonus action, 1 Focus)",
                    cid=cid,
                )
                if monk_level >= 10:
                    ma_die = 8 if monk_level >= 5 else 6
                    temp_roll = random.randint(1, ma_die) + random.randint(1, ma_die)
                    current_temp_hp = int(getattr(c, "temp_hp", 0) or 0)
                    setattr(c, "temp_hp", max(current_temp_hp, temp_roll))
                    self._log(
                        f"{c.name} gained Monk Focus temp HP: {temp_roll} (2d{ma_die}; current temp HP {getattr(c, 'temp_hp', 0)}).",
                        cid=cid,
                    )
                self._lan.toast(ws_id, "Patient Defense used (1 Focus).")
            else:
                self._log(f"{c.name} used Patient Defense (Disengage) (bonus action)", cid=cid)
                self._lan.toast(ws_id, "Patient Defense used.")
            self._rebuild_table(scroll_to_current=True)
        elif typ == "monk_step_of_wind":
            c = self.combatants.get(cid)
            if not c:
                return
            if not bool(getattr(c, "is_pc", False)):
                self._lan.toast(ws_id, "Only player characters can use Monk Focus actions, matey.")
                return
            player_name = _resolve_pc_name(cid)
            profile = self._profile_for_player_name(player_name)
            if not isinstance(profile, dict):
                self._lan.toast(ws_id, "No player profile found, matey.")
                return
            monk_level = self._class_level_from_profile(profile, "monk")
            if monk_level < 2:
                self._lan.toast(ws_id, "Only monks level 2+ can use Step of the Wind, matey.")
                return
            mode = str(msg.get("mode") or "free").strip().lower()
            if mode not in ("free", "focus"):
                mode = "free"
            if not self._use_bonus_action(c):
                self._lan.toast(ws_id, "No bonus actions left, matey.")
                return
            if mode == "focus":
                ok_pool, pool_err = self._consume_resource_pool_for_cast(player_name, "focus_points", 1)
                if not ok_pool:
                    self._lan.toast(ws_id, pool_err or "No Focus Points remain, matey.")
                    return
            try:
                base_speed = int(self._mode_speed(c))
            except Exception:
                base_speed = int(getattr(c, "speed", 30) or 30)
            total = int(getattr(c, "move_total", 0) or 0)
            rem = int(getattr(c, "move_remaining", 0) or 0)
            setattr(c, "move_total", total + base_speed)
            setattr(c, "move_remaining", rem + base_speed)
            if mode == "focus":
                self._log(
                    f"{c.name} used Step of the Wind (Dash + Disengage) (bonus action, 1 Focus)",
                    cid=cid,
                )
            else:
                self._log(f"{c.name} used Step of the Wind (Dash) (bonus action)", cid=cid)
            self._log(f"{c.name} jump distance doubled (not automated).", cid=cid)
            self._lan.toast(ws_id, "Step of the Wind used.")
            self._rebuild_table(scroll_to_current=True)
        elif typ == "monk_elemental_attunement":
            c = self.combatants.get(cid)
            if not c:
                return
            if not bool(getattr(c, "is_pc", False)):
                self._lan.toast(ws_id, "Only player characters can use Monk Focus actions, matey.")
                return
            player_name = _resolve_pc_name(cid)
            profile = self._profile_for_player_name(player_name)
            if not isinstance(profile, dict):
                self._lan.toast(ws_id, "No player profile found, matey.")
                return
            monk_level = self._class_level_from_profile(profile, "monk")
            if monk_level < 3:
                self._lan.toast(ws_id, "Only monks with Warrior of the Elements can use Elemental Attunement, matey.")
                return
            mode = str(msg.get("mode") or "activate").strip().lower()
            currently_active = self._elemental_attunement_active(c)
            if mode == "deactivate":
                if currently_active:
                    setattr(c, "elemental_attunement_active", False)
                    self._log(f"{c.name} ended Elemental Attunement.", cid=cid)
                    self._lan.toast(ws_id, "Elemental Attunement ended.")
                    self._rebuild_table(scroll_to_current=True)
                else:
                    self._lan.toast(ws_id, "Elemental Attunement is not active.")
                return
            if currently_active:
                self._lan.toast(ws_id, "Elemental Attunement is already active.")
                return
            ok_pool, pool_err = self._consume_resource_pool_for_cast(player_name, "focus_points", 1)
            if not ok_pool:
                self._lan.toast(ws_id, pool_err or "No Focus Points remain, matey.")
                return
            setattr(c, "elemental_attunement_active", True)
            self._log(f"{c.name} activated Elemental Attunement (1 Focus).", cid=cid)
            self._lan.toast(ws_id, "Elemental Attunement activated.")
            self._rebuild_table(scroll_to_current=True)
        elif typ == "monk_elemental_burst":
            c = self.combatants.get(cid)
            if not c:
                return
            if not bool(getattr(c, "is_pc", False)):
                self._lan.toast(ws_id, "Only player characters can use Monk Focus actions, matey.")
                return
            player_name = _resolve_pc_name(cid)
            profile = self._profile_for_player_name(player_name)
            if not isinstance(profile, dict):
                self._lan.toast(ws_id, "No player profile found, matey.")
                return
            monk_level = self._class_level_from_profile(profile, "monk")
            if monk_level < 3:
                self._lan.toast(ws_id, "Only monks with Warrior of the Elements can use Elemental Burst, matey.")
                return
            payload = msg.get("payload") if isinstance(msg.get("payload"), dict) else {}
            damage_type = str(msg.get("damage_type") or payload.get("damage_type") or "").strip().lower()
            if damage_type not in {"acid", "cold", "fire", "lightning", "thunder"}:
                self._lan.toast(ws_id, "Pick a valid Elemental Burst damage type, matey.")
                return
            if int(getattr(c, "action_remaining", 0) or 0) <= 0:
                self._lan.toast(ws_id, "No actions left, matey.")
                return
            ok_pool, pool_err = self._consume_resource_pool_for_cast(player_name, "focus_points", 2)
            if not ok_pool:
                self._lan.toast(ws_id, pool_err or "Need 2 Focus Points for Elemental Burst, matey.")
                return
            if not self._use_action(c):
                self._lan.toast(ws_id, "No actions left, matey.")
                return
            movement_mode = str(msg.get("movement_mode") or payload.get("movement_mode") or "").strip().lower()
            if movement_mode not in ("push", "pull"):
                movement_mode = ""
            martial_die = self._monk_martial_arts_die(monk_level)
            save_dc = self._monk_save_dc_for_profile(profile)
            cols, rows, _obstacles, _rough, positions = self._lan_live_map_data()
            try:
                cx = float(payload.get("cx"))
                cy = float(payload.get("cy"))
            except Exception:
                origin = positions.get(int(cid))
                if isinstance(origin, tuple) and len(origin) == 2:
                    cx, cy = float(origin[0]), float(origin[1])
                else:
                    cx = max(0.0, (int(cols) - 1) / 2.0) if int(cols) > 0 else 0.0
                    cy = max(0.0, (int(rows) - 1) / 2.0) if int(rows) > 0 else 0.0
            try:
                feet_per_square = 5.0
                mw = getattr(self, "_map_window", None)
                if mw is not None and hasattr(mw, "winfo_exists") and mw.winfo_exists():
                    feet_per_square = float(getattr(mw, "feet_per_square", feet_per_square) or feet_per_square)
            except Exception:
                feet_per_square = 5.0
            feet_per_square = max(1.0, float(feet_per_square))
            aoe = {
                "kind": "sphere",
                "name": "Elemental Burst",
                "cx": float(cx),
                "cy": float(cy),
                "radius_ft": 20.0,
                "radius_sq": max(0.5, float(20.0 / feet_per_square)),
                "dc": int(save_dc),
                "save_type": "dex",
                "damage_type": str(damage_type),
                "half_on_pass": True,
            }
            fail_effects: List[Dict[str, Any]] = [{"effect": "damage", "damage_type": str(damage_type), "dice": f"3d{int(martial_die)}"}]
            if movement_mode:
                fail_effects.append({"effect": "forced_movement", "mode": str(movement_mode), "distance_ft": 10, "origin": "aoe_center"})
            preset = {
                "name": "Elemental Burst",
                "automation": "full",
                "tags": ["aoe", "automation_full"],
                "mechanics": {
                    "automation": "full",
                    "sequence": [
                        {
                            "check": {"kind": "saving_throw", "ability": "dex", "dc": int(save_dc)},
                            "outcomes": {
                                "fail": fail_effects,
                                "success": [{"effect": "damage", "damage_type": str(damage_type), "dice": f"3d{int(martial_die)}", "multiplier": 0.5}],
                            },
                        }
                    ],
                },
            }
            resolved = self._lan_auto_resolve_cast_aoe(
                0,
                aoe,
                caster=c,
                spell_slug="monk-elemental-burst",
                spell_id="monk-elemental-burst",
                slot_level=None,
                preset=preset,
            )
            if resolved:
                rider_text = f", {movement_mode} 10 ft on failed save" if movement_mode else ""
                self._log(
                    f"{c.name} used Elemental Burst ({damage_type.title()}, 3d{int(martial_die)}, DC {int(save_dc)}{rider_text}) "
                    f"(Magic Action, 2 Focus).",
                    cid=cid,
                )
                self._lan.toast(ws_id, "Elemental Burst cast.")
            else:
                self._lan.toast(ws_id, "Elemental Burst failed to resolve, matey.")
            self._rebuild_table(scroll_to_current=True)
        elif typ == "monk_uncanny_metabolism":
            c = self.combatants.get(cid)
            if not c:
                return
            if not bool(getattr(c, "is_pc", False)):
                self._lan.toast(ws_id, "Only player characters can use Monk Focus actions, matey.")
                return
            player_name = _resolve_pc_name(cid)
            profile = self._profile_for_player_name(player_name)
            if not isinstance(profile, dict):
                self._lan.toast(ws_id, "No player profile found, matey.")
                return
            monk_level = self._class_level_from_profile(profile, "monk")
            if monk_level < 2:
                self._lan.toast(ws_id, "Only monks can use Uncanny Metabolism, matey.")
                return
            if not self._use_bonus_action(c):
                self._lan.toast(ws_id, "No bonus actions left, matey.")
                return
            ok_pool, pool_err = self._consume_resource_pool_for_cast(player_name, "uncanny_metabolism", 1)
            if not ok_pool:
                self._lan.toast(ws_id, pool_err or "Uncanny Metabolism is spent, matey.")
                return
            pools = self._normalize_player_resource_pools(profile)
            focus_pool = next((entry for entry in pools if str(entry.get("id") or "").strip().lower() == "focus_points"), None)
            focus_max = 0
            try:
                focus_max = max(0, int((focus_pool or {}).get("max", 0) or 0))
            except Exception:
                focus_max = 0
            if focus_max > 0:
                self._set_player_resource_pool_current(player_name, "focus_points", focus_max)
            martial_die = self._monk_martial_arts_die(monk_level)
            heal_amount = int(random.randint(1, int(martial_die)))
            hp_now = int(getattr(c, "hp", 0) or 0)
            hp_max = int(getattr(c, "max_hp", hp_now) or hp_now)
            setattr(c, "hp", max(0, min(hp_max, hp_now + int(heal_amount))))
            self._log(
                f"{c.name} used Uncanny Metabolism: restored Focus and healed {int(heal_amount)} HP.",
                cid=cid,
            )
            self._lan.toast(ws_id, "Uncanny Metabolism used.")
            self._rebuild_table(scroll_to_current=True)
        elif typ == "use_action":
            c = self.combatants.get(cid)
            if not c:
                return
            if not self._use_action(c):
                self._lan.toast(ws_id, "No actions left, matey.")
                return
            self._lan.toast(ws_id, "Action used.")
            self._rebuild_table(scroll_to_current=True)
        elif typ == "use_bonus_action":
            c = self.combatants.get(cid)
            if not c:
                return
            if not self._use_bonus_action(c):
                self._lan.toast(ws_id, "No bonus actions left, matey.")
                return
            self._lan.toast(ws_id, "Bonus action used.")
            self._rebuild_table(scroll_to_current=True)
        elif typ == "stand_up":
            c = self.combatants.get(cid)
            if not c:
                return
            if not self._has_condition(c, "prone"):
                return
            eff = self._effective_speed(c)
            if eff <= 0:
                self._lan.toast(ws_id, "Can't stand up right now (speed is 0).")
                return
            cost = max(0, eff // 2)
            if c.move_remaining < cost:
                self._lan.toast(ws_id, f"Not enough movement to stand (need {cost} ft).")
                return
            c.move_remaining -= cost
            self._remove_condition_type(c, "prone")
            self._log(f"stood up (spent {cost} ft, prone removed)", cid=c.cid)
            self._lan.toast(ws_id, "Stood up.")
            self._rebuild_table(scroll_to_current=True)
        elif typ == "reset_turn":
            if self._lan_restore_turn_snapshot(cid):
                c = self.combatants.get(cid)
                if c:
                    self._log(f"{c.name} reset their turn snapshot.", cid=cid)
                self._lan.toast(ws_id, "Turn reset.")
                self._rebuild_table(scroll_to_current=True)
            else:
                self._lan.toast(ws_id, "No turn snapshot yet, matey.")
        elif typ == "end_turn":
            # Let player end their own turn.
            active_cid = _normalize_cid_value(
                getattr(self, "current_cid", None), "lan_action.end_turn.current_cid", log_fn=log_warning
            )
            can_end_shared_summon_turn = self._is_valid_summon_turn_for_controller(claimed, cid, active_cid)
            if in_combat and (cid is None or (active_cid != int(cid) and not can_end_shared_summon_turn)):
                self._lan.toast(ws_id, "Not yer turn yet, matey.")
                return
            try:
                for combatant in self.combatants.values():
                    setattr(combatant, "wild_resurgence_turn_used", False)
                self._next_turn()
                self._lan.toast(ws_id, "Turn ended.")
            except Exception as exc:
                self._oplog(f"LAN end turn failed: {exc}", level="warning")

    def _lan_try_move(self, cid: int, col: int, row: int) -> Tuple[bool, str, int]:
        # Boundaries
        cols, rows, obstacles, rough_terrain, positions = self._lan_live_map_data()
        if not (0 <= col < cols and 0 <= row < rows):
            return (False, "Off the map, matey.", 0)
        if (col, row) in obstacles:
            return (False, "That square be blocked.", 0)

        c = self.combatants.get(cid)
        if not c:
            return (False, "No such unit.", 0)
        if _normalize_cid_value(getattr(c, "rider_cid", None), "move.rider_cid") is not None:
            return (False, "Rider movement uses the mount, matey.", 0)

        origin = positions.get(cid)
        if origin is None:
            # seed at center
            origin = (max(0, cols // 2), max(0, rows // 2))
            self._lan_positions[cid] = origin

        rider_cid = _normalize_cid_value(getattr(c, "mounted_by_cid", None), "move.mount.rider")
        movement_owner = c
        if rider_cid is not None and rider_cid in self.combatants and self._mount_uses_rider_movement(c):
            movement_owner = self.combatants[int(rider_cid)]
        max_ft = int(getattr(movement_owner, "move_remaining", 0) or 0)
        if max_ft <= 0:
            return (False, "No movement left, matey.", 0)

        cost = self._lan_shortest_cost(
            origin,
            (col, row),
            obstacles,
            rough_terrain,
            cols,
            rows,
            max_ft,
            c,
        )
        if cost is None:
            return (False, "Can’t reach that square (blocked).", 0)
        if cost > max_ft:
            return (False, f"Ye need {cost} ft but only {max_ft} ft be left.", 0)

        # Apply
        try:
            setattr(movement_owner, "move_remaining", max(0, max_ft - cost))
        except Exception:
            pass
        origin_cell = tuple(origin)
        self._lan_positions[cid] = (col, row)
        if rider_cid is not None:
            self._lan_positions[int(rider_cid)] = (col, row)
        self._lan_sync_fixed_to_caster_aoes(int(cid))
        self._lan_handle_aoe_enter_triggers_for_moved_unit(int(cid), origin_cell, (int(col), int(row)))

        # Update live map window token if open
        mw = getattr(self, "_map_window", None)
        try:
            if mw is not None and mw.winfo_exists():
                # place by cell -> pixel
                x, y = mw._grid_to_pixel(col, row)
                mw._place_unit_at_pixel(cid, x, y)
                if rider_cid is not None:
                    mw._place_unit_at_pixel(int(rider_cid), x, y)
        except Exception:
            pass

        try:
            self._sneak_handle_hidden_movement(int(cid), origin_cell, (int(col), int(row)))
        except Exception:
            pass

        self._log(f"moved to ({col},{row}) (spent {cost} ft; {movement_owner.move_remaining}/{movement_owner.move_total} left)", cid=cid)
        self._rebuild_table(scroll_to_current=True)
        return (True, "", int(cost))

    def _lan_live_map_data(
        self,
    ) -> Tuple[int, int, set[Tuple[int, int]], Dict[Tuple[int, int], Dict[str, object]], Dict[int, Tuple[int, int]]]:
        cols = int(self._lan_grid_cols)
        rows = int(self._lan_grid_rows)
        obstacles = set(self._lan_obstacles)
        rough_terrain: Dict[Tuple[int, int], Dict[str, object]] = dict(getattr(self, "_lan_rough_terrain", {}) or {})
        positions = dict(self._lan_positions)

        mw = getattr(self, "_map_window", None)
        try:
            if mw is not None and mw.winfo_exists():
                cols = int(getattr(mw, "cols", cols))
                rows = int(getattr(mw, "rows", rows))
                obstacles = set(getattr(mw, "obstacles", obstacles) or set())
                rough_terrain = dict(getattr(mw, "rough_terrain", rough_terrain) or {})
                for cid, tok in (getattr(mw, "unit_tokens", {}) or {}).items():
                    try:
                        positions[int(cid)] = (int(tok.get("col")), int(tok.get("row")))
                    except Exception:
                        pass
        except Exception:
            pass
        return cols, rows, obstacles, rough_terrain, positions

    def _water_movement_multiplier(self, c: Optional[base.Combatant], mode: str) -> float:
        if c is None:
            return 1.0
        if self._normalize_movement_mode(mode) != "normal":
            return 1.0
        land_speed = max(0, int(getattr(c, "speed", 0) or 0))
        if land_speed <= 0:
            return 1.0
        swim_speed = max(0, int(getattr(c, "swim_speed", 0) or 0))
        if swim_speed <= 0:
            swim_speed = max(1, int(land_speed / 2))
        if swim_speed <= 0:
            return 1.0
        return float(land_speed) / float(swim_speed)

    def _lan_shortest_cost(
        self,
        origin: Tuple[int, int],
        dest: Tuple[int, int],
        obstacles: set[Tuple[int, int]],
        rough_terrain: Dict[Tuple[int, int], Dict[str, object]],
        cols: int,
        rows: int,
        max_ft: int,
        creature: Optional[base.Combatant] = None,
    ) -> Optional[int]:
        """Dijkstra over (col,row,diagParity) to match 5/10 diagonal rule.

        diagParity toggles when you take a diagonal step; first diagonal costs 5, second costs 10, then 5, etc.
        Orthogonal steps always cost 5 and do not change parity.
        """
        if origin == dest:
            return 0

        import heapq

        mode = self._normalize_movement_mode(getattr(creature, "movement_mode", "normal"))
        water_multiplier = self._water_movement_multiplier(creature, mode)

        def in_bounds(c: int, r: int) -> bool:
            return 0 <= c < cols and 0 <= r < rows

        # (cost, col, row, parity)
        pq: List[Tuple[int, int, int, int]] = [(0, origin[0], origin[1], 0)]
        best: Dict[Tuple[int, int, int], int] = {(origin[0], origin[1], 0): 0}

        while pq:
            cost, c, r, parity = heapq.heappop(pq)
            if cost != best.get((c, r, parity), 10**9):
                continue
            if cost > max_ft:
                continue
            if (c, r) == dest:
                return cost

            # neighbors 8-dir
            for dc in (-1, 0, 1):
                for dr in (-1, 0, 1):
                    if dc == 0 and dr == 0:
                        continue
                    nc, nr = c + dc, r + dr
                    if not in_bounds(nc, nr):
                        continue
                    if (nc, nr) in obstacles:
                        continue

                    diag = (dc != 0 and dr != 0)
                    if diag:
                        step = 5 if parity == 0 else 10
                        npar = 1 - parity
                    else:
                        step = 5
                        npar = parity

                    target_cell = rough_terrain.get((nc, nr))
                    current_cell = rough_terrain.get((c, r))
                    target_is_rough = bool(target_cell.get("is_rough", False)) if isinstance(target_cell, dict) else False
                    current_type = self._normalize_movement_type(
                        current_cell.get("movement_type") if isinstance(current_cell, dict) else None,
                        is_swim=bool(current_cell.get("is_swim", False))
                        if isinstance(current_cell, dict)
                        else False,
                    )
                    target_type = self._normalize_movement_type(
                        target_cell.get("movement_type") if isinstance(target_cell, dict) else None,
                        is_swim=bool(target_cell.get("is_swim", False)) if isinstance(target_cell, dict) else False,
                    )
                    if mode == "swim" and target_type != "water":
                        continue
                    if mode == "burrow" and target_type == "water":
                        continue
                    if mode != "fly":
                        if current_type == "water" or target_type == "water":
                            step = int(math.ceil(step * water_multiplier))
                        if target_is_rough:
                            step *= 2

                    ncost = cost + step
                    key = (nc, nr, npar)
                    if ncost < best.get(key, 10**9) and ncost <= max_ft:
                        best[key] = ncost
                        heapq.heappush(pq, (ncost, nc, nr, npar))

        return None



    # --------------------- Monsters (YAML library) ---------------------
    def _monsters_dir_path(self) -> Path:
        return _seed_user_monsters_dir()

    def _load_monsters_index(self) -> None:
        """Load ./Monsters/**/*.yml|*.yaml and build an index for monster lookups."""
        self._monster_specs = []
        self._monsters_by_name = {}
        self._wild_shape_beast_cache = None
        try:
            cache = self.__dict__.get("_wild_shape_available_cache")
            if isinstance(cache, dict):
                cache.clear()
            self.__dict__["_wild_shape_available_cache_source"] = None
        except Exception:
            pass

        mdir = self._monsters_dir_path()
        try:
            mdir.mkdir(parents=True, exist_ok=True)
        except Exception:
            pass

        files: List[Path] = []
        try:
            files = sorted(
                [
                    fp
                    for fp in mdir.rglob("*")
                    if fp.is_file() and fp.suffix.lower() in {".yml", ".yaml"}
                ],
                key=lambda fp: fp.relative_to(mdir).as_posix().lower(),
            )
        except Exception:
            files = []

        index_path = _ensure_logs_dir() / "monster_index.json"
        index_data = _read_index_file(index_path)
        cache_version = int(index_data.get("version") or 0) if isinstance(index_data, dict) else 0
        cached_entries = index_data.get("entries") if isinstance(index_data.get("entries"), dict) else {}
        if cache_version < 3:
            cached_entries = {}
        new_entries: Dict[str, Any] = {}
        yaml_missing_logged = False

        if not files:
            _write_index_file(index_path, {"version": 3, "entries": {}})
            return

        for fp in files:
            rel_key = fp.relative_to(mdir).as_posix()
            rel_filename = rel_key
            meta = _file_stat_metadata(fp)
            entry = cached_entries.get(rel_key) if isinstance(cached_entries, dict) else None
            if isinstance(entry, dict) and _metadata_matches(entry, meta):
                summary = entry.get("summary")
                if isinstance(summary, dict):
                    name = str(summary.get("name") or "").strip()
                    if name:
                        spec = MonsterSpec(
                            filename=rel_filename,
                            name=name,
                            mtype=str(summary.get("mtype") or "unknown").strip() or "unknown",
                            cr=summary.get("cr"),
                            hp=summary.get("hp"),
                            speed=summary.get("speed"),
                            swim_speed=summary.get("swim_speed"),
                            fly_speed=summary.get("fly_speed"),
                            burrow_speed=summary.get("burrow_speed"),
                            climb_speed=summary.get("climb_speed"),
                            dex=summary.get("dex"),
                            init_mod=summary.get("init_mod"),
                            saving_throws=summary.get("saving_throws") if isinstance(summary.get("saving_throws"), dict) else {},
                            ability_mods=summary.get("ability_mods") if isinstance(summary.get("ability_mods"), dict) else {},
                            raw_data=summary.get("raw_data") if isinstance(summary.get("raw_data"), dict) else {},
                        )
                        if name not in self._monsters_by_name:
                            self._monsters_by_name[name] = spec
                        self._monster_specs.append(spec)

                        new_entry = dict(entry)
                        new_entry["mtime_ns"] = meta.get("mtime_ns")
                        new_entry["size"] = meta.get("size")
                        if not new_entry.get("hash"):
                            try:
                                raw = fp.read_text(encoding="utf-8")
                                new_entry["hash"] = _hash_text(raw)
                            except Exception:
                                pass
                        new_entries[rel_key] = new_entry
                        continue

            if yaml is None:
                if not yaml_missing_logged:
                    try:
                        self._log("Monster YAML support requires PyYAML. Install: sudo apt install python3-yaml")
                    except Exception:
                        pass
                    yaml_missing_logged = True
                continue

            try:
                raw = fp.read_text(encoding="utf-8")
            except Exception:
                continue
            try:
                data = yaml.safe_load(raw)
            except Exception:
                continue
            if not isinstance(data, dict):
                continue
            legacy_mon = data.get("monster")
            is_legacy = "monster" in data
            if is_legacy:
                if not isinstance(legacy_mon, dict):
                    continue
                mon = legacy_mon
            else:
                mon = data

            raw_data: Dict[str, Any] = {}
            abilities: Dict[str, Any] = {}
            if not is_legacy:
                for key in (
                    "name", "size", "type", "alignment", "initiative", "challenge_rating", "ac", "hp", "speed",
                    "traits", "actions", "legendary_actions", "description", "habitat", "treasure", "levels_allowed",
                    "variants", "damage_type_by_variant", "bonus_actions",
                    "skills", "senses",
                    "damage_vulnerabilities", "damage_resistances", "damage_immunities", "condition_immunities",
                    "vulnerabilities", "resistances", "immunities",
                ):
                    if key in mon:
                        raw_data[key] = mon.get(key)
                ab = mon.get("abilities")
                if isinstance(ab, dict):
                    for key, val in ab.items():
                        if not isinstance(key, str):
                            continue
                        abilities[key.strip().lower()] = val
                    if abilities:
                        raw_data["abilities"] = abilities

            name = str(mon.get("name") or "").strip()
            if not name:
                continue
            mtype = str(mon.get("type") or "unknown").strip() or "unknown"
            cr = mon.get("challenge_rating")
            if isinstance(cr, str):
                cr_text = cr.strip()
                if cr_text:
                    cr = _cr_to_float(cr_text)
                else:
                    cr = None
            elif not isinstance(cr, (int, float)):
                cr = None

            hp = self._monster_int_from_value(mon.get("hp"))
            speed = self._monster_int_from_value(mon.get("speed"))
            swim_speed = self._monster_int_from_value(mon.get("swim_speed"))
            fly_speed = self._monster_int_from_value(mon.get("fly_speed"))
            burrow_speed = self._monster_int_from_value(mon.get("burrow_speed"))
            climb_speed = self._monster_int_from_value(mon.get("climb_speed"))

            if speed is None:
                speed_data = mon.get("speed")
                if isinstance(speed_data, dict):
                    speed = self._monster_int_from_value(speed_data.get("walk"))
                    swim_speed = self._monster_int_from_value(speed_data.get("swim"))
                    fly_speed = self._monster_int_from_value(speed_data.get("fly"))
                    burrow_speed = self._monster_int_from_value(speed_data.get("burrow"))
                    climb_speed = self._monster_int_from_value(speed_data.get("climb"))
                elif isinstance(speed_data, str):
                    parsed = self._parse_monster_speed_string(speed_data)
                    speed = parsed.get("walk")
                    swim_speed = parsed.get("swim")
                    fly_speed = parsed.get("fly")
                    burrow_speed = parsed.get("burrow")
                    climb_speed = parsed.get("climb")

            dex = None
            try:
                dex = self._monster_int_from_value(mon.get("dex"))
                if dex is None and isinstance(mon.get("abilities"), dict):
                    dex = self._monster_int_from_value(mon.get("abilities", {}).get("dex"))
                if dex is None and isinstance(mon.get("abilities"), dict):
                    dex = self._monster_int_from_value(mon.get("abilities", {}).get("Dex"))
            except Exception:
                dex = None

            init_mod = None
            try:
                ini = mon.get("initiative")
                if isinstance(ini, dict):
                    init_mod = self._monster_int_from_value(ini.get("modifier"))
                else:
                    init_mod = self._monster_int_from_value(ini)
            except Exception:
                init_mod = None

            saving_throws: Dict[str, int] = {}
            try:
                saves = mon.get("saving_throws") or {}
                if isinstance(saves, dict):
                    for key, val in saves.items():
                        if not isinstance(key, str):
                            continue
                        ability = key.strip().lower()
                        if ability not in {"str", "dex", "con", "int", "wis", "cha"}:
                            continue
                        if isinstance(val, int):
                            saving_throws[ability] = int(val)
                        elif isinstance(val, str):
                            raw_save = val.strip()
                            if raw_save.startswith("+"):
                                raw_save = raw_save[1:]
                            if raw_save.lstrip("-").isdigit():
                                saving_throws[ability] = int(raw_save)
            except Exception:
                saving_throws = {}

            ability_mods: Dict[str, int] = {}
            try:
                ab = abilities if abilities else (mon.get("abilities") or {})
                if isinstance(ab, dict):
                    for key, val in ab.items():
                        if not isinstance(key, str):
                            continue
                        ability = key.strip().lower()
                        if ability not in {"str", "dex", "con", "int", "wis", "cha"}:
                            continue
                        score = None
                        if isinstance(val, int):
                            score = int(val)
                        elif isinstance(val, str):
                            raw_score = val.strip()
                            if raw_score.lstrip("-").isdigit():
                                score = int(raw_score)
                        if score is None:
                            continue
                        ability_mods[ability] = (score - 10) // 2
            except Exception:
                ability_mods = {}

            spec = MonsterSpec(
                filename=rel_filename,
                name=name,
                mtype=mtype,
                cr=cr,
                hp=hp,
                speed=speed,
                swim_speed=swim_speed,
                fly_speed=fly_speed,
                burrow_speed=burrow_speed,
                climb_speed=climb_speed,
                dex=dex,
                init_mod=init_mod,
                saving_throws=saving_throws,
                ability_mods=ability_mods,
                raw_data=raw_data,
            )

            if name not in self._monsters_by_name:
                self._monsters_by_name[name] = spec
            self._monster_specs.append(spec)

            new_entries[rel_key] = {
                "mtime_ns": meta.get("mtime_ns"),
                "size": meta.get("size"),
                "hash": _hash_text(raw),
                "summary": {
                    "name": name,
                    "mtype": mtype,
                    "cr": cr,
                    "hp": hp,
                    "speed": speed,
                    "swim_speed": swim_speed,
                    "fly_speed": fly_speed,
                    "burrow_speed": burrow_speed,
                    "climb_speed": climb_speed,
                    "dex": dex,
                    "init_mod": init_mod,
                    "saving_throws": saving_throws,
                    "ability_mods": ability_mods,
                    "raw_data": raw_data,
                },
            }

        self._monster_specs.sort(key=lambda spec: (spec.name.lower(), str(spec.filename).lower()))
        _write_index_file(index_path, {"version": 3, "entries": new_entries})


    def _load_monster_details(self, name: str) -> Optional[MonsterSpec]:
        spec = self._monsters_by_name.get(str(name or "").strip())
        if spec is None:
            return None
        if isinstance(spec.raw_data, dict) and spec.raw_data:
            return spec
        if yaml is None:
            return spec
        fp = self._monsters_dir_path() / spec.filename
        try:
            raw = fp.read_text(encoding="utf-8")
            parsed = yaml.safe_load(raw)
        except Exception:
            return spec
        if not isinstance(parsed, dict):
            return spec

        monster_data = parsed.get("monster") if isinstance(parsed.get("monster"), dict) else parsed
        if not isinstance(monster_data, dict):
            return spec
        raw_data: Dict[str, Any] = {}
        for key in (
            "name",
            "size",
            "type",
            "alignment",
            "initiative",
            "challenge_rating",
            "ac",
            "hp",
            "speed",
            "traits",
            "actions",
            "legendary_actions",
            "description",
            "habitat",
            "treasure",
            "levels_allowed",
            "variants",
            "damage_type_by_variant",
            "bonus_actions",
            "skills",
            "senses",
            "damage_vulnerabilities",
            "damage_resistances",
            "damage_immunities",
            "condition_immunities",
            "vulnerabilities",
            "resistances",
            "immunities",
        ):
            if key in monster_data:
                raw_data[key] = monster_data.get(key)
        abilities = monster_data.get("abilities")
        if isinstance(abilities, dict):
            raw_data["abilities"] = abilities
        if raw_data:
            spec.raw_data = raw_data
        return spec

    def _monster_names_sorted(self) -> List[str]:
        return [s.name for s in self._monster_specs]

    def _monster_cr_display(self, spec: Optional[MonsterSpec]) -> str:
        if spec is None:
            return ""
        raw = None
        if isinstance(spec.raw_data, dict):
            raw = spec.raw_data.get("challenge_rating")
        if isinstance(raw, str) and raw.strip():
            return raw.strip()
        if isinstance(raw, (int, float)):
            return str(int(raw)) if float(raw).is_integer() else str(raw)
        if spec.cr is None:
            return ""
        return str(int(spec.cr)) if float(spec.cr).is_integer() else str(spec.cr)

    def _install_monster_dropdown_widget(self) -> None:
        """Replace the Name Entry with a Combobox listing ./Monsters YAML files."""
        try:
            add_frame = None

            def walk(w):
                nonlocal add_frame
                try:
                    if isinstance(w, ttk.Labelframe) and str(w.cget("text")) == "Add Combatant":
                        add_frame = w
                        return
                except Exception:
                    pass
                for ch in w.winfo_children():
                    walk(ch)

            walk(self)
            if add_frame is None:
                return

            target = None
            for ch in add_frame.winfo_children():
                try:
                    gi = ch.grid_info()
                    if int(gi.get("row", -1)) == 1 and int(gi.get("column", -1)) == 0:
                        target = ch
                        break
                except Exception:
                    continue

            if target is not None:
                try:
                    target.destroy()
                except Exception:
                    pass

            holder = ttk.Frame(add_frame)
            holder.grid(row=1, column=0, padx=(0, 8), sticky="w")

            values = self._monster_names_sorted()
            combo = ttk.Combobox(holder, textvariable=self.name_var, values=values, width=22)
            combo.pack(side="left")
            combo.bind("<<ComboboxSelected>>", lambda e: self._on_monster_selected())

            btn = ttk.Button(holder, text="📜", width=3, command=self._open_monster_library)
            btn.pack(side="left", padx=(4, 0))

            info_btn = ttk.Button(holder, text="Info", width=5, command=self._open_monster_stat_block)
            info_btn.pack(side="left", padx=(4, 0))

            self._monster_combo = combo  # type: ignore[attr-defined]

            if values and not self.name_var.get().strip():
                self.name_var.set(values[0])
                self._on_monster_selected()
        except Exception:
            return

    def _monster_int_from_value(self, value: object) -> Optional[int]:
        if isinstance(value, int):
            return value
        if isinstance(value, float) and value.is_integer():
            return int(value)
        if isinstance(value, str):
            raw = value.strip()
            if raw.startswith("+"):
                raw = raw[1:]
            if raw.lstrip("-").isdigit():
                return int(raw)
        return None

    def _format_monster_simple_value(self, value: object) -> str:
        if value is None:
            return "—"
        if isinstance(value, float) and value.is_integer():
            return str(int(value))
        return str(value)

    def _format_monster_modifier(self, value: object) -> str:
        mod = self._monster_int_from_value(value)
        if mod is None:
            return self._format_monster_simple_value(value)
        return f"{mod:+d}"

    def _format_monster_initiative(self, value: object) -> str:
        if isinstance(value, dict):
            if "modifier" in value:
                return self._format_monster_modifier(value.get("modifier"))
            return self._format_monster_simple_value(value)
        return self._format_monster_modifier(value)

    def _format_monster_ac(self, value: object) -> str:
        if isinstance(value, dict):
            for key in ("value", "ac"):
                if key in value:
                    return self._format_monster_simple_value(value.get(key))
        return self._format_monster_simple_value(value)

    def _format_monster_hp(self, value: object) -> str:
        if isinstance(value, dict):
            if "average" in value:
                return self._format_monster_simple_value(value.get("average"))
        return self._format_monster_simple_value(value)

    def _format_monster_speed(self, value: object) -> str:
        if value is None:
            return "—"
        if isinstance(value, dict):
            parts = []
            for key, val in value.items():
                label = str(key).replace("_", " ")
                parts.append(f"{label} {self._format_monster_simple_value(val)}")
            return ", ".join(parts) if parts else "—"
        return self._format_monster_simple_value(value)

    def _format_monster_text_block(self, value: object) -> str:
        if value is None:
            return ""
        if isinstance(value, str):
            return value.strip()
        if isinstance(value, list):
            parts = []
            for entry in value:
                text = self._format_monster_text_block(entry)
                if text:
                    parts.append(text)
            return "; ".join(parts)
        if isinstance(value, dict):
            parts = []
            for key, entry in value.items():
                text = self._format_monster_text_block(entry)
                if text:
                    parts.append(f"{key}: {text}")
            return ", ".join(parts)
        return str(value)

    def _monster_detail_value(self, raw: Dict[str, Any], *keys: str) -> str:
        values: List[str] = []
        for key in keys:
            text = self._format_monster_text_block(raw.get(key))
            if text:
                values.append(text)
        return "; ".join(values)

    def _format_monster_feature_lines(self, value: object) -> List[str]:
        lines: List[str] = []
        if isinstance(value, list):
            for entry in value:
                if isinstance(entry, dict):
                    name = entry.get("name") or entry.get("title")
                    desc = entry.get("desc") or entry.get("description") or entry.get("text")
                    if name and desc:
                        lines.append(f"- {name}: {self._format_monster_text_block(desc)}")
                    elif name:
                        lines.append(f"- {name}")
                    elif desc:
                        lines.append(f"- {self._format_monster_text_block(desc)}")
                elif isinstance(entry, str):
                    text = entry.strip()
                    if text:
                        lines.append(f"- {text}")
        elif isinstance(value, dict):
            for key, entry in value.items():
                text = self._format_monster_text_block(entry)
                if text:
                    lines.append(f"- {key}: {text}")
        elif isinstance(value, str):
            text = value.strip()
            if text:
                lines.append(text)
        return lines

    def _monster_stat_block_text(self, spec: MonsterSpec) -> str:
        raw = spec.raw_data or {}
        lines: List[str] = []
        lines.append(spec.name)
        lines.append("")
        lines.append("Identity")
        lines.append(f"Name: {spec.name}")
        lines.append(f"Size: {self._format_monster_simple_value(raw.get('size'))}")
        lines.append(f"Type: {self._format_monster_simple_value(raw.get('type') or spec.mtype)}")
        lines.append(f"Alignment: {self._format_monster_simple_value(raw.get('alignment'))}")
        lines.append(f"Initiative: {self._format_monster_initiative(raw.get('initiative'))}")
        lines.append(f"AC: {self._format_monster_ac(raw.get('ac'))}")
        lines.append(f"HP: {self._format_monster_hp(raw.get('hp'))}")
        lines.append(f"Speed: {self._format_monster_speed(raw.get('speed'))}")
        lines.append("")
        lines.append("Ability Scores")
        abilities = raw.get("abilities")
        ability_lines = []
        if isinstance(abilities, dict):
            for ab in ("str", "dex", "con", "int", "wis", "cha"):
                if ab not in abilities:
                    continue
                score = self._monster_int_from_value(abilities.get(ab))
                if score is None:
                    continue
                mod = (score - 10) // 2
                ability_lines.append(f"{ab.upper()} {score} ({mod:+d})")
        if ability_lines:
            lines.append("  " + " | ".join(ability_lines))
        else:
            lines.append("  No ability scores available.")

        def add_section(title: str, value: object) -> None:
            lines.append("")
            lines.append(title)
            entries = self._format_monster_feature_lines(value)
            if entries:
                lines.extend(entries)
            else:
                lines.append(f"No {title.lower()} available.")

        add_section("Traits", raw.get("traits"))
        add_section("Actions", raw.get("actions"))
        add_section("Legendary Actions", raw.get("legendary_actions"))

        def add_single_line_section(title: str, value: object) -> None:
            text = self._format_monster_text_block(value)
            lines.append("")
            lines.append(title)
            if text:
                lines.append(text)
            else:
                lines.append(f"No {title.lower()} available.")

        add_single_line_section("Description", raw.get("description"))
        add_single_line_section("Habitat", raw.get("habitat"))
        add_single_line_section("Treasure", raw.get("treasure"))
        return "\n".join(lines)

    def _open_monster_stat_block(self, spec: Optional[MonsterSpec] = None) -> None:
        if spec is None:
            nm = self.name_var.get().strip()
            spec = self._monsters_by_name.get(nm)

        win = tk.Toplevel(self)
        title = f"{spec.name} Creature Info" if spec else "Creature Info"
        win.title(title)
        win.geometry("760x760")
        win.minsize(700, 620)
        win.transient(self)

        style = ttk.Style(win)
        try:
            style.configure("CreatureInfo.Header.TLabel", font=("TkDefaultFont", 14, "bold"))
            style.configure("CreatureInfo.Meta.TLabel", font=("TkDefaultFont", 10))
            style.configure("CreatureInfo.Section.TLabelframe.Label", font=("TkDefaultFont", 10, "bold"))
        except Exception:
            pass

        body = ttk.Frame(win, padding=12)
        body.pack(fill="both", expand=True)
        body.columnconfigure(0, weight=1)
        body.rowconfigure(2, weight=1)

        if not spec or not spec.raw_data:
            ttk.Label(
                body,
                text="No stat block available for this creature.",
                wraplength=680,
                justify="left",
            ).grid(row=0, column=0, sticky="w")
            return

        raw = spec.raw_data or {}
        slug = self._monster_slug_from_spec(spec)
        image_path = self._resolve_local_monster_image_path(slug)

        header = ttk.Frame(body)
        header.grid(row=0, column=0, sticky="ew", pady=(0, 8))
        header.columnconfigure(0, weight=1)
        ttk.Label(header, text=str(spec.name or "Unknown Creature"), style="CreatureInfo.Header.TLabel").grid(
            row=0,
            column=0,
            sticky="w",
        )

        cr = self._format_monster_simple_value(raw.get("cr"))
        init = self._format_monster_initiative(raw.get("initiative"))
        meta_bits = [
            f"Size: {self._format_monster_simple_value(raw.get('size'))}",
            f"Type: {self._format_monster_simple_value(raw.get('type') or spec.mtype)}",
            f"Alignment: {self._format_monster_simple_value(raw.get('alignment'))}",
            f"CR: {cr}",
            f"Init: {init}",
        ]
        ttk.Label(
            header,
            text="   •   ".join(meta_bits),
            style="CreatureInfo.Meta.TLabel",
        ).grid(row=1, column=0, sticky="w", pady=(2, 0))

        if image_path is not None and Image is not None and ImageTk is not None:
            try:
                with Image.open(image_path) as img:
                    preview = img.copy()
                resampling = getattr(Image, "Resampling", None)
                resample_filter = resampling.LANCZOS if resampling is not None else Image.LANCZOS
                preview.thumbnail((240, 240), resample_filter)
                photo = ImageTk.PhotoImage(preview)
                image_label = ttk.Label(header, image=photo)
                image_label.image = photo
                win._monster_photo = photo
                image_label.grid(row=0, column=1, rowspan=2, sticky="ne", padx=(10, 0))
            except Exception:
                pass

        summary = ttk.Frame(body)
        summary.grid(row=1, column=0, sticky="ew", pady=(0, 10))
        for idx in range(4):
            summary.columnconfigure(idx, weight=1)
        summary_items = [
            ("AC", self._format_monster_ac(raw.get("ac"))),
            ("HP", self._format_monster_hp(raw.get("hp"))),
            ("Speed", self._format_monster_speed(raw.get("speed"))),
            ("PB", self._format_monster_simple_value(raw.get("proficiency_bonus"))),
        ]
        for idx, (label, val) in enumerate(summary_items):
            card = ttk.LabelFrame(summary, text=label, style="CreatureInfo.Section.TLabelframe")
            card.grid(row=0, column=idx, sticky="nsew", padx=(0 if idx == 0 else 6, 0))
            ttk.Label(card, text=str(val), padding=(8, 6), justify="center").pack(fill="x")

        content = ttk.Frame(body)
        content.grid(row=2, column=0, sticky="nsew")
        content.columnconfigure(0, weight=1)
        content.rowconfigure(1, weight=1)

        abilities_box = ttk.LabelFrame(content, text="Ability Scores", style="CreatureInfo.Section.TLabelframe")
        abilities_box.grid(row=0, column=0, sticky="ew", pady=(0, 8))
        abilities = raw.get("abilities")
        ability_parts: List[str] = []
        if isinstance(abilities, dict):
            for ab in ("str", "dex", "con", "int", "wis", "cha"):
                if ab not in abilities:
                    continue
                score = self._monster_int_from_value(abilities.get(ab))
                if score is None:
                    continue
                mod = (score - 10) // 2
                ability_parts.append(f"{ab.upper()} {score:>2} ({mod:+d})")
        ttk.Label(
            abilities_box,
            text="   |   ".join(ability_parts) if ability_parts else "No ability scores available.",
            padding=(8, 6),
            justify="left",
        ).pack(fill="x")

        detail = tk.Text(content, wrap="word", padx=10, pady=10, relief="flat", borderwidth=0)
        detail_scroll = ttk.Scrollbar(content, orient="vertical", command=detail.yview)
        detail.configure(yscrollcommand=detail_scroll.set)
        detail.grid(row=1, column=0, sticky="nsew")
        detail_scroll.grid(row=1, column=1, sticky="ns")

        detail.tag_configure("section", font=("TkDefaultFont", 11, "bold"), spacing1=10, spacing3=4)
        detail.tag_configure("item", lmargin1=12, lmargin2=20, spacing1=2, spacing3=2)
        detail.tag_configure("body", lmargin1=8, lmargin2=8, spacing1=2, spacing3=6)

        def add_feature_section(title: str, value: object) -> None:
            detail.insert("end", f"{title}\n", "section")
            entries = self._format_monster_feature_lines(value)
            if entries:
                for entry in entries:
                    detail.insert("end", f"{entry}\n", "item")
            else:
                detail.insert("end", f"No {title.lower()} available.\n", "body")

        def add_text_section(title: str, value: object) -> None:
            detail.insert("end", f"{title}\n", "section")
            text_value = self._format_monster_text_block(value)
            detail.insert("end", f"{text_value if text_value else f'No {title.lower()} available.'}\n", "body")

        for title, keys in (
            ("Saving Throws", ("saving_throws",)),
            ("Skills", ("skills",)),
            ("Damage Vulnerabilities", ("damage_vulnerabilities",)),
            ("Damage Resistances", ("damage_resistances", "damage_resistances_special")),
            ("Damage Immunities", ("damage_immunities", "damage_immunities_special")),
            ("Condition Immunities", ("condition_immunities", "condition_immunities_special")),
            ("Other Resistances", ("other_resistances",)),
            ("Senses", ("senses",)),
            ("Languages", ("languages",)),
        ):
            value = self._monster_detail_value(raw, *keys)
            if value:
                detail.insert("end", f"{title}\n", "section")
                detail.insert("end", f"{value}\n", "body")

        add_feature_section("Traits", raw.get("traits"))
        add_feature_section("Actions", raw.get("actions"))
        add_feature_section("Bonus Actions", raw.get("bonus_actions"))
        add_feature_section("Reactions", raw.get("reactions"))
        add_feature_section("Legendary Actions", raw.get("legendary_actions"))
        add_feature_section("Mythic Actions", raw.get("mythic_actions"))

        add_text_section("Description", raw.get("description"))
        add_text_section("Habitat", raw.get("habitat"))
        add_text_section("Treasure", raw.get("treasure"))

        detail.configure(state="disabled")

    def _on_monster_selected(self) -> None:
        nm = self.name_var.get().strip()
        spec = self._monsters_by_name.get(nm)
        if not spec:
            return

        try:
            if spec.hp is not None:
                self.hp_var.set(str(spec.hp))
            if spec.speed is not None:
                self.speed_var.set(str(spec.speed))
            if spec.swim_speed is not None and spec.swim_speed > 0:
                self.swim_var.set(str(spec.swim_speed))
            else:
                self.swim_var.set("")
            if spec.dex is not None:
                try:
                    dex_mod = (int(spec.dex) - 10) // 2
                except Exception:
                    dex_mod = None
                if dex_mod is not None:
                    self.dex_var.set(str(dex_mod))
        except Exception:
            pass

        mod = spec.init_mod
        if mod is None and spec.dex is not None:
            try:
                mod = (int(spec.dex) - 10) // 2
            except Exception:
                mod = None
        if mod is not None:
            r = random.randint(1, 20)
            self.init_var.set(str(r + int(mod)))

    def _monster_library_reload(self, libwin: tk.Toplevel) -> None:
        self._load_monsters_index()
        try:
            combo = getattr(self, "_monster_combo", None)
            if combo is not None:
                combo["values"] = self._monster_names_sorted()
        except Exception:
            pass

        try:
            libwin.destroy()
        except Exception:
            pass
        self._open_monster_library()



def main() -> None:
    app = InitiativeTracker()
    try:
        app.mainloop()
    except KeyboardInterrupt:
        try:
            lan = getattr(app, "_lan", None)
            if lan is not None:
                lan._polling = False
                lan.stop()
        except Exception:
            pass
        try:
            app.destroy()
        except Exception:
            pass


if __name__ == "__main__":
    main()
