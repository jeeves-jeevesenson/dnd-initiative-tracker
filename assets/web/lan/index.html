<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <meta name="apple-mobile-web-app-title" content="InitTracker LAN" />
  <link rel="apple-touch-icon" href="/assets/graphic.png" />
  <link rel="icon" href="/assets/icon.ico" sizes="any" />
  <link rel="manifest" href="/assets/manifest.webmanifest" />
  <title>InitTracker LAN</title>
  <script>window.PUSH_PUBLIC_KEY=__PUSH_PUBLIC_KEY__;</script>
  <script>window.LAN_BASE_URL=__LAN_BASE_URL__;</script>
  <style>
    :root{
      --bg:#0b0d10;
      --panel:#141923;
      --panel2:#0f1320;
      --text:#e8eef7;
      --muted:#93a2b8;
      --accent:#6aa9ff;
      --danger:#ff5b5b;
      --safeInsetTop: env(safe-area-inset-top, 0px);
      --safeInsetBottom: env(safe-area-inset-bottom, 0px);
      --modalTopOffset: 0px;
      --modalBottomOffset: 0px;
      --topbar-height: 0px;
      --bottombar-height: 0px;
      --battle-log-font-size: 14px;
      --battle-log-font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;
    }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--text); font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif; overflow:hidden;}
    .app{height:100dvh; display:flex; flex-direction:column; min-height:0;}
    .topbar{
      padding: calc(10px + var(--safeInsetTop)) 12px 10px 12px;
      background: linear-gradient(180deg, rgba(22,24,30,0.96), rgba(12,14,20,0.88));
      border-bottom: 1px solid rgba(214,186,126,0.28);
      display:flex;
      flex-direction:column;
      align-items:stretch;
      gap:10px;
      position:sticky;
      top:0;
      z-index:24;
      backdrop-filter: blur(12px);
      box-shadow: 0 8px 20px rgba(0,0,0,0.38);
    }
    .map-view{
      --map-view-bar-height: 68px;
      --map-view-order-font-size: 14px;
      --map-view-order-gap: 8px;
      --map-view-order-chip-pad-y: 6px;
      --map-view-order-chip-pad-x: 10px;
      --map-view-order-radius: 999px;
      --map-view-bar-bg: rgba(14,18,26,0.92);
      --map-view-bar-border: rgba(255,255,255,0.1);
    }
    .map-view .sheet-wrap,
    .map-view .cast-overlay,
    .map-view .menu-popover,
    .map-view .spell-library-overlay,
    .map-view .spell-detail-overlay,
    .map-view .spellbook-overlay,
    .map-view .turn-modal,
    .map-view .modal,
    .map-view-only .sheet-wrap,
    .map-view-only .cast-overlay,
    .map-view-only .menu-popover,
    .map-view-only .conn-popover,
    .map-view-only .spell-library-overlay,
    .map-view-only .spell-detail-overlay,
    .map-view-only .spellbook-overlay,
    .map-view-only .turn-modal,
    .map-view-only .modal{
      display:none !important;
    }
    .map-view .topbar{
      gap:8px;
      padding-bottom:8px;
    }
    .map-view .topbar-main-row{
      min-height:0;
      gap:8px;
    }
    .map-view .topbar-main-row #planningBtn,
    .map-view .topbar-main-row #planningAoeBtn,
    .map-view .topbar-main-row #spellLibraryBtn,
    .map-view .topbar-main-row #helpBtn,
    .map-view .topbar-main-row #configBtn,
    .map-view .topbar-main-row #initiativeToggleBtn,
    .map-view .topbar-main-row .topbar-controls,
    .map-view .topbar-main-row .spacer{
      display:none !important;
    }
    .map-view .topbar-main-row #topbarTitle{
      display:none;
    }
    .map-view-only .topbar-main-row #topbarTitle{
      display:none;
    }
    .map-view .conn-wrap{
      margin-left:0;
    }
    .map-view .conn-pill{
      min-width:0;
      padding:4px 8px;
      font-size:12px;
    }
    .map-view .conn-pill .conn-full-text{
      display:none;
    }
    .map-view .conn-pill .conn-compact-label,
    .map-view .conn-pill .conn-compact-dot{
      display:inline-flex;
    }
    .map-view-only .conn-popover{
      display:none !important;
    }
    .map-view .mapWrap{
      flex:1 1 auto;
    }
    .planning-view #endTurn,
    .planning-view #initiativeBarWrap,
    .planning-view #endTurnSheet,
    .planning-view #sheetWrap{
      display:none !important;
    }
    .planning-chat-window{
      position:fixed;
      right:12px;
      bottom: calc(var(--bottombar-height) + 12px);
      width:min(580px, 76vw);
      height:min(52dvh, 480px);
      min-width:280px;
      min-height:220px;
      display:flex;
      flex-direction:column;
      gap:10px;
      padding:14px;
      background: var(--panel2);
      border:1px solid rgba(255,255,255,0.14);
      border-radius:14px;
      box-shadow: 0 12px 28px rgba(0,0,0,0.45);
      z-index: 24;
      overflow:hidden;
      resize:both;
      display:none;
    }
    .planning-chat-window.show{display:flex;}
    .planning-chat-window .map-view-log-header{
      cursor:move;
      user-select:none;
      touch-action:none;
      padding:0 0 8px;
      border-bottom:1px solid rgba(255,255,255,0.12);
      margin-bottom:2px;
    }
    .planning-chat-list{
      min-height:0;
      overflow:auto;
      border:1px solid rgba(255,255,255,0.12);
      border-radius:10px;
      padding:8px;
      background: rgba(0,0,0,0.2);
      display:flex;
      flex-direction:column;
      gap:8px;
      flex:1;
    }
    .planning-chat-item{font-size:13px; line-height:1.35;}
    .planning-chat-meta{color:var(--muted); font-size:11px; margin-bottom:2px;}
    .planning-chat-compose{display:flex; gap:8px;}
    .planning-chat-compose input{flex:1 1 auto;}
    .topbar-main-row,
    .topbar-initiative-row{
      display:flex;
      align-items:center;
      gap:12px;
      flex-wrap:wrap;
      position:relative;
    }
    .topbar-main-row{
      width:100%;
    }
    .topbar-initiative{
      display:flex;
      flex-direction:column;
      gap:8px;
      min-height: var(--map-view-bar-height);
      transition: max-height 0.22s ease, opacity 0.22s ease, margin 0.22s ease;
      max-height: 300px;
      opacity: 1;
      overflow: hidden;
    }
    .initiative-hidden .topbar-initiative{
      max-height: 0;
      opacity: 0;
      margin-top: -4px;
      pointer-events:none;
    }
    .map-view-title{
      font-size: 14px;
      font-weight: 700;
      color: var(--text);
      letter-spacing: 0.2px;
    }
    .map-view-readonly{
      font-size: 12px;
      color: var(--muted);
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px dashed rgba(255,255,255,0.18);
      background: rgba(15,19,32,0.6);
      letter-spacing: 0.2px;
      display:none;
    }
    .map-view .map-view-readonly{
      display:inline-flex;
    }
    .map-view-turn-order{
      display:flex;
      gap: var(--map-view-order-gap);
      overflow-x:auto;
      overflow-y:hidden;
      align-items:center;
      padding-bottom: 2px;
      flex-wrap: nowrap;
      max-width: 100%;
      flex: 1 1 100%;
      scrollbar-width: thin;
    }
    .map-view-turn-order::-webkit-scrollbar{
      height: 6px;
    }
    .map-view-turn-order::-webkit-scrollbar-thumb{
      border-radius: 999px;
      background: rgba(255,255,255,0.22);
    }
    .map-view .turn-chip{
      font-size: var(--map-view-order-font-size);
      padding: var(--map-view-order-chip-pad-y) var(--map-view-order-chip-pad-x);
      border-radius: var(--map-view-order-radius);
    }
    .map-view .turn-chip.friendly{
      background: rgba(106,255,176,0.18);
      border-color: rgba(106,255,176,0.45);
    }
    .map-view .turn-chip.enemy{
      background: rgba(255,91,91,0.16);
      border-color: rgba(255,91,91,0.4);
    }
    .map-view .turn-chip.friendly.active{
      border-color: rgba(106,255,176,0.75);
      box-shadow: 0 0 0 1px rgba(106,255,176,0.45);
    }
    .map-view .turn-chip.enemy.active{
      border-color: rgba(255,91,91,0.75);
      box-shadow: 0 0 0 1px rgba(255,91,91,0.45);
    }
    .map-view .turn-chip-index{
      font-size: calc(var(--map-view-order-font-size) * 0.7);
    }
    .map-view .turn-order-status{
      font-size: 13px;
      color: #f5e3b2;
      font-weight: 700;
    }
    .map-view-hide-index .turn-chip-index{
      display:none;
    }
    .map-view-hide-status #mapViewTurnOrderStatus{
      display:none;
    }
    .map-view-hide-title .map-view-title{
      display:none;
    }
    .topbar h1{font-size:14px; margin:0; font-weight:650;}
    .pill{font-size:12px; color:var(--muted); padding:6px 10px; border:1px solid rgba(255,255,255,0.10); border-radius:999px;}
    .conn-wrap{
      position:relative;
      display:inline-flex;
      align-items:center;
    }
    .conn-pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      cursor:pointer;
      background: transparent;
      font: inherit;
    }
    .conn-full-text{display:inline;}
    .conn-compact-label,
    .conn-compact-dot{display:none;}
    .conn-compact .conn-full-text{display:none;}
    .conn-compact .conn-compact-label,
    .conn-compact .conn-compact-dot{display:inline-flex;}
    .conn-compact-label{font-weight:700; letter-spacing:0.5px;}
    .conn-compact-dot{
      width:8px;
      height:8px;
      border-radius:50%;
      background: var(--accent);
    }
    .conn-popover{
      position:absolute;
      top: calc(100% + 10px);
      left: 0;
      min-width: 160px;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(15,19,32,0.98);
      box-shadow: 0 12px 30px rgba(0,0,0,0.45);
      display:flex;
      flex-direction:column;
      gap:10px;
      opacity:0;
      transform: translateY(-4px);
      pointer-events:none;
      transition: opacity 0.15s ease, transform 0.15s ease;
      z-index: 30;
    }
    .conn-popover::before{
      content:"";
      position:absolute;
      top: -6px;
      left: 16px;
      width: 12px;
      height: 12px;
      background: rgba(15,19,32,0.98);
      border-left: 1px solid rgba(255,255,255,0.12);
      border-top: 1px solid rgba(255,255,255,0.12);
      transform: rotate(45deg);
    }
    .conn-popover.show{
      opacity:1;
      transform: translateY(0);
      pointer-events:auto;
    }
    .conn-popover-status{
      font-size:12px;
      color: var(--muted);
    }
    .conn-style-toggle{
      display:inline-flex;
      gap:6px;
      flex-wrap:wrap;
    }
    .conn-style-btn{
      padding:6px 10px;
      font-size:12px;
    }
    .conn-style-btn.active{
      border-color: rgba(106,169,255,0.65);
      background: rgba(106,169,255,0.2);
      color: var(--text);
    }
    .menu-wrap{
      position:relative;
      display:inline-flex;
      align-items:center;
    }
    .menu-btn{
      display:inline-flex;
      align-items:center;
      gap:6px;
    }
    .menu-popover{
      position:absolute;
      top: calc(100% + 10px);
      left: 0;
      min-width: 190px;
      padding: 6px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(15,19,32,0.98);
      box-shadow: 0 12px 30px rgba(0,0,0,0.45);
      display:flex;
      flex-direction:column;
      gap:6px;
      opacity:0;
      transform: translateY(-4px);
      pointer-events:none;
      transition: opacity 0.15s ease, transform 0.15s ease;
      z-index: 30;
    }
    .menu-popover.show{
      opacity:1;
      transform: translateY(0);
      pointer-events:auto;
    }
    .menu-item{
      border:none;
      background: transparent;
      color: var(--text);
      font-size: 13px;
      font-weight: 600;
      text-align: left;
      padding: 8px 10px;
      border-radius: 10px;
      cursor:pointer;
    }
    .menu-item:hover,
    .menu-item:focus{
      background: rgba(255,255,255,0.08);
      outline:none;
    }
    .hidden{display:none !important;}

    .close-btn{
      position: fixed;
      top: 18px;
      right: 18px;
      z-index: 111;
      width: 42px;
      height: 42px;
      border-radius: 50%;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(11,15,24,0.95);
      color: #fff;
      font-size: 28px;
      line-height: 1;
      cursor: pointer;
    }
    @media (max-width: 760px){
      .close-btn{top: 10px; right: 10px;}
    }
    .spacer{flex:1;}
    .btn{
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 13px;
      font-weight: 650;
      touch-action: manipulation;
    }
    .btn:active{transform: translateY(1px);}
    .btn:disabled,
    .btn[aria-disabled="true"],
    .btn.is-disabled{
      opacity: 0.56;
      filter: saturate(0.55);
      cursor: not-allowed;
    }
    .btn:disabled:active,
    .btn[aria-disabled="true"]:active,
    .btn.is-disabled:active{
      transform: none;
    }
    .btn.danger{background: rgba(255,91,91,0.14); border-color: rgba(255,91,91,0.35);}
    .btn.accent{background: rgba(106,169,255,0.14); border-color: rgba(106,169,255,0.35);}
    .btn.success{background: rgba(78,204,128,0.22); border-color: rgba(78,204,128,0.55); color:#dcffe8;}
    .btn.end-turn-top{
      border-color: rgba(255,88,88,0.8);
      background: linear-gradient(180deg, rgba(255,102,102,0.95) 0%, rgba(209,48,48,0.95) 100%);
      color: #fff3f3;
      font-size: 14px;
      font-weight: 800;
      letter-spacing: 0.02em;
      padding: 10px 16px;
      box-shadow: 0 8px 18px rgba(112,16,16,0.45), inset 0 0 0 1px rgba(255,255,255,0.22);
      text-shadow: 0 1px 0 rgba(20,0,0,0.35);
    }
    .btn.end-turn-top.end-turn-ready{
      border-color: rgba(255,213,138,0.95);
      box-shadow: 0 0 0 2px rgba(255,186,106,0.35), 0 0 20px rgba(255,116,106,0.7), 0 8px 20px rgba(112,16,16,0.55), inset 0 0 0 1px rgba(255,255,255,0.28);
    }
    .btn.end-turn-top.end-turn-pop{
      animation: endTurnPop 260ms ease-out;
    }
    .btn.end-turn-top:disabled,
    .btn.end-turn-top[aria-disabled="true"]{
      box-shadow: none;
    }
    .btn.end-turn-sheet{
      border-color: rgba(255,88,88,0.9);
      background: linear-gradient(180deg, rgba(255,108,108,0.98) 0%, rgba(195,36,36,0.98) 100%);
      color: #fff4f4;
      font-size: 15px;
      font-weight: 850;
      letter-spacing: 0.03em;
      padding: 11px 18px;
      box-shadow: 0 0 0 1px rgba(255,228,228,0.22), 0 0 16px rgba(255,88,88,0.65), 0 10px 22px rgba(94,8,8,0.62), inset 0 0 0 1px rgba(255,255,255,0.26);
      text-shadow: 0 1px 0 rgba(20,0,0,0.35);
      animation: endTurnSheetPulse 1.4s ease-in-out infinite;
    }
    .btn.end-turn-sheet.hidden{
      animation: none;
    }
    @keyframes endTurnPop{
      0%{transform: scale(1);}
      45%{transform: scale(1.12);}
      100%{transform: scale(1);}
    }
    @keyframes endTurnSheetPulse{
      0%, 100%{
        box-shadow: 0 0 0 1px rgba(255,228,228,0.22), 0 0 14px rgba(255,88,88,0.55), 0 10px 22px rgba(94,8,8,0.58), inset 0 0 0 1px rgba(255,255,255,0.22);
      }
      50%{
        box-shadow: 0 0 0 2px rgba(255,198,198,0.32), 0 0 24px rgba(255,74,74,0.9), 0 12px 26px rgba(94,8,8,0.72), inset 0 0 0 1px rgba(255,255,255,0.32);
      }
    }
    .topbar-controls{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
    }

    .mapWrap{flex:1 1 auto; min-height:0; position:relative; overflow:hidden; background:#0a0c12;}
    canvas{position:absolute; inset:0; width:100%; height:100%; touch-action:none;}
    .map-tooltip{
      position:absolute;
      z-index:4;
      pointer-events:none;
      max-width:240px;
      padding:4px 8px;
      border-radius:6px;
      background:rgba(16,18,24,0.92);
      color:#eef2f7;
      font-size:12px;
      font-weight:600;
      box-shadow:0 2px 8px rgba(0,0,0,0.35);
      opacity:0;
      transition:opacity 0.08s ease;
      white-space:nowrap;
    }
    .map-tooltip.show{opacity:1;}
    .effects-overlay{
      position:absolute;
      right:10px;
      top:10px;
      z-index:7;
      display:flex;
      flex-direction:column;
      align-items:flex-end;
      gap:6px;
      pointer-events:none;
    }
    .effects-overlay.hidden{display:none;}
    .effects-list{display:flex; gap:6px; flex-wrap:wrap; justify-content:flex-end; pointer-events:auto;}
    .effect-icon{
      width:28px; height:28px; border-radius:8px;
      display:inline-flex; align-items:center; justify-content:center;
      font-size:16px; line-height:1;
      border:1px solid rgba(255,255,255,0.32);
      background:rgba(16,18,24,0.86);
      box-shadow:0 2px 8px rgba(0,0,0,0.35);
      cursor:help;
    }
    .waiting{
      position:absolute; inset:0; display:none; align-items:center; justify-content:center;
      background: rgba(10,12,18,0.82); color: var(--muted); font-size: 16px; letter-spacing: 0.4px;
      text-transform: lowercase;
    }
    .waiting.show{display:flex;}
    .summon-placement-banner{
      position:absolute;
      top:12px;
      left:50%;
      transform:translateX(-50%);
      z-index:6;
      padding:8px 12px;
      border-radius:10px;
      background:rgba(15,19,32,0.92);
      border:1px solid rgba(106,169,255,0.55);
      color:#e8eef7;
      font-size:12px;
      font-weight:600;
      box-shadow:0 6px 18px rgba(0,0,0,0.35);
      pointer-events:none;
    }
    .aoe-target-preview{
      position:absolute;
      top:10px;
      right:10px;
      z-index:8;
      width:min(220px, 34vw);
      max-height:min(40vh, 300px);
      padding:8px 10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.18);
      background:rgba(15,19,32,0.78);
      box-shadow:0 6px 18px rgba(0,0,0,0.28);
      color:#e8eef7;
      pointer-events:none;
      backdrop-filter: blur(6px);
      font-size:11px;
      line-height:1.35;
    }
    .aoe-target-preview.hidden{display:none;}
    .aoe-target-preview h4{
      margin:0 0 4px 0;
      font-size:11px;
      letter-spacing:0.25px;
      text-transform:uppercase;
      color:rgba(232,238,247,0.92);
    }
    .aoe-target-preview .legend{
      margin-bottom:6px;
      color:rgba(232,238,247,0.7);
      font-size:10px;
    }
    .aoe-target-preview .ally{color:#84efaa;}
    .aoe-target-preview .enemy{color:#ff8f8f;}
    .aoe-target-preview .section + .section{margin-top:4px;}
    .aoe-target-preview .section-label{font-weight:700; font-size:10px; text-transform:uppercase; letter-spacing:0.25px;}
    .aoe-target-preview ul{
      margin:2px 0 0;
      padding-left:14px;
      max-height:84px;
      overflow:auto;
      pointer-events:auto;
    }
    .spell-target-selection-ui{
      position:absolute;
      left:10px;
      top:10px;
      z-index:9;
      width:min(260px, 40vw);
      padding:8px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.18);
      background:rgba(15,19,32,0.84);
      box-shadow:0 6px 18px rgba(0,0,0,0.28);
      font-size:12px;
    }
    .spell-target-selection-ui.hidden{display:none;}
    .spell-target-selection-counter{font-weight:700; margin-bottom:6px;}
    .spell-target-selection-list{max-height:120px; overflow:auto; margin-bottom:6px;}
    .spell-target-selection-entry{display:flex; justify-content:space-between; gap:8px; margin:2px 0;}
    .spell-target-selection-actions{display:flex; gap:6px; justify-content:flex-end;}
    .aimless-aoe-confirm{
      position:fixed;
      left:50%;
      top:calc(var(--topbar-height) + 16px);
      transform:translateX(-50%);
      z-index:95;
      max-width:calc(100vw - 24px);
      display:flex;
      gap:8px;
      padding:8px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.18);
      background:rgba(15,19,32,0.84);
      box-shadow:0 6px 18px rgba(0,0,0,0.28);
    }
    .aimless-aoe-confirm.hidden{display:none;}

    .sheet-wrap{
      position:sticky; bottom:0; z-index:20;
      display:flex; flex-direction:column;
      background: rgba(20,25,35,0.92);
      border-top: 1px solid rgba(255,255,255,0.08);
      backdrop-filter: blur(10px);
      min-height: 180px;
      max-height: 75vh;
    }
    .sheet-handle{
      height: 18px;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor: ns-resize;
      touch-action: none;
      flex:0 0 auto;
    }
    .menus-locked .sheet-handle{
      cursor: not-allowed;
      opacity: 0.45;
      pointer-events: none;
    }
    .sheet-handle::before{
      content:"";
      width: 44px;
      height: 4px;
      border-radius: 999px;
      background: rgba(255,255,255,0.25);
    }
    .sheet{
      padding: 10px 12px calc(12px + var(--safeInsetBottom)) 12px;
      display:flex;
      flex-direction:column;
      flex:1 1 auto;
      min-height:0;
    }
    .sheet-content{
      display:flex;
      flex-direction:column;
      flex:1 1 auto;
      min-height:0;
      overflow:auto;
      padding-right: 2px;
    }
    .cast-panel{
      margin-top: 10px;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.1);
      background: rgba(10,14,22,0.55);
    }
    .turn-alerts-panel{
      margin-top: 10px;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.1);
      background: rgba(10,14,22,0.55);
    }
    .turn-alerts-panel legend{
      padding: 0 6px;
      font-weight: 700;
    }
    .turn-alerts-row{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .turn-alerts-status{
      font-size: 12px;
      color: var(--muted);
    }
    .turn-alerts-note{
      margin-top: 6px;
      font-size: 11px;
      color: var(--muted);
    }
    .btn.mount.glow{
      box-shadow: 0 0 0.8rem rgba(106,169,255,0.95);
      border-color: rgba(106,169,255,0.95);
    }
    .cast-panel summary{
      cursor:pointer;
      font-weight:700;
      list-style:none;
    }
    .cast-panel summary::-webkit-details-marker{display:none;}
    .cast-panel[open] summary{margin-bottom:8px;}
    .cast-menu-trigger{
      margin-top: 10px;
      display:flex;
    }
    .cast-menu-trigger .btn{
      flex:1;
    }
    .cast-overlay{
      background: var(--bg);
      display:none;
      flex-direction:column;
      padding: 10px 12px calc(12px + var(--safeInsetBottom)) 12px;
      z-index:40;
      height:100%;
      overflow:auto;
      flex:1 1 auto;
      min-height: 0;
    }
    .cast-overlay.show{
      display:flex;
    }
    .cast-overlay-header{
      display:flex;
      align-items:center;
      gap:12px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
    }
    .cast-overlay-header .btn{
      white-space: nowrap;
    }
    .cast-overlay-title{
      font-size: 14px;
      font-weight: 700;
    }
    .cast-overlay-spacer{
      flex:1;
    }
    .cast-overlay-body{
      margin-top: 10px;
      overflow:auto;
      flex:1 1 auto;
      min-height:0;
    }
    .cast-overlay .cast-panel{
      margin-top: 0;
      padding: 0;
      border: none;
      background: transparent;
    }
    .spell-select-overlay{
      position:fixed;
      inset: 0;
      top: var(--topbar-height);
      bottom: var(--bottombar-height);
      background: var(--bg);
      display:none;
      flex-direction:column;
      padding: 10px 12px calc(12px + var(--safeInsetBottom)) 12px;
      z-index:45;
      min-height:0;
    }
    .spell-select-overlay.show{
      display:flex;
    }
    .spell-select-header{
      display:flex;
      align-items:center;
      gap:12px;
      padding-bottom:8px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      flex-wrap:wrap;
    }
    .spell-select-title{
      font-size: 14px;
      font-weight: 700;
    }
    .spell-select-spacer{
      flex:1;
    }
    .spell-select-body{
      margin-top: 10px;
      display:flex;
      flex-direction:column;
      gap:10px;
      flex:1 1 auto;
      min-height:0;
    }
    .spell-select-summary{
      font-size: 12px;
      color: var(--muted);
    }
    .spell-select-table-wrap{
      overflow:auto;
      max-height: calc(100dvh - var(--topbar-height) - var(--bottombar-height) - 170px);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(8,12,20,0.6);
    }
    .spell-select-table{
      width:100%;
      border-collapse: collapse;
      font-size: 12px;
    }
    .spell-select-table th,
    .spell-select-table td{
      padding: 8px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.06);
      text-align:left;
      vertical-align:top;
    }
    .spell-select-check-col,
    .spell-select-check-cell{
      width: 38px;
      text-align:center;
    }
    .spell-select-overlay:not(.selecting) .spell-select-check-col,
    .spell-select-overlay:not(.selecting) .spell-select-check-cell{
      display:none;
    }
    .spell-select-table th{
      position: sticky;
      top: 0;
      background: rgba(12,16,26,0.98);
      z-index: 2;
      font-size: 11px;
      letter-spacing: 0.3px;
      text-transform: uppercase;
      color: var(--muted);
    }
    .spell-select-table tr:last-child td{
      border-bottom:none;
    }
    .spell-select-name-btn{
      background: none;
      border: none;
      padding: 0;
      color: var(--accent);
      cursor:pointer;
      font-weight: 600;
      text-align:left;
    }
    .spell-select-link{
      color: var(--accent);
      text-decoration: none;
      font-weight: 600;
    }
    .spell-select-link:hover{
      text-decoration: underline;
    }
    .spell-select-details-row td{
      padding-top: 0;
      background: rgba(10,14,22,0.45);
    }
    .spell-select-details-row details{
      padding: 6px 0 10px 0;
    }
    .spell-select-details-row summary{
      cursor:pointer;
      list-style:none;
      font-weight: 700;
      color: var(--text);
    }
    .spell-select-details-row summary::-webkit-details-marker{display:none;}
    .spell-select-details-grid{
      margin-top: 8px;
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 6px;
      font-size: 11px;
      color: var(--muted);
    }
    .spell-select-actions{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .spell-select-overlay:not(.selecting) .spell-select-save-btn{
      display:none;
    }
    .spell-select-details-item strong{
      color: var(--text);
      font-weight: 600;
      display:block;
      margin-bottom: 2px;
    }
    .spell-select-controls{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .spell-select-controls select{
      flex:1;
    }
    .form-grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap:8px;
    }
    .spell-filter-toolbar{
      margin-bottom: 10px;
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .spell-filter-toolbar .form-field{
      flex:1 1 220px;
      min-width: 160px;
    }
    .spell-filter-summary{
      font-size: 12px;
      color: var(--muted);
      flex: 1 1 100%;
    }
    .spell-filter-modal{
      position: fixed;
      inset: 0;
      display:none;
      background: rgba(8,10,14,0.8);
      backdrop-filter: blur(4px);
      z-index: 70;
      padding: 12px;
      align-items:flex-end;
    }
    .spell-filter-modal.show{display:flex;}
    .spell-filter-drawer{
      width: min(620px, 100%);
      max-height: calc(100dvh - 24px);
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(13,18,28,0.98);
      display:flex;
      flex-direction:column;
      overflow:hidden;
      margin: 0 auto;
    }
    .spell-filter-drawer-header{
      display:flex;
      align-items:center;
      gap:10px;
      padding: 12px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
    }
    .spell-filter-drawer-body{
      padding: 12px;
      overflow:auto;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .spell-filter-drawer-actions{
      padding: 12px;
      border-top: 1px solid rgba(255,255,255,0.08);
      display:flex;
      justify-content:flex-end;
      gap:8px;
    }
    .multi-select{
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 10px;
      background: rgba(8,12,20,0.6);
      padding: 8px;
    }
    .multi-select summary{
      cursor:pointer;
      list-style:none;
      font-size: 12px;
      color: var(--text);
    }
    .multi-select summary::-webkit-details-marker{display:none;}
    .multi-select-options{
      margin-top: 8px;
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap:6px;
    }
    .multi-select-options label{
      display:flex;
      align-items:center;
      gap:6px;
      font-size: 12px;
      color: var(--muted);
    }
    .advanced-filter-toggle{
      margin:0;
      padding: 8px;
      border: 1px dashed rgba(255,255,255,0.2);
      border-radius: 10px;
      background: rgba(8,12,20,0.35);
    }
    .advanced-filter-toggle summary{
      cursor:pointer;
      font-size: 12px;
      font-weight: 600;
      color: var(--text);
    }
    .spell-details{
      margin-top: 10px;
      padding: 8px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.1);
      background: rgba(8,12,20,0.6);
      font-size: 12px;
      color: var(--muted);
    }
    .spell-details-grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 6px;
    }
    .spell-details-row{
      display:flex;
      gap:6px;
      align-items:baseline;
    }
    .spell-details-label{
      font-size: 11px;
      color: var(--muted);
      min-width: 64px;
    }
    .spell-details-value{
      font-size: 12px;
      color: var(--text);
      font-weight: 600;
    }
    .spellbook-overlay{
      position: fixed;
      inset: 0;
      height: calc(var(--spellbook-vh, 1vh) * 100);
      max-height: 100dvh;
      background: rgba(10, 12, 16, 0.9);
      backdrop-filter: blur(8px);
      display: none;
      flex-direction: column;
      z-index: 60;
    }
    .spellbook-overlay.show{display:flex;}
    .spell-detail-overlay{
      position: fixed;
      inset: 0;
      height: calc(var(--spellbook-vh, 1vh) * 100);
      max-height: 100dvh;
      background: rgba(10, 12, 16, 0.95);
      backdrop-filter: blur(10px);
      display: none;
      flex-direction: column;
      z-index: 95;
    }
    .spell-detail-overlay.show{display:flex;}
    .spell-detail-header{
      padding: calc(12px + var(--safeInsetTop)) 14px 12px 14px;
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border-bottom: 1px solid rgba(255,255,255,0.08);
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .spell-detail-title{
      font-size: 15px;
      font-weight: 700;
    }
    .spell-detail-spacer{flex:1;}
    .spell-detail-body{
      padding: 14px;
      padding-bottom: calc(14px + var(--safeInsetBottom));
      overflow:auto;
      flex: 1 1 auto;
      min-height: 0;
      display:flex;
      flex-direction:column;
      gap: 14px;
    }
    .spell-detail-card{
      background: rgba(20,25,35,0.92);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      padding: 12px 14px;
      display:flex;
      flex-direction:column;
      gap: 12px;
    }
    .spell-detail-heading{
      font-size: 14px;
      font-weight: 700;
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .spell-detail-meta{
      font-size: 12px;
      color: var(--muted);
    }
    .spell-detail-color-row{
      display:flex;
      align-items:center;
      gap:12px;
      flex-wrap:wrap;
    }
    .spell-detail-color-value{
      width: 96px;
      text-transform: uppercase;
    }
    .spell-color-swatch{
      width: 18px;
      height: 18px;
      border-radius: 50%;
      border: 1px solid rgba(255,255,255,0.4);
      background: rgba(255,255,255,0.2);
      display:inline-block;
      flex: 0 0 auto;
    }
    .spellbook-color-dot{
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: 1px solid rgba(255,255,255,0.4);
      background: rgba(255,255,255,0.2);
      flex: 0 0 auto;
      margin-right: 6px;
    }
    .spell-library-overlay{
      position: fixed;
      inset: 0;
      background: rgba(10, 12, 16, 0.95);
      backdrop-filter: blur(6px);
      display: none;
      flex-direction: column;
      z-index: 80;
    }
    .spell-library-overlay.show{display:flex;}
    .spell-library-header{
      padding: calc(12px + var(--safeInsetTop)) 14px 12px 14px;
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border-bottom: 1px solid rgba(255,255,255,0.08);
      display:flex;
      align-items:center;
      gap:12px;
      flex-wrap:wrap;
    }
    .spell-library-title{
      font-size: 15px;
      font-weight: 700;
    }
    .spell-library-spacer{flex:1;}
    .spell-library-controls{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .spell-library-controls input[type="search"],
    .spell-library-controls select{
      background: rgba(15,19,32,0.75);
      border: 1px solid rgba(255,255,255,0.15);
      color: var(--text);
      padding: 6px 10px;
      border-radius: 8px;
      font-size: 12px;
    }
    #spellLibraryAoeOnlyWrap{
      display:none;
      align-items:center;
      gap:6px;
      font-size:12px;
      color:var(--muted);
    }
    .spell-library-body{
      padding: 12px 14px calc(14px + var(--safeInsetBottom)) 14px;
      overflow:auto;
      flex: 1 1 auto;
      min-height: 0;
    }
    .spell-library-status{
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 10px;
    }
    .spell-library-list{
      display:flex;
      flex-direction: column;
      gap: 12px;
    }
    .spell-library-card{
      background: rgba(20,25,35,0.92);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      display:flex;
      flex-direction: column;
    }
    .spell-library-card summary{
      list-style: none;
      cursor: pointer;
      padding: 12px 14px;
    }
    .spell-library-card summary::-webkit-details-marker{display:none;}
    .spell-library-summary{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }
    .spell-library-summary-title{
      font-size: 14px;
      font-weight: 700;
    }
    .spell-library-summary-meta{
      font-size: 12px;
      color: var(--muted);
    }
    .spell-library-detail-body{
      border-top: 1px solid rgba(255,255,255,0.08);
      padding: 10px 14px 12px 14px;
      display:flex;
      flex-direction: column;
      gap: 10px;
    }
    .spell-library-detail-grid{
      display:grid;
      grid-template-columns: minmax(120px, 180px) minmax(0, 1fr);
      gap: 6px 12px;
    }
    .spell-library-detail-label{
      font-size: 12px;
      color: var(--muted);
      font-weight: 600;
    }
    .spell-library-detail-value{
      font-size: 12px;
      color: var(--text);
      white-space: pre-wrap;
      word-break: break-word;
    }
    .spell-library-detail-description{
      font-size: 12px;
      color: var(--text);
      white-space: pre-wrap;
      line-height: 1.4;
    }
    .spell-library-action-row{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
    }
    .spell-library-color-row{
      display:flex;
      align-items:center;
      gap: 8px;
    }
    .spell-library-color-row .spell-color-swatch{
      width: 16px;
      height: 16px;
    }
    .spellbook-header{
      padding: calc(12px + var(--safeInsetTop)) 14px 12px 14px;
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border-bottom: 1px solid rgba(255,255,255,0.08);
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .spellbook-title{font-size:14px; font-weight:650;}
    .spellbook-spacer{flex:1;}
    .spellbook-body{
      display:flex;
      flex-direction:column;
      gap:12px;
      padding:12px;
      padding-bottom: calc(12px + var(--safeInsetBottom) + 56px);
      overflow:hidden;
      flex:1;
      min-height: 0;
    }
    .spellbook-tabs{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-items:center;
    }
    .spellbook-controls{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-items:center;
    }
    .spellbook-controls input,
    .spellbook-controls select{
      background: rgba(15,19,32,0.75);
      border: 1px solid rgba(255,255,255,0.15);
      color: var(--text);
      padding: 6px 10px;
      border-radius: 8px;
      font-size: 12px;
    }
    .spellbook-columns{
      display:grid;
      grid-template-columns: 1fr auto 1fr;
      gap:12px;
      flex:1;
      min-height:0;
    }
    .spellbook-column{
      background: var(--panel);
      border:1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      padding:10px;
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    .spellbook-column-title{
      font-size:12px;
      color: var(--muted);
      margin-bottom:8px;
      text-transform: uppercase;
      letter-spacing:0.8px;
    }
    .spellbook-list{
      display:flex;
      flex-direction:column;
      gap:6px;
      overflow:auto;
      flex:1;
      padding-right:4px;
    }
    .spellbook-item{
      touch-action: manipulation;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:8px;
      background: rgba(255,255,255,0.05);
      border:1px solid transparent;
      border-radius:8px;
      padding:8px 10px;
      color: var(--text);
      cursor:pointer;
      font-size:13px;
    }
    .spellbook-item-name{
      display:flex;
      align-items:center;
      gap:6px;
      flex:1;
      min-width:0;
    }
    .spellbook-item-name span{
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .spellbook-item.selected{
      border-color: var(--accent);
      background: rgba(106,169,255,0.18);
    }
    .spellbook-item small{
      color: var(--muted);
      font-size:11px;
    }
    .spellbook-item.locked{
      border-color: rgba(255,180,90,0.3);
      background: rgba(255,180,90,0.12);
      cursor: default;
    }
    .wildshape-menu-actions{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-top:8px;
    }
    .wildshape-pool-row{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }
    .wildshape-pool-row input{max-width:120px;}

    .spellbook-actions{
      display:flex;
      flex-direction:column;
      gap:8px;
      justify-content:center;
    }
    .spellbook-status{
      font-size:12px;
      color: var(--muted);
      min-height:16px;
    }
    .spellbook-confirm-text{
      font-size:14px;
      margin:0 0 10px 0;
    }
    .spellbook-back-fab{
      position: fixed;
      left: 16px;
      bottom: calc(16px + var(--safeInsetBottom));
      z-index: 1;
      box-shadow: 0 10px 24px rgba(0,0,0,0.35);
    }
    .manual-entry-badge{
      display: none;
      align-items: center;
      gap: 4px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(255,180,90,0.6);
      background: rgba(255,140,60,0.2);
      color: #ffcc9b;
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.4px;
    }
    .manual-entry-badge.show{
      display: inline-flex;
    }
    .form-field{display:flex; flex-direction:column; gap:4px;}
    .form-field label{font-size:11px; color:var(--muted);}
    .form-field input,
    .form-field select{
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      border-radius: 8px;
      padding: 6px 8px;
      font-size: 12px;
    }
    .form-field select{
      background: var(--panel2);
      color: var(--text);
    }
    .form-field select option{
      background: var(--panel2);
      color: var(--text);
    }
    .form-field input[type="color"]{
      padding:0;
      height:36px;
      width:100%;
      border:none;
      background:none;
    }
    .damage-type-controls{
      display:flex;
      gap:6px;
      align-items:center;
    }
    .damage-type-controls select{flex:1;}
    .damage-type-list{
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      min-height:24px;
    }
    .damage-type-chip{
      display:inline-flex;
      align-items:center;
      gap:6px;
    }
    .chip button{
      border:none;
      background:none;
      color: var(--text);
      font-size: 14px;
      cursor:pointer;
      padding:0;
      line-height:1;
    }
    .form-actions{margin-top:10px; display:flex; gap:8px; flex-wrap:wrap;}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .row + .row{margin-top:10px;}
    .sheet-actions{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .initiative-compact .turn-order{max-height: 60px; overflow:auto;}
    .initiative-compact .turn-order-status{display:none;}
    .label{font-size:12px; color:var(--muted);}
    .value{font-size:14px; font-weight:700;}
    .me-label{display:flex; flex-direction:column; line-height:1.15;}
    .me-sub{font-size:11px; font-weight:600; opacity:.72;}
    .chip{font-size:12px; padding:6px 10px; border-radius:999px; border:1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.05);}
    .chip input{margin-right:6px;}
    .hp-bar-wrap{
      display:none;
      align-items:center;
      gap:8px;
      width:min(360px, 100%);
    }
    .hp-bar-wrap.show{display:flex;}
    .hp-bar-track{
      flex:1;
      min-width:120px;
      height:10px;
      border-radius:999px;
      background:rgba(255,255,255,0.12);
      overflow:hidden;
    }
    .hp-bar-fill{
      height:100%;
      width:0%;
      background:#38c172;
      transition:width 120ms ease-out, background 120ms ease-out;
    }
    .hp-bar-fill.mid{background:#f2c94c;}
    .hp-bar-fill.low{background:#ff5b5b;}
    .hp-bar-label{font-size:12px; color:var(--muted);}
    .turn-order{display:flex; flex-wrap:wrap; gap:6px; align-items:center;}
    .turn-chip{
      min-width: 26px;
      font-size:12px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.04);
      color: var(--text);
      display:inline-flex;
      align-items:center;
      gap:6px;
    }
    .turn-chip-index{font-weight:700;}
    .turn-chip-name{
      max-width: 140px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .turn-chip-marker{
      display:none;
      width:8px;
      height:8px;
      border-radius:50%;
      background: rgba(255,255,255,0.3);
      flex:0 0 auto;
    }
    .turn-chip-marker.active-marker{
      background: var(--accent);
      box-shadow: 0 0 6px rgba(106,169,255,0.6);
    }
    .turn-chip-marker.claimed-marker{
      background: rgba(106,169,255,0.55);
      border: 1px solid rgba(106,169,255,0.85);
    }
    .initiative-compact .turn-chip-name{display:none;}
    .initiative-compact .turn-chip-marker{display:inline-block;}
    .initiative-compact .turn-chip.active{
      background: rgba(106,169,255,0.2);
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(106,169,255,0.5);
    }
    .auto-compact .compact-optional{display:none;}
    .turn-chip.claimed{
      border-color: rgba(106,169,255,0.45);
      box-shadow: inset 0 0 0 1px rgba(106,169,255,0.18);
    }
    .turn-chip.active{
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(106,169,255,0.35);
    }
    .modal{
      position:fixed; inset:0; background: rgba(0,0,0,0.55);
      display:none; align-items:center; justify-content:center;
      padding: calc(var(--modalTopOffset) + 12px) 14px calc(var(--modalBottomOffset) + 12px);
      z-index: 80;
    }
    .modal.show{display:flex;}
    #helpModal{z-index:110;}
    .card{
      width:min(520px, 100%);
      background: var(--panel);
      border:1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 12px 40px rgba(0,0,0,0.5);
      display:flex;
      flex-direction:column;
      overflow:auto;
      max-height: calc(100dvh - var(--safeInsetTop) - var(--safeInsetBottom) - var(--modalTopOffset) - var(--modalBottomOffset) - 24px);
    }
    .config-card{overflow:hidden;}
    .card-scroll{
      max-height: calc(100dvh - var(--safeInsetTop) - var(--safeInsetBottom) - var(--modalTopOffset) - var(--modalBottomOffset) - 24px);
      overflow:auto;
    }
    .modal-body{
      flex: 1 1 auto;
      min-height: 0;
      overflow: auto;
    }
    .card h2{margin:0 0 8px 0; font-size:16px;}
    .list{max-height: 50vh; overflow:auto; border:1px solid rgba(255,255,255,0.10); border-radius:12px;}
    .item{
      padding: 12px;
      border-bottom:1px solid rgba(255,255,255,0.08);
      display:flex; align-items:center; gap:10px;
      touch-action: manipulation;
    }
    .item:last-child{border-bottom:none;}
    .item .name{font-weight:750;}
    .item .meta{font-size:12px; color:var(--muted);}
    .item:active{background: rgba(255,255,255,0.04);}
    .claim-item{
      width:100%;
      text-align:left;
      background: transparent;
      color: var(--text);
      border: none;
      cursor:pointer;
    }
    .claim-item.selected{
      background: rgba(106,169,255,0.12);
      box-shadow: inset 0 0 0 1px rgba(106,169,255,0.35);
    }
    .claim-item input{
      pointer-events:none;
    }
    .hint{font-size:12px; color:var(--muted); margin-top:10px; line-height:1.4;}
    .mastery-advantage-text{color:#34d399;font-weight:700;}
    .hint.hidden{display:none;}
    .modal-actions{display:flex; gap:10px; flex-wrap:wrap; margin-top:12px;}

    .rules-help-layout{display:grid; grid-template-columns:minmax(220px, 32%) 1fr; gap:10px; min-height:68vh; max-height:calc(100dvh - 170px);}
    .cast-modal-layout{display:grid; grid-template-columns:minmax(240px, 34%) 1fr; gap:10px; min-height:74vh; max-height:calc(100dvh - 180px);}
    #castSpellModal{
      --castModalAvailableHeight: calc(100dvh - var(--safeInsetTop) - var(--safeInsetBottom) - var(--modalTopOffset) - var(--modalBottomOffset) - 24px);
      align-items:flex-start;
      overflow:auto;
    }
    #castSpellModal .panel{
      width:min(1200px,96vw);
      margin:auto;
      background: var(--panel);
      border:1px solid rgba(255,255,255,0.12);
      border-radius:14px;
      padding:14px;
      box-shadow: 0 12px 40px rgba(0,0,0,0.5);
      display:flex;
      flex-direction:column;
      overflow:hidden;
      height: var(--castModalAvailableHeight);
      max-height: var(--castModalAvailableHeight);
    }
    #castSpellModal .cast-modal-layout{
      flex:1 1 auto;
      min-height:0;
      overflow:auto;
    }
    .cast-modal-left,
    .cast-modal-right{min-height:0; overflow:auto; border:1px solid rgba(255,255,255,0.1); border-radius:12px; background:rgba(10,14,22,0.55); padding:10px;}
    .cast-modal-controls{display:grid; grid-template-columns:1fr minmax(120px,auto); gap:10px; align-items:end; margin-bottom:10px;}
    .cast-modal-search{margin-bottom:0;}
    .cast-modal-sort{margin-bottom:0;}
    .cast-modal-list{display:flex; flex-direction:column; gap:6px; margin-top:8px;}
    .cast-modal-list .btn{justify-content:flex-start; text-align:left; width:100%;}
    .cast-modal-list .btn.active{border-color:var(--accent); box-shadow:0 0 0 1px rgba(106,169,255,0.35) inset;}
    .cast-preview-empty{font-size:13px; color:var(--muted);}
    .cast-preview-heading{font-size:15px; font-weight:700; margin-bottom:8px;}
    .cast-preview-grid{display:grid; grid-template-columns:repeat(auto-fit,minmax(150px,1fr)); gap:8px;}
    .cast-preview-dtype-row{display:flex; gap:8px; align-items:center;}
    .cast-preview-dtype-row select{flex:1;}
    .cast-preview-dtype-list{margin-top:8px;}
    .cast-preview-section{margin-top:10px;}
    .cast-preview-actions{display:block;}
    .cast-preview-cast-btn{width:100%; padding:8px;}
    .rules-help-left{display:flex; flex-direction:column; gap:8px; min-height:0;}
    .rules-help-search{width:100%;}
    .rules-help-tree{overflow:auto; border:1px solid rgba(255,255,255,.12); border-radius:10px; padding:8px; background:rgba(8,10,14,.5); min-height:200px;}
    .rules-help-node{margin:4px 0;}
    .rules-help-node button{width:100%; text-align:left; background:transparent; border:0; color:var(--text); padding:4px 6px; border-radius:6px;}
    .rules-help-node button:hover{background:rgba(255,255,255,.1);}
    .rules-help-pinned{margin:0 0 8px 0; padding-bottom:8px; border-bottom:1px solid rgba(255,255,255,.12);}
    .rules-help-pinned button{width:100%; text-align:left;}
    .rules-help-children{margin-left:12px; border-left:1px solid rgba(255,255,255,.08); padding-left:8px;}
    .rules-help-right{display:flex; flex-direction:column; gap:8px; min-height:0; height:100%;}
    .rules-help-frame{flex:1 1 auto; min-height:460px; height:100%; border:1px solid rgba(255,255,255,.15); border-radius:10px; background:#0b0d10; width:100%;}
    .rules-help-message{font-size:12px; color:var(--muted); min-height:16px;}
    @media (max-width: 1600px){ .rules-help-layout{min-height:64vh; max-height:calc(100dvh - 150px);} }
    @media (max-width: 1200px){ .rules-help-layout{min-height:60vh; max-height:calc(100dvh - 130px);} }
    @media (max-width: 900px){ .rules-help-layout{grid-template-columns:1fr; min-height:56vh; max-height:none;} .rules-help-frame{min-height:360px;} }
    @media (max-width: 900px){ .cast-modal-layout{grid-template-columns:1fr; min-height:56vh; max-height:none;} .cast-modal-controls{grid-template-columns:1fr;} }
    .modal-actions .btn{flex:1; min-width:120px;}
    .sculpt-list{
      display:flex;
      flex-direction:column;
      gap:8px;
      margin-top:8px;
      max-height:40vh;
      overflow:auto;
    }
    .sculpt-row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      border:1px solid rgba(255,255,255,0.12);
      border-radius:10px;
      padding:8px 10px;
      background:rgba(10,14,22,0.45);
    }
    .sculpt-row label{
      display:flex;
      align-items:center;
      gap:8px;
      width:100%;
      cursor:pointer;
    }
    .sculpt-row-name{font-weight:600;}
    .sacrifice-btn{
      background:transparent;
      color:var(--text);
      border:1px solid rgba(255,255,255,0.28);
    }
    .sacrifice-btn:hover{
      background:#b00020;
      color:#fff;
      border-color:#b00020;
    }
    .pool-spell-confirm-card{max-width:420px;border:1px solid rgba(255,255,255,.12);box-shadow:0 14px 36px rgba(0,0,0,.38);}
    .action-picker-list{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-top:4px;
    }
    .action-picker-item{
      border:1px solid rgba(255,255,255,0.12);
      border-radius:12px;
      padding:10px;
      background: rgba(15,20,30,0.6);
      text-align:left;
      color: var(--text);
      cursor:pointer;
    }
    .action-picker-item:disabled,
    .action-picker-item[aria-disabled="true"],
    .action-picker-item.is-disabled{
      opacity: 0.56;
      filter: saturate(0.55);
      cursor: not-allowed;
    }
    .action-picker-item:disabled:active,
    .action-picker-item[aria-disabled="true"]:active,
    .action-picker-item.is-disabled:active{
      transform: none;
    }
    .action-picker-item .action-picker-name{
      font-weight:650;
      margin-bottom:4px;
    }
    .action-picker-item .action-picker-meta{
      font-size:12px;
      color: var(--muted);
      line-height:1.4;
    }
    .config-section{margin-top:8px;}
    .config-section summary{
      cursor:pointer;
      list-style:none;
      font-weight:700;
      font-size:14px;
      padding: 6px 4px;
    }
    .config-section summary::-webkit-details-marker{display:none;}
    .config-list{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-top:8px;
    }
    .config-item{
      display:flex;
      flex-direction:column;
      gap:8px;
      padding: 10px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,0.1);
      background: rgba(10,14,22,0.55);
    }
    .config-item-title{font-size:13px; font-weight:650;}
    .config-controls{display:flex; align-items:center; gap:8px; flex-wrap:wrap;}
    .preset-actions{display:flex; align-items:center; gap:8px; flex-wrap:wrap;}
    .preset-status{font-size:12px; color:var(--accent); min-height:16px;}
    .config-toggle{
      display:flex;
      align-items:center;
      gap:6px;
      font-size:12px;
      color: var(--muted);
    }
    .config-toggle input{transform: scale(1.05);}
    .hotkey-input{
      width:120px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      padding:6px 8px;
      font-size:12px;
    }
    .hotkey-input.conflict{
      border-color: rgba(255,91,91,0.55);
      box-shadow: 0 0 0 1px rgba(255,91,91,0.3);
    }
    .hotkey-conflict{
      min-height:14px;
      font-size:11px;
      color: var(--danger);
    }
    .hotkey-hint{font-size:11px; color: var(--muted);}
    .color-section-title{font-size:12px; color:var(--muted); letter-spacing:0.04em; text-transform:uppercase; font-weight:700; margin:2px 0 6px 0; text-align:left;}
    .color-row{display:flex; align-items:center; gap:12px; flex-wrap:wrap;}
    .rgb-values{display:flex; align-items:center; gap:6px; flex-wrap:wrap;}
    .rgb-box{min-width:44px; padding:6px 8px; border-radius:8px; border:1px solid rgba(255,255,255,0.14); background:rgba(255,255,255,0.05); font-size:12px; color:var(--text); text-align:center; font-variant-numeric:tabular-nums;}
    .color-divider{height:1px; width:100%; margin: 4px 0 2px 0; background:rgba(255,255,255,0.12);}
    .color-swatch{width:36px; height:36px; border-radius:50%; border:2px solid rgba(255,255,255,0.2); background:#6aa9ff;}
    .color-input{width:64px; height:44px; border:none; background:none; padding:0;}
    .turn-modal{
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 20px 14px;
      background: rgba(0,0,0,0.6);
      opacity:0;
      pointer-events:none;
      transition: opacity 0.2s ease;
    }
    .turn-modal.show{
      opacity:1;
      pointer-events:auto;
    }
    .turn-card{
      width:min(380px, 100%);
      background: var(--panel);
      border:1px solid rgba(255,255,255,0.16);
      border-radius: 16px;
      padding: 18px 16px;
      text-align:center;
      box-shadow: 0 16px 40px rgba(0,0,0,0.5);
      display:flex;
      flex-direction:column;
      max-height: calc(100vh - var(--safeInsetTop) - var(--safeInsetBottom) - 40px);
    }
    .turn-card h2{margin:0 0 12px 0; font-size:18px;}
    .turn-countdown{
      margin: 0 0 12px 0;
      font-size: 14px;
      font-weight: 700;
      color: rgba(255,206,206,0.95);
      letter-spacing: 0.02em;
    }
    .turn-flash{
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 150;
      opacity: 0;
      background: radial-gradient(circle at center, rgba(255,70,70,0.68) 0%, rgba(220,0,0,0.54) 45%, rgba(120,0,0,0.42) 100%);
    }
    .turn-flash.active{
      animation: turnFlashFade 2s ease-out forwards;
    }
    @keyframes turnFlashFade{
      0%{opacity:0.95;}
      100%{opacity:0;}
    }
    .dm-side-layout{
      position:absolute;
      top:10px;
      bottom:10px;
      left:10px;
      right:10px;
      pointer-events:none;
      display:flex;
      justify-content:space-between;
      gap:10px;
      z-index:5;
    }
    .dm-log-panel,.dm-map-preview{
      pointer-events:auto;
      background: rgba(11,14,21,0.72);
      border:1px solid rgba(255,255,255,0.16);
      border-radius:12px;
      backdrop-filter: blur(6px);
    }
    .dm-log-panel{
      width:min(430px,42vw);
      display:none;
      flex-direction:column;
      overflow:hidden;
    }
    .dm-log-panel.show{display:flex;}
    .dm-log-header{display:flex;justify-content:space-between;gap:8px;padding:8px;border-bottom:1px solid rgba(255,255,255,0.1);}
    .dm-log-list{overflow:auto; padding:6px 8px; font-size:12px; display:flex; flex-direction:column; gap:4px;}
    .dm-log-entry{display:grid; grid-template-columns: 72px 1fr; gap:8px; padding:4px 6px; border-radius:6px; cursor:pointer;}
    .dm-log-entry:hover{background:rgba(255,255,255,0.08);}
    .dm-log-time{color:var(--muted); font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;}
    .dm-log-entry.attack .dm-log-msg{color:#ffdbb0;}
    .dm-log-entry.damage .dm-log-msg{color:#ffbcbc;}
    .dm-log-entry.heal .dm-log-msg{color:#bcffd9;}
    .dm-log-entry.save .dm-log-msg{color:#b8d3ff;}
    .dm-map-preview{width:min(300px,28vw); display:none; flex-direction:column; padding:8px; opacity:0.55;}
    .dm-map-preview.show{display:flex;}
    .dm-map-preview canvas{width:100%; aspect-ratio:1/1; background:rgba(5,8,14,0.78); border-radius:8px;}
    .map-view-log-panel{
      position:fixed;
      right:12px;
      bottom:12px;
      width:min(540px,52vw);
      max-height:min(42vh, 360px);
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.2);
      background: rgba(8,10,16,0.82);
      box-shadow: 0 12px 28px rgba(0,0,0,0.45);
      backdrop-filter: blur(8px);
      z-index: 16;
      overflow: hidden;
      pointer-events:auto;
      display:none;
      flex-direction:column;
    }
    .map-view .map-view-log-panel{display:flex;}
    .map-view-log-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      padding:8px 10px;
      border-bottom:1px solid rgba(255,255,255,0.12);
      font-size:12px;
      letter-spacing:0.3px;
    }
    .map-view-log-title{font-weight:700;}
    .map-view-log-subtitle{color:var(--muted); font-size:11px;}
    .map-view-log-list{
      overflow:auto;
      padding:8px;
      display:flex;
      flex-direction:column;
      gap:6px;
      font-size:15px;
      line-height:1.35;
    }
    .map-view-log-entry{
      display:grid;
      grid-template-columns: 74px 1fr;
      gap:8px;
      align-items:start;
      padding:5px 8px;
      border-radius:8px;
      background: rgba(255,255,255,0.03);
      border:1px solid rgba(255,255,255,0.06);
    }
    .map-view-log-time{
      color:var(--muted);
      font-size:11px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      margin-top:2px;
    }
    .map-view-log-msg{color:#f2f6ff; text-shadow: 0 1px 0 rgba(0,0,0,0.45);}
    .map-view-log-msg.is-crit{font-weight:800; font-style:italic; letter-spacing:0.2px; color:#7a1016; text-shadow:0 0 10px rgba(122,16,22,0.45);}
    .map-view-log-msg .damage-type{font-weight:700; text-shadow:0 0 8px currentColor;}
    @media (max-width: 900px){
      .map-view-log-panel{left:8px; right:8px; bottom:8px; width:auto; max-height:34vh;}
      .map-view-log-list{font-size:13px;}
      .map-view-log-entry{grid-template-columns: 64px 1fr;}
    }

    .log-overlay{
      position:fixed;
      right:12px;
      bottom: calc(var(--bottombar-height) + 12px);
      width:min(760px, 82vw);
      height:min(58vh, 560px);
      min-width:260px;
      min-height:180px;
      border:1px solid rgba(255,255,255,0.2);
      border-radius:12px;
      background: rgba(0,0,0,0.72);
      box-shadow: 0 12px 30px rgba(0,0,0,0.45);
      backdrop-filter: blur(8px);
      z-index: 22;
      display:none;
      flex-direction:column;
      overflow:hidden;
      resize: both;
    }
    .log-overlay.show{display:flex;}
    .log-overlay .map-view-log-header{
      cursor:move;
      user-select:none;
      touch-action:none;
    }
    .log-content{
      overflow:auto;
      flex:1;
      min-height:0;
      padding: 10px;
      font-size: var(--battle-log-font-size);
      font-family: var(--battle-log-font-family);
      line-height: 1.45;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .log-content .map-view-log-entry{
      background: rgba(255,255,255,0.04);
    }
    .log-content .map-view-log-time{
      font-size: max(10px, calc(var(--battle-log-font-size) * 0.72));
    }
    .log-resize-handle{
      position:absolute;
      right:4px;
      bottom:4px;
      width:18px;
      height:18px;
      cursor:nwse-resize;
      touch-action:none;
      opacity:0.75;
      background:
        linear-gradient(135deg, transparent 47%, rgba(255,255,255,0.62) 48%, rgba(255,255,255,0.62) 52%, transparent 53%),
        linear-gradient(135deg, transparent 61%, rgba(255,255,255,0.42) 62%, rgba(255,255,255,0.42) 66%, transparent 67%);
      border-radius:4px;
    }
    .spell-slot-monitor-row{
      align-items:center;
    }
    .spell-slot-monitor{
      display:flex;
      flex-wrap:wrap;
      gap:10px 14px;
      align-items:center;
      min-height: 18px;
      padding: 4px 2px;
    }
    .spell-slot-monitor.is-empty{
      display:none;
    }
    .spell-slot-level{
      display:inline-flex;
      align-items:center;
      gap:6px;
      font-size: 11px;
      letter-spacing: 0.5px;
      color: var(--muted);
      text-transform: uppercase;
    }
    .spell-slot-squares{
      display:inline-flex;
      gap:4px;
    }
    .spell-slot-square{
      width:10px;
      height:10px;
      border-radius:3px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.14);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.35);
    }
    .spell-slot-square.is-active{
      background: linear-gradient(135deg, rgba(106,169,255,0.9), rgba(106,255,176,0.55));
      border-color: rgba(106,169,255,0.9);
      box-shadow: 0 0 6px rgba(106,169,255,0.55), inset 0 0 0 1px rgba(255,255,255,0.25);
    }
    .spell-slot-square.is-spent{
      background: rgba(255,255,255,0.05);
      border-color: rgba(255,255,255,0.08);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.4);
    }
    .resource-pools-panel{
      width: 100%;
      border: 1px solid #2c3f54;
      border-radius: 10px;
      background: #121b26;
      padding: 6px 8px;
    }
    .resource-pools-panel summary{
      cursor: pointer;
      font-weight: 700;
      color: #d6e6ff;
    }
    .resource-pool-list{
      margin-top: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .resource-pool-entry{
      display:flex;
      flex-direction:column;
      gap:4px;
      align-items:flex-start;
    }
    .resource-pool-chip{
      background: #19293b;
      border: 1px solid #335172;
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 12px;
      color: #d6e6ff;
    }
    .resource-pool-chip.is-empty{
      opacity: .45;
    }
    .resource-pool-spells{
      display:flex;
      flex-wrap:wrap;
      gap:4px;
    }
    .resource-pool-cast-btn{
      font-size:11px;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid rgba(106,169,255,0.45);
      background: rgba(106,169,255,0.2);
      color: var(--text);
      cursor:pointer;
    }
    .resource-pool-cast-btn:disabled{
      opacity:0.45;
      cursor:not-allowed;
    }
    .turn-order-status{
      margin-top: 6px;
      font-size: 12px;
      color: var(--muted);
    }
    .turn-order-bubble{
      position:absolute;
      left:0;
      top:0;
      transform: translate(-50%, 0);
      background: rgba(16,20,28,0.95);
      border: 1px solid rgba(255,255,255,0.16);
      border-radius: 999px;
      padding: 6px 12px;
      font-size: 12px;
      color: var(--text);
      box-shadow: 0 10px 24px rgba(0,0,0,0.4);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s ease;
      z-index: 2;
      max-width: calc(100% - 16px);
      box-sizing: border-box;
      text-align: center;
    }
    .turn-order-bubble.show{
      opacity: 1;
    }
    .turn-chip.selected{
      border-color: rgba(255,255,255,0.5);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.18);
    }
    .topbar-initiative .turn-chip{
      min-width: 44px;
      border-radius: 999px;
      border-color: rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.07);
      box-shadow: 0 4px 10px rgba(0,0,0,0.32);
      padding: 7px 12px;
      flex: 0 0 auto;
    }
    .topbar-initiative .turn-chip.active{
      border-color: rgba(214,186,126,0.95);
      box-shadow: 0 0 0 1px rgba(214,186,126,0.7), 0 0 12px rgba(214,186,126,0.35);
    }
    .topbar-initiative .turn-chip.friendly{
      background: rgba(106,255,176,0.16);
      border-color: rgba(106,255,176,0.42);
    }
    .topbar-initiative .turn-chip.enemy{
      background: rgba(255,91,91,0.15);
      border-color: rgba(255,91,91,0.35);
    }
    .topbar-initiative .turn-chip-name{
      max-width: 120px;
    }
    @media (max-width: 720px), (max-height: 720px){
      .btn{padding: 6px 8px; font-size: 12px;}
      .btn.end-turn-top{padding: 9px 12px; font-size: 13px;}
      .btn.end-turn-sheet{padding: 10px 14px; font-size: 14px;}
      .topbar{gap:8px; padding: calc(8px + var(--safeInsetTop)) 10px 8px 10px;}
      .sheet{padding: 8px 10px calc(10px + var(--safeInsetBottom)) 10px;}
    }
  </style>
</head>
<body>
<div class="app">
  <div class="topbar">
    <div class="topbar-main-row">
      <h1 class="map-view-title" id="topbarTitle">Initiative Tracker</h1>
      <div class="conn-wrap">
        <button class="pill conn-pill" id="conn" type="button" title="Connecting" aria-haspopup="dialog" aria-expanded="false">
          <span class="conn-full-text" id="connFullText">Connecting</span>
          <span class="conn-compact-label" id="connCompactLabel" aria-hidden="true">C</span>
          <span class="conn-compact-dot" id="connDot" aria-hidden="true"></span>
        </button>
        <div class="conn-popover" id="connPopover" role="dialog" aria-hidden="true">
          <div class="conn-popover-status" id="connPopoverStatus">Connecting</div>
          <button class="btn" id="connReconnectBtn" type="button">Reconnect</button>
        </div>
      </div>
      <button class="btn end-turn-top" id="endTurn">End Turn</button>
      <div class="spacer"></div>
      <button class="btn" id="planningBtn" type="button">Planning Mode</button>
      <button class="btn" id="inventoryBtn" type="button" aria-pressed="false">Inventory</button>
      <button class="btn" id="planningAoeBtn" type="button">Place AoE</button>
      <button class="btn" id="planningChatBtn" type="button" aria-pressed="false">Chat</button>
      <button class="btn" id="spellLibraryBtn" type="button">Spellbook</button>
      <button class="btn" id="helpBtn" type="button" aria-controls="helpModal" aria-expanded="false">Help</button>
      <button class="btn" id="configBtn" aria-controls="configModal" aria-expanded="false">Config</button>
      <div class="topbar-controls">
        <button class="btn" id="lockMap">Lock Map</button>
        <button class="btn compact-optional" id="lockAoeToggle" type="button" aria-pressed="true">Unlock my AOEs</button>
        <button class="btn compact-optional" id="auraToggle" type="button" aria-pressed="true">Auras: On</button>
        <button class="btn" id="centerMap">Center on Me</button>
        <button class="btn compact-optional" id="tokenColorModeBtn">Token Color</button>
        <button class="btn" id="measureToggle" aria-pressed="false">Measure</button>
        <button class="btn compact-optional" id="measureClear">Clear Measure</button>
        <button class="btn accent" id="zoomIn">Zoom +</button>
        <button class="btn accent" id="zoomOut">Zoom </button>
        <button class="btn compact-optional" id="battleLog">Battle Log</button>
        <button class="btn" id="toggleSheetPanel" aria-pressed="false">Hide Panel</button>
      </div>
    </div>
    <div class="topbar-initiative" id="initiativeBarWrap" aria-label="Initiative bar">
      <div class="topbar-initiative-row">
        <div class="map-view-readonly" id="mapViewReadOnly" role="note">View-only: actions and movement are disabled.</div>
      </div>
      <div class="topbar-initiative-row">
        <div class="turn-order map-view-turn-order" id="mapViewTurnOrder" aria-label="Initiative order"></div>
        <div class="turn-order-bubble" id="mapViewTurnOrderBubble" role="status" aria-live="polite"></div>
      </div>
      <div class="topbar-initiative-row">
        <div class="turn-order-status" id="mapViewTurnOrderStatus"></div>
      </div>
    </div>
  </div>

  <aside class="planning-chat-window" id="planningChatOverlay" aria-hidden="true" role="dialog" aria-labelledby="planningChatTitle">
      <div class="map-view-log-header" id="planningChatHeader">
        <strong id="planningChatTitle">Planning Chat</strong>
        <button class="btn" id="planningChatClose" type="button">Hide</button>
      </div>
      <div class="hint">Names use IP assignment when available; otherwise sender IP is shown.</div>
      <div class="planning-chat-list" id="planningChatList" aria-live="polite"></div>
      <form class="planning-chat-compose" id="planningChatForm">
        <input class="input" id="planningChatInput" maxlength="500" placeholder="Message" />
        <button class="btn accent" id="planningChatSend" type="submit">Send</button>
      </form>
      <div class="log-resize-handle" id="planningChatResizeHandle" aria-hidden="true"></div>
  </aside>

  <div class="mapWrap">
    <canvas id="c"></canvas>
    <div class="waiting" id="waitingOverlay">(waiting for combat...)</div>
    <div class="summon-placement-banner hidden" id="summonPlacementBanner" role="status" aria-live="polite"></div>
    <div class="aoe-target-preview hidden" id="aoeTargetPreview" aria-live="polite" aria-hidden="true">
      <h4>AoE targets</h4>
      <div class="legend"><span class="ally">Allies</span>  <span class="enemy">Enemies</span></div>
      <div class="section">
        <div class="section-label ally">Allies</div>
        <ul id="aoeTargetPreviewAllies"></ul>
      </div>
      <div class="section">
        <div class="section-label enemy">Enemies</div>
        <ul id="aoeTargetPreviewEnemies"></ul>
      </div>
    </div>
    <div class="spell-target-selection-ui hidden" id="spellTargetSelectionUi" aria-live="polite" aria-hidden="true">
      <div class="spell-target-selection-counter" id="spellTargetSelectionCounter">0/0</div>
      <div class="spell-target-selection-list" id="spellTargetSelectionList"></div>
      <div class="spell-target-selection-actions">
        <button class="btn" id="spellTargetSelectionRemoveLast" type="button">Remove last</button>
        <button class="btn" id="spellTargetSelectionCancel" type="button">Cancel</button>
        <button class="btn accent" id="spellTargetSelectionConfirm" type="button"> Confirm</button>
      </div>
    </div>
    <div class="aimless-aoe-confirm hidden" id="aimlessAoeConfirm" aria-live="polite" aria-hidden="true">
      <button class="btn" id="aimlessAoeCancelBtn" type="button">Cancel</button>
      <button class="btn success" id="aimlessAoeConfirmBtn" type="button">Confirm</button>
    </div>
    <div class="map-tooltip" id="tokenTooltip" role="tooltip" aria-hidden="true"></div>
    <div class="effects-overlay hidden" id="effectsOverlay" aria-live="polite">
      <div class="effects-list" id="effectsList"></div>
    </div>
    <div class="dm-side-layout" id="dmSideLayout">
      <aside class="dm-log-panel" id="dmLogPanel">
        <div class="dm-log-header">
          <strong>Battle Log</strong>
          <label><input type="checkbox" id="dmLogAutoScroll" checked /> Auto-scroll</label>
        </div>
        <div class="dm-log-header">
          <label><input type="checkbox" data-log-filter="attack" checked /></label>
          <label><input type="checkbox" data-log-filter="damage" checked /></label>
          <label><input type="checkbox" data-log-filter="save" checked /></label>
          <label><input type="checkbox" data-log-filter="heal" checked /></label>
          <label><input type="checkbox" data-log-filter="spell" checked /></label>
        </div>
        <div class="dm-log-list" id="dmLogList"></div>
      </aside>
      <aside class="dm-map-preview" id="dmMapPreview">
        <strong>Map Preview</strong>
        <canvas id="dmPreviewCanvas" width="240" height="240"></canvas>
      </aside>
    </div>
    <aside class="map-view-log-panel" id="mapViewLogPanel" aria-live="polite">
      <div class="map-view-log-header">
        <div class="map-view-log-title">Battle Feed</div>
        <div class="map-view-log-subtitle">Spectator view</div>
      </div>
      <div class="map-view-log-list" id="mapViewLogList"></div>
    </aside>

    <div class="modal" id="claimModal" aria-hidden="true">
      <div class="card">
        <h2>Claim yer character</h2>
        <div class="modal-body">
          <div class="list" id="claimList"></div>
          <div class="hint hidden" id="claimEmptyHint">No claimable PCs yet. Ask the DM to add one.</div>
          <div class="hint" id="claimHint">Pick a character to control. The DM can reassign ye later.</div>
        </div>
        <div class="modal-actions">
          <button class="btn accent" id="claimConfirm" type="button">Confirm</button>
          <button class="btn" id="claimSpectator" type="button">Spectator / View only</button>
          <button class="btn" id="claimContinue" type="button">Continue unclaimed</button>
        </div>
      </div>
    </div>

    <div class="modal" id="initiativePromptModal" aria-hidden="true">
      <div class="card">
        <h2>Roll Initiative</h2>
        <div class="hint" id="initiativePromptBody">Roll initiative and enter your total.</div>
        <div class="modal-body">
          <input id="initiativePromptInput" type="number" step="1" placeholder="Initiative total" />
        </div>
        <div class="modal-actions">
          <button class="btn accent" id="initiativePromptSubmit" type="button">Submit</button>
          <button class="btn" id="initiativePromptCancel" type="button">Cancel</button>
        </div>
      </div>
    </div>

    <div class="modal" id="attackResolveModal" aria-hidden="true">
      <div class="card">
        <h2>Resolve Attack</h2>
        <div class="hint" id="attackResolveBody">Choose hit or miss, then add damage on a hit. Leave damage blank to auto-roll when a weapon/spell formula is available.</div>
        <div class="modal-body">
          <div class="row">
            <label class="chip"><input type="radio" name="attackResolveOutcome" id="attackResolveHit" value="hit" checked>Hit</label>
            <label class="chip"><input type="radio" name="attackResolveOutcome" id="attackResolveMiss" value="miss">Miss</label>
          </div>
          <div class="row">
            <label class="chip"><input type="checkbox" id="attackResolveCrit">Critical hit</label>
          </div>
          <div class="row" id="attackStunningStrikeRow" style="display:none;align-items:center;gap:8px;">
            <label class="chip"><input type="checkbox" id="attackStunningStrike">Stunning Strike (1 Focus)</label>
          </div>
          <div class="row" id="attackDamageTypeOverrideRow" style="display:none;align-items:center;gap:8px;">
            <label for="attackDamageTypeOverrideSelect">Unarmed element</label>
            <select id="attackDamageTypeOverrideSelect">
              <option value="">Normal</option>
              <option value="acid">Acid</option>
              <option value="cold">Cold</option>
              <option value="fire">Fire</option>
              <option value="lightning">Lightning</option>
              <option value="thunder">Thunder</option>
            </select>
          </div>
          <div class="row" id="attackTacticalMasterRow" style="display:none;align-items:center;gap:8px;">
            <label for="attackTacticalMasterSelect">Tactical Master</label>
            <select id="attackTacticalMasterSelect">
              <option value="">Use weapon default mastery</option>
              <option value="push">Push</option>
              <option value="sap">Sap</option>
              <option value="slow">Slow</option>
            </select>
          </div>
          <div class="damage-type-list" id="attackDamageRows" aria-live="polite"></div>
          <div class="modal-actions" style="justify-content:flex-start;padding:0;">
            <button class="btn" id="attackDamageAdd" type="button">Add damage box</button>
          </div>
        </div>
        <div class="modal-actions">
          <button class="btn accent" id="attackResolveSubmit" type="button">Confirm</button>
          <button class="btn" id="attackResolveCancel" type="button">Cancel</button>
        </div>
      </div>
    </div>

    <div class="modal" id="spellResolveModal" aria-hidden="true">
      <div class="card">
        <h2>Resolve Spell (AoE)</h2>
        <div class="hint" id="spellResolveBody">Enter table-rolled damage totals by type, or leave blank to let the system auto-roll.</div>
        <div class="modal-body">
          <div class="damage-type-list" id="spellResolveDamageRows" aria-live="polite"></div>
          <div class="modal-actions" style="justify-content:flex-start;padding:0;">
            <button class="btn" id="spellResolveAddDamage" type="button">Add damage box</button>
          </div>
        </div>
        <div class="modal-actions">
          <button class="btn accent" id="spellResolveSubmit" type="button">Confirm</button>
          <button class="btn" id="spellResolveCancel" type="button">Cancel</button>
        </div>
      </div>
    </div>

    <div class="modal" id="sculptSelectModal" aria-hidden="true">
      <div class="card">
        <h2>Choose Sacrifice(s)</h2>
        <div class="hint" id="sculptSelectBody">Pick allies to protect with Sculpt Spells.</div>
        <div class="modal-body">
          <div class="sculpt-list" id="sculptSelectList" aria-live="polite"></div>
        </div>
        <div class="modal-actions">
          <button class="btn accent" id="sculptSelectConfirm" type="button">Confirm</button>
          <button class="btn" id="sculptSelectCancel" type="button">Cancel</button>
        </div>
      </div>
    </div>

    <div class="modal" id="cleavePromptModal" aria-hidden="true">
      <div class="card card-scroll">
        <h2>Cleave Attack</h2>
        <div class="hint" id="cleavePromptBody">Choose one nearby enemy to cleave.</div>
        <div class="action-picker-list" id="cleavePromptList"></div>
        <div class="modal-actions">
          <button class="btn" id="cleavePromptCancel" type="button">Cancel</button>
        </div>
      </div>
    </div>

    <div class="modal" id="colorModal" aria-hidden="true">
      <div class="card">
        <h2>Pick yer token colors</h2>
        <div class="color-section-title">Token</div>
        <div class="row color-row">
          <div class="color-swatch" id="tokenColorSwatch"></div>
          <input class="color-input" type="color" id="tokenColorInput" value="#6aa9ff" />
          <div class="rgb-values" id="tokenColorRgbValues" aria-label="Token RGB value">
            <div class="rgb-box" id="tokenColorR">R: 106</div>
            <div class="rgb-box" id="tokenColorG">G: 169</div>
            <div class="rgb-box" id="tokenColorB">B: 255</div>
          </div>
        </div>
        <div class="color-divider" role="presentation"></div>
        <div class="color-section-title">Border</div>
        <div class="row color-row">
          <div class="color-swatch" id="tokenBorderColorSwatch"></div>
          <input class="color-input" type="color" id="tokenBorderColorInput" value="#ffffff" />
          <div class="rgb-values" id="tokenBorderColorRgbValues" aria-label="Border RGB value">
            <div class="rgb-box" id="tokenBorderColorR">R: 255</div>
            <div class="rgb-box" id="tokenBorderColorG">G: 255</div>
            <div class="rgb-box" id="tokenBorderColorB">B: 255</div>
          </div>
        </div>
        <div class="modal-actions">
          <button class="btn accent" id="tokenColorConfirm">Confirm</button>
          <button class="btn" id="tokenColorCancel">Cancel</button>
        </div>
      </div>
    </div>
    <div class="modal" id="actionPickerModal" aria-hidden="true">
      <div class="card card-scroll">
        <h2 id="actionPickerTitle">Choose an Action</h2>
        <div class="action-picker-list" id="actionPickerList"></div>
        <div class="modal-actions">
          <button class="btn" id="actionPickerCancel">Cancel</button>
        </div>
      </div>
    </div>
    <div class="modal" id="reactionOfferModal" aria-hidden="true">
      <div class="card card-scroll">
        <h2>Reaction</h2>
        <div class="hint" id="reactionOfferBody">A reaction is available.</div>
        <div class="action-picker-list" id="reactionOfferList"></div>
        <div class="modal-actions">
          <button class="btn" id="reactionOfferDecline" type="button">Ignore</button>
        </div>
      </div>
    </div>
    <div class="modal" id="warCasterModal" aria-hidden="true">
      <div class="card">
        <h2>War Caster Reaction</h2>
        <div class="form-field">
          <label for="warCasterSpellSelect">Spell</label>
          <select id="warCasterSpellSelect"></select>
        </div>
        <div class="form-field">
          <label for="warCasterTargetSelect">Target</label>
          <select id="warCasterTargetSelect"></select>
        </div>
        <div class="modal-actions">
          <button class="btn accent" id="warCasterCast" type="button">Cast</button>
          <button class="btn" id="warCasterCancel" type="button">Cancel</button>
        </div>
      </div>
    </div>
    <div class="modal" id="dashModal" aria-hidden="true">
      <div class="card">
        <h2>Use Action or Bonus Action?</h2>
        <div class="modal-actions">
          <button class="btn accent" id="dashAction">Use Action</button>
          <button class="btn accent" id="dashBonusAction">Use Bonus Action</button>
          <button class="btn" id="dashCancel">Cancel</button>
        </div>
      </div>
    </div>
    <aside class="log-overlay" id="logModal" aria-hidden="true">
      <div class="map-view-log-header" id="logHeader">
        <div class="map-view-log-title">Battle Log</div>
        <div class="config-controls">
          <button class="btn" id="logClose" type="button">Hide</button>
        </div>
      </div>
      <div class="log-content" id="logContent"></div>
      <div class="log-resize-handle" id="logResizeHandle" aria-hidden="true"></div>
    </aside>

    <div class="modal" id="helpModal" aria-hidden="true">
      <div class="panel" role="dialog" aria-modal="true" aria-labelledby="helpModalTitle" style="width:min(1200px,96vw)">
        <h2 id="helpModalTitle">Rules Help</h2>
        <div class="modal-actions" style="margin-top:0;">
          <button class="btn" id="helpOpenBook" type="button">Open book</button>
          <button class="btn" id="helpOpenClass" type="button">Open my class</button>
          <button class="btn" id="helpOpenTab" type="button">Open in new tab</button>
          <button class="btn" id="helpClose" type="button">Close</button>
        </div>
        <div class="rules-help-layout">
          <div class="rules-help-left">
            <input class="input rules-help-search" id="helpSearch" type="text" placeholder="Search sections" />
            <div class="rules-help-tree" id="helpTocTree"></div>
          </div>
          <div class="rules-help-right">
            <div class="rules-help-message" id="helpMessage"></div>
            <iframe class="rules-help-frame" id="helpViewer" title="Rules PDF viewer" loading="lazy"></iframe>
          </div>
        </div>
      </div>
    </div>

    <div class="modal" id="configModal" aria-hidden="true">
      <div class="card config-card">
        <h2>Config</h2>
        <div class="modal-body">
          <details class="config-section">
            <summary>Top Bar</summary>
            <div class="config-list">
              <div class="config-item">
                <div class="config-item-title">InitTracker LAN title</div>
                <div class="config-controls">
                  <label class="config-toggle"><input type="checkbox" id="toggleTopbarTitle" />Show</label>
                  <input class="hotkey-input" id="hotkeyTopbarTitle" data-hotkey-action="toggleTopbarTitle" placeholder="Hotkey" readonly />
                </div>
                <div class="hotkey-conflict" id="hotkeyConflictTopbarTitle"></div>
              </div>
              <div class="config-item">
                <div class="config-item-title">Connection indicator</div>
                <div class="config-controls">
                  <label class="config-toggle"><input type="checkbox" id="toggleConnIndicator" />Show</label>
                  <div class="conn-style-toggle" role="group" aria-label="Connection indicator style">
                    <button class="btn conn-style-btn" type="button" data-conn-style="full">Full</button>
                    <button class="btn conn-style-btn" type="button" data-conn-style="compact">Compact</button>
                  </div>
                  <input class="hotkey-input" id="hotkeyConnStyle" data-hotkey-action="toggleConnStyle" placeholder="Hotkey" readonly />
                </div>
                <div class="hotkey-conflict" id="hotkeyConflictConnStyle"></div>
              </div>
              <div class="config-item">
                <div class="config-item-title">Lock Map</div>
                <div class="config-controls">
                  <label class="config-toggle"><input type="checkbox" id="toggleLockMap" />Show</label>
                  <input class="hotkey-input" id="hotkeyLockMap" data-hotkey-action="lockMap" placeholder="Hotkey" readonly />
                </div>
                <div class="hotkey-conflict" id="hotkeyConflictLockMap"></div>
              </div>
              <div class="config-item">
                <div class="config-item-title">Center on Me</div>
                <div class="config-controls">
                  <label class="config-toggle"><input type="checkbox" id="toggleCenterMap" />Show</label>
                  <input class="hotkey-input" id="hotkeyCenterMap" data-hotkey-action="centerMap" placeholder="Hotkey" readonly />
                </div>
                <div class="hotkey-conflict" id="hotkeyConflictCenterMap"></div>
              </div>
              <div class="config-item">
                <div class="config-item-title">Measure</div>
                <div class="config-controls">
                  <label class="config-toggle"><input type="checkbox" id="toggleMeasure" />Show</label>
                  <input class="hotkey-input" id="hotkeyMeasure" data-hotkey-action="measure" placeholder="Hotkey" readonly />
                </div>
                <div class="hotkey-conflict" id="hotkeyConflictMeasure"></div>
              </div>
              <div class="config-item">
                <div class="config-item-title">Clear Measure</div>
                <div class="config-controls">
                  <label class="config-toggle"><input type="checkbox" id="toggleMeasureClear" />Show</label>
                  <input class="hotkey-input" id="hotkeyMeasureClear" data-hotkey-action="measureClear" placeholder="Hotkey" readonly />
                </div>
                <div class="hotkey-conflict" id="hotkeyConflictMeasureClear"></div>
              </div>
              <div class="config-item">
                <div class="config-item-title">Zoom +</div>
                <div class="config-controls">
                  <label class="config-toggle"><input type="checkbox" id="toggleZoomIn" />Show</label>
                  <input class="hotkey-input" id="hotkeyZoomIn" data-hotkey-action="zoomIn" placeholder="Hotkey" readonly />
                </div>
                <div class="hotkey-conflict" id="hotkeyConflictZoomIn"></div>
              </div>
              <div class="config-item">
                <div class="config-item-title">Zoom -</div>
                <div class="config-controls">
                  <label class="config-toggle"><input type="checkbox" id="toggleZoomOut" />Show</label>
                  <input class="hotkey-input" id="hotkeyZoomOut" data-hotkey-action="zoomOut" placeholder="Hotkey" readonly />
                </div>
                <div class="hotkey-conflict" id="hotkeyConflictZoomOut"></div>
              </div>
              <div class="config-item">
              <div class="config-item-title">Battle Log</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="toggleBattleLog" />Show</label>
                <input class="hotkey-input" id="hotkeyBattleLog" data-hotkey-action="battleLog" placeholder="Hotkey" readonly />
              </div>
              <div class="hotkey-conflict" id="hotkeyConflictBattleLog"></div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Battle log font family</div>
              <div class="config-controls">
                <select id="battleLogFontFamily">
                  <option value="system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif">System</option>
                  <option value="ui-sans-serif,Arial,Helvetica,sans-serif">Sans-serif</option>
                  <option value="Georgia,Times New Roman,serif">Serif</option>
                  <option value="ui-monospace,SFMono-Regular,Menlo,Consolas,monospace">Monospace</option>
                </select>
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Battle log text size</div>
              <div class="config-controls">
                <input id="battleLogFontSize" type="range" min="11" max="28" step="1" />
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">DM side log panel</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="toggleDmLogPanel" />Show</label>
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">DM map preview</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="toggleDmMapPreview" />Show</label>
              </div>
            </div>
          </div>
        </details>
        <details class="config-section">
          <summary>Bottom Bar</summary>
          <div class="config-list">
            <div class="config-item">
              <div class="config-item-title">Action</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="toggleUseAction" />Show</label>
                <input class="hotkey-input" id="hotkeyUseAction" data-hotkey-action="useAction" placeholder="Hotkey" readonly />
              </div>
              <div class="hotkey-conflict" id="hotkeyConflictUseAction"></div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Bonus Action</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="toggleUseBonusAction" />Show</label>
                <input class="hotkey-input" id="hotkeyUseBonusAction" data-hotkey-action="useBonusAction" placeholder="Hotkey" readonly />
              </div>
              <div class="hotkey-conflict" id="hotkeyConflictUseBonusAction"></div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Dash</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="toggleDash" />Show</label>
                <input class="hotkey-input" id="hotkeyDash" data-hotkey-action="dash" placeholder="Hotkey" readonly />
              </div>
              <div class="hotkey-conflict" id="hotkeyConflictDash"></div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Stand</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="toggleStandUp" />Show</label>
                <input class="hotkey-input" id="hotkeyStandUp" data-hotkey-action="standUp" placeholder="Hotkey" readonly />
              </div>
              <div class="hotkey-conflict" id="hotkeyConflictStandUp"></div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Reset</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="toggleResetTurn" />Show</label>
                <input class="hotkey-input" id="hotkeyResetTurn" data-hotkey-action="resetTurn" placeholder="Hotkey" readonly />
              </div>
              <div class="hotkey-conflict" id="hotkeyConflictResetTurn"></div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Toggle bottom panel</div>
              <div class="config-controls">
                <input class="hotkey-input" id="hotkeyToggleSheetPanel" data-hotkey-action="toggleSheetPanel" placeholder="Hotkey" readonly />
              </div>
              <div class="hotkey-conflict" id="hotkeyConflictToggleSheetPanel"></div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Attack overlay</div>
              <div class="config-controls">
                <input class="hotkey-input" id="hotkeyAttackOverlay" data-hotkey-action="toggleAttackOverlay" placeholder="Hotkey" readonly />
              </div>
              <div class="hotkey-conflict" id="hotkeyConflictAttackOverlay"></div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Hide spell menu for non spell casters</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="toggleSpellMenu" />Hide</label>
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Bottom panel height</div>
              <div class="config-controls">
                <input id="sheetHeight" type="range" min="180" max="720" step="2" />
              </div>
            </div>
          </div>
        </details>
        <details class="config-section">
          <summary>Initiative Display</summary>
          <div class="config-list">
            <div class="config-item">
              <div class="config-item-title">Text size</div>
              <div class="config-controls">
                <input id="mapViewTextSize" type="range" min="10" max="28" step="1" />
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Bar height</div>
              <div class="config-controls">
                <input id="mapViewBarHeight" type="range" min="56" max="140" step="2" />
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Chip padding</div>
              <div class="config-controls">
                <input id="mapViewChipPadding" type="range" min="4" max="18" step="1" />
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Chip gap</div>
              <div class="config-controls">
                <input id="mapViewChipGap" type="range" min="2" max="20" step="1" />
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Chip radius</div>
              <div class="config-controls">
                <input id="mapViewCornerRadius" type="range" min="6" max="40" step="2" />
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Rotate handle scale</div>
              <div class="config-controls">
                <input id="mapViewRotateHandleScale" type="range" min="0.8" max="2.4" step="0.1" />
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Show tracker title</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="mapViewShowTitle" />Show</label>
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Show status</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="mapViewShowStatus" />Show</label>
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Show turn index</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="mapViewShowIndex" />Show</label>
              </div>
            </div>
          </div>
        </details>
        <details class="config-section">
          <summary>Notifications</summary>
          <div class="config-list">
            <div class="config-item">
              <div class="config-item-title">Push notifications</div>
              <div class="config-controls">
                <button class="btn" id="enableNotifications" type="button">Enable</button>
                <div class="preset-status" id="notificationStatus" aria-live="polite"></div>
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Focus tab on my turn</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="focusTabOnTurn" />Focus</label>
              </div>
            </div>
          </div>
        </details>
        <div class="hint hidden" id="iosInstallHint">
          Open Safari  Share  Add to Home Screen.
          <a href="https://support.apple.com/en-us/HT201366" target="_blank" rel="noopener">Learn more</a>
        </div>
        </div>
        <div class="modal-actions">
          <button class="btn" id="configClose">Close</button>
        </div>
      </div>
    </div>
  </div>
    </div>
  </div>

  <div class="sheet-wrap" id="sheetWrap">
    <div class="sheet-handle" id="sheetHandle" role="separator" aria-orientation="horizontal" aria-label="Resize sheet"></div>
    <div class="sheet" id="sheet">
      <div class="sheet-content">
      <div class="row">
        <div class="label">Ye be:</div>
        <div class="value" id="me">(unclaimed)</div>
        <button class="btn" id="switchCharacter" type="button">Switch character</button>
        <div class="spacer"></div>
        <div class="sheet-actions">
          <button class="btn hidden" id="dismissSummons">Dismiss Summons</button>
          <button class="btn" id="resetTurn">Reset Turn</button>
          <button class="btn" id="useReaction">Reaction</button>
          <button class="btn" id="dash">Dash</button>
          <button class="btn" id="standUp">Stand Up</button>
          <button class="btn" id="useBonusAction">Use Bonus Action</button>
          <button class="btn" id="castSpellModalOpen" type="button">Cast Spell</button>
          <button class="btn" id="attackOverlayToggle" type="button" aria-pressed="false">Attack</button>
          <button class="btn mount hidden" id="mountBtn">Mount</button>
          <button class="btn end-turn-sheet hidden" id="endTurnSheet">End Turn</button>
          <button class="btn hidden" id="dismountBtn">Dismount</button>
        </div>
      </div>
      <div class="row hidden" id="inventoryRow">
        <div class="form-field">
          <label for="mainhandWeaponSelect">Mainhand</label>
          <select id="mainhandWeaponSelect">
            <option value="">Auto (first configured)</option>
          </select>
        </div>
        <div class="form-field">
          <label for="offhandWeaponSelect">Offhand</label>
          <select id="offhandWeaponSelect">
            <option value="">None</option>
          </select>
        </div>
      </div>
      <div class="row">
        <div class="chip" id="move">Move: </div>
        <div class="chip" id="action">Action: </div>
        <div class="chip" id="attackResource">Attacks: </div>
        <div class="chip" id="bonusAction">Bonus Action: </div>
        <div class="chip" id="reaction">Reaction: </div>
        <div class="chip" id="turn">Turn: </div>
        <div class="chip" id="note">Tip: drag yer token  hold Shift to drag AoE (touch-hold ok)</div>
        <label class="chip"><input type="checkbox" id="showAllNames">Show All Names</label>
      </div>
      <div class="row hp-bar-wrap" id="playerHpBarWrap" aria-live="polite">
        <div class="hp-bar-track"><div class="hp-bar-fill" id="playerHpBarFill"></div></div>
        <div class="hp-bar-label" id="playerHpBarLabel">HP </div>
      </div>
      <fieldset class="turn-alerts-panel" id="turnAlertsPanel">
        <legend>Turn Alerts</legend>
        <div class="turn-alerts-row">
          <div class="turn-alerts-status" id="turnAlertStatus" aria-live="polite">Not installed.</div>
          <button class="btn" id="unlockAudio" type="button">Enable sounds</button>
          <button class="btn" id="enableTurnAlerts" type="button">Enable Turn Alerts</button>
          <button class="btn" id="hideTurnAlerts" type="button">Hide</button>
        </div>
        <div class="turn-alerts-note">Only works when installed as an app.</div>
      </fieldset>
      <div class="row spell-slot-monitor-row">
        <div class="spell-slot-monitor" id="spellSlotMonitor" aria-label="Spell slot monitor"></div>
      </div>
      <div class="row">
        <details class="resource-pools-panel" id="resourcePoolsPanel">
          <summary>Resource Pools</summary>
          <div class="resource-pool-list" id="resourcePoolsList"></div>
        </details>
      </div>
      </div>
    </div>
    <div class="cast-overlay hidden" id="sheetCastView" aria-hidden="true">
      <div class="cast-overlay-header">
        <button class="btn" id="castOverlayBack" type="button">Back</button>
        <div class="cast-overlay-title" id="castOverlayTitle">Cast Spell</div>
        <div class="cast-overlay-spacer"></div>
        <button class="btn" id="spellbookOpen" type="button">Manage Spells</button>
        <button class="btn" id="wildShapeManageOpen" type="button">Manage Wild Shapes</button>
      </div>
      <div class="cast-overlay-body" role="dialog" aria-modal="true" aria-labelledby="castOverlayTitle">
        <div class="cast-panel" id="castPanel">
          <form id="castForm">
            <div class="spell-filter-toolbar">
              <div class="form-field">
                <label for="castSearch">Search</label>
                <input id="castSearch" type="search" placeholder="Search name, tags, description" />
              </div>
              <button class="btn" id="openSpellFilters" type="button">Filters</button>
              <div class="spell-filter-summary" id="spellFilterSummary">No filters active.</div>
            </div>
            <div class="spell-filter-modal" id="spellFilterModal" aria-hidden="true">
              <div class="spell-filter-drawer" role="dialog" aria-modal="true" aria-labelledby="spellFilterModalTitle">
                <div class="spell-filter-drawer-header">
                  <strong id="spellFilterModalTitle">Spell Filters</strong>
                  <div class="spell-select-spacer"></div>
                  <button class="btn" id="closeSpellFilters" type="button">Close</button>
                </div>
                <div class="spell-filter-drawer-body">
                  <div class="form-grid">
                    <div class="form-field">
                      <label for="castFilterLevelMin">Level Min</label>
                      <select id="castFilterLevelMin">
                        <option value="" selected>Any</option>
                        <option value="0">Cantrip</option>
                        <option value="1">1st</option>
                        <option value="2">2nd</option>
                        <option value="3">3rd</option>
                        <option value="4">4th</option>
                        <option value="5">5th</option>
                        <option value="6">6th</option>
                        <option value="7">7th</option>
                        <option value="8">8th</option>
                        <option value="9">9th</option>
                      </select>
                    </div>
                    <div class="form-field">
                      <label for="castFilterLevelMax">Level Max</label>
                      <select id="castFilterLevelMax">
                        <option value="" selected>Any</option>
                        <option value="0">Cantrip</option>
                        <option value="1">1st</option>
                        <option value="2">2nd</option>
                        <option value="3">3rd</option>
                        <option value="4">4th</option>
                        <option value="5">5th</option>
                        <option value="6">6th</option>
                        <option value="7">7th</option>
                        <option value="8">8th</option>
                        <option value="9">9th</option>
                      </select>
                    </div>
                    <div class="form-field">
                      <label for="castFilterCastingTime">Casting Time</label>
                      <select id="castFilterCastingTime"><option value="" selected>Any</option></select>
                    </div>
                    <div class="form-field">
                      <label for="castFilterRange">Range</label>
                      <select id="castFilterRange"><option value="" selected>Any</option></select>
                    </div>
                  </div>
                  <details class="multi-select" id="castFilterSchoolMulti">
                    <summary>Schools: Any</summary>
                    <div class="multi-select-options" id="castFilterSchoolOptions"></div>
                  </details>
                  <details class="multi-select" id="castFilterTagMulti">
                    <summary>Tags: Any</summary>
                    <div class="multi-select-options" id="castFilterTagOptions"></div>
                  </details>
                  <details class="multi-select" id="castFilterListMulti">
                    <summary>Lists: Any</summary>
                    <div class="multi-select-options" id="castFilterListOptions"></div>
                  </details>
                  <details class="advanced-filter-toggle" id="advancedSpellFilters">
                    <summary>Advanced Filters</summary>
                    <div class="form-grid" style="margin-top:8px;">
                      <label class="chip"><input type="checkbox" id="castFilterRitual"> Ritual only</label>
                      <label class="chip"><input type="checkbox" id="castFilterConcentration"> Concentration only</label>
                    </div>
                  </details>
                </div>
                <div class="spell-filter-drawer-actions">
                  <button class="btn" id="clearSpellFilters" type="button">Clear</button>
                  <button class="btn" id="applySpellFilters" type="button">Apply</button>
                </div>
              </div>
            </div>
          <div class="form-grid">
            <div class="form-field">
              <label for="castPreset">Preset <span class="manual-entry-badge" id="castManualEntryBadge" title="Manual entry required.">Manual entry required</span></label>
              <div class="spell-select-controls">
                <select id="castPreset">
                  <option value="" selected>Custom</option>
                </select>
              </div>
            </div>
            <div class="form-field">
              <label for="castName">Name</label>
              <input id="castName" type="text" placeholder="Fireball" />
            </div>
            <div class="form-field">
              <label for="castSlotLevel">Slot Level</label>
              <input id="castSlotLevel" type="number" min="0" step="1" placeholder="1" disabled />
            </div>
          </div>
          <div class="form-grid" id="aoeOptions">
            <div class="form-field">
              <label for="castShape">Shape</label>
              <select id="castShape">
                <option value="" selected>Choose shape</option>
                <option value="circle">Circle</option>
                <option value="square">Square</option>
                <option value="line">Line</option>
                <option value="sphere">Sphere</option>
                <option value="cube">Cube</option>
                <option value="cone">Cone</option>
                <option value="cylinder">Cylinder</option>
                <option value="wall">Wall</option>
              </select>
            </div>
            <div class="form-field cast-size-field" id="castRadiusField">
              <label for="castRadius">Radius (ft)</label>
              <input id="castRadius" type="number" min="5" step="5" value="10" readonly disabled />
            </div>
            <div class="form-field cast-size-field" id="castSideField">
              <label for="castSide">Side (ft)</label>
              <input id="castSide" type="number" min="5" step="5" value="10" readonly disabled />
            </div>
            <div class="form-field cast-size-field" id="castLengthField">
              <label for="castLength">Length (ft)</label>
              <input id="castLength" type="number" min="5" step="5" value="30" readonly disabled />
            </div>
            <div class="form-field cast-size-field" id="castWidthField">
              <label for="castWidth">Width (ft)</label>
              <input id="castWidth" type="number" min="5" step="5" value="5" readonly disabled />
            </div>
            <div class="form-field cast-size-field" id="castAngleField">
              <label for="castAngle">Angle (deg)</label>
              <input id="castAngle" type="number" min="0" step="5" value="90" readonly disabled />
            </div>
            <div class="form-field cast-size-field" id="castOrientField">
              <label for="castOrient">Orientation</label>
              <select id="castOrient" disabled>
                <option value="vertical" selected>Vertical</option>
                <option value="horizontal">Horizontal</option>
              </select>
            </div>
            <div class="form-field cast-size-field" id="castThicknessField">
              <label for="castThickness">Thickness (ft)</label>
              <input id="castThickness" type="number" min="1" step="1" value="5" readonly disabled />
            </div>
            <div class="form-field cast-size-field" id="castHeightField">
              <label for="castHeight">Height (ft)</label>
              <input id="castHeight" type="number" min="1" step="1" value="10" readonly disabled />
            </div>
            <div class="form-field">
              <label for="castDcType">DC Type</label>
              <select id="castDcType">
                <option value="">None</option>
                <option value="str">STR</option>
                <option value="dex">DEX</option>
                <option value="con">CON</option>
                <option value="int">INT</option>
                <option value="wis">WIS</option>
                <option value="cha">CHA</option>
              </select>
            </div>
            <div class="form-field">
              <label for="castDcValue">Save DC</label>
              <input id="castDcValue" type="number" min="0" step="1" placeholder="15" />
            </div>
            <div class="form-field">
              <label for="castDefaultDamage">Default Damage</label>
              <input id="castDefaultDamage" type="text" placeholder="28" />
            </div>
            <div class="form-field">
              <label for="castDice">Damage Dice</label>
              <input id="castDice" type="text" placeholder="8d6" />
            </div>
            <div class="form-field">
              <label for="castDamageType">Damage Types</label>
              <div class="damage-type-controls">
                <select id="castDamageType">
                  <option value="" selected>Select a type</option>
__DAMAGE_TYPE_OPTIONS__
                </select>
                <button class="btn" type="button" id="castAddDamageType">Add</button>
              </div>
              <div class="damage-type-list" id="castDamageTypeList" aria-live="polite"></div>
            </div>
            <div class="form-field">
              <label for="castColor">Color</label>
              <input id="castColor" type="color" value="#6aa9ff" />
            </div>
          </div>
          <div id="summonOptions" class="hidden">
            <div class="form-grid">
              <div class="form-field" id="castSummonChoiceField">
                <label for="castSummonChoice">Summon</label>
                <select id="castSummonChoice"></select>
              </div>
              <div class="form-field" id="castSummonVariantField">
                <label for="castSummonVariant">Variant</label>
                <select id="castSummonVariant"></select>
              </div>
              <div class="form-field" id="castSummonQuantityField">
                <label for="castSummonQuantity">Quantity</label>
                <input id="castSummonQuantity" type="number" min="1" step="1" value="1" />
              </div>
              <div class="form-field hidden" id="castCustomSummonNameField">
                <label for="castCustomSummonName">Summon Name</label>
                <input id="castCustomSummonName" type="text" placeholder="Custom summon" />
              </div>
              <div class="form-field hidden" id="castCustomSummonMonsterSearchField">
                <label for="castCustomSummonMonsterSearch">Search Monster YAMLs</label>
                <input id="castCustomSummonMonsterSearch" type="search" placeholder="Search monsters..." />
              </div>
              <div class="form-field hidden" id="castCustomSummonMonsterField">
                <label for="castCustomSummonMonster">Monster YAML</label>
                <select id="castCustomSummonMonster"></select>
              </div>
              <div class="form-field hidden" id="castCustomSummonTypeField">
                <label for="castCustomSummonType">Type</label>
                <input id="castCustomSummonType" type="text" placeholder="construct" />
              </div>
              <div class="form-field hidden" id="castCustomSummonHpField">
                <label for="castCustomSummonHp">HP</label>
                <input id="castCustomSummonHp" type="number" min="1" step="1" value="30" />
              </div>
              <div class="form-field hidden" id="castCustomSummonAcField">
                <label for="castCustomSummonAc">AC</label>
                <input id="castCustomSummonAc" type="number" min="1" step="1" value="10" />
              </div>
              <div class="form-field hidden" id="castCustomSummonWalkField">
                <label for="castCustomSummonWalk">Walk (ft)</label>
                <input id="castCustomSummonWalk" type="number" min="0" step="5" value="30" />
              </div>
              <div class="form-field hidden" id="castCustomSummonSwimField">
                <label for="castCustomSummonSwim">Swim (ft)</label>
                <input id="castCustomSummonSwim" type="number" min="0" step="5" value="0" />
              </div>
              <div class="form-field hidden" id="castCustomSummonFlyField">
                <label for="castCustomSummonFly">Fly (ft)</label>
                <input id="castCustomSummonFly" type="number" min="0" step="5" value="0" />
              </div>
              <div class="form-field hidden" id="castCustomSummonBurrowField">
                <label for="castCustomSummonBurrow">Burrow (ft)</label>
                <input id="castCustomSummonBurrow" type="number" min="0" step="5" value="0" />
              </div>
              <div class="form-field hidden" id="castCustomSummonClimbField">
                <label for="castCustomSummonClimb">Climb (ft)</label>
                <input id="castCustomSummonClimb" type="number" min="0" step="5" value="0" />
              </div>
              <div class="form-field hidden" id="castCustomSummonStrField">
                <label for="castCustomSummonStr">STR</label>
                <input id="castCustomSummonStr" type="number" min="1" max="30" step="1" value="10" />
              </div>
              <div class="form-field hidden" id="castCustomSummonDexField">
                <label for="castCustomSummonDex">DEX</label>
                <input id="castCustomSummonDex" type="number" min="1" max="30" step="1" value="10" />
              </div>
              <div class="form-field hidden" id="castCustomSummonConField">
                <label for="castCustomSummonCon">CON</label>
                <input id="castCustomSummonCon" type="number" min="1" max="30" step="1" value="10" />
              </div>
              <div class="form-field hidden" id="castCustomSummonIntField">
                <label for="castCustomSummonInt">INT</label>
                <input id="castCustomSummonInt" type="number" min="1" max="30" step="1" value="10" />
              </div>
              <div class="form-field hidden" id="castCustomSummonWisField">
                <label for="castCustomSummonWis">WIS</label>
                <input id="castCustomSummonWis" type="number" min="1" max="30" step="1" value="10" />
              </div>
              <div class="form-field hidden" id="castCustomSummonChaField">
                <label for="castCustomSummonCha">CHA</label>
                <input id="castCustomSummonCha" type="number" min="1" max="30" step="1" value="10" />
              </div>
              <div class="form-field hidden" id="castCustomSummonRangeField">
                <label for="castCustomSummonRange">Range (ft)</label>
                <input id="castCustomSummonRange" type="number" min="0" step="5" value="30" />
              </div>
            </div>
            <div class="spell-details" id="castSummonMeta" aria-live="polite"></div>
          </div>
          <div class="spell-details" id="spellPresetDetails" aria-live="polite">
            Select a preset to see spell details.
          </div>
          <div class="form-actions">
            <button class="btn accent" id="castSubmit" type="submit">Cast</button>
          </div>
        </form>
      </div>
    </div>

  </div>
  </div>
</div>
<div class="modal" id="mountPromptModal" aria-hidden="true">
  <div class="card">
    <h2>Mount Request</h2>
    <div class="hint" id="mountPromptBody">Someone wants to mount you. OK?</div>
    <div class="modal-actions">
      <button class="btn accent" id="mountPromptYes">Yes</button>
      <button class="btn" id="mountPromptNo">No</button>
    </div>
  </div>
</div>
<div class="modal" id="echoTetherPromptModal" aria-hidden="true">
  <div class="card">
    <h2>Echo Warning</h2>
    <div class="hint" id="echoTetherPromptBody">Warning. Moving here will destroy your echo. Proceed?</div>
    <div class="modal-actions">
      <button class="btn accent" id="echoTetherPromptYes">Yes</button>
      <button class="btn" id="echoTetherPromptNo">No</button>
    </div>
  </div>
</div>

<div class="modal" id="castSpellModal" aria-hidden="true">
  <div class="panel" role="dialog" aria-modal="true" aria-labelledby="castSpellModalTitle">
    <h2 id="castSpellModalTitle">Cast Spell</h2>
    <div class="modal-actions" style="margin-top:0;">
      <button class="btn" id="castSpellModalBack" type="button">Back</button>
      <button class="btn accent" id="castSpellModalManageSpells" type="button">Manage Spells</button>
      <button class="btn" id="castSpellModalClose" type="button">Close</button>
    </div>
    <div class="cast-modal-layout">
      <div class="cast-modal-left">
        <div class="cast-modal-controls">
          <div class="form-field cast-modal-search">
            <label for="castSpellModalSearch">Search</label>
            <input id="castSpellModalSearch" type="search" placeholder="Search spells" />
          </div>
          <div class="form-field cast-modal-sort">
            <label for="castSpellModalSort">Sort</label>
            <select id="castSpellModalSort">
              <option value="alpha" selected>Name</option>
              <option value="level">Level</option>
            </select>
          </div>
        </div>
        <details open>
          <summary id="castSpellPresetSummary">Spells &amp; Presets (None)</summary>
          <div class="cast-modal-list" id="castSpellPresetList"></div>
        </details>
      </div>
      <div class="cast-modal-right" id="castSpellPreview" aria-live="polite">
        <div class="cast-preview-empty">Please select a spell to cast</div>
      </div>
    </div>
  </div>
</div>
<div class="spellbook-overlay" id="spellbookOverlay" aria-hidden="true">
  <div class="spellbook-header">
    <button class="btn" id="spellbookBack" type="button">Back</button>
    <div class="spellbook-title" id="spellbookTitle">Manage Spells</div>
    <div class="spellbook-spacer"></div>
    <button class="btn accent" id="spellbookSave" type="button">Save</button>
  </div>
  <div class="spellbook-body">
    <div class="spellbook-tabs">
      <button class="btn" id="spellbookTabKnown" type="button">Known Spells</button>
      <button class="btn" id="spellbookTabPrepared" type="button">Prepared Spells</button>
      <label class="chip spellbook-toggle"><input type="checkbox" id="spellbookKnownEnabled" />Known spells enabled</label>
    </div>
    <div class="spellbook-controls">
      <input id="spellbookSearch" type="search" placeholder="Search spells..." />
      <select id="spellbookSort">
        <option value="alpha" selected>Name</option>
        <option value="level">Level</option>
      </select>
    </div>
    <div class="spellbook-columns">
      <div class="spellbook-column">
        <div class="spellbook-column-title" id="spellbookLeftTitle">All Spells</div>
        <div class="spellbook-list" id="spellbookLeftList"></div>
      </div>
      <div class="spellbook-column spellbook-actions">
        <button class="btn" id="spellbookAdd" type="button">Add </button>
        <button class="btn" id="spellbookRemove" type="button"> Remove</button>
      </div>
      <div class="spellbook-column">
        <div class="spellbook-column-title" id="spellbookRightTitle">Known Spells</div>
        <div class="spellbook-column-title hidden" id="spellbookFreePreparedTitle">Free Prepared</div>
        <div class="spellbook-list hidden" id="spellbookFreePreparedList"></div>
        <div class="spellbook-list" id="spellbookRightList"></div>
      </div>
    </div>
    <div class="spellbook-status" id="spellbookStatus"></div>
  </div>
  <button class="btn spellbook-back-fab" id="spellbookBackFloating" type="button" aria-label="Close spellbook">Close</button>
</div>
<div class="spell-detail-overlay" id="spellDetailOverlay" aria-hidden="true">
  <div class="spell-detail-header">
    <button class="btn" id="spellDetailBack" type="button">Back</button>
    <div class="spell-detail-title" id="spellDetailTitle">Spell Details</div>
    <div class="spell-detail-spacer"></div>
  </div>
  <div class="spell-detail-body">
    <div class="spell-detail-card">
      <div class="spell-detail-heading">
        <span id="spellDetailName">Spell</span>
        <span class="spell-detail-meta" id="spellDetailMeta"></span>
      </div>
      <div class="form-field">
        <label for="spellDetailColorInput">Spell Color</label>
        <div class="spell-detail-color-row">
          <span class="spell-color-swatch" id="spellDetailColorSwatch"></span>
          <input class="color-input" type="color" id="spellDetailColorInput" value="#6aa9ff" />
          <input class="spell-detail-color-value" id="spellDetailColorValue" type="text" inputmode="text" autocomplete="off" />
        </div>
      </div>
      <div class="spell-detail-meta" id="spellDetailStatus"></div>
    </div>
    <div class="spell-detail-card">
      <div class="spell-detail-heading">Spell Details</div>
      <div class="spell-details-grid" id="spellDetailGrid"></div>
    </div>
  </div>
</div>
<div class="modal" id="spellbookConfirmModal" aria-hidden="true">
  <div class="card">
    <h2>Confirm Spellbook</h2>
    <p class="spellbook-confirm-text" id="spellbookConfirmText">Overwrite player file?</p>
    <div class="modal-actions">
      <button class="btn" id="spellbookConfirmCancel" type="button">Cancel</button>
      <button class="btn accent" id="spellbookConfirmYes" type="button">Overwrite</button>
    </div>
  </div>
</div>
<div class="spell-library-overlay" id="spellLibraryOverlay" aria-hidden="true">
  <div class="spell-library-header">
    <button class="btn" id="spellLibraryClose" type="button">Back</button>
    <div class="spell-library-title">Spellbook</div>
    <div class="spell-library-spacer"></div>
    <div class="spell-library-controls">
      <button class="btn" id="spellLibraryManageSpells" type="button">Manage Spells</button>
      <input id="spellLibrarySearch" type="search" placeholder="Search spells..." />
      <select id="spellLibrarySort">
        <option value="alpha" selected>Name</option>
        <option value="level">Level</option>
      </select>
      <label id="spellLibraryAoeOnlyWrap" title="Planning Mode only">
        <input id="spellLibraryAoeOnly" type="checkbox" />
        AoE only
      </label>
    </div>
  </div>
  <div class="spell-library-body">
    <div class="spell-library-status" id="spellLibraryStatus">Loading spells</div>
    <div class="spell-library-list" id="spellLibraryList"></div>
  </div>
</div>

<div class="modal" id="wildShapeMenuOverlay" aria-hidden="true">
  <div class="card">
    <h2>Wild Shape</h2>
    <div class="wildshape-menu-actions">
      <button class="btn" id="wildShapeMenuManagePool" type="button">Manage Resource Pool</button>
      <button class="btn" id="wildShapeMenuManageForms" type="button">Manage Wildshapes</button>
      <button class="btn success" id="wildShapeMenuApply" type="button">Wildshape</button>
      <button class="btn" id="wildShapeMenuRevert" type="button" style="display:none;">Revert</button>
      <button class="btn" id="wildShapeMenuRegainUse" type="button">Wild Resurgence: Regain Use</button>
      <button class="btn" id="wildShapeMenuRegainSpell" type="button">Wild Resurgence: Regain Spell Slot</button>
      <button class="btn" id="wildShapeMenuClose" type="button">Close</button>
    </div>
  </div>
</div>
<div class="modal" id="wildShapePoolOverlay" aria-hidden="true">
  <div class="card">
    <h2>Manage Wild Shape Resource Pool</h2>
    <div class="spellbook-status" id="wildShapePoolSummary"></div>
    <div class="wildshape-pool-row">
      <button class="btn" id="wildShapePoolDec" type="button"></button>
      <input id="wildShapePoolCurrentInput" type="number" min="0" step="1" />
      <button class="btn" id="wildShapePoolInc" type="button">+</button>
    </div>
    <div class="modal-actions" style="margin-top:10px;">
      <button class="btn" id="wildShapePoolBack" type="button">Back</button>
      <button class="btn accent" id="wildShapePoolApply" type="button">Apply</button>
    </div>
  </div>
</div>
<div class="modal" id="wildShapePickOverlay" aria-hidden="true">
  <div class="card">
    <h2>Choose Wild Shape Form</h2>
    <div class="spellbook-list" id="wildShapePickList" style="max-height:50vh;"></div>
    <div class="modal-actions" style="margin-top:10px;">
      <button class="btn" id="wildShapePickBack" type="button">Back</button>
    </div>
  </div>
</div>
<div class="modal" id="secondWindOverlay" aria-hidden="true">
  <div class="card">
    <h2>Second Wind</h2>
    <div class="spellbook-status" id="secondWindSummary"></div>
    <div class="spellbook-status" id="secondWindRules">
      Roll 1d10, enter the die result below, and this will add your fighter level automatically.
      Core Mechanics: Bonus Action to regain 1d10 + fighter level HP. Uses: 2 at level 1, 3 at level 4, 4 at level 10. Recharging: regain 1 use on Short Rest, all uses on Long Rest.
      Tactical Mind (Level 2): When you fail an ability check, expend a use to add 1d10; if the check still fails, the use is not expended.
      Tactical Shift (Level 5): When you activate Second Wind, move up to half your Speed without provoking Opportunity Attacks.
    </div>
    <div class="wildshape-pool-row" style="margin-top:8px;">
      <label for="secondWindRollInput">d10 roll</label>
      <input id="secondWindRollInput" type="number" min="1" max="10" step="1" placeholder="1-10" />
    </div>
    <div class="modal-actions" style="margin-top:10px;">
      <button class="btn" id="secondWindCancel" type="button">Cancel</button>
      <button class="btn accent" id="secondWindUse" type="button">Use 1 Charge</button>
    </div>
  </div>
</div>
<div class="modal" id="monkFocusOverlay" aria-hidden="true">
  <div class="card">
    <h2>Monk Focus</h2>
    <div class="spellbook-status" id="monkFocusSummary">Focus Points: 0/0</div>
    <div class="spellbook-status" id="monkFocusRules">
      Spend Focus Points; reset on Short/Long Rest. Monk Save DC = 8 + prof + wis_mod.
    </div>
    <div class="modal-actions" style="margin-top:10px;display:grid;grid-template-columns:1fr;gap:8px;">
      <button class="btn" id="monkPatientDefenseFree" type="button">Patient Defense (Disengage)  Bonus Action</button>
      <button class="btn accent" id="monkPatientDefenseFocus" type="button">Patient Defense (Disengage + Dodge)  1 Focus</button>
      <button class="btn" id="monkStepOfWindFree" type="button">Step of the Wind (Dash)  Bonus Action</button>
      <button class="btn accent" id="monkStepOfWindFocus" type="button">Step of the Wind (Dash + Disengage)  1 Focus</button>
      <button class="btn" id="monkMartialArtsBonus" type="button">Martial Arts: Bonus Unarmed Strike  Bonus Action</button>
      <button class="btn accent" id="monkFlurryOfBlows" type="button">Flurry of Blows  1 Focus (2 strikes; 3 at Monk 10+)</button>
      <div class="spellbook-status" style="margin-top:6px;">Warrior of the Elements</div>
      <button class="btn accent" id="monkElementalAttunementToggle" type="button">Elemental Attunement (1 Focus)</button>
      <button class="btn accent" id="monkElementalBurst" type="button">Elemental Burst (20-ft sphere, 120 ft)  2 Focus (Magic Action)</button>
      <button class="btn accent" id="monkUncannyMetabolism" type="button">Uncanny Metabolism  Bonus Action (1/Long Rest)</button>
      <button class="btn" id="monkFocusClose" type="button">Close</button>
    </div>
  </div>
</div>
<div class="modal" id="resourcePoolDetailOverlay" aria-hidden="true">
  <div class="card">
    <h2 id="resourcePoolDetailTitle">Resource Pool Details</h2>
    <div class="spellbook-status" id="resourcePoolDetailSummary"></div>
    <div class="spellbook-status" style="margin-top:8px;">Actions that use this pool</div>
    <div class="modal-actions" id="resourcePoolDetailActions" style="margin-top:8px;display:grid;grid-template-columns:1fr;gap:8px;"></div>
    <div class="spellbook-status" style="margin-top:8px;">Spells that use this pool</div>
    <div class="modal-actions" id="resourcePoolDetailSpells" style="margin-top:8px;display:grid;grid-template-columns:1fr;gap:8px;"></div>
    <div class="modal-actions" style="margin-top:10px;">
      <button class="btn" id="resourcePoolDetailClose" type="button">Close</button>
    </div>
  </div>
</div>
<div class="modal" id="poolSpellConfirmModal" aria-hidden="true">
  <div class="card pool-spell-confirm-card">
    <h2 id="poolSpellConfirmTitle">Confirm Cast</h2>
    <div class="spellbook-status" id="poolSpellConfirmMessage">Are you sure?</div>
    <div class="modal-actions" style="margin-top:10px;">
      <button class="btn" id="poolSpellConfirmCancel" type="button">Cancel</button>
      <button class="btn accent" id="poolSpellConfirmCast" type="button">Cast</button>
    </div>
  </div>
</div>

<div class="modal" id="beguilingMagicModal" aria-hidden="true">
  <div class="card">
    <h2 id="beguilingMagicTitle">Use Beguiling Magic</h2>
    <div class="wildshape-pool-row" style="margin-top:8px;">
      <label for="beguilingMagicCondition">Condition</label>
      <select id="beguilingMagicCondition">
        <option value="charmed">Charmed</option>
        <option value="frightened">Frightened</option>
      </select>
    </div>
    <div class="spellbook-status" id="beguilingMagicStatus" style="margin-top:8px;"></div>
    <div class="modal-actions" style="margin-top:10px;">
      <button class="btn" id="beguilingMagicCancel" type="button">Cancel</button>
      <button class="btn accent" id="beguilingMagicConfirm" type="button">Select Target</button>
    </div>
  </div>
</div>

<div class="modal" id="commandOptionModal" aria-hidden="true">
  <div class="card">
    <h2 id="commandOptionTitle">Choose Command Word</h2>
    <div class="wildshape-pool-row" style="margin-top:8px;">
      <label for="commandOptionSelect">Command option</label>
      <select id="commandOptionSelect">
        <option value="approach">Approach</option>
        <option value="drop">Drop</option>
        <option value="flee">Flee</option>
        <option value="grovel">Grovel</option>
        <option value="halt">Halt</option>
      </select>
    </div>
    <div class="spellbook-status" id="commandOptionStatus" style="margin-top:8px;"></div>
    <div class="modal-actions" style="margin-top:10px;">
      <button class="btn" id="commandOptionCancel" type="button">Cancel</button>
      <button class="btn accent" id="commandOptionConfirm" type="button">OK</button>
    </div>
  </div>
</div>

<div class="modal" id="bardicDiceConfirmModal" aria-hidden="true">
  <div class="card">
    <h2 id="bardicDiceConfirmTitle">Spend Bardic Dice?</h2>
    <div class="spellbook-status" id="bardicDiceConfirmStatus">Are you sure ye want to expend yer Bardic Inspiration die?</div>
    <div class="modal-actions" style="margin-top:10px;">
      <button class="btn" id="bardicDiceConfirmCancel" type="button">Cancel</button>
      <button class="btn accent" id="bardicDiceConfirmYes" type="button">Yes</button>
    </div>
  </div>
</div>
<div class="modal" id="mantleResolveModal" aria-hidden="true">
  <div class="card">
    <h2>Mantle of Inspiration</h2>
    <div class="spellbook-status" id="mantleResolveSummary"></div>
    <div class="wildshape-pool-row" style="margin-top:8px;">
      <label for="mantleResolveDieInput">Bardic die roll (optional)</label>
      <input id="mantleResolveDieInput" type="number" min="1" step="1" placeholder="Auto-roll if blank" />
    </div>
    <div class="modal-actions" style="margin-top:10px;">
      <button class="btn" id="mantleResolveCancel" type="button">Cancel</button>
      <button class="btn accent" id="mantleResolveUse" type="button">Apply</button>
    </div>
  </div>
</div>
<div class="modal" id="elementalBurstConfigOverlay" aria-hidden="true">
  <div class="card">
    <h2>Elemental Burst</h2>
    <div class="wildshape-pool-row" style="margin-top:8px;">
      <label for="elementalBurstDamageType">Damage type</label>
      <select id="elementalBurstDamageType">
        <option value="acid">Acid</option>
        <option value="cold">Cold</option>
        <option value="fire" selected>Fire</option>
        <option value="lightning">Lightning</option>
        <option value="thunder">Thunder</option>
      </select>
    </div>
    <div class="wildshape-pool-row" style="margin-top:8px;">
      <label for="elementalBurstMovementMode">Movement rider</label>
      <select id="elementalBurstMovementMode">
        <option value="none" selected>None</option>
        <option value="push">Push</option>
        <option value="pull">Pull</option>
      </select>
    </div>
    <div class="modal-actions" style="margin-top:10px;">
      <button class="btn" id="elementalBurstConfigCancel" type="button">Cancel</button>
      <button class="btn accent" id="elementalBurstConfigContinue" type="button">Start Placement</button>
    </div>
  </div>
</div>
<div class="modal" id="layOnHandsOverlay" aria-hidden="true">
  <div class="card">
    <h2>Lay on Hands</h2>
    <div class="spellbook-status" id="layOnHandsSummary"></div>
    <div class="spellbook-status" id="layOnHandsTarget"></div>
    <div class="wildshape-pool-row" style="margin-top:8px;">
      <label for="layOnHandsAmountInput">HP to heal</label>
      <input id="layOnHandsAmountInput" type="number" min="1" step="1" placeholder="1+" />
    </div>
    <label class="chip spellbook-toggle" style="margin-top:8px; display:inline-flex; align-items:center; gap:8px;">
      <input type="checkbox" id="layOnHandsCurePoisonToggle" />
      Spend 5 points to remove Poisoned (no healing)
    </label>
    <div class="modal-actions" style="margin-top:10px;">
      <button class="btn" id="layOnHandsCancel" type="button">Cancel</button>
      <button class="btn accent" id="layOnHandsUse" type="button">Heal</button>
    </div>
  </div>
</div>
<div class="spellbook-overlay" id="wildShapeOverlay" aria-hidden="true">
  <div class="spellbook-header">
    <button class="btn" id="wildShapeBack" type="button">Back</button>
    <div class="spellbook-title" id="wildShapeTitle">Manage Wild Shapes</div>
    <div class="spellbook-spacer"></div>
    <button class="btn accent" id="wildShapeSave" type="button">Save</button>
  </div>
  <div class="spellbook-body">
    <div class="spellbook-controls">
      <input id="wildShapeSearch" type="search" placeholder="Search beast forms..." />
      <label class="chip spellbook-toggle"><input type="checkbox" id="wildShapeShowLocked" />Show locked forms</label>
    </div>
    <div class="spellbook-columns">
      <div class="spellbook-column">
        <div class="spellbook-column-title">Available Beast Forms</div>
        <div class="spellbook-list" id="wildShapeLeftList"></div>
      </div>
      <div class="spellbook-column spellbook-actions">
        <button class="btn" id="wildShapeAdd" type="button">Add </button>
        <button class="btn" id="wildShapeRemove" type="button"> Remove</button>
      </div>
      <div class="spellbook-column">
        <div class="spellbook-column-title">Known Forms</div>
        <div class="spellbook-list" id="wildShapeRightList"></div>
      </div>
    </div>
    <div class="spellbook-status" id="wildShapeStatus"></div>
  </div>
</div>
<div class="modal" id="polymorphFormOverlay" aria-hidden="true">
  <div class="card">
    <h2>Choose Polymorph Form</h2>
    <div class="wildshape-pool-row" style="margin-top:8px;">
      <label for="polymorphFormSearch">Search beast forms</label>
      <input id="polymorphFormSearch" type="search" placeholder="Wolf, brown bear..." />
    </div>
    <div class="spellbook-list" id="polymorphFormList" style="margin-top:8px; max-height: 280px;"></div>
    <div class="modal-actions" style="margin-top:10px;">
      <button class="btn" id="polymorphFormCancel" type="button">Cancel</button>
    </div>
  </div>
</div>
<div class="turn-modal" id="turnModal" aria-hidden="true">
  <div class="turn-card" role="dialog" aria-live="assertive">
    <h2>Its your turn!</h2>
    <div class="turn-countdown" id="turnModalCountdown" aria-live="polite">Alert repeats in 5s</div>
    <button class="btn accent" id="turnModalOk">OK</button>
  </div>
</div>
<div class="turn-flash" id="turnFlash" aria-hidden="true"></div>

<script>
(() => {
  const logClientError = (payload) => {
    try {
      console.error("Client error:", payload);
      fetch("/api/client-log", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify(payload),
      }).catch(() => {});
    } catch (err) {
      console.error("Failed to report client error:", err);
    }
  };

  window.onerror = (message, source, line, column, error) => {
    const stack = error?.stack ? String(error.stack) : "";
    logClientError({
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      url: location.href,
      stack: stack || `${message} at ${source}:${line}:${column}`,
    });
  };

  window.onunhandledrejection = (event) => {
    const reason = event?.reason;
    const stack = reason?.stack ? String(reason.stack) : "";
    const message = reason?.message ? String(reason.message) : String(reason || "");
    logClientError({
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      url: location.href,
      stack: stack || message || "Unhandled promise rejection",
    });
  };
})();

(() => {
  document.addEventListener("contextmenu", (e) => e.preventDefault());
  const canVibrate = "vibrate" in navigator;
  function vibrate(pattern){
    if (!canVibrate) return false;
    return navigator.vibrate(pattern);
  }

  const qs = new URLSearchParams(location.search);
  const normalizedPath = location.pathname.replace(/\/+$/, "") || "/";
  const isMapView = false;
  const isMapViewOnly = false;
  const isPlanning = normalizedPath === "/planning";
  const wsPath = "/ws";
  const wsUrl = (() => {
    const lanBase = (window.LAN_BASE_URL || "").trim();
    const fallbackOrigin = (location.origin && location.origin !== "null") ? location.origin : "";
    const baseCandidate = lanBase || fallbackOrigin;
    if (!baseCandidate){
      const host = location.host || location.hostname;
      if (!host) return "";
      const proto = location.protocol === "https:" ? "wss" : "ws";
      return `${proto}://${host}${wsPath}`;
    }
    try {
      const baseUrl = new URL(baseCandidate, location.href);
      const wsUrlObj = new URL(wsPath, baseUrl);
      wsUrlObj.protocol = wsUrlObj.protocol === "https:" ? "wss:" : "ws:";
      return wsUrlObj.toString();
    } catch (err){
      console.warn("Failed to resolve websocket base URL.", {baseCandidate, err});
      return "";
    }
  })();
  const pushPublicKey = (window.PUSH_PUBLIC_KEY || "").trim();
  const turnAlertStorageKey = "inittracker_turnAlertSubscription";
  const turnAlertHideKey = "inittracker_hideTurnAlerts";
  const spellFilterStorageKey = "inittracker_spellFilters_v2";
  const focusTabOnTurnStorageKey = "inittracker_focus_tab_on_turn";
  const clientIdStorageKey = "inittracker_client_id";
  let swRegistration = null;
  const cidWarningCache = new Set();
  const warnCid = (context, value, reason) => {
    const key = `${context}:${reason}`;
    if (cidWarningCache.has(key)) return;
    cidWarningCache.add(key);
    console.warn(`[CID normalize] ${context}: ${reason}`, {value});
  };
  const normalizeCid = (value, context = "cid") => {
    if (value === null || value === undefined || value === "") return null;
    if (typeof value === "number"){
      if (!Number.isFinite(value)){
        warnCid(context, value, "non-finite number");
        return null;
      }
      if (!Number.isInteger(value)){
        warnCid(context, value, "non-integer number");
        return null;
      }
      return value;
    }
    if (typeof value === "string"){
      const trimmed = value.trim();
      if (!trimmed) return null;
      const parsed = Number(trimmed);
      if (!Number.isFinite(parsed) || !Number.isInteger(parsed)){
        warnCid(context, value, "unusable string");
        return null;
      }
      warnCid(context, value, "coerced string to number");
      return parsed;
    }
    warnCid(context, value, `unsupported ${typeof value}`);
    return null;
  };
  const cidMatches = (left, right, context = "cidMatch") => {
    const leftCid = normalizeCid(left, `${context}.left`);
    const rightCid = normalizeCid(right, `${context}.right`);
    return leftCid !== null && rightCid !== null && leftCid === rightCid;
  };

  function setNotificationStatus(message){
    if (!notificationStatus) return;
    notificationStatus.textContent = message;
  }

  function setTurnAlertStatus(message){
    if (!turnAlertStatus) return;
    turnAlertStatus.textContent = message;
  }

  function isStandaloneDisplay(){
    return window.matchMedia("(display-mode: standalone)").matches || window.navigator.standalone;
  }

  function isiOSLike(){
    const ua = String(navigator.userAgent || "").toLowerCase();
    const platform = String(navigator.platform || "").toLowerCase();
    const touchMac = platform === "macintel" && navigator.maxTouchPoints > 1;
    return /iphone|ipad|ipod/.test(ua) || /iphone|ipad|ipod/.test(platform) || touchMac;
  }

  function getTurnAlertIdentity(){
    const playerId = normalizeCid(claimedCid, "turnAlert.playerId");
    const claimedUnit = getClaimedUnit();
    const playerName = claimedUnit?.name ? String(claimedUnit.name) : "";
    return {
      playerId,
      username: null,
      playerName: playerName || null,
    };
  }

  function formatTurnAlertLabel(identity){
    if (identity?.playerName) return identity.playerName;
    if (identity?.username) return identity.username;
    if (identity?.playerId !== null && identity?.playerId !== undefined){
      return `#${identity.playerId}`;
    }
    return "";
  }

  function persistTurnAlertSubscription(subscription, identity){
    if (!subscription) return;
    const payload = {
      subscription: subscription.toJSON ? subscription.toJSON() : subscription,
      playerId: identity?.playerId ?? null,
      username: identity?.username ?? null,
      label: formatTurnAlertLabel(identity),
      createdAt: new Date().toISOString(),
    };
    try {
      localStorage.setItem(turnAlertStorageKey, JSON.stringify(payload));
    } catch (err){
      console.warn("Unable to store turn alert subscription.", err);
    }
  }

  function loadTurnAlertSubscription(){
    try {
      const raw = localStorage.getItem(turnAlertStorageKey);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (parsed && typeof parsed === "object") return parsed;
    } catch (err){
      console.warn("Unable to read turn alert subscription.", err);
    }
    return null;
  }

  function formatTurnAlertStatus(identity){
    const label = formatTurnAlertLabel(identity);
    return label ? `Subscribed (${label})` : "Subscribed";
  }

  async function syncTurnAlertSubscription(subscription, identity){
    if (!subscription || !identity?.playerId) return;
    const payload = {
      subscription: subscription.toJSON ? subscription.toJSON() : subscription,
      playerId: identity.playerId,
    };
    try {
      await fetch("/api/push/subscribe", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify(payload),
      });
    } catch (err){
      console.warn("Unable to sync turn alert subscription.", err);
    }
  }

  async function refreshTurnAlertStatus(){
    if (!turnAlertStatus) return;
    if (!window.isSecureContext){
      setTurnAlertStatus("HTTPS required.");
      return;
    }
    if (isiOSLike() && !isStandaloneDisplay()){
      setTurnAlertStatus("Install to Home Screen (iOS).");
      return;
    }
    if (!("Notification" in window)){
      setTurnAlertStatus("Notifications not supported.");
      return;
    }
    if (Notification.permission === "denied"){
      setTurnAlertStatus("Permission denied.");
      return;
    }
    if (!("serviceWorker" in navigator)){
      setTurnAlertStatus("Service worker unsupported.");
      return;
    }
    if (!("PushManager" in window)){
      setTurnAlertStatus("Push not supported.");
      return;
    }
    setTurnAlertStatus("Not subscribed.");
    try {
      swRegistration = swRegistration || await navigator.serviceWorker.ready;
      const existing = await swRegistration.pushManager.getSubscription();
      if (existing){
        const stored = loadTurnAlertSubscription();
        setTurnAlertStatus(formatTurnAlertStatus(stored || getTurnAlertIdentity()));
      }
    } catch (err){
      console.warn("Unable to check push subscription.", err);
    }
  }

  async function ensurePushSubscribed({vapidPublicKey, playerId}){
    if (!window.isSecureContext){
      throw new Error("HTTPS is required for push notifications.");
    }
    if (isiOSLike() && !isStandaloneDisplay()){
      throw new Error("On iOS, install this app to your Home Screen first.");
    }
    if (!vapidPublicKey){
      throw new Error("Missing push public key.");
    }
    if (!playerId){
      throw new Error("Claim a character first.");
    }
    if (!("Notification" in window)){
      throw new Error("Notifications are not supported.");
    }
    if (!("serviceWorker" in navigator)){
      throw new Error("Service worker unsupported.");
    }
    if (!("PushManager" in window)){
      throw new Error("Push is not supported.");
    }
    try {
      swRegistration = swRegistration || await navigator.serviceWorker.ready;
    } catch (err){
      throw new Error("Service worker not ready.");
    }
    const permission = await Notification.requestPermission();
    if (permission !== "granted"){
      throw new Error(permission === "denied" ? "Permission denied." : "Permission required.");
    }
    const existing = await swRegistration.pushManager.getSubscription();
    if (existing){
      const identity = getTurnAlertIdentity();
      setTurnAlertStatus(formatTurnAlertStatus(identity));
      await syncTurnAlertSubscription(existing, identity);
      return existing;
    }
    const subscription = await swRegistration.pushManager.subscribe({
      userVisibleOnly: true,
      applicationServerKey: urlBase64ToUint8Array(vapidPublicKey),
    });
    const identity = getTurnAlertIdentity();
    persistTurnAlertSubscription(subscription, identity);
    setTurnAlertStatus(formatTurnAlertStatus(identity));
    await syncTurnAlertSubscription(subscription, identity);
    return subscription;
  }

  function routeDeepLink(url){
    if (!url) return;
    try {
      const target = new URL(url, location.origin);
      if (target.origin === location.origin){
        location.href = target.href;
      } else {
        location.href = url;
      }
    } catch (err){
      location.href = url;
    }
  }

  function urlBase64ToUint8Array(base64String){
    const padding = "=".repeat((4 - (base64String.length % 4)) % 4);
    const base64 = (base64String + padding).replace(/-/g, "+").replace(/_/g, "/");
    const rawData = atob(base64);
    const outputArray = new Uint8Array(rawData.length);
    for (let i = 0; i < rawData.length; ++i){
      outputArray[i] = rawData.charCodeAt(i);
    }
    return outputArray;
  }

  function generateClientId(){
    try {
      if (window.crypto && typeof window.crypto.randomUUID === "function"){
        return window.crypto.randomUUID();
      }
    } catch (err){
      console.warn("Unable to use crypto.randomUUID.", err);
    }
    try {
      if (window.crypto && typeof window.crypto.getRandomValues === "function"){
        const data = new Uint8Array(16);
        window.crypto.getRandomValues(data);
        return Array.from(data).map((byte) => byte.toString(16).padStart(2, "0")).join("");
      }
    } catch (err){
      console.warn("Unable to use crypto.getRandomValues.", err);
    }
    return `client_${Date.now().toString(36)}_${Math.random().toString(36).slice(2)}`;
  }

  function getClientId(){
    let existing = "";
    try {
      existing = String(localStorage.getItem(clientIdStorageKey) || "").trim();
    } catch (err){
      console.warn("Unable to read client id storage.", err);
    }
    if (existing){
      return existing;
    }
    const fresh = generateClientId();
    try {
      localStorage.setItem(clientIdStorageKey, fresh);
    } catch (err){
      console.warn("Unable to persist client id storage.", err);
    }
    return fresh;
  }

  const clientId = getClientId();

  if ("serviceWorker" in navigator){
    navigator.serviceWorker.register("/sw.js")
      .then(() => navigator.serviceWorker.ready)
      .then((registration) => {
        swRegistration = registration;
        navigator.serviceWorker.addEventListener("message", (event) => {
          const data = event.data || {};
          if (data && data.type === "deep-link" && typeof data.url === "string"){
            routeDeepLink(data.url);
          }
        });
      })
      .catch((err) => {
        console.warn("Service worker registration failed.", err);
      });
  }

  const connEl = document.getElementById("conn");
  const connFullTextEl = document.getElementById("connFullText");
  const connCompactLabelEl = document.getElementById("connCompactLabel");
  const connDotEl = document.getElementById("connDot");
  const topbarTitleEl = document.getElementById("topbarTitle");
  const mapViewTurnOrderEl = document.getElementById("mapViewTurnOrder");
  const mapViewTurnOrderStatusEl = document.getElementById("mapViewTurnOrderStatus");
  const mapViewTurnOrderBubbleEl = document.getElementById("mapViewTurnOrderBubble");
  const mapViewTextSizeInput = document.getElementById("mapViewTextSize");
  const mapViewBarHeightInput = document.getElementById("mapViewBarHeight");
  const mapViewChipPaddingInput = document.getElementById("mapViewChipPadding");
  const mapViewChipGapInput = document.getElementById("mapViewChipGap");
  const mapViewCornerRadiusInput = document.getElementById("mapViewCornerRadius");
  const mapViewRotateHandleScaleInput = document.getElementById("mapViewRotateHandleScale");
  const mapViewShowTitleInput = document.getElementById("mapViewShowTitle");
  const mapViewShowStatusInput = document.getElementById("mapViewShowStatus");
  const mapViewShowIndexInput = document.getElementById("mapViewShowIndex");
  const sheetHeightInput = document.getElementById("sheetHeight");
  const battleLogFontFamilyInput = document.getElementById("battleLogFontFamily");
  const battleLogFontSizeInput = document.getElementById("battleLogFontSize");
  const connPopoverEl = document.getElementById("connPopover");
  const connPopoverStatusEl = document.getElementById("connPopoverStatus");
  const connReconnectBtn = document.getElementById("connReconnectBtn");
  const connStyleButtons = Array.from(document.querySelectorAll(".conn-style-btn"));
  const meEl = document.getElementById("me");
  const moveEl = document.getElementById("move");
  const actionEl = document.getElementById("action");
  const attackResourceEl = document.getElementById("attackResource");
  const bonusActionEl = document.getElementById("bonusAction");
  const reactionEl = document.getElementById("reaction");
  const turnEl = document.getElementById("turn");
  const playerHpBarWrap = document.getElementById("playerHpBarWrap");
  const playerHpBarFill = document.getElementById("playerHpBarFill");
  const playerHpBarLabel = document.getElementById("playerHpBarLabel");
  const spellSlotMonitorEl = document.getElementById("spellSlotMonitor");
  const resourcePoolsPanelEl = document.getElementById("resourcePoolsPanel");
  const resourcePoolsListEl = document.getElementById("resourcePoolsList");
  const activeTurnOrderEl = mapViewTurnOrderEl;
  const activeTurnOrderStatusEl = mapViewTurnOrderStatusEl;
  const activeTurnOrderBubbleEl = mapViewTurnOrderBubbleEl;
  if (activeTurnOrderEl){
    activeTurnOrderEl.addEventListener("mouseleave", () => {
      hoveredTurnCid = null;
      hideTurnOrderBubble();
    });
  }
  const noteEl = document.getElementById("note");
  const colorModal = document.getElementById("colorModal");
  const tokenColorInput = document.getElementById("tokenColorInput");
  const tokenColorSwatch = document.getElementById("tokenColorSwatch");
  const tokenColorR = document.getElementById("tokenColorR");
  const tokenColorG = document.getElementById("tokenColorG");
  const tokenColorB = document.getElementById("tokenColorB");
  const tokenBorderColorInput = document.getElementById("tokenBorderColorInput");
  const tokenBorderColorSwatch = document.getElementById("tokenBorderColorSwatch");
  const tokenBorderColorR = document.getElementById("tokenBorderColorR");
  const tokenBorderColorG = document.getElementById("tokenBorderColorG");
  const tokenBorderColorB = document.getElementById("tokenBorderColorB");
  const tokenColorConfirm = document.getElementById("tokenColorConfirm");
  const tokenColorCancel = document.getElementById("tokenColorCancel");
  const tokenColorModeBtn = document.getElementById("tokenColorModeBtn");
  const dashModal = document.getElementById("dashModal");
  const dashActionBtn = document.getElementById("dashAction");
  const dashBonusActionBtn = document.getElementById("dashBonusAction");
  const dashCancelBtn = document.getElementById("dashCancel");
  const actionPickerModal = document.getElementById("actionPickerModal");
  const actionPickerTitle = document.getElementById("actionPickerTitle");
  const actionPickerList = document.getElementById("actionPickerList");
  const actionPickerCancelBtn = document.getElementById("actionPickerCancel");
  const warCasterModal = document.getElementById("warCasterModal");
  const reactionOfferModal = document.getElementById("reactionOfferModal");
  const reactionOfferBody = document.getElementById("reactionOfferBody");
  const reactionOfferList = document.getElementById("reactionOfferList");
  const reactionOfferDecline = document.getElementById("reactionOfferDecline");
  const warCasterSpellSelect = document.getElementById("warCasterSpellSelect");
  const warCasterTargetSelect = document.getElementById("warCasterTargetSelect");
  const warCasterCastBtn = document.getElementById("warCasterCast");
  const warCasterCancelBtn = document.getElementById("warCasterCancel");
  const battleLogBtn = document.getElementById("battleLog");
  const toggleSheetPanelBtn = document.getElementById("toggleSheetPanel");
  const lockMapBtn = document.getElementById("lockMap");
  const lockAoeBtn = document.getElementById("lockAoeToggle");
  const auraToggleBtn = document.getElementById("auraToggle");
  const effectsOverlay = document.getElementById("effectsOverlay");
  const effectsList = document.getElementById("effectsList");
  const centerMapBtn = document.getElementById("centerMap");
  const zoomInBtn = document.getElementById("zoomIn");
  const zoomOutBtn = document.getElementById("zoomOut");
  const dashBtn = document.getElementById("dash");
  const configBtn = document.getElementById("configBtn");
  const helpBtn = document.getElementById("helpBtn");
  const helpModal = document.getElementById("helpModal");
  const helpCloseBtn = document.getElementById("helpClose");
  const helpOpenBookBtn = document.getElementById("helpOpenBook");
  const helpOpenClassBtn = document.getElementById("helpOpenClass");
  const helpOpenTabBtn = document.getElementById("helpOpenTab");
  const helpSearchInput = document.getElementById("helpSearch");
  const helpTocTree = document.getElementById("helpTocTree");
  const helpViewer = document.getElementById("helpViewer");
  const helpMessage = document.getElementById("helpMessage");
  const rulesLastPageStorageKey = "inittracker_rules_last_page_v1";
  const initiativeToggleBtn = document.getElementById("initiativeToggleBtn");
  const configModal = document.getElementById("configModal");
  const configCloseBtn = document.getElementById("configClose");
  const toggleTopbarTitle = document.getElementById("toggleTopbarTitle");
  const toggleConnIndicator = document.getElementById("toggleConnIndicator");
  const toggleLockMap = document.getElementById("toggleLockMap");
  const toggleCenterMap = document.getElementById("toggleCenterMap");
  const toggleMeasure = document.getElementById("toggleMeasure");
  const toggleMeasureClear = document.getElementById("toggleMeasureClear");
  const toggleZoomIn = document.getElementById("toggleZoomIn");
  const toggleZoomOut = document.getElementById("toggleZoomOut");
  const toggleBattleLog = document.getElementById("toggleBattleLog");
  const initiativeStyleSelect = document.getElementById("initiativeStyleSelect");
  const toggleUseAction = document.getElementById("toggleUseAction");
  const toggleUseBonusAction = document.getElementById("toggleUseBonusAction");
  const toggleDash = document.getElementById("toggleDash");
  const toggleStandUp = document.getElementById("toggleStandUp");
  const toggleResetTurn = document.getElementById("toggleResetTurn");
  const toggleSpellMenu = document.getElementById("toggleSpellMenu");
  const toggleLockMenus = document.getElementById("toggleLockMenus");
  const presetSaveBtn = document.getElementById("savePreset");
  const presetLoadBtn = document.getElementById("loadPreset");
  const presetStatus = document.getElementById("presetStatus");
  const enableNotificationsBtn = document.getElementById("enableNotifications");
  const notificationStatus = document.getElementById("notificationStatus");
  const focusTabOnTurnInput = document.getElementById("focusTabOnTurn");
  const unlockAudioBtn = document.getElementById("unlockAudio");
  const enableTurnAlertsBtn = document.getElementById("enableTurnAlerts");
  const hideTurnAlertsBtn = document.getElementById("hideTurnAlerts");
  const turnAlertsPanel = document.getElementById("turnAlertsPanel");
  const turnAlertStatus = document.getElementById("turnAlertStatus");
  const hotkeyTopbarTitleInput = document.getElementById("hotkeyTopbarTitle");
  const hotkeyConnStyleInput = document.getElementById("hotkeyConnStyle");
  const hotkeyLockMapInput = document.getElementById("hotkeyLockMap");
  const hotkeyCenterMapInput = document.getElementById("hotkeyCenterMap");
  const hotkeyMeasureInput = document.getElementById("hotkeyMeasure");
  const hotkeyMeasureClearInput = document.getElementById("hotkeyMeasureClear");
  const hotkeyZoomInInput = document.getElementById("hotkeyZoomIn");
  const hotkeyZoomOutInput = document.getElementById("hotkeyZoomOut");
  const hotkeyBattleLogInput = document.getElementById("hotkeyBattleLog");
  const hotkeyUseActionInput = document.getElementById("hotkeyUseAction");
  const toggleDmLogPanelInput = document.getElementById("toggleDmLogPanel");
  const toggleDmMapPreviewInput = document.getElementById("toggleDmMapPreview");
  const hotkeyUseBonusActionInput = document.getElementById("hotkeyUseBonusAction");
  const hotkeyDashInput = document.getElementById("hotkeyDash");
  const hotkeyStandUpInput = document.getElementById("hotkeyStandUp");
  const hotkeyResetTurnInput = document.getElementById("hotkeyResetTurn");
  const hotkeyToggleSheetPanelInput = document.getElementById("hotkeyToggleSheetPanel");
  const hotkeyAttackOverlayInput = document.getElementById("hotkeyAttackOverlay");
  const iosInstallHint = document.getElementById("iosInstallHint");
  const measureToggle = document.getElementById("measureToggle");
  const attackOverlayToggleBtn = document.getElementById("attackOverlayToggle");
  const measureClear = document.getElementById("measureClear");
  const logModal = document.getElementById("logModal");
  const logHeader = document.getElementById("logHeader");
  const logContent = document.getElementById("logContent");
  const logResizeHandle = document.getElementById("logResizeHandle");
  const logCloseBtn = document.getElementById("logClose");
  const dmSideLayout = document.getElementById("dmSideLayout");
  const dmLogPanel = document.getElementById("dmLogPanel");
  const dmLogList = document.getElementById("dmLogList");
  const mapViewLogPanel = document.getElementById("mapViewLogPanel");
  const mapViewLogList = document.getElementById("mapViewLogList");
  const dmMapPreview = document.getElementById("dmMapPreview");
  const dmPreviewCanvas = document.getElementById("dmPreviewCanvas");
  const dmLogAutoScrollInput = document.getElementById("dmLogAutoScroll");
  const dmLogFilterInputs = Array.from(document.querySelectorAll("input[data-log-filter]"));
  const waitingOverlay = document.getElementById("waitingOverlay");
  const claimModal = document.getElementById("claimModal");
  const claimListEl = document.getElementById("claimList");
  const claimEmptyHint = document.getElementById("claimEmptyHint");
  const claimConfirmBtn = document.getElementById("claimConfirm");
  const claimSpectatorBtn = document.getElementById("claimSpectator");
  const claimContinueBtn = document.getElementById("claimContinue");
  const turnModal = document.getElementById("turnModal");
  const turnModalOk = document.getElementById("turnModalOk");
  const turnModalCountdown = document.getElementById("turnModalCountdown");
  const turnFlash = document.getElementById("turnFlash");
  const switchCharacterBtn = document.getElementById("switchCharacter");
  const useActionBtn = document.getElementById("useAction");
  const useBonusActionBtn = document.getElementById("useBonusAction");
  const useReactionBtn = document.getElementById("useReaction");
  const actionSelectEl = document.getElementById("actionSelect");
  const bonusActionSelectEl = document.getElementById("bonusActionSelect");
  const mainhandWeaponSelectEl = document.getElementById("mainhandWeaponSelect");
  const offhandWeaponSelectEl = document.getElementById("offhandWeaponSelect");
  const resetTurnBtn = document.getElementById("resetTurn");
  const standUpBtn = document.getElementById("standUp");
  const dismissSummonsBtn = document.getElementById("dismissSummons");
  const endTurnBtn = document.getElementById("endTurn");
  const endTurnSheetBtn = document.getElementById("endTurnSheet");
  const mountBtn = document.getElementById("mountBtn");
  const dismountBtn = document.getElementById("dismountBtn");
  const mountPromptModal = document.getElementById("mountPromptModal");
  const mountPromptBody = document.getElementById("mountPromptBody");
  const mountPromptYes = document.getElementById("mountPromptYes");
  const mountPromptNo = document.getElementById("mountPromptNo");
  const echoTetherPromptModal = document.getElementById("echoTetherPromptModal");
  const echoTetherPromptBody = document.getElementById("echoTetherPromptBody");
  const echoTetherPromptYes = document.getElementById("echoTetherPromptYes");
  const echoTetherPromptNo = document.getElementById("echoTetherPromptNo");
  const initiativePromptModal = document.getElementById("initiativePromptModal");
  const initiativePromptBody = document.getElementById("initiativePromptBody");
  const initiativePromptInput = document.getElementById("initiativePromptInput");
  const initiativePromptSubmit = document.getElementById("initiativePromptSubmit");
  const initiativePromptCancel = document.getElementById("initiativePromptCancel");
  const attackResolveModal = document.getElementById("attackResolveModal");
  const attackResolveBody = document.getElementById("attackResolveBody");
  const attackResolveHit = document.getElementById("attackResolveHit");
  const attackResolveMiss = document.getElementById("attackResolveMiss");
  const attackResolveCrit = document.getElementById("attackResolveCrit");
  const attackStunningStrikeRow = document.getElementById("attackStunningStrikeRow");
  const attackStunningStrike = document.getElementById("attackStunningStrike");
  const attackDamageTypeOverrideRow = document.getElementById("attackDamageTypeOverrideRow");
  const attackDamageTypeOverrideSelect = document.getElementById("attackDamageTypeOverrideSelect");
  const attackTacticalMasterRow = document.getElementById("attackTacticalMasterRow");
  const attackTacticalMasterSelect = document.getElementById("attackTacticalMasterSelect");
  const attackDamageRows = document.getElementById("attackDamageRows");
  const attackDamageAdd = document.getElementById("attackDamageAdd");
  const attackResolveSubmit = document.getElementById("attackResolveSubmit");
  const attackResolveCancel = document.getElementById("attackResolveCancel");
  const spellResolveModal = document.getElementById("spellResolveModal");
  const spellResolveBody = document.getElementById("spellResolveBody");
  const spellResolveDamageRows = document.getElementById("spellResolveDamageRows");
  const spellResolveAddDamage = document.getElementById("spellResolveAddDamage");
  const spellResolveSubmit = document.getElementById("spellResolveSubmit");
  const spellResolveCancel = document.getElementById("spellResolveCancel");
  const sculptSelectModal = document.getElementById("sculptSelectModal");
  const sculptSelectBody = document.getElementById("sculptSelectBody");
  const sculptSelectList = document.getElementById("sculptSelectList");
  const sculptSelectConfirm = document.getElementById("sculptSelectConfirm");
  const sculptSelectCancel = document.getElementById("sculptSelectCancel");
  const cleavePromptModal = document.getElementById("cleavePromptModal");
  const cleavePromptBody = document.getElementById("cleavePromptBody");
  const cleavePromptList = document.getElementById("cleavePromptList");
  const cleavePromptCancel = document.getElementById("cleavePromptCancel");
  const showAllNamesEl = document.getElementById("showAllNames");
  const castOverlay = document.getElementById("sheetCastView");
  const castOverlayOpenBtn = document.getElementById("castOverlayOpen");
  const castOverlayBackBtn = document.getElementById("castOverlayBack");
  const castMenuTrigger = document.getElementById("castMenuTrigger");
  const castSpellModal = document.getElementById("castSpellModal");
  const castSpellModalOpenBtn = document.getElementById("castSpellModalOpen");
  const castSpellModalBackBtn = document.getElementById("castSpellModalBack");
  const castSpellModalManageSpellsBtn = document.getElementById("castSpellModalManageSpells");
  const castSpellModalCloseBtn = document.getElementById("castSpellModalClose");
  const castSpellModalSearchInput = document.getElementById("castSpellModalSearch");
  const castSpellModalSortInput = document.getElementById("castSpellModalSort");
  const castSpellPresetList = document.getElementById("castSpellPresetList");
  const castSpellPresetSummary = document.getElementById("castSpellPresetSummary");
  const castSpellPreview = document.getElementById("castSpellPreview");
  if (castSpellModal?.parentElement?.classList?.contains("modal")){
    console.warn("#castSpellModal is nested inside another .modal and may not display correctly.");
  }
  const castPanel = document.getElementById("castPanel");
  const castForm = document.getElementById("castForm");
  const castSearchInput = document.getElementById("castSearch");
  const openSpellFiltersBtn = document.getElementById("openSpellFilters");
  const closeSpellFiltersBtn = document.getElementById("closeSpellFilters");
  const applySpellFiltersBtn = document.getElementById("applySpellFilters");
  const clearSpellFiltersBtn = document.getElementById("clearSpellFilters");
  const spellFilterModal = document.getElementById("spellFilterModal");
  const spellFilterSummary = document.getElementById("spellFilterSummary");
  const castFilterLevelMinInput = document.getElementById("castFilterLevelMin");
  const castFilterLevelMaxInput = document.getElementById("castFilterLevelMax");
  const castFilterSchoolOptions = document.getElementById("castFilterSchoolOptions");
  const castFilterTagOptions = document.getElementById("castFilterTagOptions");
  const castFilterListOptions = document.getElementById("castFilterListOptions");
  const castFilterSchoolMulti = document.getElementById("castFilterSchoolMulti");
  const castFilterTagMulti = document.getElementById("castFilterTagMulti");
  const castFilterListMulti = document.getElementById("castFilterListMulti");
  const castFilterCastingTimeInput = document.getElementById("castFilterCastingTime");
  const castFilterRangeInput = document.getElementById("castFilterRange");
  const castFilterRitualInput = document.getElementById("castFilterRitual");
  const castFilterConcentrationInput = document.getElementById("castFilterConcentration");
  const castPresetInput = document.getElementById("castPreset");
  const castManualEntryBadge = document.getElementById("castManualEntryBadge");
  const planningBtn = document.getElementById("planningBtn");
  const inventoryBtn = document.getElementById("inventoryBtn");
  const inventoryRow = document.getElementById("inventoryRow");
  const planningAoeBtn = document.getElementById("planningAoeBtn");
  const planningChatBtn = document.getElementById("planningChatBtn");
  const planningChatOverlay = document.getElementById("planningChatOverlay");
  const planningChatCloseBtn = document.getElementById("planningChatClose");
  const planningChatList = document.getElementById("planningChatList");
  const planningChatForm = document.getElementById("planningChatForm");
  const planningChatInput = document.getElementById("planningChatInput");
  const planningChatHeader = document.getElementById("planningChatHeader");
  const planningChatResizeHandle = document.getElementById("planningChatResizeHandle");
  const spellLibraryBtn = document.getElementById("spellLibraryBtn");
  const spellLibraryOverlay = document.getElementById("spellLibraryOverlay");
  const spellLibraryCloseBtn = document.getElementById("spellLibraryClose");
  const spellLibraryManageSpellsBtn = document.getElementById("spellLibraryManageSpells");
  const spellLibrarySearchInput = document.getElementById("spellLibrarySearch");
  const spellLibrarySortSelect = document.getElementById("spellLibrarySort");
  const spellLibraryAoeOnlyWrap = document.getElementById("spellLibraryAoeOnlyWrap");
  const spellLibraryAoeOnlyInput = document.getElementById("spellLibraryAoeOnly");
  const spellLibraryStatus = document.getElementById("spellLibraryStatus");
  const spellLibraryList = document.getElementById("spellLibraryList");
  const spellbookOpenBtn = document.getElementById("spellbookOpen");
  const wildShapeManageOpenBtn = document.getElementById("wildShapeManageOpen");
  const wildShapeMenuOverlay = document.getElementById("wildShapeMenuOverlay");
  const wildShapeMenuManagePoolBtn = document.getElementById("wildShapeMenuManagePool");
  const wildShapeMenuManageFormsBtn = document.getElementById("wildShapeMenuManageForms");
  const wildShapeMenuApplyBtn = document.getElementById("wildShapeMenuApply");
  const wildShapeMenuRevertBtn = document.getElementById("wildShapeMenuRevert");
  const wildShapeMenuRegainUseBtn = document.getElementById("wildShapeMenuRegainUse");
  const wildShapeMenuRegainSpellBtn = document.getElementById("wildShapeMenuRegainSpell");
  const wildShapeMenuCloseBtn = document.getElementById("wildShapeMenuClose");
  const wildShapePoolOverlay = document.getElementById("wildShapePoolOverlay");
  const wildShapePoolSummary = document.getElementById("wildShapePoolSummary");
  const wildShapePoolCurrentInput = document.getElementById("wildShapePoolCurrentInput");
  const wildShapePoolDecBtn = document.getElementById("wildShapePoolDec");
  const wildShapePoolIncBtn = document.getElementById("wildShapePoolInc");
  const wildShapePoolBackBtn = document.getElementById("wildShapePoolBack");
  const wildShapePoolApplyBtn = document.getElementById("wildShapePoolApply");
  const wildShapePickOverlay = document.getElementById("wildShapePickOverlay");
  const wildShapePickList = document.getElementById("wildShapePickList");
  const wildShapePickBackBtn = document.getElementById("wildShapePickBack");
  const secondWindOverlay = document.getElementById("secondWindOverlay");
  const secondWindSummary = document.getElementById("secondWindSummary");
  const secondWindRollInput = document.getElementById("secondWindRollInput");
  const secondWindCancelBtn = document.getElementById("secondWindCancel");
  const secondWindUseBtn = document.getElementById("secondWindUse");
  const monkFocusOverlay = document.getElementById("monkFocusOverlay");
  const monkFocusSummary = document.getElementById("monkFocusSummary");
  const resourcePoolDetailOverlay = document.getElementById("resourcePoolDetailOverlay");
  const resourcePoolDetailTitle = document.getElementById("resourcePoolDetailTitle");
  const resourcePoolDetailSummary = document.getElementById("resourcePoolDetailSummary");
  const resourcePoolDetailActions = document.getElementById("resourcePoolDetailActions");
  const resourcePoolDetailSpells = document.getElementById("resourcePoolDetailSpells");
  const resourcePoolDetailCloseBtn = document.getElementById("resourcePoolDetailClose");
  const poolSpellConfirmModal = document.getElementById("poolSpellConfirmModal");
  const poolSpellConfirmTitle = document.getElementById("poolSpellConfirmTitle");
  const poolSpellConfirmMessage = document.getElementById("poolSpellConfirmMessage");
  const poolSpellConfirmCancelBtn = document.getElementById("poolSpellConfirmCancel");
  const poolSpellConfirmCastBtn = document.getElementById("poolSpellConfirmCast");
  const beguilingMagicModal = document.getElementById("beguilingMagicModal");
  const beguilingMagicConditionInput = document.getElementById("beguilingMagicCondition");
  const beguilingMagicStatus = document.getElementById("beguilingMagicStatus");
  const beguilingMagicCancelBtn = document.getElementById("beguilingMagicCancel");
  const beguilingMagicConfirmBtn = document.getElementById("beguilingMagicConfirm");
  const commandOptionModal = document.getElementById("commandOptionModal");
  const commandOptionSelect = document.getElementById("commandOptionSelect");
  const commandOptionStatus = document.getElementById("commandOptionStatus");
  const commandOptionCancelBtn = document.getElementById("commandOptionCancel");
  const commandOptionConfirmBtn = document.getElementById("commandOptionConfirm");
  const bardicDiceConfirmModal = document.getElementById("bardicDiceConfirmModal");
  const bardicDiceConfirmStatus = document.getElementById("bardicDiceConfirmStatus");
  const bardicDiceConfirmCancelBtn = document.getElementById("bardicDiceConfirmCancel");
  const bardicDiceConfirmYesBtn = document.getElementById("bardicDiceConfirmYes");
  const mantleResolveModal = document.getElementById("mantleResolveModal");
  const mantleResolveSummary = document.getElementById("mantleResolveSummary");
  const mantleResolveDieInput = document.getElementById("mantleResolveDieInput");
  const mantleResolveCancelBtn = document.getElementById("mantleResolveCancel");
  const mantleResolveUseBtn = document.getElementById("mantleResolveUse");
  const monkPatientDefenseFreeBtn = document.getElementById("monkPatientDefenseFree");
  const monkPatientDefenseFocusBtn = document.getElementById("monkPatientDefenseFocus");
  const monkStepOfWindFreeBtn = document.getElementById("monkStepOfWindFree");
  const monkStepOfWindFocusBtn = document.getElementById("monkStepOfWindFocus");
  const monkMartialArtsBonusBtn = document.getElementById("monkMartialArtsBonus");
  const monkFlurryOfBlowsBtn = document.getElementById("monkFlurryOfBlows");
  const monkElementalAttunementToggleBtn = document.getElementById("monkElementalAttunementToggle");
  const monkElementalBurstBtn = document.getElementById("monkElementalBurst");
  const monkUncannyMetabolismBtn = document.getElementById("monkUncannyMetabolism");
  const monkFocusCloseBtn = document.getElementById("monkFocusClose");
  const elementalBurstConfigOverlay = document.getElementById("elementalBurstConfigOverlay");
  const elementalBurstDamageTypeInput = document.getElementById("elementalBurstDamageType");
  const elementalBurstMovementModeInput = document.getElementById("elementalBurstMovementMode");
  const elementalBurstConfigCancelBtn = document.getElementById("elementalBurstConfigCancel");
  const elementalBurstConfigContinueBtn = document.getElementById("elementalBurstConfigContinue");
  const layOnHandsOverlay = document.getElementById("layOnHandsOverlay");
  const layOnHandsSummary = document.getElementById("layOnHandsSummary");
  const layOnHandsTarget = document.getElementById("layOnHandsTarget");
  const layOnHandsAmountInput = document.getElementById("layOnHandsAmountInput");
  const layOnHandsCancelBtn = document.getElementById("layOnHandsCancel");
  const layOnHandsUseBtn = document.getElementById("layOnHandsUse");
  const layOnHandsCurePoisonToggle = document.getElementById("layOnHandsCurePoisonToggle");
  const wildShapeOverlay = document.getElementById("wildShapeOverlay");
  const wildShapeBackBtn = document.getElementById("wildShapeBack");
  const wildShapeSaveBtn = document.getElementById("wildShapeSave");
  const wildShapeSearchInput = document.getElementById("wildShapeSearch");
  const wildShapeShowLockedInput = document.getElementById("wildShapeShowLocked");
  const wildShapeLeftList = document.getElementById("wildShapeLeftList");
  const wildShapeRightList = document.getElementById("wildShapeRightList");
  const wildShapeAddBtn = document.getElementById("wildShapeAdd");
  const wildShapeRemoveBtn = document.getElementById("wildShapeRemove");
  const wildShapeStatusEl = document.getElementById("wildShapeStatus");
  const spellbookOverlay = document.getElementById("spellbookOverlay");
  const spellbookBackBtn = document.getElementById("spellbookBack");
  const spellbookBackFloatingBtn = document.getElementById("spellbookBackFloating");
  const spellbookSaveBtn = document.getElementById("spellbookSave");
  const spellbookTabKnown = document.getElementById("spellbookTabKnown");
  const spellbookTabPrepared = document.getElementById("spellbookTabPrepared");
  const spellbookKnownEnabledToggle = document.getElementById("spellbookKnownEnabled");
  const spellbookSearchInput = document.getElementById("spellbookSearch");
  const spellbookSortSelect = document.getElementById("spellbookSort");
  const spellbookLeftTitle = document.getElementById("spellbookLeftTitle");
  const spellbookRightTitle = document.getElementById("spellbookRightTitle");
  const spellbookFreePreparedTitle = document.getElementById("spellbookFreePreparedTitle");
  const spellbookFreePreparedList = document.getElementById("spellbookFreePreparedList");
  const spellbookLeftList = document.getElementById("spellbookLeftList");
  const spellbookRightList = document.getElementById("spellbookRightList");
  const spellbookAddBtn = document.getElementById("spellbookAdd");
  const spellbookRemoveBtn = document.getElementById("spellbookRemove");
  const spellbookStatus = document.getElementById("spellbookStatus");
  const spellbookConfirmModal = document.getElementById("spellbookConfirmModal");
  const spellbookConfirmText = document.getElementById("spellbookConfirmText");
  const spellbookConfirmCancel = document.getElementById("spellbookConfirmCancel");
  const spellbookConfirmYes = document.getElementById("spellbookConfirmYes");
  const spellDetailOverlay = document.getElementById("spellDetailOverlay");
  const spellDetailBackBtn = document.getElementById("spellDetailBack");
  const spellDetailTitle = document.getElementById("spellDetailTitle");
  const spellDetailName = document.getElementById("spellDetailName");
  const spellDetailMeta = document.getElementById("spellDetailMeta");
  const spellDetailGrid = document.getElementById("spellDetailGrid");
  const spellDetailColorInput = document.getElementById("spellDetailColorInput");
  const spellDetailColorSwatch = document.getElementById("spellDetailColorSwatch");
  const spellDetailColorValue = document.getElementById("spellDetailColorValue");
  const spellDetailStatus = document.getElementById("spellDetailStatus");
  const castNameInput = document.getElementById("castName");
  const castSubmitBtn = document.getElementById("castSubmit");
  const aoeOptions = document.getElementById("aoeOptions");
  const summonOptions = document.getElementById("summonOptions");
  const castSummonChoiceInput = document.getElementById("castSummonChoice");
  const castSummonVariantInput = document.getElementById("castSummonVariant");
  const castSummonQuantityInput = document.getElementById("castSummonQuantity");
  const castSummonMeta = document.getElementById("castSummonMeta");
  const castSummonChoiceField = document.getElementById("castSummonChoiceField");
  const castSummonVariantField = document.getElementById("castSummonVariantField");
  const castSummonVariantLabel = castSummonVariantField?.querySelector("label");
  const castSummonQuantityField = document.getElementById("castSummonQuantityField");
  const castCustomSummonNameField = document.getElementById("castCustomSummonNameField");
  const castCustomSummonMonsterSearchField = document.getElementById("castCustomSummonMonsterSearchField");
  const castCustomSummonMonsterField = document.getElementById("castCustomSummonMonsterField");
  const castCustomSummonTypeField = document.getElementById("castCustomSummonTypeField");
  const castCustomSummonHpField = document.getElementById("castCustomSummonHpField");
  const castCustomSummonAcField = document.getElementById("castCustomSummonAcField");
  const castCustomSummonWalkField = document.getElementById("castCustomSummonWalkField");
  const castCustomSummonSwimField = document.getElementById("castCustomSummonSwimField");
  const castCustomSummonFlyField = document.getElementById("castCustomSummonFlyField");
  const castCustomSummonBurrowField = document.getElementById("castCustomSummonBurrowField");
  const castCustomSummonClimbField = document.getElementById("castCustomSummonClimbField");
  const castCustomSummonStrField = document.getElementById("castCustomSummonStrField");
  const castCustomSummonDexField = document.getElementById("castCustomSummonDexField");
  const castCustomSummonConField = document.getElementById("castCustomSummonConField");
  const castCustomSummonIntField = document.getElementById("castCustomSummonIntField");
  const castCustomSummonWisField = document.getElementById("castCustomSummonWisField");
  const castCustomSummonChaField = document.getElementById("castCustomSummonChaField");
  const castCustomSummonRangeField = document.getElementById("castCustomSummonRangeField");
  const castCustomSummonNameInput = document.getElementById("castCustomSummonName");
  const castCustomSummonMonsterSearchInput = document.getElementById("castCustomSummonMonsterSearch");
  const castCustomSummonMonsterInput = document.getElementById("castCustomSummonMonster");
  const castCustomSummonTypeInput = document.getElementById("castCustomSummonType");
  const castCustomSummonHpInput = document.getElementById("castCustomSummonHp");
  const castCustomSummonAcInput = document.getElementById("castCustomSummonAc");
  const castCustomSummonWalkInput = document.getElementById("castCustomSummonWalk");
  const castCustomSummonSwimInput = document.getElementById("castCustomSummonSwim");
  const castCustomSummonFlyInput = document.getElementById("castCustomSummonFly");
  const castCustomSummonBurrowInput = document.getElementById("castCustomSummonBurrow");
  const castCustomSummonClimbInput = document.getElementById("castCustomSummonClimb");
  const castCustomSummonStrInput = document.getElementById("castCustomSummonStr");
  const castCustomSummonDexInput = document.getElementById("castCustomSummonDex");
  const castCustomSummonConInput = document.getElementById("castCustomSummonCon");
  const castCustomSummonIntInput = document.getElementById("castCustomSummonInt");
  const castCustomSummonWisInput = document.getElementById("castCustomSummonWis");
  const castCustomSummonChaInput = document.getElementById("castCustomSummonCha");
  const castCustomSummonRangeInput = document.getElementById("castCustomSummonRange");
  const castShapeInput = document.getElementById("castShape");
  const castRadiusField = document.getElementById("castRadiusField");
  const castSideField = document.getElementById("castSideField");
  const castLengthField = document.getElementById("castLengthField");
  const castWidthField = document.getElementById("castWidthField");
  const castAngleField = document.getElementById("castAngleField");
  const castOrientField = document.getElementById("castOrientField");
  const castThicknessField = document.getElementById("castThicknessField");
  const castHeightField = document.getElementById("castHeightField");
  const castRadiusInput = document.getElementById("castRadius");
  const castSideInput = document.getElementById("castSide");
  const castLengthInput = document.getElementById("castLength");
  const castWidthInput = document.getElementById("castWidth");
  const castAngleInput = document.getElementById("castAngle");
  const castOrientInput = document.getElementById("castOrient");
  const castThicknessInput = document.getElementById("castThickness");
  const castHeightInput = document.getElementById("castHeight");
  const castDcTypeInput = document.getElementById("castDcType");
  const castDcValueInput = document.getElementById("castDcValue");
  const castDefaultDamageInput = document.getElementById("castDefaultDamage");
  const castDiceInput = document.getElementById("castDice");
  const castSlotLevelInput = document.getElementById("castSlotLevel");
  const castDamageTypeInput = document.getElementById("castDamageType");
  const castDamageTypeList = document.getElementById("castDamageTypeList");
  const castAddDamageTypeBtn = document.getElementById("castAddDamageType");
  const castColorInput = document.getElementById("castColor");
  const castShapeField = castShapeInput?.closest(".form-field");
  const castDcTypeField = castDcTypeInput?.closest(".form-field");
  const castDcValueField = castDcValueInput?.closest(".form-field");
  const castDefaultDamageField = castDefaultDamageInput?.closest(".form-field");
  const castDiceField = castDiceInput?.closest(".form-field");
  const spellPresetDetails = document.getElementById("spellPresetDetails");
  const sheetWrap = document.getElementById("sheetWrap");
  const sheet = document.getElementById("sheet");
  const sheetHandle = document.getElementById("sheetHandle");
  const tokenTooltip = document.getElementById("tokenTooltip");
  const summonPlacementBanner = document.getElementById("summonPlacementBanner");
  const aoeTargetPreview = document.getElementById("aoeTargetPreview");
  const aoeTargetPreviewAllies = document.getElementById("aoeTargetPreviewAllies");
  const aoeTargetPreviewEnemies = document.getElementById("aoeTargetPreviewEnemies");
  const spellTargetSelectionUi = document.getElementById("spellTargetSelectionUi");
  const spellTargetSelectionCounter = document.getElementById("spellTargetSelectionCounter");
  const spellTargetSelectionList = document.getElementById("spellTargetSelectionList");
  const spellTargetSelectionRemoveLastBtn = document.getElementById("spellTargetSelectionRemoveLast");
  const spellTargetSelectionCancelBtn = document.getElementById("spellTargetSelectionCancel");
  const spellTargetSelectionConfirmBtn = document.getElementById("spellTargetSelectionConfirm");
  const polymorphFormOverlay = document.getElementById("polymorphFormOverlay");
  const polymorphFormSearchInput = document.getElementById("polymorphFormSearch");
  const polymorphFormList = document.getElementById("polymorphFormList");
  const polymorphFormCancelBtn = document.getElementById("polymorphFormCancel");
  const aimlessAoeConfirm = document.getElementById("aimlessAoeConfirm");
  const aimlessAoeConfirmBtn = document.getElementById("aimlessAoeConfirmBtn");
  const aimlessAoeCancelBtn = document.getElementById("aimlessAoeCancelBtn");
  const clientInitPayload = {
    timestamp: new Date().toISOString(),
    userAgent: navigator.userAgent,
    url: location.href,
    message: "LAN client initialized",
    stack: "",
  };
  console.info("LAN client initialized");
  document.documentElement.dataset.lanBoot = "true";
  try {
    fetch("/api/client-log", {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify(clientInitPayload),
    }).catch(() => {});
  } catch (err) {
    console.warn("Failed to report LAN client init:", err);
  }
  const turnAlertAudio = new Audio("/assets/alert.wav");
  turnAlertAudio.preload = "auto";
  const koAlertAudio = new Audio("/assets/ko.wav");
  koAlertAudio.preload = "auto";
  let audioUnlocked = false;
  let focusTabOnTurn = localStorage.getItem(focusTabOnTurnStorageKey) === "1";
  let pendingTurnAlert = false;
  let pendingVibrate = false;
  let turnModalCountdownInterval = null;
  let turnModalAttentionTimeout = null;
  let turnModalCountdownValue = 5;
  const notificationPermissionAskedKey = "inittracker_notification_permission_asked_v1";
  let notificationPermissionAsked = localStorage.getItem(notificationPermissionAskedKey) === "1";
  let lastVibrateSupported = canVibrate;
  let userHasInteracted = navigator.userActivation?.hasBeenActive ?? false;
  let castOverlayPreviousFocus = null;
  let castSpellModalPreviousFocus = null;
  let castSpellModalSelection = "";
  let pendingSpellActionType = null;
  let forcedPoolCastContext = null;
  let pendingSummonPlacement = null;
  let pendingAoePlacement = null;
  let aoeAimGuide = null; // {start,end,blocked,outOfRange,invalid,distFt,rangeFt,facingDeg,casterCid}
  let pendingSpellResolve = null;
  let pendingSculptSelect = null;
  const castAutomationStorageKey = "inittracker_cast_automation_enabled";
  let castAutomationEnabled = localStorage.getItem(castAutomationStorageKey) !== "0";
  let summonValidCells = new Set();
  let aoeTargetPreviewSignature = "";
  const preparedSpellDefaults = {
    prepared: [],
    preparedFree: [],
    max: null,
    maxFormula: "",
    known: [],
    knownFree: [],
    knownLimit: null,
    knownEnabled: true,
    cantrips: [],
    cantripsMax: null,
  };

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  let ws = null;
  let state = null;
  let planningSnapshotLocked = false;
  let planningChatOpen = false;
  let planningChatMessages = [];
  const planningChatMaxMessages = 200;
  let reconnectTimer = null;
  let reconnecting = false;
  let claimedCid = null;
  claimedCid = normalizeCid(claimedCid, "init.claimedCid");
  let shownNoOwnedToast = false;
  let pendingClaim = null;
  let lastPcList = [];
  let claimStaticDataSeen = false;
  let claimStateSeen = false;
  let claimDataReady = false;
  let claimRenderRetryTimer = null;
  const claimRenderRetryDelayMs = 500;
  let allowUnclaimed = false;
  let selectedClaimCid = null;
  const lanSelectedCidKey = "lan_selected_cid";
  const lanSelectedNameKey = "lan_selected_name";
  const autoClaimTimeoutMs = 1500;
  let autoClaimPending = null;
  let autoClaimChecked = false;
  let claimInFlight = false;
  let claimInFlightCid = null;
  let claimInFlightTimeoutId = null;
  const claimInFlightTimeoutMs = 8000;
  let claimStatus = "unclaimed";
  let claimRev = 0;
  let stateUpdateCounter = 0;
  let lastActiveCid = null;
  let lastTurnRound = null;
  let turnAlertPrimed = false;
  const turnNotificationAutoCloseMs = 5000;
  let endTurnReadyVisualActive = false;
  let selectedTurnCid = null;
  let pendingMountRequestId = null;
  let pendingEchoTetherRequestId = null;
  let pendingInitiativeCid = null;
  let pendingMountPair = null;
  let hoveredTurnCid = null;
  const claimDebugLoggingEnabled = window.location.hostname === "localhost"
    || window.location.hostname === "127.0.0.1";

  // view transform
  let zoom = 32; // px per square
  let panX = 0, panY = 0;
  let dragging = null; // {cid, startX, startY, origCol, origRow}
  let rotatingToken = null; // {cid}
  let rotatePreviewDeg = null;
  let aoeDragging = null; // {aid, offsetCol, offsetRow, isRotating}
  let aoeDragPreview = null; // {aid, cx, cy, angle_deg, ax, ay, spread_deg}
  let aoeDragPending = null; // {pointerId, aid, offsetCol, offsetRow, centerCol, centerRow, startX, startY, timerId}
  let panning = null;  // {x,y, panX, panY}
  let shiftMoveMode = false;
  const isShiftKey = (event) => (
    event?.key === "Shift"
    || event?.code === "ShiftLeft"
    || event?.code === "ShiftRight"
  );
  let centeredCid = null;
  let initialCenterDone = false;
  let initialCenterFallback = false;
  let lockMap = false;
  let lastGrid = {cols: null, rows: null};
  let lastGridVersion = null;
  let roughTerrainVersion = 0;
  let obstacleVersion = 0;
  let cachedRoughMap = null;
  let cachedRoughMapVersion = -1;
  let cachedObstacleSet = null;
  let cachedObstacleSetVersion = -1;
  let movementRangeCacheKey = "";
  let movementRangeCostMap = null;
  const movementRangePerfDebug = localStorage.getItem("lanPerfDebug") === "1";
  const movementRangeCacheStats = {hits: 0, misses: 0};
  if (movementRangePerfDebug){
    window.__lanMovementRangeCacheStats = movementRangeCacheStats;
  }
  let fittedToGrid = false;
  let showAllNames = localStorage.getItem("inittracker_showAllNames") === "1";
  let measurementMode = false;
  let measurement = {start: null, end: null};
  let attackOverlayMode = false;
  const weaponSelectionStorageKey = "inittracker_weapon_selection_by_character";
  let selectedMainhandWeaponValue = "";
  let selectedOffhandWeaponValue = "";
  let cachedOffhandWeaponValue = "";
  let weaponSelectionCharacterKey = "";
  let equipmentSyncStateKey = "";
  let inventoryPanelOpen = false;
  let pendingAttackResolve = null;
  let pendingActionAttackWeapon = null;
  let pendingMonkBonusAttackSequence = null;
  let pendingUnleashIncarnation = null;
  let pendingOpportunityAttack = false;
  let pendingReactionRequestId = "";
  let pendingReactionOffer = null;
  let pendingCleavePrompt = null;
  let pendingSpellTargeting = null;
  let pendingSpellTargetSelection = null;
  let pendingPolymorphSelection = null;
  let pendingLayOnHandsTargeting = null;
  let pendingLayOnHandsResolve = null;
  let pendingBeguilingMagic = null;
  let pendingPoolSpellConfirm = null;
  let pendingCommandResolution = null;
  let pendingBardicInspirationTargeting = null;
  let pendingBardicDiceUse = null;
  let pendingMantleOfInspiration = null;
  let losPreview = null; // {start:{col,row}, end:{col,row}, blocked, expiresAt}
  const LOS_PREVIEW_MS = 900;
  const sheetHeightKey = "inittracker_sheetHeight";
  const lockMyAoesKey = "inittracker_lock_my_aoes";
  const uiToggleKeys = {
    topbarTitle: "inittracker_ui_topbarTitle",
    connIndicator: "inittracker_ui_connIndicator",
    lockMap: "inittracker_ui_lockMap",
    centerMap: "inittracker_ui_centerMap",
    measure: "inittracker_ui_measure",
    measureClear: "inittracker_ui_measureClear",
    zoomIn: "inittracker_ui_zoomIn",
    zoomOut: "inittracker_ui_zoomOut",
    battleLog: "inittracker_ui_battleLog",
    useAction: "inittracker_ui_useAction",
    useBonusAction: "inittracker_ui_useBonusAction",
    dash: "inittracker_ui_dash",
    standUp: "inittracker_ui_standUp",
    resetTurn: "inittracker_ui_resetTurn",
    hideSpellMenu: "inittracker_ui_hideSpellMenu",
    lockMenus: "inittracker_lockMenus",
  };
  const uiSelectKeys = {
    connStyle: "inittracker_ui_connStyle",
    initiativeStyle: "inittracker_ui_initiativeStyle",
  };
  const mapViewSettingsKey = "inittracker_map_view_settings";
  const dmUiPrefsKey = "inittracker_dm_ui_prefs";
  const battleLogViewPrefsKey = "inittracker_battle_log_view_prefs";
  const chatViewPrefsKey = "inittracker_chat_view_prefs";
  const sheetPanelHiddenKey = "inittracker_ui_sheetPanelHidden";
  let dmLogLines = [];
  let battleLogSubscribed = false;
  const DM_LOG_LINES_MAX = 3000;
  let dmHighlightUntil = new Map();
  let dmUiPrefs = {showMapPreview:false, showLogPanel:false, autoScroll:true, filters:{attack:true,damage:true,save:true,heal:true,spell:true}};
  try { dmUiPrefs = {...dmUiPrefs, ...(JSON.parse(localStorage.getItem(dmUiPrefsKey)||"{}")||{})}; } catch(_) {}

  let showTopbarTitle = readToggle(uiToggleKeys.topbarTitle, true);
  let showConnIndicator = readToggle(uiToggleKeys.connIndicator, true);
  let showLockMap = readToggle(uiToggleKeys.lockMap, true);
  let showCenterMap = readToggle(uiToggleKeys.centerMap, true);
  let showMeasure = readToggle(uiToggleKeys.measure, true);
  let showMeasureClear = readToggle(uiToggleKeys.measureClear, true);
  let showZoomIn = readToggle(uiToggleKeys.zoomIn, true);
  let showZoomOut = readToggle(uiToggleKeys.zoomOut, true);
  let showBattleLog = readToggle(uiToggleKeys.battleLog, true);
  let showUseAction = readToggle(uiToggleKeys.useAction, true);
  let showUseBonusAction = readToggle(uiToggleKeys.useBonusAction, true);
  let showDash = readToggle(uiToggleKeys.dash, true);
  let showStandUp = readToggle(uiToggleKeys.standUp, true);
  let showResetTurn = readToggle(uiToggleKeys.resetTurn, true);
  let hideSpellMenu = readToggle(uiToggleKeys.hideSpellMenu, false);
  let menusLocked = readToggle(uiToggleKeys.lockMenus, false);
  let sheetPanelHidden = isPlanning ? true : readToggle(sheetPanelHiddenKey, false);
  let lockMyAoes = readToggle(lockMyAoesKey, true);
  let mapViewSettings = null;
  let battleLogViewPrefs = null;
  let chatViewPrefs = null;
  let connStyle = "full";
  let initiativeStyle = "full";
  let sheetHeight = null;
  if (turnAlertStatus){
    refreshTurnAlertStatus();
  }
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
  const isSafariEngine = /AppleWebKit/.test(navigator.userAgent);
  const isAltBrowser = /CriOS|FxiOS|EdgiOS|OPiOS/.test(navigator.userAgent);
  const isStandalone = window.navigator.standalone === true;
  if (document.body){
    document.body.classList.toggle("map-view", isMapView);
    document.body.classList.toggle("map-view-only", isMapViewOnly);
    document.body.classList.toggle("planning-view", isPlanning);
  }
  if (iosInstallHint){
    const showHint = isIOS && isSafariEngine && !isAltBrowser && !isStandalone;
    iosInstallHint.classList.toggle("hidden", !showHint);
  }
  if (turnAlertsPanel){
    const hideTurnAlerts = localStorage.getItem(turnAlertHideKey) === "1";
    const shouldHideAlerts = !isIOS || hideTurnAlerts;
    turnAlertsPanel.classList.toggle("hidden", shouldHideAlerts);
  }
  applyMapViewSettings(readMapViewSettings());
  battleLogViewPrefs = readBattleLogViewPrefs();
  chatViewPrefs = readChatViewPrefs();
  applyBattleLogViewPrefs();
  applyChatViewPrefs();
  if (isMapView){ dmUiPrefs.showLogPanel = dmUiPrefs.showLogPanel === true; dmUiPrefs.showMapPreview = dmUiPrefs.showMapPreview === true; renderDmLogPanel(); refreshMapViewLogPolling(); }
  function applyMapViewReadOnlyControls(){
    if (!isMapView) return;
    const controls = [
      useActionBtn,
      useBonusActionBtn,
      useReactionBtn,
      dashBtn,
      standUpBtn,
      resetTurnBtn,
      endTurnBtn,
      endTurnSheetBtn,
    ];
    controls.forEach((control) => {
      if (!control) return;
      control.disabled = true;
      control.setAttribute("aria-disabled", "true");
    });
  }
  function updateEndTurnState(){
    const needsClaim = claimedCid === null || claimedCid === undefined;
    const myTurn = !needsClaim && activeControlledUnitCid() !== null;
    const shouldDisable = isMapView || needsClaim || !myTurn;
    const endTurnButtons = [endTurnBtn, endTurnSheetBtn].filter(Boolean);
    endTurnButtons.forEach((button) => {
      button.disabled = shouldDisable;
      button.setAttribute("aria-disabled", shouldDisable ? "true" : "false");
    });
    if (shouldDisable){
      endTurnButtons.forEach((button) => button.classList.remove("end-turn-ready", "end-turn-pop"));
      endTurnReadyVisualActive = false;
    }
    let titleText = "";
    if (needsClaim){
      titleText = "Claim a character first, matey.";
    } else if (isMapView){
      titleText = "Map view is read-only.";
    } else if (!myTurn){
      titleText = "Wait for your turn, matey.";
    }
    endTurnButtons.forEach((button) => {
      if (titleText){
        button.setAttribute("title", titleText);
      } else {
        button.removeAttribute("title");
      }
    });
  }
  function updateEndTurnReadyVisual(me, myTurn){
    const endTurnButtons = [endTurnBtn, endTurnSheetBtn].filter(Boolean);
    if (!endTurnButtons.length || !me || endTurnButtons.every((button) => button.disabled)){
      endTurnButtons.forEach((button) => button.classList.remove("end-turn-ready", "end-turn-pop"));
      endTurnReadyVisualActive = false;
      return;
    }
    const noMovement = Number(me.move_remaining || 0) <= 0;
    const noAction = Number(me.action_remaining || 0) <= 0;
    const noBonusAction = Number(me.bonus_action_remaining || 0) <= 0;
    const shouldEmphasize = myTurn && noMovement && noAction && noBonusAction;
    endTurnButtons.forEach((button) => {
      if (shouldEmphasize && !button.disabled){
        button.classList.add("end-turn-ready");
        if (!endTurnReadyVisualActive){
          button.classList.remove("end-turn-pop");
          void button.offsetWidth;
          button.classList.add("end-turn-pop");
        }
      } else {
        button.classList.remove("end-turn-ready", "end-turn-pop");
      }
    });
    endTurnReadyVisualActive = shouldEmphasize;
  }
  applyMapViewReadOnlyControls();
  updateEndTurnState();
  if (showAllNamesEl){
    showAllNamesEl.checked = showAllNames;
    showAllNamesEl.addEventListener("change", (ev) => {
      showAllNames = !!ev.target.checked;
      localStorage.setItem("inittracker_showAllNames", showAllNames ? "1" : "0");
      draw();
    });
  }

  window.addEventListener("resize", () => {
    if (sheetWrap){
      applySheetHeight(sheetHeight);
    }
    applyUiConfig();
    applyChatViewPrefs();
  });
  updateSpellbookViewportHeight();
  window.addEventListener("resize", updateSpellbookViewportHeight);
  if (window.visualViewport){
    window.visualViewport.addEventListener("resize", updateSpellbookViewportHeight);
    window.visualViewport.addEventListener("scroll", updateSpellbookViewportHeight);
  }

  function updateConnDisplay(){
    if (connFullTextEl) connFullTextEl.textContent = connStatusText;
    if (connEl) connEl.setAttribute("title", connStatusText);
    if (connCompactLabelEl) connCompactLabelEl.textContent = "C";
    if (connDotEl){
      connDotEl.style.background = connStatusOk ? "var(--accent)" : "var(--danger)";
    }
    if (connPopoverStatusEl){
      connPopoverStatusEl.textContent = connStatusText;
    }
  }

  function setConn(ok, txt){
    connStatusOk = !!ok;
    connStatusText = String(txt || "");
    if (connEl){
      connEl.style.borderColor = connStatusOk ? "rgba(106,169,255,0.35)" : "rgba(255,91,91,0.35)";
      connEl.style.background = connStatusOk ? "rgba(106,169,255,0.14)" : "rgba(255,91,91,0.14)";
    }
    updateConnDisplay();
  }

  function setConnPopover(open){
    if (!connPopoverEl || !connEl) return;
    connPopoverEl.classList.toggle("show", open);
    connPopoverEl.setAttribute("aria-hidden", open ? "false" : "true");
    connEl.setAttribute("aria-expanded", open ? "true" : "false");
  }

  function closeConnPopover(){
    setConnPopover(false);
  }

  function scheduleReconnect(delayMs){
    if (reconnectTimer){
      clearTimeout(reconnectTimer);
    }
    reconnectTimer = setTimeout(() => {
      reconnectTimer = null;
      connect();
    }, delayMs);
  }

  function softReconnect(){
    reconnecting = true;
    setConn(false, "Reconnecting");
    closeConnPopover();
    if (ws && ws.readyState === 1){
      ws.close(4001, "reconnect");
    } else {
      scheduleReconnect(200);
    }
  }

  function resize(){
    const r = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.max(1, Math.floor(r.width * dpr));
    canvas.height = Math.max(1, Math.floor(r.height * dpr));
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }
  window.addEventListener("resize", resize);

  function getSheetConstraints(){
    const viewportHeight = window.innerHeight || 0;
    const min = Math.max(180, Math.round(viewportHeight * 0.2));
    const max = Math.max(min + 80, Math.round(viewportHeight * 0.7));
    return {min, max};
  }

  function updateModalOffsets(){
    const topbarHeight = document.querySelector(".topbar")?.getBoundingClientRect().height || 0;
    const sheetHeight = document.getElementById("sheetWrap")?.getBoundingClientRect().height || 0;
    const rootStyle = document.documentElement.style;
    rootStyle.setProperty("--modalTopOffset", `${topbarHeight}px`);
    rootStyle.setProperty("--modalBottomOffset", `${sheetHeight}px`);
    rootStyle.setProperty("--topbar-height", `${topbarHeight}px`);
    rootStyle.setProperty("--bottombar-height", `${sheetHeight}px`);
  }

  function updateSpellbookViewportHeight(){
    const viewportHeight = window.visualViewport?.height || window.innerHeight || 0;
    const vh = Math.max(1, viewportHeight) * 0.01;
    document.documentElement.style.setProperty("--spellbook-vh", `${vh}px`);
  }

  function readMapViewSettings(){
    const defaults = {
      textSize: 14,
      barHeight: 68,
      chipPadding: 6,
      chipGap: 8,
      cornerRadius: 40,
      rotateHandleScale: 1.2,
      showTitle: true,
      showStatus: true,
      showIndex: true,
    };
    try {
      const raw = localStorage.getItem(mapViewSettingsKey);
      if (!raw){
        return defaults;
      }
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== "object"){
        return defaults;
      }
      return {
        ...defaults,
        ...parsed,
      };
    } catch (err){
      return defaults;
    }
  }

  function applyMapViewSettings(settings){
    if (!settings){
      return;
    }
    mapViewSettings = settings;
    const rootStyle = document.documentElement.style;
    rootStyle.setProperty("--map-view-order-font-size", `${settings.textSize}px`);
    rootStyle.setProperty("--map-view-bar-height", `${settings.barHeight}px`);
    rootStyle.setProperty("--map-view-order-chip-pad-y", `${settings.chipPadding}px`);
    rootStyle.setProperty("--map-view-order-chip-pad-x", `${Math.max(6, settings.chipPadding + 4)}px`);
    rootStyle.setProperty("--map-view-order-gap", `${settings.chipGap}px`);
    rootStyle.setProperty("--map-view-order-radius", `${settings.cornerRadius}px`);
    if (document.body){
      document.body.classList.toggle("map-view-hide-title", !settings.showTitle);
      document.body.classList.toggle("map-view-hide-status", !settings.showStatus);
      document.body.classList.toggle("map-view-hide-index", !settings.showIndex);
    }
    if (mapViewTextSizeInput){
      mapViewTextSizeInput.value = String(settings.textSize);
    }
    if (mapViewBarHeightInput){
      mapViewBarHeightInput.value = String(settings.barHeight);
    }
    if (mapViewChipPaddingInput){
      mapViewChipPaddingInput.value = String(settings.chipPadding);
    }
    if (mapViewChipGapInput){
      mapViewChipGapInput.value = String(settings.chipGap);
    }
    if (mapViewCornerRadiusInput){
      mapViewCornerRadiusInput.value = String(settings.cornerRadius);
    }
    if (mapViewRotateHandleScaleInput){
      mapViewRotateHandleScaleInput.value = String(settings.rotateHandleScale);
    }
    if (mapViewShowTitleInput){
      mapViewShowTitleInput.checked = !!settings.showTitle;
    }
    if (mapViewShowStatusInput){
      mapViewShowStatusInput.checked = !!settings.showStatus;
    }
    if (mapViewShowIndexInput){
      mapViewShowIndexInput.checked = !!settings.showIndex;
    }
  }

  function persistMapViewSettings(){
    if (!mapViewSettings){
      return;
    }
    try {
      localStorage.setItem(mapViewSettingsKey, JSON.stringify(mapViewSettings));
    } catch (err){
      console.warn("Failed to persist map view settings.", err);
    }
  }

  function readBattleLogViewPrefs(){
    const defaults = {
      visible: false,
      fontFamily: "system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif",
      fontSize: 14,
      width: null,
      height: null,
      left: null,
      top: null,
    };
    try {
      const raw = localStorage.getItem(battleLogViewPrefsKey);
      if (!raw){
        return defaults;
      }
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== "object"){
        return defaults;
      }
      const merged = {
        ...defaults,
        ...parsed,
      };
      if (Number.isFinite(Number(merged.left)) && Number.isFinite(Number(merged.top))){
        if (Number(merged.left) <= 4 && Number(merged.top) <= 4){
          merged.left = null;
          merged.top = null;
        }
      }
      return merged;
    } catch (_err){
      return defaults;
    }
  }

  function persistBattleLogViewPrefs(){
    if (!battleLogViewPrefs){
      return;
    }
    try {
      localStorage.setItem(battleLogViewPrefsKey, JSON.stringify(battleLogViewPrefs));
    } catch (_err) {}
  }

  function applyBattleLogViewPrefs(){
    if (!battleLogViewPrefs){
      battleLogViewPrefs = readBattleLogViewPrefs();
    }
    const rootStyle = document.documentElement.style;
    rootStyle.setProperty("--battle-log-font-family", battleLogViewPrefs.fontFamily || "system-ui,sans-serif");
    rootStyle.setProperty("--battle-log-font-size", `${Number(battleLogViewPrefs.fontSize) || 14}px`);
    if (battleLogFontFamilyInput){
      battleLogFontFamilyInput.value = battleLogViewPrefs.fontFamily || "";
    }
    if (battleLogFontSizeInput){
      battleLogFontSizeInput.value = String(Number(battleLogViewPrefs.fontSize) || 14);
    }
    if (logModal){
      if (Number.isFinite(Number(battleLogViewPrefs.width))){
        logModal.style.width = `${Math.max(260, Number(battleLogViewPrefs.width))}px`;
      }
      if (Number.isFinite(Number(battleLogViewPrefs.height))){
        logModal.style.height = `${Math.max(180, Number(battleLogViewPrefs.height))}px`;
      }
      if (Number.isFinite(Number(battleLogViewPrefs.left)) && Number.isFinite(Number(battleLogViewPrefs.top))){
        const modalRect = logModal.getBoundingClientRect();
        const topbarHeight = document.querySelector(".topbar")?.getBoundingClientRect().height || 0;
        const sheetHeight = sheetWrap && !sheetWrap.classList.contains("hidden")
          ? sheetWrap.getBoundingClientRect().height
          : 0;
        const minTop = Math.max(0, topbarHeight + 8);
        const maxLeft = Math.max(0, window.innerWidth - modalRect.width);
        const maxTop = Math.max(minTop, window.innerHeight - sheetHeight - modalRect.height - 8);
        const left = Math.min(maxLeft, Math.max(0, Number(battleLogViewPrefs.left)));
        const top = Math.min(maxTop, Math.max(minTop, Number(battleLogViewPrefs.top)));
        logModal.style.left = `${left}px`;
        logModal.style.top = `${top}px`;
        logModal.style.right = "auto";
        logModal.style.bottom = "auto";
      } else {
        const modalRect = logModal.getBoundingClientRect();
        const topbarHeight = document.querySelector(".topbar")?.getBoundingClientRect().height || 0;
        const sheetHeight = sheetWrap && !sheetWrap.classList.contains("hidden")
          ? sheetWrap.getBoundingClientRect().height
          : 0;
        const minTop = Math.max(0, topbarHeight + 8);
        const maxTop = Math.max(minTop, window.innerHeight - sheetHeight - modalRect.height - 8);
        const defaultTop = Math.round(minTop + ((maxTop - minTop) / 2));
        logModal.style.left = "auto";
        logModal.style.top = `${defaultTop}px`;
        logModal.style.right = "12px";
        logModal.style.bottom = "auto";
      }
      logModal.classList.toggle("show", battleLogViewPrefs.visible === true);
      logModal.setAttribute("aria-hidden", battleLogViewPrefs.visible === true ? "false" : "true");
    }
    if (battleLogBtn){
      battleLogBtn.setAttribute("aria-pressed", battleLogViewPrefs.visible === true ? "true" : "false");
    }
  }


  function readChatViewPrefs(){
    const defaults = {
      visible: false,
      width: null,
      height: null,
      left: null,
      top: null,
    };
    try {
      const raw = localStorage.getItem(chatViewPrefsKey);
      if (!raw) return defaults;
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== "object") return defaults;
      return {
        ...defaults,
        ...parsed,
      };
    } catch (_err){
      return defaults;
    }
  }

  function persistChatViewPrefs(){
    if (!chatViewPrefs) return;
    try {
      localStorage.setItem(chatViewPrefsKey, JSON.stringify(chatViewPrefs));
    } catch (_err) {}
  }

  function applyChatViewPrefs(){
    if (!chatViewPrefs){
      chatViewPrefs = readChatViewPrefs();
    }
    if (!planningChatOverlay) return;
    if (Number.isFinite(Number(chatViewPrefs.width))){
      planningChatOverlay.style.width = `${Math.max(280, Number(chatViewPrefs.width))}px`;
    }
    if (Number.isFinite(Number(chatViewPrefs.height))){
      planningChatOverlay.style.height = `${Math.max(220, Number(chatViewPrefs.height))}px`;
    }
    if (Number.isFinite(Number(chatViewPrefs.left)) && Number.isFinite(Number(chatViewPrefs.top))){
      const modalRect = planningChatOverlay.getBoundingClientRect();
      const topbarHeight = document.querySelector(".topbar")?.getBoundingClientRect().height || 0;
      const sheetHeight = sheetWrap && !sheetWrap.classList.contains("hidden")
        ? sheetWrap.getBoundingClientRect().height
        : 0;
      const minTop = Math.max(0, topbarHeight + 8);
      const maxLeft = Math.max(0, window.innerWidth - modalRect.width);
      const maxTop = Math.max(minTop, window.innerHeight - sheetHeight - modalRect.height - 8);
      const left = Math.min(maxLeft, Math.max(0, Number(chatViewPrefs.left)));
      const top = Math.min(maxTop, Math.max(minTop, Number(chatViewPrefs.top)));
      planningChatOverlay.style.left = `${left}px`;
      planningChatOverlay.style.top = `${top}px`;
      planningChatOverlay.style.right = "auto";
      planningChatOverlay.style.bottom = "auto";
    } else {
      const modalRect = planningChatOverlay.getBoundingClientRect();
      const topbarHeight = document.querySelector(".topbar")?.getBoundingClientRect().height || 0;
      const sheetHeight = sheetWrap && !sheetWrap.classList.contains("hidden")
        ? sheetWrap.getBoundingClientRect().height
        : 0;
      const minTop = Math.max(0, topbarHeight + 8);
      const maxTop = Math.max(minTop, window.innerHeight - sheetHeight - modalRect.height - 8);
      const defaultTop = Math.round(minTop + ((maxTop - minTop) / 2));
      planningChatOverlay.style.left = "auto";
      planningChatOverlay.style.top = `${defaultTop}px`;
      planningChatOverlay.style.right = "12px";
      planningChatOverlay.style.bottom = "auto";
    }
    planningChatOverlay.classList.toggle("show", chatViewPrefs.visible === true);
    planningChatOverlay.setAttribute("aria-hidden", chatViewPrefs.visible === true ? "false" : "true");
    planningChatOpen = chatViewPrefs.visible === true;
    if (planningChatBtn){
      planningChatBtn.setAttribute("aria-pressed", planningChatOpen ? "true" : "false");
    }
  }
  function mapRotateHandleScale(){
    const raw = Number(mapViewSettings?.rotateHandleScale);
    if (!Number.isFinite(raw)) return 1.2;
    return Math.min(2.4, Math.max(0.8, raw));
  }

  function applySheetHeight(value){
    if (!sheetWrap) return;
    const {min, max} = getSheetConstraints();
    let target = Number(value);
    if (!Number.isFinite(target)){
      target = Math.round((min + max) / 2);
    }
    target = Math.min(max, Math.max(min, target));
    sheetWrap.style.height = `${target}px`;
    sheetWrap.style.minHeight = `${min}px`;
    sheetWrap.style.maxHeight = `${max}px`;
    sheetHeight = target;
    if (sheetHeightInput){
      sheetHeightInput.min = String(min);
      sheetHeightInput.max = String(max);
      sheetHeightInput.value = String(Math.round(target));
    }
    resize();
    updateModalOffsets();
  }

  function setSheetPanelHidden(hidden){
    sheetPanelHidden = !!hidden;
    persistToggle(sheetPanelHiddenKey, sheetPanelHidden);
    if (sheetWrap){
      sheetWrap.classList.toggle("hidden", sheetPanelHidden);
    }
    if (toggleSheetPanelBtn){
      toggleSheetPanelBtn.textContent = sheetPanelHidden ? "Show Panel" : "Hide Panel";
      toggleSheetPanelBtn.setAttribute("aria-pressed", sheetPanelHidden ? "true" : "false");
    }
    resize();
    updateModalOffsets();
  }

  function setCastOverlayOpen(open){
    if (!castOverlay) return;
    castOverlay.classList.toggle("show", open);
    castOverlay.classList.toggle("hidden", !open);
    castOverlay.setAttribute("aria-hidden", open ? "false" : "true");
    if (sheet){
      sheet.classList.toggle("hidden", open);
    }
    if (!open){
      pendingSpellActionType = null;
    }
    if (open){
      castOverlayPreviousFocus = document.activeElement instanceof HTMLElement
        ? document.activeElement
        : null;
      requestAnimationFrame(() => {
        castOverlayBackBtn?.focus();
      });
      applyDefaultSpellSaveDc();
    } else if (castOverlayPreviousFocus){
      castOverlayPreviousFocus.focus();
      castOverlayPreviousFocus = null;
    }
    updateModalOffsets();
    resize();
  }

  function getClaimedPlayerName(){
    const claimedUnit = getClaimedUnit();
    if (!claimedUnit?.name) return null;
    return String(claimedUnit.name);
  }

  function normalizeCharacterLookupKey(value){
    return String(value || "").trim().toLowerCase();
  }

  function characterSlugify(value){
    return normalizeCharacterLookupKey(value)
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/^-+|-+$/g, "");
  }

  function stripCombatNameSuffix(value){
    const text = String(value || "").trim();
    if (!text) return "";
    const withoutForm = text.replace(/\s*\([^)]*\)\s*$/, "").trim();
    const withoutDupe = withoutForm.replace(/\s+\d+$/, "").trim();
    return withoutDupe || text;
  }

  function getPlayerProfile(name){
    if (!name) return null;
    const profiles = state?.player_profiles;
    if (!profiles || typeof profiles !== "object") return null;
    const direct = profiles[name];
    if (direct && typeof direct === "object") return direct;
    const lookup = normalizeCharacterLookupKey(name);
    const lookupSlug = characterSlugify(name);
    const stripped = stripCombatNameSuffix(name);
    const strippedLookup = normalizeCharacterLookupKey(stripped);
    const strippedSlug = characterSlugify(stripped);
    for (const [profileName, profile] of Object.entries(profiles)){
      if (!profile || typeof profile !== "object") continue;
      const knownLookup = normalizeCharacterLookupKey(profileName);
      const knownSlug = characterSlugify(profileName);
      if (
        knownLookup === lookup
        || (lookupSlug && knownSlug === lookupSlug)
        || (strippedLookup && knownLookup === strippedLookup)
        || (strippedSlug && knownSlug === strippedSlug)
      ){
        return profile;
      }
    }
    return null;
  }

  function getClaimedWeapons(){
    const profile = getPlayerProfile(getClaimedPlayerName());
    const attacks = profile?.attacks;
    const weapons = Array.isArray(attacks?.weapons)
      ? attacks.weapons.filter((entry) => entry && typeof entry === "object")
      : [];
    const hasUnarmed = weapons.some((entry) => normalizeLowerValue(entry?.id) === "unarmed_strike");
    if (!hasUnarmed){
      weapons.push({
        id: "unarmed_strike",
        name: "Fist (Unarmed Strike)",
        range: "5",
        one_handed: {damage_formula: "1 + str_mod", damage_type: "bludgeoning"},
        two_handed: {},
        effect: {},
        properties: [],
      });
    }
    return weapons;
  }

  function getClaimedInventoryItems(){
    const profile = getPlayerProfile(getClaimedPlayerName());
    const inventory = profile?.inventory;
    if (!inventory || typeof inventory !== "object" || !Array.isArray(inventory.items)){
      return [];
    }
    return inventory.items.filter((entry) => entry && typeof entry === "object");
  }

  function getWeaponSelectionCharacterKey(){
    const claimedName = getClaimedPlayerName();
    const stripped = stripCombatNameSuffix(claimedName || "");
    const slug = characterSlugify(stripped || claimedName || "");
    return slug || "";
  }

  function readWeaponSelectionStore(){
    try {
      const parsed = JSON.parse(localStorage.getItem(weaponSelectionStorageKey) || "{}");
      return parsed && typeof parsed === "object" ? parsed : {};
    } catch (_err){
      return {};
    }
  }

  function saveCurrentWeaponSelections(){
    const key = getWeaponSelectionCharacterKey();
    if (!key) return;
    const store = readWeaponSelectionStore();
    store[key] = {
      mainhand: String(selectedMainhandWeaponValue || "").trim(),
      offhand: String(cachedOffhandWeaponValue || "").trim(),
    };
    try {
      localStorage.setItem(weaponSelectionStorageKey, JSON.stringify(store));
    } catch (_err) {}
  }

  function loadWeaponSelectionsForClaimedCharacter(){
    const key = getWeaponSelectionCharacterKey();
    if (!key){
      selectedMainhandWeaponValue = "";
      selectedOffhandWeaponValue = "";
      cachedOffhandWeaponValue = "";
      return;
    }
    const entry = readWeaponSelectionStore()[key] || {};
    selectedMainhandWeaponValue = String(entry.mainhand || "").trim();
    selectedOffhandWeaponValue = String(entry.offhand || "").trim();
    cachedOffhandWeaponValue = selectedOffhandWeaponValue;
  }

  function ensureWeaponSelectionCharacterLoaded(){
    const key = getWeaponSelectionCharacterKey();
    if (key === weaponSelectionCharacterKey) return;
    weaponSelectionCharacterKey = key;
    equipmentSyncStateKey = "";
    loadWeaponSelectionsForClaimedCharacter();
  }

  function getWeaponPropertySet(weapon){
    const properties = Array.isArray(weapon?.properties) ? weapon.properties : [];
    return new Set(properties.map((entry) => normalizeLowerValue(entry)).filter(Boolean));
  }

  function isWeaponVersatile(weapon){
    const properties = getWeaponPropertySet(weapon);
    const hasTwoHandedOnlyProperty = properties.has("two_handed") && !properties.has("versatile");
    const hasVersatileProperty = properties.has("versatile");
    const hasTwoFormula = !!String(weapon?.two_handed?.damage_formula || "").trim();
    if (hasTwoHandedOnlyProperty) return false;
    return hasVersatileProperty || hasTwoFormula;
  }

  function isWeaponTwoHandedOnly(weapon){
    const properties = getWeaponPropertySet(weapon);
    return properties.has("two_handed") && !properties.has("versatile");
  }

  function isWeaponLight(weapon){
    return getWeaponPropertySet(weapon).has("light");
  }

  function isShieldItem(item){
    const category = normalizeLowerValue(item?.category || item?.type || item?.slot || item?.armor_type);
    if (category.includes("shield")) return true;
    const name = normalizeLowerValue(item?.name || item?.id);
    return name.includes("shield");
  }

  function buildMainhandOptions(weapons){
    const options = [];
    (Array.isArray(weapons) ? weapons : []).forEach((weapon) => {
      const id = String(weapon?.id || weapon?.name || "").trim();
      const name = String(weapon?.name || weapon?.id || "Weapon").trim() || "Weapon";
      if (!id) return;
      if (isWeaponVersatile(weapon)){
        options.push({value: `${id}|one`, weapon, mode: "one", label: `${name} (One Handed)`});
        options.push({value: `${id}|two`, weapon, mode: "two", label: `${name} (Two Handed)`});
        return;
      }
      if (isWeaponTwoHandedOnly(weapon)){
        options.push({value: `${id}|two`, weapon, mode: "two", label: `${name} (Two Handed)`});
        return;
      }
      options.push({value: `${id}|one`, weapon, mode: "one", label: `${name} (One Handed)`});
    });
    return options;
  }

  function buildOffhandOptions(weapons){
    const options = [];
    (Array.isArray(weapons) ? weapons : []).forEach((weapon) => {
      const id = String(weapon?.id || weapon?.name || "").trim();
      const name = String(weapon?.name || weapon?.id || "Weapon").trim() || "Weapon";
      if (!id) return;
      if (isWeaponTwoHandedOnly(weapon)) return;
      if (isWeaponLight(weapon)){
        options.push({value: `${id}|one`, weapon, mode: "one", label: `${name} (One Handed)`});
      }
    });
    const inventoryItems = getClaimedInventoryItems();
    inventoryItems.forEach((item) => {
      if (!isShieldItem(item)) return;
      const itemId = String(item?.id || item?.name || "shield").trim();
      if (!itemId) return;
      const itemName = String(item?.name || "Shield").trim() || "Shield";
      options.push({value: `${itemId}|shield`, item, mode: "shield", label: `${itemName} (+2 AC)`, offhand_kind: "shield"});
    });
    return options;
  }

  function getSelectedOffhandOption(){
    const selectedValue = String(selectedOffhandWeaponValue || "").trim();
    if (!selectedValue) return null;
    const offhandOptions = buildOffhandOptions(getClaimedWeapons());
    return offhandOptions.find((entry) => entry.value === selectedValue) || null;
  }

  function sendEquipmentUpdate(){
    if (claimedCid === null || claimedCid === undefined){
      equipmentSyncStateKey = "";
      return;
    }
    const selectedMainhand = getSelectedMainhandWeapon();
    const selectedOffhand = getSelectedOffhandOption();
    const payload = {
      type: "equipment_update",
      cid: claimedCid,
      mainhand_weapon_id: String(selectedMainhand?.id || "").trim(),
      offhand_item_id: String(selectedOffhand?.weapon?.id || selectedOffhand?.item?.id || "").trim(),
      offhand_kind: String(selectedOffhand?.offhand_kind || "").trim(),
      shield_equipped: selectedOffhand?.offhand_kind === "shield",
    };
    const nextKey = JSON.stringify([payload.mainhand_weapon_id, payload.offhand_item_id, payload.offhand_kind, payload.shield_equipped]);
    if (nextKey === equipmentSyncStateKey) return;
    equipmentSyncStateKey = nextKey;
    send(payload);
  }

  function getDefaultMainhandValue(weapons, mainhandOptions){
    const defaultWeapon = getDefaultAttackWeapon(weapons);
    const defaultId = String(defaultWeapon?.id || defaultWeapon?.name || "").trim();
    if (!defaultId) return "";
    const preferred = `${defaultId}|one`;
    if (mainhandOptions.some((entry) => entry.value === preferred)) return preferred;
    const fallback = mainhandOptions.find((entry) => entry.value.startsWith(`${defaultId}|`));
    return fallback ? fallback.value : (mainhandOptions[0]?.value || "");
  }

  function getSelectedMainhandWeapon(){
    const weapons = getClaimedWeapons();
    const options = buildMainhandOptions(weapons);
    const selectedValue = String(selectedMainhandWeaponValue || "").trim();
    const selected = options.find((entry) => entry.value === selectedValue) || options.find((entry) => entry.value === getDefaultMainhandValue(weapons, options)) || options[0] || null;
    if (!selected) return null;
    const mode = selected.mode === "two" ? "two" : "one";
    return {
      ...(selected.weapon || {}),
      selected_mode: mode,
      one_handed: mode === "one"
        ? (selected.weapon?.one_handed || {})
        : (isWeaponVersatile(selected.weapon)
          ? (selected.weapon?.two_handed || selected.weapon?.one_handed || {})
          : (selected.weapon?.two_handed || selected.weapon?.one_handed || {})),
      two_handed: selected.weapon?.two_handed || {},
    };
  }

  function isMainhandSelectionTwoHanded(){
    const selectedValue = String(selectedMainhandWeaponValue || "").trim();
    return selectedValue.endsWith("|two");
  }

  function refreshWeaponSelectors(){
    const weapons = getClaimedWeapons();
    const mainhandOptions = buildMainhandOptions(weapons);
    const offhandOptions = buildOffhandOptions(weapons);
    if (mainhandWeaponSelectEl){
      mainhandWeaponSelectEl.textContent = "";
      mainhandOptions.forEach((entry) => {
        const option = document.createElement("option");
        option.value = entry.value;
        option.textContent = entry.label;
        mainhandWeaponSelectEl.appendChild(option);
      });
      const candidate = String(selectedMainhandWeaponValue || "").trim();
      if (candidate && mainhandOptions.some((entry) => entry.value === candidate)){
        mainhandWeaponSelectEl.value = candidate;
      } else {
        const fallback = getDefaultMainhandValue(weapons, mainhandOptions);
        selectedMainhandWeaponValue = fallback;
        mainhandWeaponSelectEl.value = fallback;
      }
    }
    const mainhandTwo = isMainhandSelectionTwoHanded();
    if (offhandWeaponSelectEl){
      offhandWeaponSelectEl.textContent = "";
      const none = document.createElement("option");
      none.value = "";
      none.textContent = "None";
      offhandWeaponSelectEl.appendChild(none);
      offhandOptions.forEach((entry) => {
        const option = document.createElement("option");
        option.value = entry.value;
        option.textContent = entry.label;
        offhandWeaponSelectEl.appendChild(option);
      });
      const savedCandidate = String(cachedOffhandWeaponValue || selectedOffhandWeaponValue || "").trim();
      const validSaved = savedCandidate && offhandOptions.some((entry) => entry.value === savedCandidate);
      if (!mainhandTwo && validSaved){
        selectedOffhandWeaponValue = savedCandidate;
        offhandWeaponSelectEl.value = savedCandidate;
      } else {
        selectedOffhandWeaponValue = "";
        offhandWeaponSelectEl.value = "";
      }
      offhandWeaponSelectEl.disabled = mainhandTwo;
      offhandWeaponSelectEl.style.opacity = mainhandTwo ? "0.6" : "";
    }
    if (mainhandTwo){
      selectedOffhandWeaponValue = "";
    }
    saveCurrentWeaponSelections();
    sendEquipmentUpdate();
  }

  function setInventoryPanelOpen(open){
    inventoryPanelOpen = !!open;
    if (inventoryRow){
      inventoryRow.classList.toggle("hidden", !inventoryPanelOpen);
    }
    if (inventoryBtn){
      inventoryBtn.setAttribute("aria-pressed", inventoryPanelOpen ? "true" : "false");
    }
  }

  function isWeaponEquipped(weapon){
    const value = weapon?.equipped;
    if (typeof value === "boolean") return value;
    if (typeof value === "number") return value !== 0;
    if (typeof value === "string"){
      const normalized = value.trim().toLowerCase();
      return normalized === "1" || normalized === "true" || normalized === "yes" || normalized === "on";
    }
    return false;
  }

  function getDefaultAttackWeapon(weapons){
    if (!Array.isArray(weapons) || !weapons.length){
      return null;
    }
    const equipped = weapons.find((entry) => isWeaponEquipped(entry));
    return equipped || weapons[0] || null;
  }

  function isMeleeWeapon(weapon){
    const category = normalizeLowerValue(weapon?.category || weapon?.weapon_group);
    if (category.includes("melee")) return true;
    const rangeText = normalizeLowerValue(weapon?.range);
    if (!rangeText) return true;
    if (rangeText.includes("/")) return false;
    return parseWeaponRangeFeet(weapon) <= 10;
  }

  function getPrimaryMeleeAttackWeapon(){
    const weapons = getClaimedWeapons();
    if (!weapons.length){
      return null;
    }
    const meleeWeapons = weapons.filter((entry) => isMeleeWeapon(entry));
    const selectedMainhand = getSelectedMainhandWeapon();
    if (selectedMainhand && isMeleeWeapon(selectedMainhand)){
      return selectedMainhand;
    }
    const fallback = getDefaultAttackWeapon(meleeWeapons);
    if (!fallback) return null;
    return {...fallback, selected_mode: "one"};
  }

  function parseWeaponRangeFeet(weapon){
    const raw = weapon?.range ?? weapon?.normal_range ?? weapon?.reach ?? "";
    const text = String(raw || "").trim().toLowerCase();
    if (!text){
      return 5;
    }
    const firstPart = text.split("/")[0];
    const match = firstPart.match(/(\d+(?:\.\d+)?)/);
    if (!match){
      return 5;
    }
    const value = Number(match[1]);
    return Number.isFinite(value) && value > 0 ? value : 5;
  }

  function getSelectedAttackWeapon(){
    return getSelectedMainhandWeapon();
  }

  function getMonkLevelFromProfile(profile){
    const classes = profile?.leveling?.classes;
    if (!Array.isArray(classes)) return 0;
    return classes
      .filter((entry) => normalizeLowerValue(entry?.name) === "monk")
      .reduce((sum, entry) => sum + Math.max(0, Number(entry?.level || 0)), 0);
  }

  function unitHasElementalAttunement(unit){
    return !!unit && unit.elemental_attunement_active === true;
  }

  function isUnarmedStrikeWeapon(weapon){
    const weaponId = normalizeLowerValue(weapon?.id);
    const weaponName = normalizeLowerValue(weapon?.name);
    return weaponId === "unarmed_strike" || weaponName === "unarmed strike";
  }

  const MELEE_RANGE_FUDGE_FT = 3;

  function effectiveAttackRangeFeetForWeapon(weapon, unit){
    const baseRange = parseWeaponRangeFeet(weapon) + (isMeleeWeapon(weapon) ? MELEE_RANGE_FUDGE_FT : 0);
    if (isUnarmedStrikeWeapon(weapon) && unitHasElementalAttunement(unit)){
      return baseRange + 10;
    }
    return baseRange;
  }

  function getUnarmedStrikeWeapon(){
    const weapons = getClaimedWeapons();
    if (!weapons.length) return null;
    const byId = weapons.find((entry) => normalizeLowerValue(entry?.id) === "unarmed_strike");
    if (byId) return {...byId, selected_mode: "one"};
    const melee = weapons.filter((entry) => isMeleeWeapon(entry));
    const fallback = getDefaultAttackWeapon(melee.length ? melee : weapons);
    return fallback ? {...fallback, selected_mode: "one"} : null;
  }

  function getPlayerResourcePools(name){
    if (!name) return [];
    const poolsByPlayer = state?.resource_pools;
    if (!poolsByPlayer || typeof poolsByPlayer !== "object") return [];
    const pools = poolsByPlayer[name];
    if (!Array.isArray(pools)) return [];
    return pools.filter((entry) => entry && typeof entry === "object").map((entry) => {
      const currentRaw = Number(entry.current ?? 0);
      const maxRaw = Number(entry.max ?? 0);
      const max = Number.isFinite(maxRaw) ? Math.max(0, Math.floor(maxRaw)) : 0;
      const current = Number.isFinite(currentRaw) ? Math.max(0, Math.min(Math.floor(currentRaw), max)) : 0;
      return {
        id: String(entry.id || "").trim(),
        label: String(entry.label || entry.id || "").trim(),
        current,
        max,
      };
    }).filter((entry) => entry.id);
  }

  function getResourcePoolById(name, poolId){
    const pools = getPlayerResourcePools(name);
    const key = normalizeLowerValue(poolId);
    return pools.find((entry) => normalizeLowerValue(entry?.id) === key) || null;
  }

  function getPoolGrantedSpellEntries(name){
    const cfg = state?.player_spells?.[name];
    const block = cfg?.spellcasting?.pool_granted_spells ?? cfg?.pool_granted_spells;
    if (!Array.isArray(block)) return [];
    return block.filter((entry) => entry && typeof entry === "object");
  }

  function getPoolGrantedSpellsByPool(name){
    const entries = getPoolGrantedSpellEntries(name);
    const grouped = new Map();
    entries.forEach((entry) => {
      const consumes = entry.consumes_pool && typeof entry.consumes_pool === "object" ? entry.consumes_pool : {};
      const poolId = normalizeTextValue(consumes.id || consumes.pool);
      const spellSlug = normalizeTextValue(entry.spell || entry.slug || entry.id);
      if (!poolId || !spellSlug) return;
      const costRaw = Number(consumes.cost ?? 1);
      const cost = Number.isFinite(costRaw) ? Math.max(1, Math.floor(costRaw)) : 1;
      const actionType = normalizeSpellActionType(entry.action_type || entry.actionType || "action");
      const preset = spellPresetBySlug.get(getSpellKey(spellSlug))
        || cachedSpellPresets.find((candidate) => getSpellKey(getPresetSlug(candidate)) === getSpellKey(spellSlug));
      const spellName = normalizeTextValue(preset?.name || spellSlug);
      const key = getSpellKey(poolId);
      if (!grouped.has(key)){
        grouped.set(key, []);
      }
      grouped.get(key).push({
        spellSlug,
        spellName,
        actionType,
        preset,
        consumesPool: {id: poolId, cost},
      });
    });
    return grouped;
  }

  function clearForcedPoolCastContext(){
    forcedPoolCastContext = null;
  }

  function beginForcedPoolCast(entry){
    if (!entry?.preset){
      localToast("Could not find that spell preset, matey.");
      return;
    }
    if (!isPlanning && !claimedCid){
      localToast("Claim a character first, matey.");
      return;
    }
    if (!state){
      localToast("Map not ready yet, matey.");
      return;
    }
    forcedPoolCastContext = {
      preset: entry.preset,
      consumesPool: {id: entry.consumesPool.id, cost: entry.consumesPool.cost},
      actionType: entry.actionType,
    };
    pendingSpellActionType = entry.actionType;
    applySpellPreset(entry.preset);
    if (castPresetInput){
      castPresetInput.value = "";
    }
    setCastOverlayOpen(true);
    localToast(`Pool cast ready: ${entry.spellName}.`);
  }

  function beginForcedPoolAimingCast(entry){
    if (!entry?.preset){
      localToast("Could not find that spell preset, matey.");
      return false;
    }
    if (!castForm){
      beginForcedPoolCast(entry);
      return true;
    }
    forcedPoolCastContext = {
      preset: entry.preset,
      consumesPool: {id: entry.consumesPool.id, cost: entry.consumesPool.cost},
      actionType: entry.actionType,
    };
    pendingSpellActionType = entry.actionType;
    applySpellPreset(entry.preset);
    if (castPresetInput){
      castPresetInput.value = "";
    }
    if (castOverlay?.classList.contains("show")){
      setCastOverlayOpen(false);
    }
    try {
      castForm.requestSubmit();
    } catch (_err){
      castSubmitBtn?.click();
    }
    return true;
  }

  function performResourcePoolAction(entry){
    const actionCid = activeControlledUnitCid();
    const activeUnit = getUnitByCid(actionCid);
    if (actionCid === null || !activeUnit) return;
    const normalizedActionKey = String(entry?.name || "").toLowerCase().replace(/[^a-z0-9]+/g, " ").trim();
    if (entry?.spend === "bonus" && normalizedActionKey.startsWith("bardic inspiration")){
      setResourcePoolDetailOverlayOpen(false);
      startBardicInspirationGrantTargeting({...entry, sourceCid: actionCid});
      return;
    }
    if (entry?.spend === "bonus" && normalizedActionKey.startsWith("mantle of inspiration")){
      setResourcePoolDetailOverlayOpen(false);
      startMantleOfInspirationTargeting({...entry, sourceCid: actionCid});
      return;
    }
    const msg = {
      type: "perform_action",
      cid: actionCid,
      spend: entry.spend,
      action: entry.name,
    };
    if (isPlanning){
      planningMutate(msg);
      draw();
      updateHud();
    }
    send(msg);
    setResourcePoolDetailOverlayOpen(false);
  }

  function setPoolSpellConfirmModalOpen(open){
    setModalOpen(poolSpellConfirmModal, open);
    if (!open){
      pendingPoolSpellConfirm = null;
    }
  }

  function requiresPoolSpellConfirmation(entry){
    const poolId = normalizeLowerValue(entry?.consumesPool?.id);
    const spellSlug = normalizeLowerValue(entry?.spellSlug);
    return poolId === "wand_of_fireballs_fireball_cast" && spellSlug === "fireball";
  }

  function queuePoolSpellCastConfirmation(entry, pool){
    if (poolSpellConfirmTitle){
      poolSpellConfirmTitle.textContent = `Cast ${entry?.spellName || "Spell"}?`;
    }
    if (poolSpellConfirmMessage){
      poolSpellConfirmMessage.textContent = "Spend your Wand of Fireballs charge to cast Fireball at level 3?";
    }
    pendingPoolSpellConfirm = {entry, pool};
    setPoolSpellConfirmModalOpen(true);
  }

  function castResourcePoolSpell(entry, pool, skipConfirm = false){
    if (!entry?.preset){
      localToast("Could not find that spell preset, matey.");
      return;
    }
    const unit = getClaimedUnit();
    if (!unit){
      localToast("Claim a character first, matey.");
      return;
    }
    const poolCurrent = Number(pool?.current || 0);
    const poolCost = Number(entry?.consumesPool?.cost || 1);
    if (poolCurrent < poolCost){
      localToast("That resource pool be exhausted, matey.");
      return;
    }
    if (!isPlanning){
      const actionCheck = canSpendSpellAction(unit, entry.actionType);
      if (!actionCheck.ok){
        localToast(actionCheck.reason || "You can't cast right now.");
        return;
      }
    }
    if (requiresPoolSpellConfirmation(entry) && !skipConfirm){
      queuePoolSpellCastConfirmation(entry, pool);
      return;
    }
    const spellActionTag = resolveSpellActionTag(entry.preset);
    if (spellActionTag === "aoe"){
      beginForcedPoolAimingCast(entry);
      setResourcePoolDetailOverlayOpen(false);
      return;
    }
    const payload = {
      action_type: entry.actionType,
      name: normalizeTextValue(entry.preset?.name) || entry.spellName || "Spell",
      consumes_pool: {id: entry.consumesPool.id, cost: poolCost},
    };
    const msg = {
      type: "cast_spell",
      payload,
      action_type: entry.actionType,
      spell_slug: normalizeTextValue(getPresetSlug(entry.preset)) || null,
      spell_id: normalizeTextValue(entry.preset?.id) || null,
      consumes_pool_id: entry.consumesPool.id,
      consumes_pool_cost: poolCost,
    };
    if (isPlanning){
      planningMutate(msg);
      draw();
      updateHud();
    }
    send(msg);
    const config = getSpellTargetingConfig(entry.preset, null);
    if (config){
      startSpellTargetingSession(config, entry.preset, null, null);
    }
    setResourcePoolDetailOverlayOpen(false);
  }

  function setResourcePoolDetailOverlayOpen(open, pool = null){
    setModalOpen(resourcePoolDetailOverlay, open);
    if (!open) return;
    if (!pool){
      if (resourcePoolDetailTitle) resourcePoolDetailTitle.textContent = "Resource Pool Details";
      if (resourcePoolDetailSummary) resourcePoolDetailSummary.textContent = "No pool selected.";
      return;
    }
    const playerName = getClaimedPlayerName();
    const unit = getClaimedUnit();
    if (resourcePoolDetailTitle){
      resourcePoolDetailTitle.textContent = pool.label || pool.id || "Resource Pool";
    }
    if (resourcePoolDetailSummary){
      resourcePoolDetailSummary.textContent = `Current uses: ${pool.current}/${pool.max}`;
    }
    if (resourcePoolDetailActions){
      resourcePoolDetailActions.textContent = "";
      if (normalizeLowerValue(pool.id) === "beguiling_magic"){
        const windowS = getClaimedBeguilingMagicWindowSeconds();
        const biPool = getResourcePoolById(playerName, "bardic_inspiration");
        const useBtn = document.createElement("button");
        useBtn.type = "button";
        useBtn.className = "btn accent";
        useBtn.textContent = windowS > 0 ? `Use Beguiling Magic (${formatShortDuration(windowS)})` : "Use Beguiling Magic";
        useBtn.disabled = windowS <= 0;
        useBtn.addEventListener("click", () => {
          setResourcePoolDetailOverlayOpen(false);
          beginBeguilingMagicFlow(true);
        });
        resourcePoolDetailActions.appendChild(useBtn);
        if (Number(pool.current || 0) <= 0 && Number(biPool?.current || 0) > 0){
          const restoreBtn = document.createElement("button");
          restoreBtn.type = "button";
          restoreBtn.className = "btn";
          restoreBtn.textContent = "Restore Beguiling Magic (spend 1 Bardic Inspiration)";
          restoreBtn.addEventListener("click", () => {
            send({type: "beguiling_magic_restore", cid: activeControlledUnitCid()});
          });
          resourcePoolDetailActions.appendChild(restoreBtn);
        }
      }
      const actions = unit ? normalizeActionList(unit.actions, "action") : [];
      const bonusActions = unit ? normalizeActionList(unit.bonus_actions, "bonus_action") : [];
      const reactions = unit ? normalizeActionList(unit.reactions, "reaction") : [];
      const all = [
        ...actions.map((entry) => ({...entry, spend: "action"})),
        ...bonusActions.map((entry) => ({...entry, spend: "bonus"})),
        ...reactions.map((entry) => ({...entry, spend: "reaction"})),
      ].filter((entry) => normalizeLowerValue(entry?.uses?.pool) === normalizeLowerValue(pool.id));
      if (!all.length){
        const empty = document.createElement("div");
        empty.className = "action-picker-meta";
        empty.textContent = "No actions use this pool.";
        resourcePoolDetailActions.appendChild(empty);
      } else {
        all.forEach((entry) => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "btn";
          const spendLabel = entry.spend === "bonus" ? "Bonus Action" : (entry.spend === "reaction" ? "Reaction" : "Action");
          btn.textContent = `${entry.name} (${spendLabel})`;
          btn.addEventListener("click", () => performResourcePoolAction(entry));
          resourcePoolDetailActions.appendChild(btn);
        });
      }
    }
    if (resourcePoolDetailSpells){
      resourcePoolDetailSpells.textContent = "";
      const byPool = getPoolGrantedSpellsByPool(playerName);
      const entries = byPool.get(getSpellKey(pool.id)) || [];
      if (!entries.length){
        const empty = document.createElement("div");
        empty.className = "action-picker-meta";
        empty.textContent = "No pool-granted spells.";
        resourcePoolDetailSpells.appendChild(empty);
      } else {
        entries.forEach((entry) => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "btn accent";
          const actionLabel = entry.actionType === "bonus_action" ? "bonus action" : entry.actionType;
          btn.textContent = `Cast ${entry.spellName} (${actionLabel})`;
          btn.disabled = Number(pool.current || 0) < Number(entry.consumesPool?.cost || 1);
          btn.addEventListener("click", () => castResourcePoolSpell(entry, pool));
          resourcePoolDetailSpells.appendChild(btn);
        });
      }
    }
  }

  function renderResourcePools(){
    if (!resourcePoolsListEl) return;
    const playerName = getClaimedPlayerName();
    const pools = getPlayerResourcePools(playerName);
    resourcePoolsListEl.textContent = "";
    if (!pools.length){
      if (resourcePoolsPanelEl){
        resourcePoolsPanelEl.style.display = "none";
      }
      return;
    }
    if (resourcePoolsPanelEl){
      resourcePoolsPanelEl.style.display = "block";
    }
    pools.forEach((pool) => {
      const wrapper = document.createElement("div");
      wrapper.className = "resource-pool-entry";
      const chip = document.createElement("span");
      chip.className = `resource-pool-chip ${pool.current <= 0 ? "is-empty" : ""}`;
      if (normalizeLowerValue(pool.id) === "beguiling_magic"){
        const windowS = getClaimedBeguilingMagicWindowSeconds();
        const timerText = windowS > 0 ? ` (${formatShortDuration(windowS)})` : "";
        chip.textContent = `${pool.label || pool.id}${timerText} ${pool.current}/${pool.max}`;
      } else if (normalizeLowerValue(pool.id).startsWith("temp_bardic_dice_")){
        const dieSides = Number(pool?.die_sides || 0);
        const dieLabel = Number.isFinite(dieSides) && dieSides > 0 ? `d${Math.floor(dieSides)}` : "die";
        const timeLeft = Number(pool?.time_left_s || 0);
        const timerText = Number.isFinite(timeLeft) && timeLeft > 0 ? ` (${formatShortDuration(timeLeft)})` : "";
        chip.textContent = `${pool.label || "Bardic Dice"} ${dieLabel}${timerText}`;
      } else {
        chip.textContent = `${pool.label || pool.id} ${pool.current}/${pool.max}`;
      }
      if (pool.id === "wild_shape"){
        chip.style.cursor = "pointer";
        chip.title = "Wild Shape actions";
        chip.addEventListener("click", () => {
          if (!isClaimedUnitDruid()){
            localToast("Only Druids level 2+ can use Wild Shape.");
            return;
          }
          setWildShapeMenuOpen(true);
        });
      }
      if (pool.id === "second_wind"){
        chip.style.cursor = "pointer";
        chip.title = "Second Wind";
        chip.addEventListener("click", () => setSecondWindOverlayOpen(true));
      }
      if (pool.id === "focus_points"){
        chip.style.cursor = "pointer";
        chip.title = "Monk Focus";
        chip.addEventListener("click", () => {
          const cid = activeControlledUnitCid();
          if (cid === null){
            localToast("Claim a character first, matey.");
            return;
          }
          setMonkFocusOverlayOpen(true);
        });
      }
      if (pool.id === "action_surge"){
        chip.style.cursor = "pointer";
        chip.title = "Use Action Surge";
        chip.addEventListener("click", () => {
          const cid = activeControlledUnitCid();
          if (cid === null){
            localToast("Claim a character first, matey.");
            return;
          }
          if (!window.confirm("Action Surge?")){
            return;
          }
          const msg = {type: "action_surge_use", cid};
          if (isPlanning){
            planningMutate(msg);
            draw();
            updateHud();
          }
          send(msg);
        });
      }
      if (pool.id === "lay_on_hands"){
        chip.style.cursor = "pointer";
        chip.title = "Lay on Hands";
        chip.addEventListener("click", () => {
          const me = getClaimedUnit();
          if (!me || !me.pos){
            localToast("Claim a character first, matey.");
            return;
          }
          pendingLayOnHandsTargeting = {
            poolCurrent: Number(pool.current || 0),
            poolMax: Number(pool.max || 0),
            rangeFt: 5,
          };
          pendingLayOnHandsResolve = null;
          setLayOnHandsOverlayOpen(false);
          setAttackOverlayMode(true);
          localToast("Select a creature within 5 ft for Lay on Hands.");
          draw();
        });
      }
      if (pool.id === "unleash_incarnation"){
        chip.style.cursor = "pointer";
        chip.title = "Unleash Incarnation";
        chip.addEventListener("click", () => {
          if (pool.current <= 0){
            localToast("That resource pool be exhausted, matey.");
            return;
          }
          const claimedUnit = getClaimedUnit();
          if (!claimedUnit){
            localToast("Claim a character first, matey.");
            return;
          }
          const units = Array.isArray(state?.units) ? state.units : [];
          const echo = units.find((entry) => {
            if (!entry) return false;
            const source = normalizeLowerValue(entry.summon_source_spell || entry.summonSourceSpell || "");
            if (source !== "echo_knight") return false;
            return cidMatches(entry.summoned_by_cid, claimedUnit.cid, "unleash.echoOwner");
          });
          if (!echo || !echo.pos){
            localToast("Arr... I dont be seeing no echo, matey");
            return;
          }
          if (!window.confirm(`Use Unleash Incarnation? (${pool.current}/${pool.max} remaining uses)`)){
            return;
          }
          const weapon = getPrimaryMeleeAttackWeapon();
          if (!weapon){
            localToast("No configured melee weapon found, matey.");
            return;
          }
          pendingUnleashIncarnation = {
            poolId: pool.id,
            poolLabel: pool.label,
            cost: 1,
            echoCid: Number(echo.cid),
          };
          pendingActionAttackWeapon = {
            ...weapon,
            resolve_prompt: `Resolve Unleash Incarnation on target with ${String(weapon.name || "weapon")}.`,
          };
          setAttackOverlayMode(true);
          localToast("Select an enemy within echo range for Unleash Incarnation.");
        });
      }
      if (normalizeLowerValue(pool.id).startsWith("temp_bardic_dice_")){
        chip.style.cursor = "pointer";
        chip.title = "Spend Bardic Inspiration die";
        chip.addEventListener("click", () => setBardicDiceConfirmModalOpen(true, pool));
      }
      const specializedPools = new Set(["wild_shape", "focus_points", "lay_on_hands", "second_wind", "action_surge", "unleash_incarnation"]);
      if (!specializedPools.has(pool.id)){
        chip.style.cursor = "pointer";
        chip.title = "Resource pool details";
        chip.addEventListener("click", () => {
          if (!state){
            localToast("Map not ready yet, matey.");
            return;
          }
          setResourcePoolDetailOverlayOpen(true, pool);
        });
      }
      wrapper.appendChild(chip);
      resourcePoolsListEl.appendChild(wrapper);
    });
  }

  const spellSlotNumerals = ["I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
  let wildShapeSelectedAvailable = null;
  let wildShapeSelectedKnown = null;
  let wildShapeKnownDraft = [];
  let wildShapeAllowedMap = new Map();

  function setModalOpen(el, open){
    if (!el) return;
    el.classList.toggle("show", !!open);
    el.setAttribute("aria-hidden", open ? "false" : "true");
  }

  function setWildShapeMenuOpen(open){
    setModalOpen(wildShapeMenuOverlay, open);
    const me = getClaimedUnit();
    if (wildShapeMenuRevertBtn){
      wildShapeMenuRevertBtn.style.display = me?.is_wild_shaped ? "" : "none";
    }
  }

  function setWildShapePoolOverlayOpen(open){
    setModalOpen(wildShapePoolOverlay, open);
    if (!open) return;
    const pools = getPlayerResourcePools(getClaimedPlayerName());
    const wildPool = pools.find((entry) => entry.id === "wild_shape");
    if (!wildPool){
      if (wildShapePoolSummary) wildShapePoolSummary.textContent = "No Wild Shape pool found.";
      return;
    }
    if (wildShapePoolSummary) wildShapePoolSummary.textContent = `Current uses: ${wildPool.current}/${wildPool.max}`;
    if (wildShapePoolCurrentInput){
      wildShapePoolCurrentInput.min = "0";
      wildShapePoolCurrentInput.max = String(wildPool.max);
      wildShapePoolCurrentInput.value = String(wildPool.current);
    }
  }

  function setWildShapePickOverlayOpen(open){
    setModalOpen(wildShapePickOverlay, open);
    if (!open || !wildShapePickList) return;
    const {forms, known} = getWildShapeProfileData();
    const knownSet = new Set(known);
    const picks = forms.filter((entry) => knownSet.has(String(entry?.id || "").trim().toLowerCase()));
    wildShapePickList.textContent = "";
    if (!picks.length){
      const empty = document.createElement("div");
      empty.className = "spellbook-item";
      empty.textContent = "No prepared forms. Use Manage Wildshapes first.";
      wildShapePickList.appendChild(empty);
      return;
    }
    picks.forEach((entry) => {
      const id = String(entry?.id || "").trim().toLowerCase();
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "spellbook-item";
      btn.textContent = `${entry?.name || id}  CR ${entry?.challenge_rating ?? 0}`;
      btn.addEventListener("click", () => {
        if (claimedCid == null) return;
        send({type:"wild_shape_apply", cid: claimedCid, beast_id: id});
        setWildShapePickOverlayOpen(false);
        setWildShapeMenuOpen(false);
      });
      wildShapePickList.appendChild(btn);
    });
  }

  function setSecondWindOverlayOpen(open){
    setModalOpen(secondWindOverlay, open);
    if (!open) return;
    const pools = getPlayerResourcePools(getClaimedPlayerName());
    const secondWind = pools.find((entry) => entry.id === "second_wind");
    if (!secondWind){
      if (secondWindSummary) secondWindSummary.textContent = "No Second Wind pool found.";
      return;
    }
    if (secondWindSummary) secondWindSummary.textContent = `Current uses: ${secondWind.current}/${secondWind.max}`;
  }

  function setElementalBurstConfigOverlayOpen(open){
    setModalOpen(elementalBurstConfigOverlay, open);
    if (!open) return;
    if (elementalBurstDamageTypeInput) elementalBurstDamageTypeInput.value = "fire";
    if (elementalBurstMovementModeInput) elementalBurstMovementModeInput.value = "none";
  }

  function setMonkFocusOverlayOpen(open){
    setModalOpen(monkFocusOverlay, open);
    if (!open) return;
    const playerName = getClaimedPlayerName();
    const pools = getPlayerResourcePools(playerName);
    const focusPool = pools.find((entry) => entry.id === "focus_points");
    const current = Math.max(0, Number(focusPool?.current || 0));
    const max = Math.max(0, Number(focusPool?.max || 0));
    if (monkFocusSummary) monkFocusSummary.textContent = focusPool ? `Focus Points: ${current}/${max}` : "No Focus Points pool found.";
    const monkLevel = getMonkLevelFromProfile(getPlayerProfile(playerName));
    const flurryStrikes = monkLevel >= 10 ? 3 : 2;
    const uncannyPool = pools.find((entry) => entry.id === "uncanny_metabolism");
    if (monkFlurryOfBlowsBtn){
      monkFlurryOfBlowsBtn.textContent = `Flurry of Blows  1 Focus (${flurryStrikes} strikes)`;
    }
    const noFocus = current <= 0;
    const me = getClaimedUnit();
    const attuned = unitHasElementalAttunement(me);
    if (monkElementalAttunementToggleBtn){
      monkElementalAttunementToggleBtn.textContent = attuned
        ? "Elemental Attunement: Active (Deactivate)"
        : "Elemental Attunement (1 Focus)";
      monkElementalAttunementToggleBtn.disabled = !attuned && noFocus;
      monkElementalAttunementToggleBtn.style.opacity = (!attuned && noFocus) ? "0.6" : "";
      monkElementalAttunementToggleBtn.title = (!attuned && noFocus) ? "No Focus Points remaining." : "";
    }
    [monkPatientDefenseFocusBtn, monkStepOfWindFocusBtn, monkFlurryOfBlowsBtn].forEach((btn) => {
      if (!btn) return;
      btn.disabled = noFocus;
      btn.style.opacity = noFocus ? "0.6" : "";
      btn.title = noFocus ? "No Focus Points remaining." : "";
    });
    if (monkElementalBurstBtn){
      const noBurstFocus = current < 2;
      monkElementalBurstBtn.disabled = noBurstFocus;
      monkElementalBurstBtn.style.opacity = noBurstFocus ? "0.6" : "";
      monkElementalBurstBtn.title = noBurstFocus ? "Need 2 Focus Points." : "";
    }
    if (monkUncannyMetabolismBtn){
      const uncannyCurrent = Math.max(0, Number(uncannyPool?.current || 0));
      const noUse = uncannyCurrent <= 0;
      monkUncannyMetabolismBtn.disabled = noUse;
      monkUncannyMetabolismBtn.style.opacity = noUse ? "0.6" : "";
      monkUncannyMetabolismBtn.title = noUse ? "No Uncanny Metabolism uses left." : "";
    }
  }

  function setLayOnHandsOverlayOpen(open){
    setModalOpen(layOnHandsOverlay, open);
    if (!open) return;
    const pools = getPlayerResourcePools(getClaimedPlayerName());
    const pool = pools.find((entry) => entry.id === "lay_on_hands");
    const current = Math.max(0, Number(pool?.current || 0));
    const max = Math.max(0, Number(pool?.max || 0));
    if (layOnHandsSummary) layOnHandsSummary.textContent = pool ? `Pool: ${current}/${max}` : "No Lay on Hands pool found.";
    if (layOnHandsTarget){
      layOnHandsTarget.textContent = pendingLayOnHandsResolve
        ? `Target: ${pendingLayOnHandsResolve.targetName}`
        : "Target: none selected";
    }
    const curePoisonCost = 5;
    if (layOnHandsAmountInput){
      const curePoison = !!layOnHandsCurePoisonToggle?.checked;
      layOnHandsAmountInput.disabled = curePoison;
      layOnHandsAmountInput.min = "1";
      layOnHandsAmountInput.max = String(current);
      layOnHandsAmountInput.value = curePoison ? "0" : (current > 0 ? "1" : "0");
    }
    if (layOnHandsCurePoisonToggle){
      layOnHandsCurePoisonToggle.checked = false;
      layOnHandsCurePoisonToggle.disabled = current < curePoisonCost;
      layOnHandsCurePoisonToggle.title = current < curePoisonCost ? `Need ${curePoisonCost} Lay on Hands points.` : "";
    }
    if (layOnHandsUseBtn){
      layOnHandsUseBtn.textContent = "Heal";
    }
  }

  function isClaimedUnitDruid(){
    const name = getClaimedPlayerName();
    const profile = getPlayerProfile(name);
    const classes = profile?.leveling?.classes;
    if (Array.isArray(classes)){
      const level = classes
        .filter((entry) => String(entry?.name || "").trim().toLowerCase() === "druid")
        .reduce((sum, entry) => sum + Math.max(0, Number(entry?.level || 0)), 0);
      return level >= 2;
    }
    return String(profile?.leveling?.class || "").trim().toLowerCase() === "druid" && Number(profile?.leveling?.level || 0) >= 2;
  }

  function getWildShapeProfileData(){
    const playerName = getClaimedPlayerName();
    const profile = getPlayerProfile(playerName) || {};
    const forms = Array.isArray(profile.wild_shape_available_forms) ? profile.wild_shape_available_forms : [];
    const known = Array.isArray(profile.learned_wild_shapes) ? profile.learned_wild_shapes.map((v) => String(v || "").trim().toLowerCase()).filter(Boolean) : [];
    const limit = Number(profile.wild_shape_known_limit || 0);
    return {forms, known, limit};
  }

  function wildShapeLockReason(entry){
    const reasons = [];
    if (entry?.allowed === false){
      const speed = entry?.speed || {};
      if (Number(speed.fly || 0) > 0) reasons.push("flight locked at current level");
      if (Number(speed.swim || 0) > 0) reasons.push("swim locked at current level");
      if (String(entry?.size || "").toLowerCase() === "tiny") reasons.push("tiny forms unlock at level 11");
      if (!reasons.length) reasons.push("CR too high for current level");
    }
    return reasons.join(", ");
  }

  function renderWildShapeOverlay(){
    if (!wildShapeOverlay) return;
    const {forms, limit} = getWildShapeProfileData();
    const query = String(wildShapeSearchInput?.value || "").trim().toLowerCase();
    const showLocked = !!wildShapeShowLockedInput?.checked;
    if (!Array.isArray(wildShapeKnownDraft) || !wildShapeKnownDraft.length){
      wildShapeKnownDraft = getWildShapeProfileData().known.slice(0, Math.max(0, limit));
    }
    const available = forms.filter((entry) => {
      const id = String(entry?.id || "").trim().toLowerCase();
      const name = String(entry?.name || "").toLowerCase();
      const cr = String(entry?.challenge_rating ?? "");
      if (!showLocked && entry?.allowed === false) return false;
      if (!query) return true;
      return id.includes(query) || name.includes(query) || cr.includes(query);
    });
    if (wildShapeLeftList) wildShapeLeftList.textContent = "";
    if (wildShapeRightList) wildShapeRightList.textContent = "";
    wildShapeAllowedMap = new Map();
    available.forEach((entry) => {
      const id = String(entry?.id || "").trim().toLowerCase();
      if (!id) return;
      wildShapeAllowedMap.set(id, entry);
      const item = document.createElement("button");
      item.type = "button";
      item.dataset.wildshapeId = id;
      item.className = `spellbook-item ${entry?.allowed === false ? "locked" : ""} ${wildShapeSelectedAvailable === id ? "selected" : ""}`;
      item.textContent = `${entry?.name || id}  CR ${entry?.challenge_rating ?? 0}  ${entry?.size || ""}`;
      wildShapeLeftList?.appendChild(item);
    });
    const knownSet = new Set(wildShapeKnownDraft);
    forms.filter((entry) => knownSet.has(String(entry?.id || "").trim().toLowerCase())).forEach((entry) => {
      const id = String(entry?.id || "").trim().toLowerCase();
      const item = document.createElement("button");
      item.type = "button";
      item.dataset.wildshapeKnownId = id;
      item.className = `spellbook-item ${wildShapeSelectedKnown === id ? "selected" : ""}`;
      item.textContent = `${entry?.name || id}  CR ${entry?.challenge_rating ?? 0}`;
      wildShapeRightList?.appendChild(item);
    });
    if (wildShapeStatusEl){
      const remaining = Math.max(0, limit - wildShapeKnownDraft.length);
      wildShapeStatusEl.textContent = `Known forms: ${wildShapeKnownDraft.length}/${limit}. Remaining choices: ${remaining}.`;
    }
  }

  function setWildShapeOverlayOpen(open){
    if (!wildShapeOverlay) return;
    wildShapeOverlay.classList.toggle("show", !!open);
    wildShapeOverlay.setAttribute("aria-hidden", open ? "false" : "true");
    if (open){
      wildShapeKnownDraft = getWildShapeProfileData().known.slice();
      wildShapeSelectedAvailable = null;
      wildShapeSelectedKnown = null;
      renderWildShapeOverlay();
    }
  }

  function getSpellSlotLevels(profile){
    const slots = profile?.spellcasting?.spell_slots;
    if (!slots || typeof slots !== "object") return [];
    const levels = [];
    for (let level = 1; level <= 9; level += 1){
      const entry = Array.isArray(slots)
        ? slots[level - 1]
        : (slots[String(level)] ?? slots[level]);
      let maxValue = 0;
      let currentValue = 0;
      if (entry && typeof entry === "object"){
        maxValue = Number(entry.max ?? entry.total ?? entry.slots ?? 0);
        currentValue = Number(entry.current ?? entry.remaining ?? entry.max ?? maxValue);
      } else {
        maxValue = Number(entry ?? 0);
        currentValue = maxValue;
      }
      if (!Number.isFinite(maxValue)) maxValue = 0;
      if (!Number.isFinite(currentValue)) currentValue = maxValue;
      maxValue = Math.max(0, Math.floor(maxValue));
      currentValue = Math.max(0, Math.min(Math.floor(currentValue), maxValue));
      levels.push({level, max: maxValue, current: currentValue});
    }
    return levels;
  }

  function getAvailableSlotCountAtOrAbove(profile, minLevel){
    const levelFloor = Number.isFinite(Number(minLevel)) ? Math.max(1, Math.floor(Number(minLevel))) : 1;
    return getSpellSlotLevels(profile)
      .filter((entry) => entry.level >= levelFloor)
      .reduce((sum, entry) => sum + Math.max(0, Number(entry.current) || 0), 0);
  }

  function renderSpellSlotMonitor(){
    if (!spellSlotMonitorEl) return;
    const playerName = getClaimedPlayerName();
    const profile = getPlayerProfile(playerName);
    const levels = getSpellSlotLevels(profile).filter((entry) => entry.max > 0);
    spellSlotMonitorEl.textContent = "";
    if (!levels.length){
      spellSlotMonitorEl.classList.add("is-empty");
      return;
    }
    spellSlotMonitorEl.classList.remove("is-empty");
    levels.forEach((entry) => {
      const levelWrap = document.createElement("div");
      levelWrap.className = "spell-slot-level";
      const label = document.createElement("span");
      label.textContent = spellSlotNumerals[entry.level - 1] || String(entry.level);
      levelWrap.appendChild(label);
      const squaresWrap = document.createElement("div");
      squaresWrap.className = "spell-slot-squares";
      for (let i = 0; i < entry.max; i += 1){
        const square = document.createElement("span");
        square.className = `spell-slot-square ${i < entry.current ? "is-active" : "is-spent"}`;
        squaresWrap.appendChild(square);
      }
      levelWrap.appendChild(squaresWrap);
      spellSlotMonitorEl.appendChild(levelWrap);
    });
  }

  function normalizePreparedSpellList(list){
    if (!Array.isArray(list)) return [];
    return list.map(normalizeTextValue).filter(Boolean);
  }

  function getPlayerCantripList(name){
    const profile = getPlayerProfile(name);
    const spellcasting = profile?.spellcasting;
    if (!spellcasting || typeof spellcasting !== "object") return [];
    if (Array.isArray(spellcasting.cantrips_list)){
      return normalizePreparedSpellList(spellcasting.cantrips_list);
    }
    const cantrips = spellcasting.cantrips;
    if (Array.isArray(cantrips)){
      return normalizePreparedSpellList(cantrips);
    }
    if (cantrips && typeof cantrips === "object"){
      return normalizePreparedSpellList(cantrips.known);
    }
    return [];
  }

  function evaluatePreparedFormula(formula, variables){
    if (typeof formula !== "string") return null;
    const trimmed = formula.trim();
    if (!trimmed) return null;
    if (!/^[0-9+\-*/(). _a-zA-Z]+$/.test(trimmed)) return null;
    let expr = trimmed;
    Object.entries(variables).forEach(([key, value]) => {
      const safeValue = Number.isFinite(value) ? String(value) : "0";
      const pattern = new RegExp(`\\b${key}\\b`, "g");
      expr = expr.replace(pattern, safeValue);
    });
    if (/[a-zA-Z]/.test(expr)) return null;
    try {
      const result = Function(`"use strict"; return (${expr});`)();
      if (!Number.isFinite(result)) return null;
      return Math.max(0, Math.floor(result));
    } catch (err){
      return null;
    }
  }

  function getAbilityModifier(profile, key){
    const normalizedKey = normalizeAbilityKey(key);
    const abilities = profile?.abilities;
    if (!abilities || typeof abilities !== "object") return 0;
    const modValue = Number(
      abilities[`${normalizedKey}_mod`]
      ?? abilities[`${normalizedKey}_modifier`]
    );
    if (Number.isFinite(modValue)){
      return Math.floor(modValue);
    }
    const scoreValue = Number(
      abilities[normalizedKey]
      ?? abilities[normalizedKey.toUpperCase()]
      ?? abilities[`${normalizedKey}_score`]
    );
    if (Number.isFinite(scoreValue)){
      return Math.floor((scoreValue - 10) / 2);
    }
    return 0;
  }

  function normalizeAbilityKey(key){
    const raw = normalizeLowerValue(key || "");
    if (!raw) return "";
    const abilityMap = {
      strength: "str",
      str: "str",
      dexterity: "dex",
      dex: "dex",
      constitution: "con",
      con: "con",
      intelligence: "int",
      int: "int",
      wisdom: "wis",
      wis: "wis",
      charisma: "cha",
      cha: "cha",
      chr: "cha",
      char: "cha",
    };
    return abilityMap[raw] || raw;
  }

  function getProficiencyBonus(profile){
    const level = getPlayerLevel(profile);
    if (level >= 1){
      if (level >= 17) return 6;
      if (level >= 13) return 5;
      if (level >= 9) return 4;
      if (level >= 5) return 3;
      return 2;
    }
    const prof = Number(profile?.proficiency?.bonus);
    return Number.isFinite(prof) ? Math.floor(prof) : 0;
  }

  function getPreparedSpellLimit(profile, preparedData){
    const maxFormula = preparedData?.maxFormula;
    const maxValue = preparedData?.maxValue;
    const levelRaw = profile?.leveling?.level ?? profile?.leveling?.total_level ?? profile?.leveling?.lvl;
    const level = Number.isFinite(Number(levelRaw)) ? Math.max(0, Math.floor(Number(levelRaw))) : 0;
    const variables = {
      level,
      total_level: level,
      str_mod: getAbilityModifier(profile, "str"),
      dex_mod: getAbilityModifier(profile, "dex"),
      con_mod: getAbilityModifier(profile, "con"),
      int_mod: getAbilityModifier(profile, "int"),
      wis_mod: getAbilityModifier(profile, "wis"),
      cha_mod: getAbilityModifier(profile, "cha"),
    };
    const evaluated = evaluatePreparedFormula(maxFormula, variables);
    if (Number.isFinite(evaluated)){
      return evaluated;
    }
    if (Number.isFinite(maxValue)){
      return Math.max(0, Math.floor(maxValue));
    }
    const fallbackKnown = Number(profile?.spellcasting?.known_spells);
    if (Number.isFinite(fallbackKnown)){
      return Math.max(0, Math.floor(fallbackKnown));
    }
    return null;
  }

  function getPlayerSpellSaveDc(name){
    const profile = getPlayerProfile(name);
    const spellcasting = profile?.spellcasting;
    if (!spellcasting || typeof spellcasting !== "object") return null;
    const rawValue = spellcasting.save_dc ?? spellcasting.saveDC;
    const dcValue = Number(rawValue);
    if (Number.isFinite(dcValue)){
      return Math.floor(dcValue);
    }
    const formula = normalizeTextValue(spellcasting.save_dc_formula);
    if (formula){
      const castingAbility = normalizeAbilityKey(spellcasting.casting_ability || "");
      const castingMod = castingAbility ? getAbilityModifier(profile, castingAbility) : 0;
      const prof = getProficiencyBonus(profile);
      const variables = {
        prof,
        casting_mod: castingMod,
        str_mod: getAbilityModifier(profile, "str"),
        dex_mod: getAbilityModifier(profile, "dex"),
        con_mod: getAbilityModifier(profile, "con"),
        int_mod: getAbilityModifier(profile, "int"),
        wis_mod: getAbilityModifier(profile, "wis"),
        cha_mod: getAbilityModifier(profile, "cha"),
      };
      const evaluated = evaluatePreparedFormula(formula, variables);
      if (Number.isFinite(evaluated)){
        return evaluated;
      }
    }
    return null;
  }

  function applyDefaultSpellSaveDc(){
    if (!castDcValueInput) return;
    if (String(castDcValueInput.value || "").trim()){
      return;
    }
    const playerName = getClaimedPlayerName();
    const dcValue = getPlayerSpellSaveDc(playerName);
    if (Number.isFinite(dcValue)){
      castDcValueInput.value = String(dcValue);
    }
  }

  function getSpellbookConfig(name){
    const defaults = {...preparedSpellDefaults};
    if (!name) return defaults;
    const profile = getPlayerProfile(name);
    const spellcasting = profile?.spellcasting && typeof profile.spellcasting === "object"
      ? profile.spellcasting
      : null;
    if (!spellcasting){
      return defaults;
    }
    const preparedBlock = spellcasting.prepared_spells && typeof spellcasting.prepared_spells === "object"
      ? spellcasting.prepared_spells
      : {};
    const knownBlock = spellcasting.known_spells && typeof spellcasting.known_spells === "object"
      ? spellcasting.known_spells
      : {};
    const cantripsBlock = spellcasting.cantrips && typeof spellcasting.cantrips === "object"
      ? spellcasting.cantrips
      : {};
    const maxFormula = normalizeTextValue(
      spellcasting.prepared_limit_formula
      ?? preparedBlock.max_formula
    );
    const maxValue = Number(preparedBlock.max ?? preparedBlock.max_spells ?? preparedBlock.max_prepared);
    const limit = getPreparedSpellLimit(profile, {maxFormula, maxValue});
    const knownLimitRaw = spellcasting.known_limit ?? knownBlock.max ?? spellcasting.known_spells;
    const knownLimit = Number.isFinite(Number(knownLimitRaw))
      ? Math.max(0, Math.floor(Number(knownLimitRaw)))
      : null;
    const cantripsMaxRaw = cantripsBlock.max;
    const cantripsMax = Number.isFinite(Number(cantripsMaxRaw))
      ? Math.max(0, Math.floor(Number(cantripsMaxRaw)))
      : null;
    return {
      prepared: normalizePreparedSpellList(
        spellcasting.prepared_list ?? preparedBlock.prepared
      ),
      preparedFree: normalizePreparedSpellList(
        spellcasting.prepared_free_list ?? preparedBlock.free
      ),
      max: limit,
      maxFormula,
      known: normalizePreparedSpellList(
        spellcasting.known_list ?? knownBlock.known ?? spellcasting.known_spell_names
      ),
      knownFree: normalizePreparedSpellList(
        spellcasting.known_free_list ?? knownBlock.free
      ),
      knownLimit,
      knownEnabled: spellcasting.known_enabled !== false,
      cantrips: normalizePreparedSpellList(
        spellcasting.cantrips_list ?? cantripsBlock.known ?? spellcasting.cantrips
      ),
      cantripsMax,
    };
  }

  function persistSheetHeight(){
    if (!Number.isFinite(sheetHeight)) return;
    const roundedHeight = Math.round(sheetHeight);
    localStorage.setItem(sheetHeightKey, String(roundedHeight));
    const localPreset = loadLocalPreset();
    if (localPreset && typeof localPreset === "object"){
      localPreset.sheetHeight = roundedHeight;
      persistLocalPreset(localPreset);
    }
  }

  function loadSheetHeight(){
    if (!sheetWrap) return;
    const stored = Number(localStorage.getItem(sheetHeightKey));
    if (Number.isFinite(stored)){
      applySheetHeight(stored);
      return;
    }
    const {min, max} = getSheetConstraints();
    const viewportHeight = window.innerHeight || 0;
    const preferredRatio = viewportHeight <= 760 ? 0.72 : 0.64;
    let target = Math.round(min + ((max - min) * preferredRatio));
    const poolsPanel = document.getElementById("resourcePoolsPanel");
    if (poolsPanel){
      const required = Math.ceil(poolsPanel.offsetTop + poolsPanel.offsetHeight + 20);
      if (Number.isFinite(required) && required > 0){
        target = Math.max(target, required);
      }
    }
    applySheetHeight(Math.min(max, target));
  }

  function readToggle(key, defaultValue){
    const stored = localStorage.getItem(key);
    if (stored === null || stored === undefined) return defaultValue;
    return stored === "1";
  }

  function readChoice(key, allowed, defaultValue){
    const stored = localStorage.getItem(key);
    if (stored && allowed.includes(stored)) return stored;
    return defaultValue;
  }

  function persistToggle(key, value){
    localStorage.setItem(key, value ? "1" : "0");
  }

  function persistChoice(key, value){
    if (!value){
      localStorage.removeItem(key);
      return;
    }
    localStorage.setItem(key, value);
  }

  connStyle = readChoice(uiSelectKeys.connStyle, ["full", "compact"], "full");
  initiativeStyle = readChoice(uiSelectKeys.initiativeStyle, ["full", "compact", "hidden"], "full");
  let connStatusText = "Connecting";
  let connStatusOk = false;

  const hotkeyConfig = {
    toggleTopbarTitle: {
      input: hotkeyTopbarTitleInput,
      conflictEl: document.getElementById("hotkeyConflictTopbarTitle"),
      storageKey: "inittracker_hotkey_toggleTopbarTitle",
      action: () => {
        showTopbarTitle = !showTopbarTitle;
        persistToggle(uiToggleKeys.topbarTitle, showTopbarTitle);
        applyUiConfig();
      },
    },
    toggleConnStyle: {
      input: hotkeyConnStyleInput,
      conflictEl: document.getElementById("hotkeyConflictConnStyle"),
      storageKey: "inittracker_hotkey_toggleConnStyle",
      action: () => {
        connStyle = connStyle === "compact" ? "full" : "compact";
        persistChoice(uiSelectKeys.connStyle, connStyle);
        applyUiConfig();
      },
    },
    lockMap: {
      input: hotkeyLockMapInput,
      conflictEl: document.getElementById("hotkeyConflictLockMap"),
      storageKey: "inittracker_hotkey_lockMap",
      action: () => lockMapBtn && lockMapBtn.click(),
    },
    centerMap: {
      input: hotkeyCenterMapInput,
      conflictEl: document.getElementById("hotkeyConflictCenterMap"),
      storageKey: "inittracker_hotkey_centerMap",
      action: () => centerMapBtn && centerMapBtn.click(),
    },
    measure: {
      input: hotkeyMeasureInput,
      conflictEl: document.getElementById("hotkeyConflictMeasure"),
      storageKey: "inittracker_hotkey_measure",
      action: () => measureToggle && measureToggle.click(),
    },
    measureClear: {
      input: hotkeyMeasureClearInput,
      conflictEl: document.getElementById("hotkeyConflictMeasureClear"),
      storageKey: "inittracker_hotkey_measureClear",
      action: () => measureClear && measureClear.click(),
    },
    zoomIn: {
      input: hotkeyZoomInInput,
      conflictEl: document.getElementById("hotkeyConflictZoomIn"),
      storageKey: "inittracker_hotkey_zoomIn",
      action: () => zoomInBtn && zoomInBtn.click(),
    },
    zoomOut: {
      input: hotkeyZoomOutInput,
      conflictEl: document.getElementById("hotkeyConflictZoomOut"),
      storageKey: "inittracker_hotkey_zoomOut",
      action: () => zoomOutBtn && zoomOutBtn.click(),
    },
    battleLog: {
      input: hotkeyBattleLogInput,
      conflictEl: document.getElementById("hotkeyConflictBattleLog"),
      storageKey: "inittracker_hotkey_battleLog",
      action: () => battleLogBtn && battleLogBtn.click(),
    },
    useAction: {
      input: hotkeyUseActionInput,
      conflictEl: document.getElementById("hotkeyConflictUseAction"),
      storageKey: "inittracker_hotkey_useAction",
      action: () => useActionBtn && useActionBtn.click(),
    },
    useBonusAction: {
      input: hotkeyUseBonusActionInput,
      conflictEl: document.getElementById("hotkeyConflictUseBonusAction"),
      storageKey: "inittracker_hotkey_useBonusAction",
      action: () => useBonusActionBtn && useBonusActionBtn.click(),
    },
    dash: {
      input: hotkeyDashInput,
      conflictEl: document.getElementById("hotkeyConflictDash"),
      storageKey: "inittracker_hotkey_dash",
      action: () => dashBtn && dashBtn.click(),
    },
    standUp: {
      input: hotkeyStandUpInput,
      conflictEl: document.getElementById("hotkeyConflictStandUp"),
      storageKey: "inittracker_hotkey_standUp",
      action: () => standUpBtn && standUpBtn.click(),
    },
    resetTurn: {
      input: hotkeyResetTurnInput,
      conflictEl: document.getElementById("hotkeyConflictResetTurn"),
      storageKey: "inittracker_hotkey_resetTurn",
      action: () => resetTurnBtn && resetTurnBtn.click(),
    },
    toggleSheetPanel: {
      input: hotkeyToggleSheetPanelInput,
      conflictEl: document.getElementById("hotkeyConflictToggleSheetPanel"),
      storageKey: "inittracker_hotkey_toggleSheetPanel",
      action: () => setSheetPanelHidden(!sheetPanelHidden),
    },
    toggleAttackOverlay: {
      input: hotkeyAttackOverlayInput,
      conflictEl: document.getElementById("hotkeyConflictAttackOverlay"),
      storageKey: "inittracker_hotkey_toggleAttackOverlay",
      action: () => attackOverlayToggleBtn && !attackOverlayToggleBtn.disabled && attackOverlayToggleBtn.click(),
    },
  };

  if (!localStorage.getItem("inittracker_hotkey_toggleSheetPanel")){
    localStorage.setItem("inittracker_hotkey_toggleSheetPanel", "Delete");
  }
  if (!localStorage.getItem("inittracker_hotkey_toggleAttackOverlay")){
    localStorage.setItem("inittracker_hotkey_toggleAttackOverlay", "");
  }

  let hotkeyBindings = new Map();
  const RESERVED_PAN_BASE_KEYS = new Set(["W", "A", "S", "D", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"]);
  const PAN_KEY_CODES = new Set(["KeyW", "KeyA", "KeyS", "KeyD", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"]);
  const panHeldKeys = new Set();
  let panVelocityX = 0;
  let panVelocityY = 0;
  let panLoopId = null;
  let panLastTs = 0;

  function normalizeHotkeyEvent(event){
    if (!event) return null;
    if (event.key === "Shift" || event.key === "Control" || event.key === "Alt" || event.key === "Meta"){
      return null;
    }
    const parts = [];
    if (event.ctrlKey) parts.push("Ctrl");
    if (event.altKey) parts.push("Alt");
    if (event.metaKey) parts.push("Meta");
    if (event.shiftKey) parts.push("Shift");
    let key = event.key;
    if (key === " ") key = "Space";
    if (key.length === 1) key = key.toUpperCase();
    parts.push(key);
    return parts.join("+");
  }

  function isTypingTarget(target){
    if (!target) return false;
    const tag = target.tagName ? target.tagName.toLowerCase() : "";
    if (tag === "input" || tag === "textarea" || tag === "select") return true;
    if (target.isContentEditable) return true;
    return false;
  }

  function hotkeyContainsReservedPanKey(value){
    const combo = String(value || "").trim();
    if (!combo) return false;
    const parts = combo.split("+").map((part) => String(part || "").trim()).filter(Boolean);
    if (!parts.length) return false;
    const base = parts[parts.length - 1];
    return RESERVED_PAN_BASE_KEYS.has(base);
  }

  function clearReservedHotkeysFromStorage(){
    Object.values(hotkeyConfig).forEach((config) => {
      if (!config || !config.storageKey) return;
      const stored = (localStorage.getItem(config.storageKey) || "").trim();
      if (stored && hotkeyContainsReservedPanKey(stored)){
        localStorage.removeItem(config.storageKey);
      }
    });
  }

  function setHotkey(action, value){
    const config = hotkeyConfig[action];
    if (!config) return;
    const stored = value ? String(value).trim() : "";
    if (stored && hotkeyContainsReservedPanKey(stored)){
      if (config.conflictEl){
        config.conflictEl.textContent = "Reserved";
      }
      if (config.input){
        config.input.classList.add("conflict");
      }
      return;
    }
    if (stored){
      localStorage.setItem(config.storageKey, stored);
    } else {
      localStorage.removeItem(config.storageKey);
    }
    updateHotkeyInputs();
  }

  function updateHotkeyInputs(){
    const usage = {};
    hotkeyBindings = new Map();
    Object.entries(hotkeyConfig).forEach(([action, config]) => {
      if (!config || !config.input) return;
      const stored = localStorage.getItem(config.storageKey) || "";
      const normalized = stored.trim();
      config.input.value = normalized;
      if (normalized){
        if (!usage[normalized]) usage[normalized] = [];
        usage[normalized].push(action);
      }
    });
    Object.entries(hotkeyConfig).forEach(([action, config]) => {
      if (!config || !config.input) return;
      const stored = (localStorage.getItem(config.storageKey) || "").trim();
      const conflicts = stored && usage[stored] && usage[stored].length > 1;
      const reserved = stored && hotkeyContainsReservedPanKey(stored);
      config.input.classList.toggle("conflict", !!(conflicts || reserved));
      if (config.conflictEl){
        config.conflictEl.textContent = reserved ? "Reserved" : (conflicts ? "Conflict" : "");
      }
      if (stored && !conflicts && !reserved){
        hotkeyBindings.set(stored, action);
      }
    });
  }

  let presetStatusTimer = null;
  const presetStorageKey = "inittracker_gui_preset";

  function setPresetStatus(text, durationMs=2000){
    if (!presetStatus) return;
    presetStatus.textContent = text || "";
    if (presetStatusTimer){
      clearTimeout(presetStatusTimer);
      presetStatusTimer = null;
    }
    if (text && durationMs > 0){
      presetStatusTimer = setTimeout(() => {
        if (presetStatus) presetStatus.textContent = "";
        presetStatusTimer = null;
      }, durationMs);
    }
  }

  function normalizePresetHotkey(value){
    if (value === null || value === undefined) return "";
    const normalized = String(value).trim();
    return normalized;
  }

  function buildGuiPreset(){
    const hotkeys = {};
    Object.entries(hotkeyConfig).forEach(([action, config]) => {
      if (!config || !config.storageKey) return;
      hotkeys[action] = normalizePresetHotkey(localStorage.getItem(config.storageKey) || "");
    });
    return {
      version: 1,
      toggles: {
        topbarTitle: showTopbarTitle,
        connIndicator: showConnIndicator,
        lockMap: showLockMap,
        centerMap: showCenterMap,
        measure: showMeasure,
        measureClear: showMeasureClear,
        zoomIn: showZoomIn,
        zoomOut: showZoomOut,
        battleLog: showBattleLog,
        useAction: showUseAction,
        useBonusAction: showUseBonusAction,
        dash: showDash,
        standUp: showStandUp,
        resetTurn: showResetTurn,
        hideSpellMenu: hideSpellMenu,
        lockMenus: menusLocked,
      },
      choices: {
        connStyle,
        initiativeStyle,
      },
      showAllNames: showAllNames,
      sheetHeight: Number.isFinite(sheetHeight) ? Math.round(sheetHeight) : null,
      hotkeys,
    };
  }

  function persistLocalPreset(preset){
    try {
      localStorage.setItem(presetStorageKey, JSON.stringify(preset));
    } catch (err){
      console.warn("Failed to persist GUI preset locally.", err);
    }
  }

  function loadLocalPreset(){
    try {
      const raw = localStorage.getItem(presetStorageKey);
      if (!raw) return null;
      const preset = JSON.parse(raw);
      if (preset && typeof preset === "object"){
        return preset;
      }
    } catch (err){
      console.warn("Failed to load GUI preset from storage.", err);
    }
    return null;
  }

  function applyGuiPreset(preset, options = {}){
    if (!preset || typeof preset !== "object") return;
    const persist = options.persist !== false;
    const toggles = preset.toggles && typeof preset.toggles === "object" ? preset.toggles : {};
    const choices = preset.choices && typeof preset.choices === "object" ? preset.choices : {};
    if (typeof toggles.topbarTitle === "boolean") showTopbarTitle = toggles.topbarTitle;
    if (typeof toggles.connIndicator === "boolean") showConnIndicator = toggles.connIndicator;
    if (typeof toggles.lockMap === "boolean") showLockMap = toggles.lockMap;
    if (typeof toggles.centerMap === "boolean") showCenterMap = toggles.centerMap;
    if (typeof toggles.measure === "boolean") showMeasure = toggles.measure;
    if (typeof toggles.measureClear === "boolean") showMeasureClear = toggles.measureClear;
    if (typeof toggles.zoomIn === "boolean") showZoomIn = toggles.zoomIn;
    if (typeof toggles.zoomOut === "boolean") showZoomOut = toggles.zoomOut;
    if (typeof toggles.battleLog === "boolean") showBattleLog = toggles.battleLog;
    if (typeof toggles.useAction === "boolean") showUseAction = toggles.useAction;
    if (typeof toggles.useBonusAction === "boolean") showUseBonusAction = toggles.useBonusAction;
    if (typeof toggles.dash === "boolean") showDash = toggles.dash;
    if (typeof toggles.standUp === "boolean") showStandUp = toggles.standUp;
    if (typeof toggles.resetTurn === "boolean") showResetTurn = toggles.resetTurn;
    if (typeof toggles.hideSpellMenu === "boolean") hideSpellMenu = toggles.hideSpellMenu;
    if (typeof toggles.lockMenus === "boolean") menusLocked = toggles.lockMenus;
    if (persist){
      persistToggle(uiToggleKeys.topbarTitle, showTopbarTitle);
      persistToggle(uiToggleKeys.connIndicator, showConnIndicator);
      persistToggle(uiToggleKeys.lockMap, showLockMap);
      persistToggle(uiToggleKeys.centerMap, showCenterMap);
      persistToggle(uiToggleKeys.measure, showMeasure);
      persistToggle(uiToggleKeys.measureClear, showMeasureClear);
      persistToggle(uiToggleKeys.zoomIn, showZoomIn);
      persistToggle(uiToggleKeys.zoomOut, showZoomOut);
      persistToggle(uiToggleKeys.battleLog, showBattleLog);
      persistToggle(uiToggleKeys.useAction, showUseAction);
      persistToggle(uiToggleKeys.useBonusAction, showUseBonusAction);
      persistToggle(uiToggleKeys.dash, showDash);
      persistToggle(uiToggleKeys.standUp, showStandUp);
      persistToggle(uiToggleKeys.resetTurn, showResetTurn);
      persistToggle(uiToggleKeys.hideSpellMenu, hideSpellMenu);
      persistToggle(uiToggleKeys.lockMenus, menusLocked);
    }
    if (choices.connStyle && ["full", "compact"].includes(choices.connStyle)){
      connStyle = choices.connStyle;
      if (persist){
        persistChoice(uiSelectKeys.connStyle, connStyle);
      }
    }
    if (choices.initiativeStyle && ["full", "compact", "hidden"].includes(choices.initiativeStyle)){
      initiativeStyle = choices.initiativeStyle;
      if (persist){
        persistChoice(uiSelectKeys.initiativeStyle, initiativeStyle);
      }
    }
    if (typeof preset.showAllNames === "boolean"){
      showAllNames = preset.showAllNames;
      if (showAllNamesEl){
        showAllNamesEl.checked = showAllNames;
      }
      if (persist){
        localStorage.setItem("inittracker_showAllNames", showAllNames ? "1" : "0");
      }
    }
    if (Number.isFinite(Number(preset.sheetHeight))){
      applySheetHeight(Number(preset.sheetHeight));
      if (persist){
        persistSheetHeight();
      }
    }
    if (preset.hotkeys && typeof preset.hotkeys === "object"){
      Object.entries(preset.hotkeys).forEach(([action, value]) => {
        const config = hotkeyConfig[action];
        if (!config || !config.storageKey) return;
        const normalized = normalizePresetHotkey(value);
        if (persist){
          if (normalized){
            localStorage.setItem(config.storageKey, normalized);
          } else {
            localStorage.removeItem(config.storageKey);
          }
        }
        if (config.input){
          config.input.value = normalized;
        }
      });
    }
    applyUiConfig();
    updateHotkeyInputs();
  }

  function applyConnStyle(){
    if (!connEl) return;
    connEl.classList.toggle("conn-compact", connStyle === "compact");
    updateConnDisplay();
  }

  function shouldAutoCompactLayout(){
    const width = window.innerWidth || document.documentElement?.clientWidth || 0;
    const height = window.innerHeight || document.documentElement?.clientHeight || 0;
    return width <= 900 || height <= 720;
  }

  function toggleInitiativeBar(forceVisible){
    const shouldShow = typeof forceVisible === "boolean"
      ? forceVisible
      : document.body.classList.contains("initiative-hidden");
    document.body.classList.toggle("initiative-hidden", !shouldShow);
    initiativeStyle = shouldShow ? "full" : "hidden";
    persistChoice(uiSelectKeys.initiativeStyle, initiativeStyle);
    if (initiativeStyleSelect){
      initiativeStyleSelect.value = initiativeStyle;
    }
    if (initiativeToggleBtn){
      initiativeToggleBtn.setAttribute("aria-pressed", shouldShow ? "true" : "false");
    }
    updateModalOffsets();
    updateTurnOrder();
    resize();
  }

  function applyUiConfig(){
    const autoCompact = initiativeStyle === "full" && shouldAutoCompactLayout();
    document.body.classList.toggle("menus-locked", menusLocked);
    document.body.classList.toggle("initiative-compact", initiativeStyle === "compact" || autoCompact);
    document.body.classList.toggle("initiative-hidden", initiativeStyle === "hidden");
    document.body.classList.toggle("auto-compact", autoCompact);
    if (initiativeToggleBtn) initiativeToggleBtn.setAttribute("aria-pressed", initiativeStyle === "hidden" ? "false" : "true");
    if (topbarTitleEl) topbarTitleEl.classList.toggle("hidden", !showTopbarTitle);
    if (connEl) connEl.classList.toggle("hidden", !showConnIndicator);
    if (!showConnIndicator){
      closeConnPopover();
    }
    if (lockMapBtn) lockMapBtn.classList.toggle("hidden", !showLockMap);
    if (centerMapBtn) centerMapBtn.classList.toggle("hidden", !showCenterMap);
    if (measureToggle) measureToggle.classList.toggle("hidden", !showMeasure);
    if (measureClear) measureClear.classList.toggle("hidden", !showMeasureClear);
    if (zoomInBtn) zoomInBtn.classList.toggle("hidden", !showZoomIn);
    if (zoomOutBtn) zoomOutBtn.classList.toggle("hidden", !showZoomOut);
    if (battleLogBtn) battleLogBtn.classList.toggle("hidden", !showBattleLog);
    if (useActionBtn) useActionBtn.classList.toggle("hidden", !showUseAction);
    if (useBonusActionBtn) useBonusActionBtn.classList.toggle("hidden", !showUseBonusAction);
    if (dashBtn) dashBtn.classList.toggle("hidden", !showDash);
    if (standUpBtn) standUpBtn.classList.toggle("hidden", !showStandUp);
    if (resetTurnBtn) resetTurnBtn.classList.toggle("hidden", !showResetTurn);
    if (toggleTopbarTitle) toggleTopbarTitle.checked = showTopbarTitle;
    if (toggleConnIndicator) toggleConnIndicator.checked = showConnIndicator;
    if (connStyleButtons.length){
      connStyleButtons.forEach((button) => {
        const isActive = button.dataset.connStyle === connStyle;
        button.classList.toggle("active", isActive);
        button.setAttribute("aria-pressed", isActive ? "true" : "false");
      });
    }
    if (toggleLockMap) toggleLockMap.checked = showLockMap;
    if (toggleCenterMap) toggleCenterMap.checked = showCenterMap;
    if (toggleMeasure) toggleMeasure.checked = showMeasure;
    if (toggleMeasureClear) toggleMeasureClear.checked = showMeasureClear;
    if (toggleZoomIn) toggleZoomIn.checked = showZoomIn;
    if (toggleZoomOut) toggleZoomOut.checked = showZoomOut;
    if (toggleBattleLog) toggleBattleLog.checked = showBattleLog;
    if (initiativeStyleSelect) initiativeStyleSelect.value = initiativeStyle;
    if (toggleUseAction) toggleUseAction.checked = showUseAction;
    if (toggleUseBonusAction) toggleUseBonusAction.checked = showUseBonusAction;
    if (toggleDash) toggleDash.checked = showDash;
    if (toggleStandUp) toggleStandUp.checked = showStandUp;
    if (toggleResetTurn) toggleResetTurn.checked = showResetTurn;
    if (toggleSpellMenu) toggleSpellMenu.checked = hideSpellMenu;
    if (toggleLockMenus) toggleLockMenus.checked = menusLocked;
    if (sheetWrap){
      sheetWrap.classList.toggle("hidden", sheetPanelHidden);
    }
    if (toggleSheetPanelBtn){
      toggleSheetPanelBtn.textContent = sheetPanelHidden ? "Show Panel" : "Hide Panel";
      toggleSheetPanelBtn.setAttribute("aria-pressed", sheetPanelHidden ? "true" : "false");
    }
    if (sheetHandle){
      sheetHandle.setAttribute("aria-disabled", menusLocked ? "true" : "false");
    }
    applyConnStyle();
    updateHotkeyInputs();
    updateSpellPanelVisibility();
    updateResourceGatedControls();
    updateMountControls();
    updateAoeLockButton();
  }

  const localPreset = loadLocalPreset();
  if (localPreset){
    applyGuiPreset(localPreset, {persist: true});
    if (!Number.isFinite(Number(localPreset.sheetHeight))){
      loadSheetHeight();
    }
  } else {
    applyUiConfig();
    loadSheetHeight();
  }
  if (sheetHandle && sheetWrap){
    let dragState = null;
    sheetHandle.addEventListener("pointerdown", (event) => {
      if (menusLocked) return;
      sheetHandle.setPointerCapture(event.pointerId);
      dragState = {
        startY: event.clientY,
        startHeight: sheetWrap.getBoundingClientRect().height,
      };
      event.preventDefault();
    });
    sheetHandle.addEventListener("pointermove", (event) => {
      if (!dragState) return;
      const delta = dragState.startY - event.clientY;
      applySheetHeight(dragState.startHeight + delta);
    });
    sheetHandle.addEventListener("pointerup", () => {
      if (!dragState) return;
      dragState = null;
      persistSheetHeight();
    });
    sheetHandle.addEventListener("pointercancel", () => {
      if (!dragState) return;
      dragState = null;
      persistSheetHeight();
    });
  }

  function setHelpMessage(text){
    if (helpMessage){ helpMessage.textContent = text || ""; }
  }

  function flattenToc(nodes){
    const out = [];
    const walk = (items) => (items || []).forEach((node) => { out.push(node); walk(node.children || []); });
    walk(nodes || []);
    return out;
  }

  function renderRulesToc(){
    if (!helpTocTree) return;
    const q = String(helpSearchInput?.value || "").trim().toLowerCase();
    const matches = (title) => !q || String(title || "").toLowerCase().includes(q);
    const className = getClaimedPlayerClassName();
    const classNode = findClassNode(className);
    const build = (nodes) => {
      const frag = document.createDocumentFragment();
      (nodes || []).forEach((node) => {
        const childFrag = build(node.children || []);
        const include = matches(node.title) || childFrag.childNodes.length > 0;
        if (!include) return;
        const row = document.createElement("div");
        row.className = "rules-help-node";
        const btn = document.createElement("button");
        btn.type = "button";
        const page = node.page ? ` (p.${node.page})` : "";
        btn.textContent = `${node.title}${page}`;
        btn.addEventListener("click", () => jumpRulesPage(node.page || 1));
        row.appendChild(btn);
        if (childFrag.childNodes.length){
          const children = document.createElement("div");
          children.className = "rules-help-children";
          children.appendChild(childFrag);
          row.appendChild(children);
        }
        frag.appendChild(row);
      });
      return frag;
    };
    helpTocTree.innerHTML = "";
    if (rulesStatusCache?.available && classNode?.page){
      const pinned = document.createElement("div");
      pinned.className = "rules-help-pinned";
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "btn";
      btn.textContent = `My class: ${className || classNode.title || "Unknown"} (p.${classNode.page})`;
      btn.addEventListener("click", () => jumpRulesPage(classNode.page || 1));
      pinned.appendChild(btn);
      helpTocTree.appendChild(pinned);
    }
    helpTocTree.appendChild(build(rulesTocCache));
  }

  function loadRulesViewer(page=1){
    if (!helpViewer) return;
    rulesLastPage = Math.max(1, Number(page || 1));
    const base = "/assets/web/lan/pdfjs/web/viewer.html";
    const nonce = Date.now();
    const url = `${base}?page=${rulesLastPage}&_ts=${nonce}#page=${rulesLastPage}`;
    rulesViewerReady = false;
    helpViewer.src = url;
    rulesViewerLoaded = true;
  }

  function jumpRulesPage(page=1){
    const num = Math.max(1, Number(page || 1));
    rulesLastPage = num;
    try { localStorage.setItem(rulesLastPageStorageKey, String(num)); } catch (_err) {}
    if (!rulesViewerLoaded){
      loadRulesViewer(num);
      return;
    }
    try {
      const frameWin = helpViewer.contentWindow;
      if (rulesViewerReady && frameWin){
        frameWin.postMessage({ type: "rules:jump", page: num }, window.location.origin);
      }
      const current = new URL(helpViewer.src, window.location.origin);
      current.hash = `page=${num}`;
      const nextUrl = current.toString();
      if (helpViewer.src !== nextUrl){
        helpViewer.src = nextUrl;
      }
    } catch (_err){
      loadRulesViewer(num);
    }
  }

  function normalizeClassToken(value){
    const raw = String(value || "").trim().toLowerCase();
    if (!raw) return "";
    const first = raw.split(/[\/,;&+|]/)[0] || raw;
    return first.trim().replace(/[^a-z0-9\s-]/g, " ").split(/\s+/)[0] || "";
  }

  function getClaimedPlayerClassName(){
    const claimed = getClaimedUnit?.();
    const claimedName = String(claimed?.name || "").trim();
    if (!claimedName) return "";
    const profiles = state?.player_profiles && typeof state.player_profiles === "object"
      ? state.player_profiles
      : null;
    if (!profiles) return "";
    const player = profiles[claimedName] || null;
    if (!player || typeof player !== "object") return "";
    const leveling = player.leveling && typeof player.leveling === "object" ? player.leveling : null;
    if (!leveling) return "";
    if (typeof leveling.class === "string" && leveling.class.trim()) return leveling.class.trim();
    const classes = Array.isArray(leveling.classes) ? leveling.classes : [];
    const first = classes.find((entry) => entry && typeof entry === "object" && typeof entry.name === "string" && entry.name.trim());
    return first?.name?.trim() || "";
  }

  function findClassNode(className){
    const token = normalizeClassToken(className);
    if (!token) return null;
    const flat = flattenToc(rulesTocCache);
    const normalized = flat.map((n) => ({
      node: n,
      title: String(n?.title || "").trim().toLowerCase().replace(/[^a-z0-9\s-]/g, " ").replace(/\s+/g, " ").trim(),
    }));
    return normalized.find((n) => n.title === token)?.node
      || normalized.find((n) => n.title.startsWith(`${token} `))?.node
      || normalized.find((n) => n.title.includes(token))?.node
      || null;
  }

  async function ensureRulesData(){
    if (!rulesStatusCache){
      const statusResp = await fetch("/api/rules/status");
      rulesStatusCache = await statusResp.json();
    }
    if (rulesStatusCache?.available && (!Array.isArray(rulesTocCache) || !rulesTocCache.length)){
      const tocResp = await fetch("/api/rules/toc");
      const tocPayload = await tocResp.json();
      rulesTocCache = Array.isArray(tocPayload?.toc) ? tocPayload.toc : [];
    }
    if (!rulesSpellPagesCache){
      const spellPagesResp = await fetch("/api/rules/spell-pages");
      const spellPagesPayload = await spellPagesResp.json();
      rulesSpellPagesCache = spellPagesPayload?.pages && typeof spellPagesPayload.pages === "object"
        ? spellPagesPayload.pages
        : {};
    }
    renderRulesToc();
    const available = !!rulesStatusCache?.available;
    if (helpOpenBookBtn) helpOpenBookBtn.disabled = !available;
    if (helpOpenClassBtn) helpOpenClassBtn.disabled = !available;
    if (!available){
      const expected = rulesStatusCache?.expected_path || "~/Documents/Dnd-Init-Yamls/rules/PlayersHandbook2024.pdf";
      setHelpMessage(`Place your PDF at: ${expected} (or set INITTRACKER_RULES_PDF).`);
    } else if (rulesStatusCache?.error){
      setHelpMessage(String(rulesStatusCache.error));
    } else {
      setHelpMessage("");
    }
  }

  function showHelpModal(){
    if (!helpModal) return;
    helpModal.classList.add("show");
    helpModal.setAttribute("aria-hidden", "false");
    if (helpBtn) helpBtn.setAttribute("aria-expanded", "true");
    ensureRulesData().catch(() => setHelpMessage("Failed to load rules metadata."));
  }

  function hideHelpModal(){
    if (!helpModal) return;
    helpModal.classList.remove("show");
    helpModal.setAttribute("aria-hidden", "true");
    if (helpBtn) helpBtn.setAttribute("aria-expanded", "false");
  }

  function renderCastSpellModalPresetList(){
    if (!castSpellPresetList) return;
    const search = normalizeLowerValue(castSpellModalSearchInput?.value || "");
    castSpellPresetList.textContent = "";
    const preparedSet = getPreparedSpellFilterSet();
    const sortMode = normalizeLowerValue(castSpellModalSortInput?.value || "alpha");
    const presets = filterPresetsByKnownList(cachedSpellPresets.slice(), preparedSet)
      .filter((preset) => !search || normalizeLowerValue(preset?.name).includes(search))
      .sort((a, b) => {
        if (sortMode === "level"){
          const aLevel = getPresetLevelNumber(a);
          const bLevel = getPresetLevelNumber(b);
          const aRank = Number.isFinite(aLevel) ? aLevel : 99;
          const bRank = Number.isFinite(bLevel) ? bLevel : 99;
          if (aRank !== bRank) return aRank - bRank;
        }
        return normalizeTextValue(a?.name).localeCompare(normalizeTextValue(b?.name));
      });
    const entries = [
      {label: "None", value: ""},
      {label: "Custom", value: "__custom__"},
      {label: CUSTOM_SUMMON_PRESET_NAME, value: CUSTOM_SUMMON_PRESET_NAME},
      ...presets.map((preset) => ({label: normalizeTextValue(preset.name), value: normalizeTextValue(preset.name)})),
    ];
    entries.forEach((entry) => {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "btn" + (castSpellModalSelection === entry.value ? " active" : "");
      btn.textContent = entry.label || "Unnamed";
      btn.addEventListener("click", () => selectCastSpellModalPreset(entry.value));
      castSpellPresetList.appendChild(btn);
    });
  }

  function renderCastSpellPreview(){
    if (!castSpellPreview) return;
    const selected = castSpellModalSelection;
    const preset = selected && selected !== "__custom__" ? (selected === CUSTOM_SUMMON_PRESET_NAME ? CUSTOM_SUMMON_PRESET : getSelectedSpellPreset()) : null;
    castSpellPreview.textContent = "";
    if (!selected){
      castSpellPreview.innerHTML = '<div class="cast-preview-empty">Please select a spell to cast</div>';
      return;
    }
    const heading = document.createElement("div");
    heading.className = "cast-preview-heading";
    heading.textContent = normalizeTextValue(castNameInput?.value || preset?.name || (selected === "__custom__" ? "Custom" : "Spell"));
    castSpellPreview.appendChild(heading);
    const form = document.createElement("div");
    form.className = "cast-preview-grid";
    const addField = (label, inputEl) => {
      if (!inputEl) return;
      const wrap = document.createElement("div");
      wrap.className = "form-field";
      const lab = document.createElement("label");
      lab.textContent = label;
      wrap.appendChild(lab);
      wrap.appendChild(inputEl);
      form.appendChild(wrap);
    };
    const mkNumber = (value, min, onInput) => {
      const input = document.createElement("input");
      input.type = "number";
      if (min !== null) input.min = String(min);
      input.step = "1";
      input.value = String(value ?? "");
      input.addEventListener("input", onInput);
      return input;
    };
    const slot = mkNumber(castSlotLevelInput?.value || "", 0, () => { castSlotLevelInput.value = slot.value; castSlotLevelInput.dispatchEvent(new Event("input", {bubbles:true})); renderCastSpellPreview(); });
    addField("Slot Level", slot);
    const automationBtn = document.createElement("button");
    automationBtn.type = "button";
    const automationOn = castAutomationIsEnabled();
    automationBtn.className = `btn ${automationOn ? "success" : "danger"}`;
    automationBtn.textContent = automationOn ? "ON" : "OFF";
    automationBtn.addEventListener("click", () => {
      setCastAutomationEnabled(!castAutomationIsEnabled());
      renderCastSpellPreview();
    });
    addField("Automation", automationBtn);
    const isSummon = isSummonPreset(preset || (selected === CUSTOM_SUMMON_PRESET_NAME ? CUSTOM_SUMMON_PRESET : null));
    const isAoe = isAoePreset(preset);
    if (isSummon){
      const summonSelect = castSummonChoiceInput?.cloneNode(true);
      summonSelect?.addEventListener("change", () => { if (castSummonChoiceInput){ castSummonChoiceInput.value = summonSelect.value; castSummonChoiceInput.dispatchEvent(new Event("change", {bubbles:true})); renderCastSpellPreview(); } });
      addField("Summon", summonSelect);
      const variant = castSummonVariantInput?.cloneNode(true);
      variant?.addEventListener("change", () => { if (castSummonVariantInput){ castSummonVariantInput.value = variant.value; castSummonVariantInput.dispatchEvent(new Event("change", {bubbles:true})); renderCastSpellPreview(); } });
      if (variant && !variant.disabled) addField("Variant", variant);
      const qty = document.createElement("input"); qty.type = "text"; qty.readOnly = true; qty.value = String(castSummonQuantityInput?.value || "1");
      addField("Quantity", qty);
      const color = document.createElement("input"); color.type = "color"; color.value = castColorInput?.value || DEFAULT_SPELL_COLOR;
      color.addEventListener("input", ()=>{ if (castColorInput) castColorInput.value = color.value; });
      addField("Color", color);
    } else if (isAoe){
      const dtype = document.createElement("input"); dtype.type = "text"; dtype.value = Array.from(castDamageTypes).join(", "); dtype.readOnly = true;
      addField("Damage Type(s)", dtype);
      const color = document.createElement("input"); color.type = "color"; color.value = castColorInput?.value || DEFAULT_SPELL_COLOR;
      color.addEventListener("input", ()=>{ if (castColorInput) castColorInput.value = color.value; });
      addField("Color", color);
    } else {
      if (castDcTypeInput?.value){
        const dcType = castDcTypeInput.cloneNode(true);
        dcType.addEventListener("change", ()=>{ castDcTypeInput.value = dcType.value; });
        addField("DC Type", dcType);
        const dcVal = mkNumber(castDcValueInput?.value || "", 0, ()=>{ castDcValueInput.value = dcVal.value; });
        addField("Save DC", dcVal);
      }
      const dmg = document.createElement("input"); dmg.type = "text"; dmg.value = castDefaultDamageInput?.value || "";
      dmg.addEventListener("input", ()=>{ castDefaultDamageInput.value = dmg.value; });
      addField("Default Damage", dmg);
      const dice = document.createElement("input"); dice.type = "text"; dice.value = castDiceInput?.value || "";
      dice.addEventListener("input", ()=>{ castDiceInput.value = dice.value; castDiceInput.dispatchEvent(new Event("input", {bubbles:true})); renderCastSpellPreview(); });
      addField("Damage Dice", dice);
      const dtypeWrap = document.createElement("div"); dtypeWrap.className = "form-field";
      const lbl = document.createElement("label"); lbl.textContent = "Damage Types"; dtypeWrap.appendChild(lbl);
      const row = document.createElement("div"); row.className = "cast-preview-dtype-row";
      const select = castDamageTypeInput?.cloneNode(true);
      const addBtn = document.createElement("button"); addBtn.type = "button"; addBtn.className = "btn"; addBtn.textContent = "Add";
      addBtn.addEventListener("click", ()=>{ addCastDamageType(select?.value || ""); renderCastSpellPreview(); });
      if (select) row.appendChild(select);
      row.appendChild(addBtn);
      dtypeWrap.appendChild(row);
      const list = castDamageTypeList?.cloneNode(true); if (list){ list.classList.add("cast-preview-dtype-list"); dtypeWrap.appendChild(list); }
      form.appendChild(dtypeWrap);
      const color = document.createElement("input"); color.type = "color"; color.value = castColorInput?.value || DEFAULT_SPELL_COLOR;
      color.addEventListener("input", ()=>{ if (castColorInput) castColorInput.value = color.value; });
      addField("Color", color);
    }
    castSpellPreview.appendChild(form);
    const details = spellPresetDetails?.cloneNode(true);
    if (details){ details.classList.add("cast-preview-section"); castSpellPreview.appendChild(details); }
    const actions = document.createElement("div");
    actions.className = "form-actions cast-preview-section cast-preview-actions";
    const castBtn = document.createElement("button");
    castBtn.type = "button";
    castBtn.className = "btn success cast-preview-cast-btn";
    castBtn.textContent = "Cast";
    castBtn.addEventListener("click", () => {
      if (!castForm) return;
      if (!castForm.checkValidity()){
        castForm.reportValidity();
        localToast("Cast form invalid; check wall dimensions/range.");
        return;
      }
      try {
        castForm.requestSubmit();
      } catch (_err){
        castSubmitBtn?.click();
      }
    });
    actions.appendChild(castBtn);
    castSpellPreview.appendChild(actions);
  }

  function selectCastSpellModalPreset(value){
    castSpellModalSelection = String(value || "");
    if (castSpellPresetSummary){
      const label = castSpellModalSelection === "" ? "None" : (castSpellModalSelection === "__custom__" ? "Custom" : castSpellModalSelection);
      castSpellPresetSummary.textContent = `Spells & Presets (${label})`;
    }
    if (castPresetInput){
      castPresetInput.value = castSpellModalSelection === "__custom__" ? "" : castSpellModalSelection;
      castPresetInput.dispatchEvent(new Event("change", {bubbles:true}));
    }
    renderCastSpellModalPresetList();
    renderCastSpellPreview();
  }

  function showCastSpellModal(){
    if (!castSpellModal) return;
    castSpellModal.classList.add("show");
    castSpellModal.setAttribute("aria-hidden", "false");
    castSpellModalPreviousFocus = document.activeElement instanceof HTMLElement ? document.activeElement : null;
    castSpellModalSelection = castPresetInput?.value === "" ? (castSpellModalSelection || "") : String(castPresetInput?.value || "");
    if (castSpellModalSelection === "Custom") castSpellModalSelection = "__custom__";
    renderCastSpellModalPresetList();
    renderCastSpellPreview();
    requestAnimationFrame(() => castSpellModalBackBtn?.focus());
  }

  function hideCastSpellModal(){
    if (!castSpellModal) return;
    castSpellModal.classList.remove("show");
    castSpellModal.setAttribute("aria-hidden", "true");
    if (castSpellModalPreviousFocus){ castSpellModalPreviousFocus.focus(); castSpellModalPreviousFocus = null; }
  }

  function showConfigModal(){
    if (!configModal) return;
    configModal.classList.add("show");
    configModal.setAttribute("aria-hidden", "false");
    if (configBtn){
      configBtn.setAttribute("aria-expanded", "true");
    }
  }

  function hideConfigModal(){
    if (!configModal) return;
    configModal.classList.remove("show");
    configModal.setAttribute("aria-hidden", "true");
    if (configBtn){
      configBtn.setAttribute("aria-expanded", "false");
    }
  }

  if (helpBtn){
    helpBtn.addEventListener("click", () => {
      if (castSpellModal?.classList.contains("show")){
        hideCastSpellModal();
        return;
      }
      if (helpModal?.classList.contains("show")){
        hideHelpModal();
        return;
      }
      showHelpModal();
    });
  }
  if (helpCloseBtn){
    helpCloseBtn.addEventListener("click", hideHelpModal);
  }
  if (helpModal){
    helpModal.addEventListener("click", (event) => {
      if (event.target === helpModal){
        hideHelpModal();
      }
    });
  }
  if (castSpellModalOpenBtn){
    castSpellModalOpenBtn.addEventListener("click", () => {
      showCastSpellModal();
    });
  }
  if (castSpellModalBackBtn){
    castSpellModalBackBtn.addEventListener("click", hideCastSpellModal);
  }
  if (castSpellModalManageSpellsBtn){
    castSpellModalManageSpellsBtn.addEventListener("click", () => {
      hideCastSpellModal();
      openSpellbookOverlay(true);
    });
  }
  if (castSpellModalCloseBtn){
    castSpellModalCloseBtn.addEventListener("click", hideCastSpellModal);
  }
  if (castSpellModal){
    castSpellModal.addEventListener("click", (event) => {
      if (event.target === castSpellModal){
        hideCastSpellModal();
      }
    });
  }
  if (castSpellModalSearchInput){
    castSpellModalSearchInput.addEventListener("input", renderCastSpellModalPresetList);
  }
  if (castSpellModalSortInput){
    castSpellModalSortInput.addEventListener("change", renderCastSpellModalPresetList);
  }
  if (helpSearchInput){
    helpSearchInput.addEventListener("input", () => renderRulesToc());
  }
  if (helpViewer){
    helpViewer.addEventListener("load", () => {
      rulesViewerReady = true;
      try {
        const frameWin = helpViewer.contentWindow;
        if (frameWin){
          frameWin.postMessage({ type: "rules:jump", page: rulesLastPage || 1 }, window.location.origin);
        }
      } catch (_err) {}
    });
  }
  if (helpOpenBookBtn){
    helpOpenBookBtn.addEventListener("click", () => jumpRulesPage(rulesLastPage || 1));
  }
  if (helpOpenTabBtn){
    helpOpenTabBtn.addEventListener("click", () => {
      window.open(`/assets/web/lan/pdfjs/web/viewer.html?page=${rulesLastPage || 1}#page=${rulesLastPage || 1}`, "_blank", "noopener,noreferrer");
    });
  }
  if (helpOpenClassBtn){
    helpOpenClassBtn.addEventListener("click", () => {
      const className = getClaimedPlayerClassName();
      const node = findClassNode(className);
      if (!className){
        setHelpMessage("Could not determine your class from the claimed character profile.");
        return;
      }
      if (!node || !node.page){
        setHelpMessage(`Could not find a bookmark for class: ${className}`);
        return;
      }
      setHelpMessage("");
      jumpRulesPage(node.page);
    });
  }

  const mapViewBlockedTypes = new Set([
    "move",
    "dash",
    "cycle_movement_mode",
    "perform_action",
    "end_turn",
    "use_action",
    "use_bonus_action",
    "set_color",
    "reset_turn",
    "cast_aoe",
    "cast_spell",
    "echo_summon",
    "echo_swap",
    "aoe_move",
    "aoe_remove",
    "save_preset",
    "lay_on_hands_use",
    "monk_patient_defense",
    "monk_step_of_wind",
    "monk_elemental_attunement",
    "monk_elemental_burst",
    "monk_uncanny_metabolism",
  ]);

  function send(msg){
    if (isPlanning){
      const typ = String(msg?.type || "");
      if (typ !== "planning_hello" && typ !== "planning_chat") return;
    }
    if (isMapView && msg && mapViewBlockedTypes.has(msg.type)){
      return;
    }
    if (!ws || ws.readyState !== 1) return;
    ws.send(JSON.stringify(msg));
  }

  function localToast(text){
    if (!noteEl) return;
    noteEl.textContent = text || "";
  }

  function renderPlanningChat(){
    if (!planningChatList) return;
    planningChatList.textContent = "";
    planningChatMessages.forEach((entry) => {
      const item = document.createElement("div");
      item.className = "planning-chat-item";
      const meta = document.createElement("div");
      meta.className = "planning-chat-meta";
      const who = String(entry?.name || entry?.host || "Unknown");
      const host = String(entry?.host || "?");
      const ts = String(entry?.ts || "");
      meta.textContent = `${who} (${host}) ${ts}`.trim();
      const body = document.createElement("div");
      body.textContent = String(entry?.text || "");
      item.appendChild(meta);
      item.appendChild(body);
      planningChatList.appendChild(item);
    });
    planningChatList.scrollTop = planningChatList.scrollHeight;
  }

  function appendPlanningChatMessage(msg){
    const text = String(msg?.text || "").trim();
    if (!text) return;
    planningChatMessages.push({
      ts: String(msg?.ts || ""),
      host: String(msg?.host || ""),
      name: String(msg?.name || ""),
      text,
    });
    if (planningChatMessages.length > planningChatMaxMessages){
      planningChatMessages = planningChatMessages.slice(-planningChatMaxMessages);
    }
    renderPlanningChat();
  }

  function setPlanningChatOpen(open){
    planningChatOpen = !!open;
    if (!planningChatOverlay) return;
    if (!chatViewPrefs){
      chatViewPrefs = readChatViewPrefs();
    }
    chatViewPrefs.visible = planningChatOpen;
    planningChatOverlay.classList.toggle("show", planningChatOpen);
    planningChatOverlay.setAttribute("aria-hidden", planningChatOpen ? "false" : "true");
    if (planningChatBtn){
      planningChatBtn.setAttribute("aria-pressed", planningChatOpen ? "true" : "false");
    }
    if (planningChatOpen){
      applyChatViewPrefs();
      renderPlanningChat();
      planningChatInput?.focus();
    }
    persistChatViewPrefs();
  }

  const DEFAULT_SPELL_COLOR = "#6aa9ff";

  function normalizeHexColor(raw){
    if (!raw) return null;
    const value = String(raw).trim().toLowerCase();
    if (!/^#[0-9a-f]{6}$/.test(value)) return null;
    return value;
  }

  function normalizeMovementMode(value){
    if (typeof value !== "string") return "normal";
    const lowered = value.trim().toLowerCase();
    if (["normal", "swim", "burrow", "fly"].includes(lowered)) return lowered;
    if (lowered === "land") return "normal";
    if (lowered === "water") return "swim";
    return "normal";
  }

  function normalizeMovementType(value, isSwim){
    if (typeof value === "string"){
      const lowered = value.trim().toLowerCase();
      if (["water", "ground"].includes(lowered)) return lowered;
      if (["swim", "waterborne"].includes(lowered)) return "water";
      if (["land", "normal", "burrow", "earth"].includes(lowered)) return "ground";
    }
    return isSwim ? "water" : "ground";
  }

  function cellMovementType(cell){
    return normalizeMovementType(cell?.movement_type, !!cell?.is_swim);
  }

  function movementModeLabel(mode){
    const key = normalizeMovementMode(mode);
    if (key === "swim") return "Swim";
    if (key === "burrow") return "Burrow";
    if (key === "fly") return "Fly";
    return "Normal";
  }

  function resolveSpellColor(raw){
    return normalizeHexColor(raw || "") || DEFAULT_SPELL_COLOR;
  }

  function hexToRgb(hex){
    const value = normalizeHexColor(hex);
    if (!value) return null;
    return {
      r: parseInt(value.slice(1, 3), 16),
      g: parseInt(value.slice(3, 5), 16),
      b: parseInt(value.slice(5, 7), 16),
    };
  }


  function applyServerClaim(claimedCidValue, claimedName, incomingRev){
    const revValue = Number.isFinite(Number(incomingRev)) ? Number(incomingRev) : claimRev;
    if (Number.isFinite(revValue) && revValue < claimRev){
      return false;
    }
    claimRev = Number.isFinite(revValue) ? revValue : claimRev;
    claimedCid = normalizeCid(claimedCidValue, "claim.server.claimedCid");
    claimStatus = (claimedCid !== null && claimedCid !== undefined) ? "claimed" : "unclaimed";
    clearClaimInFlight();
    if (meEl){
      if (claimedCid !== null && claimedCid !== undefined){
        const name = claimedName || getClaimablePcName(claimedCid, lastPcList || []) || `#${claimedCid}`;
        setMeLabel({name}, false);
      } else {
        setMeLabel(null, false);
      }
    }
    if (claimedCid !== null && claimedCid !== undefined){
      shownNoOwnedToast = false;
    }
    refreshSpellPresetOptions();
    updateClaimOverlay();
    updateResourceGatedControls();
    updateMountControls();
    queueMicrotask(updateMountControls);
    return true;
  }

  function rgbaFromHex(hex, alpha){
    const rgb = hexToRgb(hex);
    if (!rgb) return null;
    return `rgba(${rgb.r},${rgb.g},${rgb.b},${alpha})`;
  }

  function updateColorRgbBoxes(color, rEl, gEl, bEl){
    const rgb = hexToRgb(color);
    if (!rgb) return;
    if (rEl) rEl.textContent = `R: ${rgb.r}`;
    if (gEl) gEl.textContent = `G: ${rgb.g}`;
    if (bEl) bEl.textContent = `B: ${rgb.b}`;
  }

  function updateTokenColorSwatch(color){
    const resolved = normalizeHexColor(color) || "#6aa9ff";
    if (tokenColorSwatch) tokenColorSwatch.style.background = resolved;
    updateColorRgbBoxes(resolved, tokenColorR, tokenColorG, tokenColorB);
  }

  function updateTokenBorderColorSwatch(color){
    const resolved = normalizeHexColor(color) || "#ffffff";
    if (tokenBorderColorSwatch) tokenBorderColorSwatch.style.background = resolved;
    updateColorRgbBoxes(resolved, tokenBorderColorR, tokenBorderColorG, tokenBorderColorB);
  }

  function openColorModal(unit){
    if (!colorModal || !tokenColorInput || !tokenBorderColorInput) return;
    const targetUnit = unit || getClaimedUnit();
    if (!targetUnit){
      localToast("Claim a character first, matey.");
      return;
    }
    pendingClaim = targetUnit;
    let preferred = normalizeHexColor(targetUnit?.token_color)
      || normalizeHexColor(localStorage.getItem("inittracker_tokenColor"))
      || "#6aa9ff";
    const preferredBorder = normalizeHexColor(targetUnit?.token_border_color)
      || normalizeHexColor(localStorage.getItem("inittracker_tokenBorderColor"))
      || "#ffffff";
    tokenColorInput.value = preferred;
    tokenBorderColorInput.value = preferredBorder;
    updateTokenColorSwatch(preferred);
    updateTokenBorderColorSwatch(preferredBorder);
    colorModal.classList.add("show");
    colorModal.setAttribute("aria-hidden", "false");
  }

  function closeColorModal(){
    if (!colorModal) return;
    colorModal.classList.remove("show");
    colorModal.setAttribute("aria-hidden", "true");
    pendingClaim = null;
  }

  function openClaimedColorModal(){
    openColorModal(getClaimedUnit());
  }

  function validateTokenColor(raw){
    const color = normalizeHexColor(raw);
    if (!color){
      localToast("Pick a valid hex color, matey.");
      return null;
    }
    return color;
  }

  function showNoOwnedPcToast(pcs){
    if (isMapView || isPlanning) return;
    if (shownNoOwnedToast) return;
    if (claimStatus !== "unclaimed") return;
    if (claimedCid) return;
    const list = Array.isArray(pcs) ? pcs : [];
    if (!list.length) return;
    localToast("No assigned PCs found. Ask the DM to assign yer character.");
    shownNoOwnedToast = true;
  }

  function getClaimablePcName(cid, pcs){
    const list = Array.isArray(pcs) ? pcs : [];
    const match = list.find((pc) => pc && cidMatches(pc.cid, cid, "claimList.nameMatch"));
    if (match?.name) return String(match.name);
    const unit = getUnitByCid(cid);
    if (unit?.name) return String(unit.name);
    return null;
  }

  function storeLanSelection(cid, pcs){
    const cidValue = normalizeCid(cid, "lan.storeCid");
    if (cidValue === null) return;
    localStorage.setItem(lanSelectedCidKey, String(cidValue));
    const name = getClaimablePcName(cidValue, pcs);
    if (name){
      localStorage.setItem(lanSelectedNameKey, name);
    } else {
      localStorage.removeItem(lanSelectedNameKey);
    }
  }

  function clearLanSelection(){
    localStorage.removeItem(lanSelectedCidKey);
    localStorage.removeItem(lanSelectedNameKey);
  }

  function loadLanSelection(){
    const storedCid = Number(localStorage.getItem(lanSelectedCidKey));
    const cidValue = normalizeCid(storedCid, "lan.loadCid");
    if (cidValue === null) return null;
    const nameValue = localStorage.getItem(lanSelectedNameKey);
    return {
      cid: cidValue,
      name: nameValue ? String(nameValue) : null,
    };
  }

  function clearAutoClaimPending(){
    if (autoClaimPending?.timeoutId){
      clearTimeout(autoClaimPending.timeoutId);
    }
    autoClaimPending = null;
  }

  function setClaimInFlight(cid){
    if (claimInFlightTimeoutId){
      clearTimeout(claimInFlightTimeoutId);
      claimInFlightTimeoutId = null;
    }
    claimInFlight = true;
    claimInFlightCid = normalizeCid(cid, "claim.inFlightCid");
    claimStatus = "claiming";
    claimInFlightTimeoutId = setTimeout(() => {
      claimInFlightTimeoutId = null;
      if (!claimInFlight) return;
      const pendingCid = claimInFlightCid;
      clearClaimInFlight();
      if (claimStatus !== "claimed"){
        claimStatus = "unclaimed";
      }
      if (pendingCid !== null && pendingCid !== undefined){
        const displayName = getClaimablePcName(pendingCid, lastPcList || []) || `#${pendingCid}`;
        localToast(`Claim for ${displayName} timed out. Please try again.`);
      } else {
        localToast("Claim request timed out. Please try again.");
      }
      updateClaimOverlay();
    }, claimInFlightTimeoutMs);
    if (claimConfirmBtn){
      claimConfirmBtn.disabled = true;
    }
  }

  function clearClaimInFlight(){
    if (claimInFlightTimeoutId){
      clearTimeout(claimInFlightTimeoutId);
      claimInFlightTimeoutId = null;
    }
    claimInFlight = false;
    claimInFlightCid = null;
    if (claimStatus === "claiming"){
      claimStatus = (claimedCid !== null && claimedCid !== undefined) ? "claimed" : "unclaimed";
    }
    updateClaimSelection();
  }

  function handleAutoClaimFailure(){
    if (!autoClaimPending) return;
    const cid = autoClaimPending.cid;
    const displayName = autoClaimPending.name || `#${cid}`;
    clearAutoClaimPending();
    clearClaimInFlight();
    clearLanSelection();
    allowUnclaimed = false;
    localToast(`Could not claim ${displayName}. Please choose again.`);
    updateClaimOverlay();
  }

  function checkAutoClaimResolved(){
    if (!autoClaimPending) return;
    if (claimedCid !== null && claimedCid !== undefined){
      if (cidMatches(claimedCid, autoClaimPending.cid, "lan.autoClaimMatch")){
        clearAutoClaimPending();
      } else {
        handleAutoClaimFailure();
      }
    }
  }

  function maybeAutoClaimFromState(msg, pcs){
    if (autoClaimChecked) return;
    const hasPcInfo = Object.prototype.hasOwnProperty.call(msg || {}, "pcs")
      || Object.prototype.hasOwnProperty.call(msg || {}, "claimable");
    if (!hasPcInfo) return;
    autoClaimChecked = true;
    if (claimedCid !== null && claimedCid !== undefined) return;
    const selection = loadLanSelection();
    if (!selection) return;
    const list = Array.isArray(pcs) ? pcs : [];
    if (list.length){
      const inList = list.some((pc) => pc && cidMatches(pc.cid, selection.cid, "lan.autoClaimList"));
      if (!inList){
        autoClaimPending = {cid: selection.cid, name: selection.name || `#${selection.cid}`};
        handleAutoClaimFailure();
        return;
      }
    }
    const pendingName = selection.name || getClaimablePcName(selection.cid, list) || `#${selection.cid}`;
    autoClaimPending = {
      cid: selection.cid,
      name: pendingName,
      timeoutId: setTimeout(() => {
        if (!autoClaimPending) return;
        if (!claimedCid || !cidMatches(claimedCid, selection.cid, "lan.autoClaimTimeout")){
          handleAutoClaimFailure();
        }
      }, autoClaimTimeoutMs),
      startedAt: stateUpdateCounter,
    };
    setClaimInFlight(selection.cid);
    send({type:"claim", cid: selection.cid, client_id: clientId});
  }

  function handleAutoClaimStateUpdate(){
    if (!autoClaimPending) return;
    if (autoClaimPending.startedAt === undefined) return;
    if (stateUpdateCounter > autoClaimPending.startedAt){
      if (!claimedCid || !cidMatches(claimedCid, autoClaimPending.cid, "lan.autoClaimStateCheck")){
        handleAutoClaimFailure();
      } else {
        clearAutoClaimPending();
      }
    }
  }

  function setSelectedClaimCid(cid){
    selectedClaimCid = normalizeCid(cid, "claimModal.selectedCid");
    updateClaimSelection();
    updateMountControls();
  }

  function updateClaimSelection(){
    if (!claimListEl) return;
    const items = Array.from(claimListEl.querySelectorAll("[data-claim-cid]"));
    items.forEach((item) => {
      const cidValue = normalizeCid(item.dataset.claimCid, "claimModal.itemCid");
      const isSelected = cidValue !== null && selectedClaimCid !== null
        && cidMatches(cidValue, selectedClaimCid, "claimModal.selectedMatch");
      item.classList.toggle("selected", isSelected);
      const radio = item.querySelector("input[type=\"radio\"]");
      if (radio){
        radio.checked = isSelected;
      }
    });
    if (claimConfirmBtn){
      claimConfirmBtn.disabled = claimInFlight || selectedClaimCid === null || selectedClaimCid === undefined;
    }
  }

  function logClaimMessage(type, pcs){
    if (!claimDebugLoggingEnabled) return;
    console.debug(`[claim] ${type} received`, {
      ready: claimDataReady,
      static_data_seen: claimStaticDataSeen,
      state_seen: claimStateSeen,
      claimable_count: Array.isArray(pcs) ? pcs.length : 0,
      claimable_pcs: Array.isArray(pcs) ? pcs : [],
    });
  }

  function markClaimMessageSeen(type){
    if (type === "static_data"){
      claimStaticDataSeen = true;
    } else if (type === "state"){
      claimStateSeen = true;
    }
    claimDataReady = claimStaticDataSeen && claimStateSeen;
  }

  function clearClaimRenderRetry(){
    if (claimRenderRetryTimer){
      clearTimeout(claimRenderRetryTimer);
      claimRenderRetryTimer = null;
    }
  }

  function scheduleClaimRenderRetry(){
    clearClaimRenderRetry();
    claimRenderRetryTimer = setTimeout(() => {
      claimRenderRetryTimer = null;
      if (!claimDataReady) return;
      if (claimedCid !== null && claimedCid !== undefined) return;
      renderClaimList(lastPcList || []);
      updateClaimOverlay();
    }, claimRenderRetryDelayMs);
  }

  function renderClaimList(pcs){
    if (!claimListEl) return;
    const list = Array.isArray(pcs) ? pcs : [];
    if (!claimDataReady){
      clearClaimRenderRetry();
      claimListEl.textContent = "";
      selectedClaimCid = null;
      if (claimEmptyHint){
        claimEmptyHint.textContent = "Loading characters";
        claimEmptyHint.classList.remove("hidden");
      }
      updateClaimSelection();
      return;
    }
    claimListEl.textContent = "";
    let fallbackCid = null;
    list.forEach((pc) => {
      if (!pc || typeof pc !== "object") return;
      const cidValue = normalizeCid(pc.cid, "claimModal.renderCid");
      if (cidValue === null) return;
      if (fallbackCid === null){
        fallbackCid = cidValue;
      }
      const item = document.createElement("button");
      item.type = "button";
      item.className = "item claim-item";
      item.dataset.claimCid = String(cidValue);
      const radio = document.createElement("input");
      radio.type = "radio";
      radio.name = "claimChoice";
      radio.tabIndex = -1;
      const nameEl = document.createElement("div");
      nameEl.className = "name";
      nameEl.textContent = pc.name ? String(pc.name) : `#${cidValue}`;
      const metaEl = document.createElement("div");
      metaEl.className = "meta";
      metaEl.textContent = `CID ${cidValue}`;
      item.appendChild(radio);
      item.appendChild(nameEl);
      item.appendChild(metaEl);
      item.addEventListener("click", () => {
        allowUnclaimed = false;
        setSelectedClaimCid(cidValue);
      });
      claimListEl.appendChild(item);
    });
    if (!list.length){
      selectedClaimCid = null;
    } else if (selectedClaimCid === null || selectedClaimCid === undefined){
      setSelectedClaimCid(fallbackCid);
    }
    if (claimEmptyHint){
      claimEmptyHint.textContent = "No claimable PCs yet. Ask the DM to add one.";
      claimEmptyHint.classList.toggle("hidden", list.length > 0);
    }
    if (!list.length){
      scheduleClaimRenderRetry();
    } else {
      clearClaimRenderRetry();
    }
    updateClaimSelection();
  }

  function updateClaimOverlay(){
    if (!claimModal) return;
    if (isMapView || isPlanning){
      claimModal.classList.remove("show");
      claimModal.setAttribute("aria-hidden", "true");
      return;
    }
    const needsClaim = claimedCid === null || claimedCid === undefined;
    const shouldShow = claimStatus === "unclaimed" && needsClaim && !allowUnclaimed;
    claimModal.classList.toggle("show", shouldShow);
    claimModal.setAttribute("aria-hidden", shouldShow ? "false" : "true");
    if (claimSpectatorBtn){
      claimSpectatorBtn.classList.remove("hidden");
    }
    if (claimContinueBtn){
      claimContinueBtn.classList.remove("hidden");
    }
    if (shouldShow){
      if (!claimDataReady && claimEmptyHint){
        claimEmptyHint.textContent = "Loading characters";
        claimEmptyHint.classList.remove("hidden");
      }
      renderClaimList(lastPcList || []);
    } else {
      clearClaimRenderRetry();
    }
  }

  function enterUnclaimedSpectatorMode(){
    allowUnclaimed = true;
    setSelectedClaimCid(null);
    clearAutoClaimPending();
    clearClaimInFlight();
    clearLanSelection();
    setSheetPanelHidden(true);
    updateClaimOverlay();
  }

  function requestCharacterSwitch(){
    allowUnclaimed = false;
    clearAutoClaimPending();
    clearClaimInFlight();
    clearLanSelection();
    if (claimedCid !== null && claimedCid !== undefined){
      claimStatus = "unclaiming";
      send({type:"unclaim", client_id: clientId});
    }
    claimedCid = null;
    selectedClaimCid = null;
    if (meEl){
      setMeLabel(null, false);
    }
    updateEndTurnState();
    updateClaimOverlay();
  }

  function showDashModal(){
    if (!dashModal) return;
    dashModal.classList.add("show");
    dashModal.setAttribute("aria-hidden", "false");
  }

  function hideDashModal(){
    if (!dashModal) return;
    dashModal.classList.remove("show");
    dashModal.setAttribute("aria-hidden", "true");
  }

  function showLogModal(){
    if (!logModal) return;
    battleLogViewPrefs.visible = true;
    applyBattleLogViewPrefs();
    persistBattleLogViewPrefs();
    refreshMapViewLogPolling();
  }

  function hideLogModal(){
    if (!logModal) return;
    battleLogViewPrefs.visible = false;
    applyBattleLogViewPrefs();
    persistBattleLogViewPrefs();
    refreshMapViewLogPolling();
  }

  function renderBattleLogOverlay(lines){
    if (!logContent) return;
    const entries = Array.isArray(lines) ? lines : [];
    logContent.textContent = "";
    if (!entries.length){
      logContent.textContent = "No log entries yet.";
      return;
    }
    const frag = document.createDocumentFragment();
    entries.forEach((line) => {
      const parsed = parseBattleLine(line);
      const row = document.createElement("div");
      row.className = "map-view-log-entry";
      const msgClass = isCriticalLine(parsed.msg) ? "map-view-log-msg is-crit" : "map-view-log-msg";
      row.innerHTML = `<div class="map-view-log-time">${parsed.time ? parsed.time.slice(11,19) : ''}</div><div class="${msgClass}">${decorateDamageTypes(parsed.msg)}</div>`;
      frag.appendChild(row);
    });
    logContent.appendChild(frag);
    logContent.scrollTop = logContent.scrollHeight;
  }

  function requestBattleLog(){
    if (logContent){
      logContent.textContent = "Loading";
    }
    send({type:"log_request"});
  }

  function trimDmLogLines(){
    if (!Array.isArray(dmLogLines)) dmLogLines = [];
    if (dmLogLines.length > DM_LOG_LINES_MAX){
      dmLogLines = dmLogLines.slice(-DM_LOG_LINES_MAX);
    }
  }

  function invalidateMovementRangeCache(){
    movementRangeCacheKey = "";
    movementRangeCostMap = null;
  }

  function getCachedRoughTerrainMap(){
    if (cachedRoughMap && cachedRoughMapVersion === roughTerrainVersion){
      return cachedRoughMap;
    }
    cachedRoughMap = buildRoughTerrainMap(state?.rough_terrain);
    cachedRoughMapVersion = roughTerrainVersion;
    return cachedRoughMap;
  }

  function getCachedObstacleSet(){
    if (cachedObstacleSet && cachedObstacleSetVersion === obstacleVersion){
      return cachedObstacleSet;
    }
    cachedObstacleSet = buildObstacleSet(state?.obstacles);
    cachedObstacleSetVersion = obstacleVersion;
    return cachedObstacleSet;
  }

  function getMovementRangeCostMap(unit, cols, rows, feetPerSquare){
    if (!unit || !unit.pos) return null;
    const mode = normalizeMovementMode(unit.movement_mode);
    const key = [
      Number(unit.pos.col),
      Number(unit.pos.row),
      Math.max(0, Number(unit.move_remaining || 0)),
      Number(cols),
      Number(rows),
      Math.max(1, Number(feetPerSquare || 5)),
      mode,
      Math.max(0, Number(unit.speed || 0)),
      Math.max(0, Number(unit.swim_speed || 0)),
      roughTerrainVersion,
      obstacleVersion,
    ].join("|");
    if (key === movementRangeCacheKey && movementRangeCostMap){
      if (movementRangePerfDebug){
        movementRangeCacheStats.hits += 1;
      }
      return movementRangeCostMap;
    }
    if (movementRangePerfDebug){
      movementRangeCacheStats.misses += 1;
    }
    movementRangeCostMap = movementCostMap(
      Number(unit.pos.col),
      Number(unit.pos.row),
      Math.max(0, Number(unit.move_remaining || 0)),
      unit,
      getCachedRoughTerrainMap(),
      getCachedObstacleSet(),
      Number(cols),
      Number(rows),
      Math.max(1, Number(feetPerSquare || 5)),
    );
    movementRangeCacheKey = key;
    return movementRangeCostMap;
  }

  function applyTerrainPayload(terrain){
    if (!state){ state = {}; }
    if (!terrain || typeof terrain !== "object") return;
    if (Array.isArray(terrain.rough_terrain)){
      state.rough_terrain = terrain.rough_terrain;
      roughTerrainVersion += 1;
      cachedRoughMapVersion = -1;
      invalidateMovementRangeCache();
    } else if (!state.rough_terrain){
      state.rough_terrain = [];
    }
    if (Array.isArray(terrain.obstacles)){
      state.obstacles = terrain.obstacles;
      obstacleVersion += 1;
      cachedObstacleSetVersion = -1;
      invalidateMovementRangeCache();
    } else if (!state.obstacles){
      state.obstacles = [];
    }
  }

  function applyTerrainPatch(patch){
    if (!state){ state = {}; }
    if (!patch || typeof patch !== "object") return;
    const roughUpdates = Array.isArray(patch.rough_updates) ? patch.rough_updates : [];
    const roughRemovals = Array.isArray(patch.rough_removals) ? patch.rough_removals : [];
    if (roughUpdates.length || roughRemovals.length){
      const roughMap = new Map();
      (state.rough_terrain || []).forEach((cell) => {
        if (!cell) return;
        const key = `${Number(cell.col)},${Number(cell.row)}`;
        roughMap.set(key, cell);
      });
      roughUpdates.forEach((cell) => {
        if (!cell) return;
        const key = `${Number(cell.col)},${Number(cell.row)}`;
        roughMap.set(key, cell);
      });
      roughRemovals.forEach((cell) => {
        if (!cell) return;
        const key = `${Number(cell.col)},${Number(cell.row)}`;
        roughMap.delete(key);
      });
      state.rough_terrain = Array.from(roughMap.values());
      roughTerrainVersion += 1;
      cachedRoughMapVersion = -1;
      invalidateMovementRangeCache();
    }

    const obstacleUpdates = Array.isArray(patch.obstacle_updates) ? patch.obstacle_updates : [];
    const obstacleRemovals = Array.isArray(patch.obstacle_removals) ? patch.obstacle_removals : [];
    if (obstacleUpdates.length || obstacleRemovals.length){
      const obstacleSet = new Set((state.obstacles || []).map(o => `${Number(o.col)},${Number(o.row)}`));
      obstacleUpdates.forEach((cell) => {
        if (!cell) return;
        obstacleSet.add(`${Number(cell.col)},${Number(cell.row)}`);
      });
      obstacleRemovals.forEach((cell) => {
        if (!cell) return;
        obstacleSet.delete(`${Number(cell.col)},${Number(cell.row)}`);
      });
      state.obstacles = Array.from(obstacleSet).map((key) => {
        const [col, row] = key.split(",").map(Number);
        return {col, row};
      });
      obstacleVersion += 1;
      cachedObstacleSetVersion = -1;
      invalidateMovementRangeCache();
    }
  }

  function applyUnitUpdates(updates){
    if (!state || !Array.isArray(state.units)) return;
    updates.forEach((update) => {
      if (!update || update.cid === undefined || update.cid === null) return;
      const cid = Number(update.cid);
      const idx = state.units.findIndex((unit) => Number(unit.cid) === cid);
      if (idx < 0) return;
      const current = state.units[idx];
      const next = {...current};
      Object.keys(update).forEach((key) => {
        if (key === "cid") return;
        next[key] = update[key];
      });
      state.units[idx] = next;
    });
    updateMountControls();
  }

  function applyAoePatch(patch){
    if (!state){ state = {}; }
    if (!patch || typeof patch !== "object") return;
    const updates = Array.isArray(patch.updates) ? patch.updates : [];
    const removals = Array.isArray(patch.removals) ? patch.removals : [];
    if (!Array.isArray(state.aoes)){
      state.aoes = [];
    }
    const aoeMap = new Map();
    state.aoes.forEach((aoe) => {
      if (!aoe || aoe.aid === undefined || aoe.aid === null) return;
      aoeMap.set(Number(aoe.aid), aoe);
    });
    updates.forEach((aoe) => {
      if (!aoe || aoe.aid === undefined || aoe.aid === null) return;
      aoeMap.set(Number(aoe.aid), aoe);
    });
    removals.forEach((aid) => {
      aoeMap.delete(Number(aid));
    });
    state.aoes = Array.from(aoeMap.values()).sort((a, b) => Number(a.aid) - Number(b.aid));
  }

  function planningModeSpeed(unit){
    if (!unit) return 30;
    const mode = normalizeMovementMode(unit?.movement_mode);
    if (mode === "swim"){
      const swimSpeed = Number(unit?.swim_speed || 0);
      if (Number.isFinite(swimSpeed) && swimSpeed > 0) return swimSpeed;
    }
    if (mode === "fly"){
      const flySpeed = Number(unit?.fly_speed || 0);
      if (Number.isFinite(flySpeed) && flySpeed > 0) return flySpeed;
    }
    if (mode === "burrow"){
      const burrowSpeed = Number(unit?.burrow_speed || 0);
      if (Number.isFinite(burrowSpeed) && burrowSpeed > 0) return burrowSpeed;
    }
    const speed = Number(unit?.speed || 30);
    if (!Number.isFinite(speed) || speed <= 0) return 30;
    return speed;
  }

  function nextPlanningAoeId(){
    const list = Array.isArray(state?.aoes) ? state.aoes : [];
    let maxAid = 0;
    list.forEach((aoe) => {
      const aid = Number(aoe?.aid);
      if (Number.isFinite(aid) && aid > maxAid){
        maxAid = aid;
      }
    });
    return maxAid + 1;
  }

  function buildPlanningAoe(payload){
    if (!payload || typeof payload !== "object") return null;
    const shape = String(payload.shape || payload.kind || "").toLowerCase();
    if (!shape) return null;
    const feetPerSquare = Math.max(1, Number(state?.grid?.feet_per_square || 5));
    const aoe = {
      aid: nextPlanningAoeId(),
      kind: shape,
      cx: Number(payload.cx ?? 0),
      cy: Number(payload.cy ?? 0),
    };
    if (payload.name){
      aoe.name = payload.name;
    }
    if (payload.color){
      aoe.color = payload.color;
    }
    if (payload.damage_type){
      aoe.damage_type = payload.damage_type;
    }
    if (Array.isArray(payload.damage_types) && payload.damage_types.length){
      aoe.damage_types = payload.damage_types.slice();
    }
    if (payload.save_type){
      aoe.save_type = payload.save_type;
    }
    if (payload.dc !== undefined && payload.dc !== null){
      aoe.dc = Number(payload.dc);
    }
    if (payload.default_damage){
      aoe.default_damage = payload.default_damage;
    }
    if (payload.dice){
      aoe.dice = payload.dice;
    }
    if (payload.duration_turns !== undefined && payload.duration_turns !== null){
      const duration = Number(payload.duration_turns);
      if (Number.isFinite(duration)){
        aoe.duration_turns = duration;
        aoe.remaining_turns = duration > 0 ? duration : null;
      }
    }
    if (payload.over_time){
      aoe.over_time = true;
    }
    if (payload.persistent){
      aoe.persistent = true;
    }
    if (payload.trigger_on_start_or_enter){
      aoe.trigger_on_start_or_enter = payload.trigger_on_start_or_enter;
    }
    if (payload.move_per_turn_ft !== undefined && payload.move_per_turn_ft !== null){
      aoe.move_per_turn_ft = Number(payload.move_per_turn_ft);
      aoe.move_remaining_ft = Number(payload.move_per_turn_ft);
    }
    if (payload.pinned_default){
      aoe.pinned = true;
    }
    const radiusFt = Number(payload.radius_ft);
    const sideFt = Number(payload.side_ft);
    const lengthFt = Number(payload.length_ft);
    const widthFt = Number(payload.width_ft);
    const thicknessFt = Number(payload.thickness_ft);
    const heightFt = Number(payload.height_ft);
    const angleDeg = payload.angle_deg !== undefined && payload.angle_deg !== null
      ? Number(payload.angle_deg)
      : null;
    if (shape === "circle" || shape === "sphere" || shape === "cylinder"){
      if (Number.isFinite(radiusFt)){
        aoe.radius_sq = Math.max(0.5, radiusFt / feetPerSquare);
        aoe.radius_ft = radiusFt;
      }
      if ((shape === "sphere" || shape === "cylinder") && Number.isFinite(heightFt)){
        aoe.height_ft = heightFt;
      }
    } else if (shape === "square" || shape === "cube"){
      if (Number.isFinite(sideFt)){
        aoe.side_sq = Math.max(1.0, sideFt / feetPerSquare);
        aoe.side_ft = sideFt;
      }
    } else if (shape === "cone"){
      if (Number.isFinite(lengthFt)){
        aoe.length_sq = Math.max(1.0, lengthFt / feetPerSquare);
        aoe.length_ft = lengthFt;
      }
      if (Number.isFinite(angleDeg)){
        aoe.angle_deg = angleDeg;
      }
      if (payload.spread_deg !== undefined && payload.spread_deg !== null){
        const spreadDeg = Number(payload.spread_deg);
        if (Number.isFinite(spreadDeg)){
          aoe.spread_deg = spreadDeg;
        }
      }
      if (payload.ax !== undefined && payload.ax !== null && payload.ay !== undefined && payload.ay !== null){
        const ax = Number(payload.ax);
        const ay = Number(payload.ay);
        if (Number.isFinite(ax) && Number.isFinite(ay)){
          aoe.ax = ax;
          aoe.ay = ay;
        }
      }
      aoe.orient = String(payload.orient || "vertical");
    } else if (shape === "wall"){
      if (Number.isFinite(lengthFt)){
        aoe.length_sq = Math.max(1.0, lengthFt / feetPerSquare);
        aoe.length_ft = lengthFt;
      }
      if (Number.isFinite(widthFt)){
        aoe.width_sq = Math.max(1.0, widthFt / feetPerSquare);
        aoe.width_ft = widthFt;
        if (Number.isFinite(heightFt)){
          aoe.height_ft = heightFt;
        }
      } else if (Number.isFinite(thicknessFt)){
        aoe.width_sq = Math.max(1.0, thicknessFt / feetPerSquare);
        aoe.thickness_ft = thicknessFt;
        if (Number.isFinite(heightFt)){
          aoe.height_ft = heightFt;
        }
      }
      if (Number.isFinite(angleDeg)){
        aoe.angle_deg = angleDeg;
      }
      if (payload.ax !== undefined && payload.ax !== null && payload.ay !== undefined && payload.ay !== null){
        const ax = Number(payload.ax);
        const ay = Number(payload.ay);
        if (Number.isFinite(ax) && Number.isFinite(ay)){
          aoe.ax = ax;
          aoe.ay = ay;
        }
      }
      aoe.orient = String(payload.orient || "vertical");
    } else if (shape === "line"){
      if (Number.isFinite(lengthFt)){
        aoe.length_sq = Math.max(1.0, lengthFt / feetPerSquare);
        aoe.length_ft = lengthFt;
      }
      if (Number.isFinite(widthFt)){
        aoe.width_sq = Math.max(1.0, widthFt / feetPerSquare);
        aoe.width_ft = widthFt;
      } else {
        aoe.width_sq = 1.0;
      }
      if (Number.isFinite(angleDeg)){
        aoe.angle_deg = angleDeg;
      }
      if (payload.ax !== undefined && payload.ax !== null && payload.ay !== undefined && payload.ay !== null){
        const ax = Number(payload.ax);
        const ay = Number(payload.ay);
        if (Number.isFinite(ax) && Number.isFinite(ay)){
          aoe.ax = ax;
          aoe.ay = ay;
        }
      }
      aoe.orient = String(payload.orient || "vertical");
    }
    return aoe;
  }

  function planningMutate(msg){
    if (!msg || typeof msg !== "object") return;
    const type = String(msg.type || "");
    const mutateSpellSlotCounter = (unit, rawLevel) => {
      const playerName = String(unit?.name || "").trim();
      const level = Number(rawLevel);
      if (!playerName || !Number.isFinite(level) || level <= 0) return;
      const profile = getPlayerProfile(playerName);
      const spellcasting = profile?.spellcasting;
      const slots = spellcasting?.spell_slots;
      if (!slots || typeof slots !== "object") return;
      const slotLevel = Math.floor(level);
      if (Array.isArray(slots)){
        const idx = slotLevel - 1;
        if (idx < 0 || idx >= slots.length) return;
        const entry = slots[idx];
        if (entry && typeof entry === "object"){
          const current = Number(entry.current ?? entry.remaining ?? entry.max ?? 0);
          entry.current = Math.max(0, Number.isFinite(current) ? Math.floor(current) - 1 : 0);
        } else if (Number.isFinite(Number(entry))){
          slots[idx] = Math.max(0, Math.floor(Number(entry)) - 1);
        }
        return;
      }
      const key = String(slotLevel);
      const entry = slots[key] ?? slots[slotLevel];
      if (entry && typeof entry === "object"){
        const current = Number(entry.current ?? entry.remaining ?? entry.max ?? 0);
        entry.current = Math.max(0, Number.isFinite(current) ? Math.floor(current) - 1 : 0);
      } else if (Number.isFinite(Number(entry))){
        slots[key] = Math.max(0, Math.floor(Number(entry)) - 1);
      }
    };
    const mutateResourcePoolCounter = (unit, consumesPoolRaw) => {
      const playerName = String(unit?.name || "").trim();
      const consumes = consumesPoolRaw && typeof consumesPoolRaw === "object" ? consumesPoolRaw : null;
      if (!playerName || !consumes) return;
      const poolsByPlayer = state?.resource_pools;
      if (!poolsByPlayer || typeof poolsByPlayer !== "object") return;
      const pools = poolsByPlayer[playerName];
      if (!Array.isArray(pools)) return;
      const id = String(consumes.id ?? consumes.pool ?? "").trim().toLowerCase();
      if (!id) return;
      const costRaw = Number(consumes.cost ?? 1);
      const cost = Number.isFinite(costRaw) ? Math.max(1, Math.floor(costRaw)) : 1;
      const pool = pools.find((entry) => String(entry?.id || "").trim().toLowerCase() === id);
      if (!pool || typeof pool !== "object") return;
      const current = Number(pool.current ?? 0);
      if (!Number.isFinite(current)) return;
      pool.current = Math.max(0, Math.floor(current) - cost);
    };
    if (type === "move"){
      const unit = getUnitByCid(msg.cid);
      const to = msg.to || {};
      if (!unit) return;
      const update = {
        cid: unit.cid,
        pos: {col: Number(to.col ?? unit.pos.col), row: Number(to.row ?? unit.pos.row)},
      };
      const updates = [update];
      const mountedByCid = normalizeCid(unit.mounted_by_cid, "move.mountedByCid");
      const mountedByUnit = mountedByCid !== null ? getUnitByCid(mountedByCid) : null;
      const riderControlsMount = unit.mount_shared_turn === true && String(unit.mount_controller_mode || "").toLowerCase() === "rider";
      let movementSourceUnit = unit;
      let movementSourceUpdate = update;
      if (mountedByUnit && riderControlsMount) {
        const mountedByUpdate = {cid: mountedByUnit.cid, pos: {...update.pos}};
        updates.push(mountedByUpdate);
        movementSourceUnit = mountedByUnit;
        movementSourceUpdate = mountedByUpdate;
      } else if (mountedByUnit) {
        updates.push({cid: mountedByUnit.cid, pos: {...update.pos}});
      } else {
        const riderCid = normalizeCid(unit.rider_cid, "move.riderCid");
        const riderMountUnit = riderCid !== null ? getUnitByCid(riderCid) : null;
        if (riderMountUnit) {
          updates.push({cid: riderMountUnit.cid, pos: {...update.pos}});
          // Movement costs remain on the rider; the mount just mirrors position.
        }
      }
      if (gridReady()){
        const moveRemaining = Number(movementSourceUnit.move_remaining ?? 0);
        if (Number.isFinite(moveRemaining) && moveRemaining > 0){
          const feetPerSquare = Math.max(1, Number(state?.grid?.feet_per_square || 5));
          const roughMap = buildRoughTerrainMap(state.rough_terrain);
          const obstacleSet = buildObstacleSet(state.obstacles);
          const costMap = movementCostMap(
            Number(unit.pos.col),
            Number(unit.pos.row),
            moveRemaining,
            unit,
            roughMap,
            obstacleSet,
            state.grid.cols,
            state.grid.rows,
            feetPerSquare,
          );
          const cost = costMap.get(cellKey(update.pos.col, update.pos.row));
          if (Number.isFinite(cost)){
            movementSourceUpdate.move_remaining = Math.max(0, moveRemaining - cost);
          }
        }
      }
      applyUnitUpdates(updates);
      updateMountControls();
      return;
    }
    if (type === "set_facing"){
      const unit = getUnitByCid(msg.cid);
      if (!unit) return;
      const facingDeg = normalizeFacingDeg(msg.facing_deg);
      unit.facing_deg = facingDeg;
      syncOwnedRotatableAoesWithFacing(unit.cid, facingDeg);
      return;
    }
    if (["dash", "perform_action", "use_action", "use_bonus_action", "monk_patient_defense", "monk_step_of_wind", "monk_elemental_attunement"].includes(type)){
      const unit = getUnitByCid(msg.cid);
      if (!unit) return;
      const update = {cid: unit.cid};
      const spendRaw = String(msg.spend || "").toLowerCase();
      const spend = (type === "monk_patient_defense" || type === "monk_step_of_wind")
        ? "bonus"
        : (spendRaw.includes("bonus") ? "bonus" : (spendRaw === "reaction" ? "reaction" : "action"));
      const useAction = () => {
        const current = Number(unit.action_remaining || 0);
        update.action_remaining = Math.max(0, current - 1);
      };
      const useBonus = () => {
        const current = Number(unit.bonus_action_remaining || 0);
        update.bonus_action_remaining = Math.max(0, current - 1);
      };
      const useReaction = () => {
        const current = Number(unit.reaction_remaining || 0);
        update.reaction_remaining = Math.max(0, current - 1);
      };
      if (type === "use_action"){
        useAction();
      } else if (type === "use_bonus_action"){
        useBonus();
      } else if (spend === "reaction"){
        useReaction();
      } else if (spend === "bonus"){
        useBonus();
      } else {
        useAction();
      }
      const actionName = String(msg.action || msg.name || "");
      const actionKey = normalizeLowerValue(actionName);
      const mode = String(msg.mode || "").trim().toLowerCase();
      if (mode === "focus"){
        mutateResourcePoolCounter(unit, {id: "focus_points", cost: 1});
      }
      if (type === "monk_elemental_attunement"){
        if (mode === "activate"){
          mutateResourcePoolCounter(unit, {id: "focus_points", cost: 1});
          update.elemental_attunement_active = true;
        } else if (mode === "deactivate"){
          update.elemental_attunement_active = false;
        }
      }
      if (type === "dash" || actionKey === "dash" || type === "monk_step_of_wind"){
        const baseSpeed = planningModeSpeed(unit);
        const total = Number(unit.move_total || 0);
        const remaining = Number(unit.move_remaining || 0);
        update.move_total = total + baseSpeed;
        update.move_remaining = remaining + baseSpeed;
      }
      applyUnitUpdates([update]);
      updateMountControls();
      return;
    }
    if (type === "set_auras_enabled"){
      if (!state || typeof state !== "object") state = {};
      state.auras_enabled = msg.enabled !== false;
      updateAurasButton();
      draw();
      return;
    }
    if (type === "attack_request"){
      const unit = getUnitByCid(msg.cid);
      if (!unit) return;
      if (String(msg.attack_spend || "").trim().toLowerCase() === "bonus" && msg.bonus_sequence_start === true){
        const update = {cid: unit.cid};
        const current = Number(unit.bonus_action_remaining || 0);
        update.bonus_action_remaining = Math.max(0, current - 1);
        applyUnitUpdates([update]);
        if (msg.consumes_pool && typeof msg.consumes_pool === "object"){
          mutateResourcePoolCounter(unit, msg.consumes_pool);
          renderResourcePools();
        }
      }
      return;
    }
    if (type === "second_wind_use"){
      const unit = getUnitByCid(msg.cid);
      if (!unit) return;
      mutateResourcePoolCounter(unit, {id: "second_wind", cost: 1});
      const update = {cid: unit.cid};
      const current = Number(unit.bonus_action_remaining || 0);
      update.bonus_action_remaining = Math.max(0, current - 1);
      applyUnitUpdates([update]);
      renderSecondWindSummary();
      renderResourcePools();
      return;
    }
    if (type === "action_surge_use"){
      const unit = getUnitByCid(msg.cid);
      if (!unit) return;
      mutateResourcePoolCounter(unit, {id: "action_surge", cost: 1});
      const update = {cid: unit.cid};
      const current = Number(unit.action_remaining || 0);
      update.action_remaining = Math.max(0, current + 1);
      applyUnitUpdates([update]);
      renderResourcePools();
      return;
    }
    if (type === "lay_on_hands_use"){
      const unit = getUnitByCid(msg.cid);
      const target = getUnitByCid(msg.target_cid);
      const amount = Math.max(0, Number(msg.amount || 0));
      const curePoisoned = msg.cure_poisoned === true;
      if (!unit || !target || amount <= 0) return;
      mutateResourcePoolCounter(unit, {id: "lay_on_hands", cost: amount});
      const updates = [{cid: unit.cid, bonus_action_remaining: Math.max(0, Number(unit.bonus_action_remaining || 0) - 1)}];
      if (!curePoisoned){
        const targetHp = Number(target.hp || 0);
        const targetMaxHp = Number(target.max_hp || targetHp);
        updates.push({cid: target.cid, hp: Math.max(0, Math.min(targetMaxHp, targetHp + amount))});
      }
      applyUnitUpdates(updates);
      if (curePoisoned && Array.isArray(target?.condition_stacks)){
        target.condition_stacks = target.condition_stacks.filter((st) => normalizeLowerValue(st?.ctype || "") !== "poisoned");
      }
      renderResourcePools();
      return;
    }
    if (type === "cast_spell"){
      const unit = getUnitByCid(msg.cid);
      if (!unit) return;
      const payload = msg.payload && typeof msg.payload === "object" ? msg.payload : {};
      const spendRaw = String(msg.action_type || payload.action_type || "").toLowerCase();
      const spend = spendRaw.includes("bonus") ? "bonus" : (spendRaw === "reaction" ? "reaction" : "action");
      const update = {cid: unit.cid};
      const spellCastRemaining = Number(unit.spell_cast_remaining || 0);
      update.spell_cast_remaining = Math.max(0, spellCastRemaining - 1);
      update.action_remaining = 0;
      update.bonus_action_remaining = 0;
      if (spend === "reaction"){
        const currentReaction = Number(unit.reaction_remaining || 0);
        update.reaction_remaining = Math.max(0, currentReaction - 1);
      }
      applyUnitUpdates([update]);
      mutateSpellSlotCounter(unit, msg.slot_level ?? payload.slot_level ?? payload.level);
      mutateResourcePoolCounter(unit, payload.consumes_pool);
      renderResourcePools();
      updateMountControls();
      return;
    }
    if (type === "stand_up"){
      const unit = getUnitByCid(msg.cid);
      if (!unit) return;
      if (!unit.is_prone) return;
      const speed = planningModeSpeed(unit);
      const cost = Math.max(0, Math.floor(speed / 2));
      const moveRemaining = Number(unit.move_remaining || 0);
      if (!Number.isFinite(moveRemaining) || moveRemaining < cost) return;
      applyUnitUpdates([{
        cid: unit.cid,
        is_prone: false,
        move_remaining: Math.max(0, moveRemaining - cost),
      }]);
      updateMountControls();
      return;
    }
    if (type === "reset_turn"){
      const unit = getUnitByCid(msg.cid);
      if (!unit) return;
      applyUnitUpdates([{
        cid: unit.cid,
        action_remaining: Number(unit.action_total ?? 1),
        bonus_action_remaining: Number(unit.bonus_action_total ?? 1),
        reaction_remaining: Number(unit.reaction_total ?? 1),
        spell_cast_remaining: Number(unit.spell_cast_total ?? 1),
        move_remaining: Number(unit.move_total ?? planningModeSpeed(unit)),
      }]);
      updateMountControls();
      return;
    }
    if (type === "cast_aoe"){
      const aoe = buildPlanningAoe(msg.payload || {});
      if (!aoe) return;
      applyAoePatch({updates: [aoe], removals: []});
      return;
    }
    if (type === "aoe_move"){
      const aid = Number(msg.aid);
      if (!Number.isFinite(aid)) return;
      const target = msg.to || {};
      const current = Array.isArray(state?.aoes)
        ? state.aoes.find(a => Number(a?.aid) === aid)
        : null;
      if (!current) return;
      const update = {
        ...current,
        cx: Number(target.cx ?? current.cx),
        cy: Number(target.cy ?? current.cy),
      };
      if (target.angle_deg !== undefined){
        update.angle_deg = Number(target.angle_deg);
      }
      if (target.ax !== undefined){
        update.ax = Number(target.ax);
      }
      if (target.ay !== undefined){
        update.ay = Number(target.ay);
      }
      if (target.spread_deg !== undefined){
        update.spread_deg = Number(target.spread_deg);
      }
      if (target.angle_deg !== undefined){
        syncFacingFromRotatableAoe(update, target.angle_deg);
      }
      applyAoePatch({
        updates: [update],
        removals: [],
      });
      return;
    }
    if (type === "aoe_remove"){
      const aid = Number(msg.aid);
      if (!Number.isFinite(aid)) return;
      applyAoePatch({updates: [], removals: [aid]});
    }
  }

  function gridToScreen(col,row){
    return {x: panX + col*zoom + zoom/2, y: panY + row*zoom + zoom/2};
  }
  function screenToGrid(x,y){
    return {col: Math.floor((x - panX)/zoom), row: Math.floor((y - panY)/zoom)};
  }
  function screenToGridFloat(x,y){
    return {col: (x - panX - zoom / 2) / zoom, row: (y - panY - zoom / 2) / zoom};
  }

  function coneSpreadDeg(aoe){
    const spread = Number(aoe?.spread_deg);
    if (Number.isFinite(spread)) return spread;
    const angle = Number(aoe?.angle_deg);
    if (Number.isFinite(angle)) return angle;
    return 90;
  }

  function coneHeadingDeg(aoe){
    const hasSpread = Number.isFinite(Number(aoe?.spread_deg));
    const angle = Number(aoe?.angle_deg);
    if (hasSpread && Number.isFinite(angle)) return angle;
    return aoe?.orient === "horizontal" ? 0 : -90;
  }

  function normalizeAngleDeg(angle){
    let next = angle % 360;
    if (next > 180) next -= 360;
    if (next < -180) next += 360;
    return next;
  }

  function angularDiffDeg(a, b){
    return Math.abs(normalizeAngleDeg(a - b));
  }

  function renderAoeOverlay(aoe, options = {}){
    if (!aoe || !aoe.kind) return;
    const renderAoe = options.override ? {...aoe, ...options.override} : aoe;
    const remainingTurnsRaw = renderAoe.remaining_turns;
    const remainingTurnsValue = (remainingTurnsRaw === null || remainingTurnsRaw === undefined)
      ? null
      : Number(remainingTurnsRaw);
    const cx = Number(options.cx ?? renderAoe.cx ?? 0);
    const cy = Number(options.cy ?? renderAoe.cy ?? 0);
    const {x,y} = gridToScreen(cx, cy);
    const colorHex = normalizeHexColor(renderAoe.color || "");
    const isPreview = !!options.preview;
    const alphaScale = isPreview ? 0.65 : 1;
    const alwaysOnAura = !!renderAoe.light || !!renderAoe.is_aura;
    const fillBaseAlpha = alwaysOnAura ? 0.14 : 0.28;
    ctx.save();
    ctx.lineWidth = 2;
    ctx.setLineDash([6,4]);
    if (renderAoe.kind === "circle" || renderAoe.kind === "sphere" || renderAoe.kind === "cylinder"){
      const r = Math.max(0, Number(renderAoe.radius_sq || 0)) * zoom;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fillStyle = colorHex
        ? rgbaFromHex(colorHex, fillBaseAlpha * alphaScale)
        : `rgba(168,197,255,${0.32 * alphaScale})`;
      ctx.strokeStyle = colorHex || `rgba(45,79,138,${0.85 * alphaScale})`;
      ctx.fill();
      ctx.stroke();
    } else if (renderAoe.kind === "line" || renderAoe.kind === "wall"){
      const lengthPx = Math.max(0, Number(renderAoe.length_sq || 0)) * zoom;
      const widthPx = Math.max(0, Number(renderAoe.width_sq || 0)) * zoom;
      const angleDeg = Number.isFinite(Number(renderAoe.angle_deg)) ? Number(renderAoe.angle_deg) : null;
      const orient = renderAoe.orient === "horizontal" ? "horizontal" : "vertical";
      const halfW = orient === "horizontal" ? lengthPx / 2 : widthPx / 2;
      const halfH = orient === "horizontal" ? widthPx / 2 : lengthPx / 2;
      ctx.fillStyle = colorHex
        ? rgbaFromHex(colorHex, fillBaseAlpha * alphaScale)
        : (renderAoe.kind === "wall"
          ? `rgba(255,230,153,${0.32 * alphaScale})`
          : `rgba(183,255,224,${0.32 * alphaScale})`);
      ctx.strokeStyle = colorHex || (renderAoe.kind === "wall"
        ? `rgba(181,125,34,${0.85 * alphaScale})`
        : `rgba(45,138,87,${0.85 * alphaScale})`);
      if (angleDeg !== null){
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate((angleDeg * Math.PI) / 180);
        ctx.beginPath();
        ctx.rect(-lengthPx / 2, -widthPx / 2, lengthPx, widthPx);
        ctx.fill();
        ctx.stroke();
        ctx.restore();
      } else {
        ctx.beginPath();
        ctx.rect(x - halfW, y - halfH, halfW * 2, halfH * 2);
        ctx.fill();
        ctx.stroke();
      }
    } else if (renderAoe.kind === "square" || renderAoe.kind === "cube"){
      const sidePx = Math.max(0, Number(renderAoe.side_sq || 0)) * zoom;
      const half = sidePx / 2;
      const angleDeg = Number.isFinite(Number(renderAoe.angle_deg)) ? Number(renderAoe.angle_deg) : null;
      if (angleDeg !== null){
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate((angleDeg * Math.PI) / 180);
        ctx.beginPath();
        ctx.rect(-half, -half, sidePx, sidePx);
        ctx.fillStyle = colorHex
          ? rgbaFromHex(colorHex, 0.28 * alphaScale)
          : `rgba(226,182,255,${0.32 * alphaScale})`;
        ctx.strokeStyle = colorHex || `rgba(107,61,138,${0.85 * alphaScale})`;
        ctx.fill();
        ctx.stroke();
        ctx.restore();
      } else {
        ctx.beginPath();
        ctx.rect(x - half, y - half, sidePx, sidePx);
        ctx.fillStyle = colorHex
          ? rgbaFromHex(colorHex, 0.28 * alphaScale)
          : `rgba(226,182,255,${0.32 * alphaScale})`;
        ctx.strokeStyle = colorHex || `rgba(107,61,138,${0.85 * alphaScale})`;
        ctx.fill();
        ctx.stroke();
      }
    } else if (renderAoe.kind === "cone"){
      const lengthPx = Math.max(0, Number(renderAoe.length_sq || 0)) * zoom;
      const spreadDeg = coneSpreadDeg(renderAoe);
      const headingDeg = coneHeadingDeg(renderAoe);
      const halfSpread = (spreadDeg * Math.PI) / 360;
      const headingRad = (headingDeg * Math.PI) / 180;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.arc(x, y, lengthPx, headingRad - halfSpread, headingRad + halfSpread);
      ctx.closePath();
      ctx.fillStyle = colorHex
        ? rgbaFromHex(colorHex, fillBaseAlpha * alphaScale)
        : `rgba(255,189,110,${0.32 * alphaScale})`;
      ctx.strokeStyle = colorHex || `rgba(181,110,34,${0.85 * alphaScale})`;
      ctx.fill();
      ctx.stroke();
    }
    ctx.setLineDash([]);
    const label = aoe.name ? String(aoe.name) : "";
    const labelText = label
      ? (aoe.pinned && Number.isFinite(remainingTurnsValue) ? `${label} (${remainingTurnsValue}t)` : label)
      : "";
    if (labelText && !isPreview){
      ctx.font = `700 ${Math.max(10, Math.floor(zoom*0.32))}px system-ui`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = "rgba(20,25,35,0.9)";
      ctx.fillText(labelText, x + 1, y + 1);
      ctx.fillStyle = "rgba(232,238,247,0.95)";
      ctx.fillText(labelText, x, y);
    }
    ctx.restore();
  }

  function hitTestAoe(p){
    if (!state || !state.aoes || !state.aoes.length) return null;
    const gridPos = screenToGridFloat(p.x, p.y);
    for (let i = state.aoes.length - 1; i >= 0; i--){
      const aoe = state.aoes[i];
      if (!aoe || !aoe.kind) continue;
      if (!shouldRenderAoe(aoe)) continue;
      if (!canInteractWithAoe(aoe)) continue;
      const cx = Number(aoe.cx ?? 0);
      const cy = Number(aoe.cy ?? 0);
      const dx = gridPos.col - cx;
      const dy = gridPos.row - cy;
      const kind = String(aoe.kind);
      if (kind === "circle" || kind === "sphere" || kind === "cylinder"){
        const radius = Math.max(0, Number(aoe.radius_sq || 0));
        if (dx * dx + dy * dy <= radius * radius) return aoe;
      } else if (kind === "square" || kind === "cube"){
        const side = Math.max(0, Number(aoe.side_sq || 0));
        const half = side / 2;
        const angleDeg = Number.isFinite(Number(aoe.angle_deg)) ? Number(aoe.angle_deg) : null;
        if (angleDeg !== null){
          const rad = (-angleDeg * Math.PI) / 180;
          const rx = dx * Math.cos(rad) - dy * Math.sin(rad);
          const ry = dx * Math.sin(rad) + dy * Math.cos(rad);
          if (Math.abs(rx) <= half && Math.abs(ry) <= half) return aoe;
        } else if (Math.abs(dx) <= half && Math.abs(dy) <= half) return aoe;
      } else if (kind === "line" || kind === "wall"){
        const length = Math.max(0, Number(aoe.length_sq || 0));
        const width = Math.max(0, Number(aoe.width_sq || 0));
        const angleDeg = Number.isFinite(Number(aoe.angle_deg)) ? Number(aoe.angle_deg) : null;
        const orient = aoe.orient === "horizontal" ? "horizontal" : "vertical";
        const halfW = orient === "horizontal" ? length / 2 : width / 2;
        const halfH = orient === "horizontal" ? width / 2 : length / 2;
        if (angleDeg !== null){
          const rad = (-angleDeg * Math.PI) / 180;
          const rx = dx * Math.cos(rad) - dy * Math.sin(rad);
          const ry = dx * Math.sin(rad) + dy * Math.cos(rad);
          if (Math.abs(rx) <= length / 2 && Math.abs(ry) <= width / 2) return aoe;
        } else {
          if (Math.abs(dx) <= halfW && Math.abs(dy) <= halfH) return aoe;
        }
      } else if (kind === "cone"){
        const length = Math.max(0, Number(aoe.length_sq || 0));
        const dist = Math.hypot(dx, dy);
        if (dist > length) continue;
        const angleToPoint = (Math.atan2(dy, dx) * 180) / Math.PI;
        const headingDeg = coneHeadingDeg(aoe);
        const spreadDeg = coneSpreadDeg(aoe);
        const diff = angularDiffDeg(angleToPoint, headingDeg);
        if (diff <= spreadDeg / 2) return aoe;
      }
    }
    return null;
  }

  function aoeContainsGridPoint(aoe, point){
    if (!aoe || !point) return false;
    const cx = Number(aoe.cx ?? 0);
    const cy = Number(aoe.cy ?? 0);
    const dx = Number(point.col) - cx;
    const dy = Number(point.row) - cy;
    const kind = String(aoe.kind || "");
    if (kind === "circle" || kind === "sphere" || kind === "cylinder"){
      const radius = Math.max(0, Number(aoe.radius_sq || 0));
      return dx * dx + dy * dy <= radius * radius;
    }
    if (kind === "square" || kind === "cube"){
      const side = Math.max(0, Number(aoe.side_sq || 0));
      const half = side / 2;
      const angleDeg = Number.isFinite(Number(aoe.angle_deg)) ? Number(aoe.angle_deg) : null;
      if (angleDeg !== null){
        const rad = (-angleDeg * Math.PI) / 180;
        const rx = dx * Math.cos(rad) - dy * Math.sin(rad);
        const ry = dx * Math.sin(rad) + dy * Math.cos(rad);
        return Math.abs(rx) <= half && Math.abs(ry) <= half;
      }
      return Math.abs(dx) <= half && Math.abs(dy) <= half;
    }
    if (kind === "line" || kind === "wall"){
      const length = Math.max(0, Number(aoe.length_sq || 0));
      const width = Math.max(0, Number(aoe.width_sq || 0));
      const angleDeg = Number.isFinite(Number(aoe.angle_deg)) ? Number(aoe.angle_deg) : null;
      const orient = aoe.orient === "horizontal" ? "horizontal" : "vertical";
      if (angleDeg !== null){
        const rad = (-angleDeg * Math.PI) / 180;
        const rx = dx * Math.cos(rad) - dy * Math.sin(rad);
        const ry = dx * Math.sin(rad) + dy * Math.cos(rad);
        return Math.abs(rx) <= length / 2 && Math.abs(ry) <= width / 2;
      }
      const halfW = orient === "horizontal" ? length / 2 : width / 2;
      const halfH = orient === "horizontal" ? width / 2 : length / 2;
      return Math.abs(dx) <= halfW && Math.abs(dy) <= halfH;
    }
    if (kind === "cone"){
      const length = Math.max(0, Number(aoe.length_sq || 0));
      const dist = Math.hypot(dx, dy);
      if (dist > length) return false;
      const angleToPoint = (Math.atan2(dy, dx) * 180) / Math.PI;
      const headingDeg = coneHeadingDeg(aoe);
      const spreadDeg = coneSpreadDeg(aoe);
      const diff = angularDiffDeg(angleToPoint, headingDeg);
      return diff <= spreadDeg / 2;
    }
    return false;
  }

  function isAoeAllyUnit(unit){
    if (!unit || typeof unit !== "object") return false;
    if (unit.ally === true) return true;
    const role = String(unit.role || "").toLowerCase();
    return role === "pc" || role === "ally";
  }

  function renderAoeTargetPreviewList(listEl, names, cls){
    if (!listEl) return;
    listEl.textContent = "";
    if (!names.length){
      const li = document.createElement("li");
      li.textContent = "None";
      li.className = cls;
      listEl.appendChild(li);
      return;
    }
    names.forEach((name) => {
      const li = document.createElement("li");
      li.textContent = name;
      li.className = cls;
      listEl.appendChild(li);
    });
  }

  function updateAoeTargetPreviewPanel(previewAoe){
    if (!aoeTargetPreview || !aoeTargetPreviewAllies || !aoeTargetPreviewEnemies){
      return;
    }
    if (!previewAoe || !Array.isArray(state?.units)){
      hideAoeTargetPreviewPanel();
      return;
    }
    const allies = [];
    const enemies = [];
    state.units.forEach((unit) => {
      if (!unit?.pos) return;
      const col = Number(unit.pos.col);
      const row = Number(unit.pos.row);
      if (!Number.isFinite(col) || !Number.isFinite(row)) return;
      if (!aoeContainsGridPoint(previewAoe, {col, row})) return;
      const unitName = String(unit.name || `#${unit.cid ?? "?"}`);
      if (isAoeAllyUnit(unit)) allies.push(unitName);
      else enemies.push(unitName);
    });
    allies.sort((a, b) => a.localeCompare(b));
    enemies.sort((a, b) => a.localeCompare(b));
    const signature = `${allies.join("|")}::${enemies.join("|")}`;
    if (signature === aoeTargetPreviewSignature){
      aoeTargetPreview.classList.remove("hidden");
      aoeTargetPreview.setAttribute("aria-hidden", "false");
      return;
    }
    aoeTargetPreviewSignature = signature;
    renderAoeTargetPreviewList(aoeTargetPreviewAllies, allies, "ally");
    renderAoeTargetPreviewList(aoeTargetPreviewEnemies, enemies, "enemy");
    aoeTargetPreview.classList.remove("hidden");
    aoeTargetPreview.setAttribute("aria-hidden", "false");
  }

  function hideAoeTargetPreviewPanel(){
    aoeTargetPreviewSignature = "";
    if (aoeTargetPreview){
      aoeTargetPreview.classList.add("hidden");
      aoeTargetPreview.setAttribute("aria-hidden", "true");
    }
    if (aoeTargetPreviewAllies) aoeTargetPreviewAllies.textContent = "";
    if (aoeTargetPreviewEnemies) aoeTargetPreviewEnemies.textContent = "";
  }




  function gridReady(){
    if (!state || !state.grid) return false;
    if (state.grid.ready === false) return false;
    return Number.isFinite(state.grid.cols) && Number.isFinite(state.grid.rows);
  }

  function updateWaitingOverlay(){
    if (!waitingOverlay) return;
    waitingOverlay.classList.toggle("show", !gridReady());
  }

  function formatFeet(feet){
    const rounded = Math.round(feet * 10) / 10;
    const label = Number.isInteger(rounded) ? String(rounded) : rounded.toFixed(1);
    return `${label} ft`;
  }


  function getClaimedBeguilingMagicWindowSeconds(){
    const unit = getClaimedUnit();
    const value = Number(unit?.beguiling_magic_window_s || 0);
    return Number.isFinite(value) ? Math.max(0, value) : 0;
  }

  function formatShortDuration(seconds){
    const total = Math.max(0, Math.ceil(Number(seconds) || 0));
    const mins = Math.floor(total / 60);
    const secs = total % 60;
    return `${mins}:${String(secs).padStart(2, "0")}`;
  }

  function setBeguilingMagicModalOpen(open){
    setModalOpen(beguilingMagicModal, open);
    if (!open) return;
    const windowS = getClaimedBeguilingMagicWindowSeconds();
    if (beguilingMagicStatus){
      beguilingMagicStatus.textContent = windowS > 0
        ? `Window remaining: ${formatShortDuration(windowS)}`
        : "Beguiling Magic is not armed.";
    }
  }

  function beginBeguilingMagicFlow(fromPool = false){
    const me = getClaimedUnit();
    if (!me){
      localToast("Claim a character first, matey.");
      return;
    }
    const windowS = getClaimedBeguilingMagicWindowSeconds();
    if (windowS <= 0){
      localToast("Beguiling Magic is not armed.");
      return;
    }
    pendingBeguilingMagic = {fromPool: !!fromPool, condition: "charmed"};
    if (beguilingMagicConditionInput){
      beguilingMagicConditionInput.value = "charmed";
    }
    setBeguilingMagicModalOpen(true);
  }

  function isCommandSpellTargeting(){
    const slug = normalizeLowerValue(pendingSpellTargeting?.spellSlug || pendingSpellTargeting?.spellId || pendingSpellTargeting?.spellName);
    return slug === "command";
  }

  function isPolymorphSpellTargeting(){
    const slug = normalizeLowerValue(pendingSpellTargeting?.spellSlug || pendingSpellTargeting?.spellId || pendingSpellTargeting?.spellName);
    return slug === "polymorph";
  }

  function setCommandOptionModalOpen(open){
    setModalOpen(commandOptionModal, open);
    if (!open) return;
    if (commandOptionSelect && !String(commandOptionSelect.value || "").trim()){
      commandOptionSelect.value = "approach";
    }
    if (commandOptionStatus){
      const count = Array.isArray(pendingCommandResolution?.targetCids) ? pendingCommandResolution.targetCids.length : 0;
      commandOptionStatus.textContent = count > 0
        ? `Applies to ${count} target${count === 1 ? "" : "s"}.`
        : "Select a command option.";
    }
  }

  function queueCommandResolution(targetCids, castMsg = null){
    if (!pendingSpellTargeting || !isCommandSpellTargeting()){
      return false;
    }
    const ids = Array.isArray(targetCids)
      ? Array.from(new Set(targetCids.map((cid) => Number(cid)).filter((cid) => Number.isFinite(cid))))
      : [];
    if (!ids.length){
      localToast("Pick at least one target first.");
      return true;
    }
    pendingCommandResolution = {
      targetCids: ids,
      castMsg,
      spellName: String(pendingSpellTargeting.spellName || "Command"),
      slotLevel: Number.isFinite(Number(pendingSpellTargeting.slotLevel))
        ? Math.max(1, Math.floor(Number(pendingSpellTargeting.slotLevel)))
        : 1,
      spellSlug: pendingSpellTargeting.spellSlug || "command",
      spellId: pendingSpellTargeting.spellId || "command",
    };
    setCommandOptionModalOpen(true);
    return true;
  }

  function setBardicDiceConfirmModalOpen(open, pool = null){
    setModalOpen(bardicDiceConfirmModal, open);
    if (!open){
      pendingBardicDiceUse = null;
      return;
    }
    pendingBardicDiceUse = pool || null;
    const dieSides = Number(pool?.die_sides || 0);
    const label = Number.isFinite(dieSides) && dieSides > 0 ? `d${Math.floor(dieSides)}` : "die";
    if (bardicDiceConfirmStatus){
      bardicDiceConfirmStatus.textContent = `Are ye sure ye want to expend yer Bardic Inspiration ${label}?`;
    }
  }

  function startBardicInspirationGrantTargeting(entry){
    const me = getClaimedUnit();
    if (!me){
      localToast("Claim a character first, matey.");
      return;
    }
    if (Number(me?.bonus_action_remaining || 0) <= 0){
      localToast("No bonus actions left, matey.");
      return;
    }
    pendingBardicInspirationTargeting = {
      actionName: String(entry?.name || "Bardic Inspiration"),
      rangeFt: 60,
    };
    setAttackOverlayMode(true);
    localToast("Bardic Inspiration ready. Select one creature within 60 ft.");
  }

  function getUnitAbilityModifier(unit, key){
    const abilityKey = normalizeAbilityKey(key);
    if (!abilityKey) return 0;
    const modSources = [
      unit?.ability_mods,
      unit?.attrs?.ability_mods,
      unit?.raw_data?.ability_mods,
      unit?.attrs?.raw_data?.ability_mods,
    ];
    for (const source of modSources){
      if (!source || typeof source !== "object") continue;
      const direct = Number(source[abilityKey] ?? source[abilityKey.toUpperCase()] ?? source[`${abilityKey}_mod`]);
      if (Number.isFinite(direct)) return Math.floor(direct);
    }
    const scoreSources = [
      unit?.abilities,
      unit?.attrs?.abilities,
      unit?.raw_data?.abilities,
      unit?.attrs?.raw_data?.abilities,
    ];
    for (const source of scoreSources){
      if (!source || typeof source !== "object") continue;
      const score = Number(source[abilityKey] ?? source[abilityKey.toUpperCase()] ?? source[`${abilityKey}_score`]);
      if (Number.isFinite(score)) return Math.floor((score - 10) / 2);
    }
    const profile = getPlayerProfile(unit?.name);
    return getAbilityModifier(profile, abilityKey);
  }

  function mantleMaxTargetsForUnit(unit){
    const chaMod = getUnitAbilityModifier(unit, "cha");
    if (Number.isFinite(chaMod)) return Math.max(1, Math.floor(chaMod));
    return 1;
  }

  function setMantleResolveModalOpen(open){
    setModalOpen(mantleResolveModal, open);
    if (!open) return;
    const selected = Array.isArray(pendingMantleOfInspiration?.targetCids) ? pendingMantleOfInspiration.targetCids : [];
    if (mantleResolveSummary){
      mantleResolveSummary.textContent = `Selected targets: ${selected.length}. Enter a die roll or leave blank to auto-roll.`;
    }
    if (mantleResolveDieInput){
      mantleResolveDieInput.value = "";
      mantleResolveDieInput.focus();
    }
  }

  function startMantleOfInspirationTargeting(entry){
    const actingCid = normalizeCid(entry?.sourceCid, "mantle.start.sourceCid") ?? activeControlledUnitCid();
    const me = actingCid === null ? null : getUnitByCid(actingCid);
    if (actingCid === null || !me){
      localToast("Wait for yer turn before using Mantle of Inspiration.");
      return;
    }
    if (Number(me?.bonus_action_remaining || 0) <= 0){
      localToast("No bonus actions left, matey.");
      return;
    }
    pendingMantleOfInspiration = {
      actionName: String(entry?.name || "Mantle of Inspiration"),
      casterCid: actingCid,
      rangeFt: 60,
      maxTargets: mantleMaxTargetsForUnit(me),
      targetCids: [],
    };
    setAttackOverlayMode(true);
    renderSpellTargetSelectionUi();
    localToast(`Select targets (0/${pendingMantleOfInspiration.maxTargets}) for Mantle of Inspiration.`);
  }

  function touchSpellRangeFeet(){
    const feetPerSquare = Number(state?.grid?.feet_per_square);
    if (Number.isFinite(feetPerSquare) && feetPerSquare > 0){
      return feetPerSquare;
    }
    return 5;
  }

  function parseSpellRangeFeet(rangeValue){
    const text = String(rangeValue || "").toLowerCase();
    if (text.includes("touch")){
      return touchSpellRangeFeet();
    }
    const match = text.match(/(\d+(?:\.\d+)?)\s*(?:ft|feet)/);
    if (!match) return null;
    const value = Number(match[1]);
    return Number.isFinite(value) && value >= 0 ? value : null;
  }

  function parseSpellTargetRangeFeet(preset){
    const rangeKind = normalizeLowerValue(preset?.mechanics?.targeting?.range?.kind);
    const rawMechanicsRange = preset?.mechanics?.targeting?.range?.distance_ft;
    const mechanicsRange = (rawMechanicsRange === null || rawMechanicsRange === undefined)
      ? null
      : Number(rawMechanicsRange);
    const parsedTextRange = parseSpellRangeFeet(preset?.range);
    const baseRangeFt = Number.isFinite(mechanicsRange) && mechanicsRange >= 0
      ? mechanicsRange
      : parsedTextRange;
    if (!Number.isFinite(baseRangeFt)){
      return null;
    }
    const rangeText = normalizeLowerValue(preset?.range);
    const isMeleeTargetingRange = rangeKind === "touch"
      || rangeKind === "melee"
      || rangeText.includes("touch")
      || (Number.isFinite(baseRangeFt) && baseRangeFt <= touchSpellRangeFeet());
    return isMeleeTargetingRange ? baseRangeFt + MELEE_RANGE_FUDGE_FT : baseRangeFt;
  }

  function isSelfRangeAoePreset(preset){
    const rangeText = String(preset?.range || "").trim().toLowerCase();
    if (rangeText.startsWith("self")) return true;
    const rangeKind = String(preset?.mechanics?.targeting?.range?.kind || "").trim().toLowerCase();
    if (rangeKind === "self") return true;
    const origin = String(preset?.mechanics?.targeting?.origin || "").trim().toLowerCase();
    return origin === "self";
  }

  function isCenteredAoeShape(shape){
    const kind = String(shape || "").toLowerCase();
    return kind === "circle" || kind === "sphere" || kind === "cylinder" || kind === "square" || kind === "cube";
  }

  function isDirectionalSelfRangeAoePlacement(preset, shape){
    const kind = String(shape || "").toLowerCase();
    return isSelfRangeAoePreset(preset) && (kind === "line" || kind === "cone");
  }

  function isDirectionalSelfRangePlacementActive(){
    return pendingAoePlacement?.mode === "directional_self_range";
  }

  function isPlacementSquareOrCube(){
    const kind = String(pendingAoePlacement?.payload?.shape || pendingAoePlacement?.payload?.kind || "").toLowerCase();
    return kind === "square" || kind === "cube";
  }

  function normalizePlacementHeadingDeg(angleDeg){
    if (!Number.isFinite(Number(angleDeg))) return 0;
    return normalizeFacingDeg(Number(angleDeg));
  }

  function directionalPlacementAnchor(casterPos, cursorPos, headingDeg){
    const cx = Number(casterPos?.col || 0);
    const cy = Number(casterPos?.row || 0);
    let heading = Number.isFinite(Number(headingDeg)) ? Number(headingDeg) : 0;
    const dx = Number(cursorPos?.col || 0) - cx;
    const dy = Number(cursorPos?.row || 0) - cy;
    if (Math.hypot(dx, dy) < 1e-6){
      const rad = (heading * Math.PI) / 180;
      const radius = 0.5001;
      return {
        headingDeg: heading,
        vx: Math.cos(rad),
        vy: Math.sin(rad),
        ax: cx + Math.cos(rad) * radius,
        ay: cy + Math.sin(rad) * radius,
      };
    }
    heading = normalizePlacementHeadingDeg((Math.atan2(dy, dx) * 180) / Math.PI);
    const rad = (heading * Math.PI) / 180;
    const ux = Math.cos(rad);
    const uy = Math.sin(rad);
    const scale = 0.5001 / Math.max(Math.abs(ux), Math.abs(uy), 1e-6);
    return {
      headingDeg: heading,
      vx: ux,
      vy: uy,
      ax: cx + ux * scale,
      ay: cy + uy * scale,
    };
  }

  function applyDirectionalSelfRangePlacement(){
    if (!pendingAoePlacement || !isDirectionalSelfRangePlacementActive()) return;
    const casterPos = getPendingAoeCasterPos();
    if (!casterPos) return;
    const cursor = pendingAoePlacement.cursor || casterPos;
    const currentHeading = Number(pendingAoePlacement.headingDeg);
    const anchor = directionalPlacementAnchor(casterPos, cursor, currentHeading);
    const payload = pendingAoePlacement.payload || {};
    const kind = String(payload.shape || payload.kind || "").toLowerCase();
    pendingAoePlacement.headingDeg = anchor.headingDeg;
    payload.angle_deg = anchor.headingDeg;
    payload.ax = anchor.ax;
    payload.ay = anchor.ay;
    if (kind === "line"){
      const feetPerSquare = Math.max(1, Number(state?.grid?.feet_per_square || 5));
      const lineLengthSq = Number.isFinite(Number(payload.length_ft))
        ? Math.max(1, Number(payload.length_ft) / feetPerSquare)
        : Math.max(1, Number(payload.length_sq || 0));
      const halfLen = lineLengthSq / 2;
      payload.cx = anchor.ax + anchor.vx * halfLen;
      payload.cy = anchor.ay + anchor.vy * halfLen;
    } else {
      payload.cx = anchor.ax;
      payload.cy = anchor.ay;
      if (
        Number.isFinite(Number(pendingAoePlacement.coneSpreadDeg))
        && !Number.isFinite(Number(payload.spread_deg))
      ){
        payload.spread_deg = Number(pendingAoePlacement.coneSpreadDeg);
      }
    }
    pendingAoePlacement.payload = payload;
    pendingAoePlacement.cursor = {col: Number(cursor.col), row: Number(cursor.row)};
  }

  function distanceFeetBetweenCells(a, b){
    const feetPerSquare = Math.max(1, Number(state?.grid?.feet_per_square || 5));
    const dx = Math.abs(Number(a?.col || 0) - Number(b?.col || 0));
    const dy = Math.abs(Number(a?.row || 0) - Number(b?.row || 0));
    return Math.max(dx, dy) * feetPerSquare;
  }

  function setAttackOverlayMode(enabled){
    attackOverlayMode = !!enabled;
    if (!attackOverlayMode){
      pendingOpportunityAttack = false;
    pendingReactionRequestId = "";
      pendingActionAttackWeapon = null;
      pendingUnleashIncarnation = null;
      pendingMonkBonusAttackSequence = null;
      pendingBeguilingMagic = null;
      pendingCommandResolution = null;
      pendingBardicInspirationTargeting = null;
    }
    if (attackOverlayToggleBtn){
      attackOverlayToggleBtn.setAttribute("aria-pressed", attackOverlayMode ? "true" : "false");
      attackOverlayToggleBtn.classList.toggle("accent", attackOverlayMode);
    }
    draw();
  }

  function attackDamageTypeOptions(){
    const options = [];
    const select = castDamageTypeInput;
    if (select){
      Array.from(select.options || []).forEach((opt) => {
        const value = String(opt?.value || "").trim();
        if (!value) return;
        options.push(value);
      });
    }
    return options;
  }

  function addDamageRow(container, initialAmount = "", initialType = ""){
    if (!container) return;
    const row = document.createElement("div");
    row.className = "damage-type-controls";
    const amountInput = document.createElement("input");
    amountInput.type = "text";
    amountInput.inputMode = "numeric";
    amountInput.placeholder = "Damage (e.g. 8+2*3)";
    amountInput.value = String(initialAmount || "");
    const typeSelect = document.createElement("select");
    const placeholderOption = document.createElement("option");
    placeholderOption.value = "";
    placeholderOption.textContent = "Damage type";
    typeSelect.appendChild(placeholderOption);
    attackDamageTypeOptions().forEach((value) => {
      const option = document.createElement("option");
      option.value = value;
      option.textContent = value;
      typeSelect.appendChild(option);
    });
    if (initialType){
      const normalizedInitial = String(initialType).trim().toLowerCase();
      let matchedValue = "";
      Array.from(typeSelect.options || []).forEach((opt) => {
        if (matchedValue) return;
        if (String(opt?.value || "").trim().toLowerCase() === normalizedInitial){
          matchedValue = String(opt.value || "");
        }
      });
      if (!matchedValue && normalizedInitial){
        const customOption = document.createElement("option");
        customOption.value = normalizedInitial;
        customOption.textContent = normalizedInitial;
        typeSelect.appendChild(customOption);
        matchedValue = normalizedInitial;
      }
      if (matchedValue){
        typeSelect.value = matchedValue;
      }
    }
    const removeBtn = document.createElement("button");
    removeBtn.type = "button";
    removeBtn.className = "btn";
    removeBtn.textContent = "Remove";
    removeBtn.addEventListener("click", () => {
      row.remove();
    });
    row.appendChild(amountInput);
    row.appendChild(typeSelect);
    row.appendChild(removeBtn);
    container.appendChild(row);
  }

  function addAttackDamageRow(initialAmount = "", initialType = ""){
    addDamageRow(attackDamageRows, initialAmount, initialType);
  }

  function parseManualDamageAmount(rawValue){
    const text = String(rawValue ?? "").trim();
    if (!text) return {status: "blank", value: null};
    const parsed = evaluateDamageExpression(text);
    if (parsed === null) return {status: "invalid", value: null};
    if (!Number.isSafeInteger(parsed) || parsed < 0) return {status: "invalid", value: null};
    if (parsed === 0) return {status: "zero", value: null};
    return {status: "ok", value: parsed};
  }

  function evaluateDamageExpression(expression){
    let expr = String(expression || "").replace(/\s+/g, "");
    if (!expr) return null;
    if (expr.startsWith("+")) expr = expr.slice(1);
    if (!expr) return null;
    if (!/^[\d+\-*]+$/.test(expr)) return null;
    if (/^[+\-*]|[+\-*]$/.test(expr)) return null;
    if (/[+\-*]{2,}/.test(expr)) return null;
    const parts = expr.split(/([+\-])/);
    if (!parts.length || parts.some((part) => part === "")) return null;
    const evaluateProduct = (term) => {
      const factors = String(term || "").split("*");
      if (!factors.length) return null;
      let result = 1;
      for (const factor of factors){
        if (!/^\d+$/.test(factor)) return null;
        const value = Number(factor);
        if (!Number.isSafeInteger(value)) return null;
        result *= value;
        if (!Number.isSafeInteger(result)) return null;
      }
      return result;
    };
    let total = evaluateProduct(parts[0]);
    if (total === null) return null;
    for (let i = 1; i < parts.length; i += 2){
      const operator = parts[i];
      const rhs = evaluateProduct(parts[i + 1]);
      if (rhs === null) return null;
      if (operator === "+"){
        total += rhs;
      } else if (operator === "-"){
        total -= rhs;
      } else {
        return null;
      }
      if (!Number.isSafeInteger(total)) return null;
    }
    return total;
  }

  function collectDamageEntriesFromRows(container){
    const entries = [];
    let invalidCount = 0;
    if (!container) return {entries, invalidCount};
    Array.from(container.querySelectorAll(".damage-type-controls")).forEach((row) => {
      const amountInput = row.querySelector("input");
      const typeSelect = row.querySelector("select");
      const parsedAmount = parseManualDamageAmount(amountInput?.value);
      if (parsedAmount.status === "invalid"){
        invalidCount += 1;
        return;
      }
      if (parsedAmount.status !== "ok") return;
      entries.push({
        amount: parsedAmount.value,
        type: String(typeSelect?.value || "").trim().toLowerCase(),
      });
    });
    return {entries, invalidCount};
  }

  function syncAttackResolveDamageVisibility(){
    const isMiss = !!(attackResolveMiss && attackResolveMiss.checked);
    if (attackDamageRows){
      attackDamageRows.classList.toggle("hidden", isMiss);
    }
    if (attackDamageAdd){
      attackDamageAdd.classList.toggle("hidden", isMiss);
    }
  }

  function setAttackResolveModalOpen(open){
    if (!attackResolveModal) return;
    attackResolveModal.classList.toggle("show", !!open);
    attackResolveModal.setAttribute("aria-hidden", open ? "false" : "true");
    if (!open){
      if (attackResolveHit) attackResolveHit.disabled = false;
      if (attackResolveMiss) attackResolveMiss.disabled = false;
      if (attackResolveCrit) attackResolveCrit.checked = false;
      if (attackStunningStrike) attackStunningStrike.checked = false;
      if (attackStunningStrikeRow) attackStunningStrikeRow.style.display = "none";
      if (attackDamageTypeOverrideRow) attackDamageTypeOverrideRow.style.display = "none";
      if (attackDamageTypeOverrideSelect){
        attackDamageTypeOverrideSelect.value = "";
        attackDamageTypeOverrideSelect.disabled = true;
      }
      pendingAttackResolve = null;
    }
  }

  function castAutomationIsEnabled(){
    return castAutomationEnabled !== false;
  }

  function setCastAutomationEnabled(enabled){
    castAutomationEnabled = !!enabled;
    localStorage.setItem(castAutomationStorageKey, castAutomationEnabled ? "1" : "0");
  }

  function setSpellResolveModalOpen(open){
    if (!spellResolveModal) return;
    spellResolveModal.classList.toggle("show", !!open);
    spellResolveModal.setAttribute("aria-hidden", open ? "false" : "true");
    if (!open){
      pendingSpellResolve = null;
    }
  }

  function openSpellResolveModal(context, onConfirm){
    if (!spellResolveBody || !spellResolveDamageRows){
      if (typeof onConfirm === "function") onConfirm([]);
      return;
    }
    const spellName = String(context?.spellName || "Spell").trim() || "Spell";
    const slotLevel = Number.isFinite(Number(context?.slotLevel)) ? Math.floor(Number(context.slotLevel)) : null;
    const baseLevel = Number.isFinite(Number(context?.baseLevel)) ? Math.floor(Number(context.baseLevel)) : null;
    const dice = String(context?.dice || "").trim();
    const upcast = (slotLevel !== null && baseLevel !== null && slotLevel > baseLevel)
      ? ` Upcast: base level ${baseLevel}, cast at level ${slotLevel}.`
      : "";
    const slotText = slotLevel !== null ? ` (slot ${slotLevel})` : "";
    const diceText = dice ? ` Final dice: ${dice}.` : "";
    spellResolveBody.textContent = `Resolve ${spellName}${slotText}.${upcast}${diceText} Enter table-rolled damage totals by type, or leave blank to auto-roll.`;
    spellResolveDamageRows.textContent = "";
    const suggestedTypes = Array.isArray(context?.damageTypes) ? context.damageTypes : [];
    if (suggestedTypes.length){
      suggestedTypes.forEach((dtype) => addDamageRow(spellResolveDamageRows, "", dtype));
    } else {
      addDamageRow(spellResolveDamageRows);
    }
    pendingSpellResolve = {
      onConfirm: typeof onConfirm === "function" ? onConfirm : null,
    };
    setSpellResolveModalOpen(true);
  }

  function setSculptSelectModalOpen(open){
    if (!sculptSelectModal) return;
    sculptSelectModal.classList.toggle("show", !!open);
    sculptSelectModal.setAttribute("aria-hidden", open ? "false" : "true");
    if (!open){
      pendingSculptSelect = null;
      if (sculptSelectList){
        sculptSelectList.textContent = "";
      }
    }
  }

  function updateSculptSelectionSummary(){
    if (!sculptSelectBody || !sculptSelectConfirm || !pendingSculptSelect) return;
    const selectedCount = pendingSculptSelect.selected.size;
    const maxSelections = Math.max(1, Number(pendingSculptSelect.maxSelections || 1));
    const allyLabel = maxSelections === 1 ? "ally" : "allies";
    sculptSelectBody.textContent = `Select up to ${maxSelections} ${allyLabel} to protect (${selectedCount}/${maxSelections} selected).`;
    sculptSelectConfirm.disabled = selectedCount > maxSelections;
  }

  function openSculptSelectModal(allies, maxSelections, onConfirm){
    if (!sculptSelectList || !Array.isArray(allies) || typeof onConfirm !== "function"){
      if (typeof onConfirm === "function"){
        onConfirm([]);
      }
      return;
    }
    pendingSculptSelect = {
      allies: allies.slice(),
      maxSelections: Math.max(1, Number(maxSelections || 1)),
      selected: new Set(),
      onConfirm,
    };
    sculptSelectList.textContent = "";
    pendingSculptSelect.allies.forEach((ally) => {
      const row = document.createElement("div");
      row.className = "sculpt-row";
      const label = document.createElement("label");
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.value = String(Number(ally?.cid || 0));
      checkbox.addEventListener("change", () => {
        if (!pendingSculptSelect) return;
        const cid = Number(checkbox.value);
        if (!Number.isFinite(cid)) return;
        if (checkbox.checked){
          pendingSculptSelect.selected.add(cid);
        } else {
          pendingSculptSelect.selected.delete(cid);
        }
        updateSculptSelectionSummary();
      });
      const name = document.createElement("span");
      name.className = "sculpt-row-name";
      name.textContent = String(ally?.name || `#${ally?.cid ?? "?"}`);
      label.appendChild(checkbox);
      label.appendChild(name);
      row.appendChild(label);
      sculptSelectList.appendChild(row);
    });
    updateSculptSelectionSummary();
    setSculptSelectModalOpen(true);
  }

  function setCleavePromptOpen(open){
    if (!cleavePromptModal) return;
    cleavePromptModal.classList.toggle("show", !!open);
    cleavePromptModal.setAttribute("aria-hidden", open ? "false" : "true");
    if (!open){
      pendingCleavePrompt = null;
      if (cleavePromptList){
        cleavePromptList.textContent = "";
      }
    }
  }

  function openCleavePrompt(resultMsg){
    if (!cleavePromptBody || !cleavePromptList) return;
    const candidates = Array.isArray(resultMsg?.cleave_candidates) ? resultMsg.cleave_candidates : [];
    if (!candidates.length){
      return;
    }
    pendingCleavePrompt = {
      weaponId: String(resultMsg?.weapon_id || "").trim(),
      weaponName: String(resultMsg?.weapon_name || "Weapon").trim() || "Weapon",
      candidates,
    };
    cleavePromptBody.textContent = "Cleave triggers! Pick one nearby enemy for a free attack.";
    cleavePromptList.textContent = "";
    candidates.forEach((entry) => {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "btn";
      btn.textContent = String(entry?.name || `Enemy #${entry?.cid || "?"}`);
      btn.addEventListener("click", () => {
        const unit = getUnitByCid(entry?.cid) || {cid: entry?.cid, name: entry?.name || "Enemy"};
        const weapon = {id: pendingCleavePrompt.weaponId, name: pendingCleavePrompt.weaponName};
        setCleavePromptOpen(false);
        openAttackResolveModal(unit, weapon);
        if (pendingAttackResolve){
          pendingAttackResolve.masteryFreeAttack = "cleave";
        }
      });
      cleavePromptList.appendChild(btn);
    });
    setCleavePromptOpen(true);
  }

  function openAttackResolveModal(target, weapon){
    if (!attackResolveBody || !attackDamageRows) return;
    let mode = null;
    const selectedMode = String(weapon?.selected_mode || "").trim().toLowerCase();
    if (selectedMode === "two" && weapon?.two_handed && String(weapon.two_handed.damage_formula || "").trim()){
      mode = weapon.two_handed;
    } else if (weapon?.one_handed && String(weapon.one_handed.damage_formula || "").trim()){
      mode = weapon.one_handed;
    } else if (weapon?.two_handed && String(weapon.two_handed.damage_formula || "").trim()){
      mode = weapon.two_handed;
    }
    const effect = weapon?.effect && typeof weapon.effect === "object" ? weapon.effect : null;
    const hintParts = [];
    if (mode){
      const baseFormula = String(mode.damage_formula || "").trim();
      const baseType = String(mode.damage_type || "").trim().toLowerCase();
      if (baseFormula){
        hintParts.push(`Auto-on-hit: ${baseFormula}${baseType ? ` ${baseType}` : ""} damage.`);
      }
    }
    const riderText = String(effect?.on_hit || "").trim();
    if (riderText){
      hintParts.push(`Rider: ${riderText}`);
    }
    const saveAbility = String(effect?.save_ability || "").trim().toUpperCase();
    const saveDc = Number(effect?.save_dc);
    if (saveAbility && Number.isFinite(saveDc) && saveDc > 0){
      hintParts.push(`Save rider: ${saveAbility} DC ${Math.floor(saveDc)}.`);
    }
    const me = getClaimedUnit();
    const hasVexAdvantage = Number.isFinite(Number(target?.vexed_by_cid))
      && Number.isFinite(Number(me?.cid))
      && Number(target.vexed_by_cid) === Number(me.cid);
    const attunedUnarmed = isUnarmedStrikeWeapon(weapon) && unitHasElementalAttunement(me);
    const profile = getPlayerProfile(getClaimedPlayerName());
    const monkLevel = getMonkLevelFromProfile(profile);
    const focusPool = getPlayerResourcePools(getClaimedPlayerName()).find((entry) => entry.id === "focus_points");
    const canUseStunningStrike = monkLevel >= 5 && Number(focusPool?.current || 0) > 0;
    if (attackStunningStrikeRow){
      attackStunningStrikeRow.style.display = canUseStunningStrike ? "flex" : "none";
    }
    if (attackStunningStrike){
      attackStunningStrike.checked = false;
      attackStunningStrike.disabled = !canUseStunningStrike;
    }
    if (attackDamageTypeOverrideRow){
      attackDamageTypeOverrideRow.style.display = attunedUnarmed ? "flex" : "none";
    }
    if (attackDamageTypeOverrideSelect){
      attackDamageTypeOverrideSelect.value = "";
      attackDamageTypeOverrideSelect.disabled = !attunedUnarmed;
    }
    const claimedName = normalizeLowerValue(getClaimedPlayerName());
    const isJohnTwilight = claimedName === "john twilight";
    const fighterLevel = getClassLevelFromProfile(profile, "fighter");
    const tacticalMasterAllowed = !!(isJohnTwilight && fighterLevel >= 9);
    if (attackTacticalMasterRow){
      attackTacticalMasterRow.style.display = tacticalMasterAllowed ? "flex" : "none";
    }
    if (attackTacticalMasterSelect){
      attackTacticalMasterSelect.value = "";
      attackTacticalMasterSelect.disabled = !tacticalMasterAllowed;
    }

    pendingAttackResolve = {
      targetCid: Number(target?.cid),
      targetName: String(target?.name || "target"),
      weaponId: String(weapon?.id || "").trim(),
      weaponName: String(weapon?.name || "Weapon").trim() || "Weapon",
      weapon: weapon && typeof weapon === "object" ? {...weapon} : null,
      attackCount: Number.isFinite(Number(weapon?.attack_count)) ? Math.max(1, Math.floor(Number(weapon.attack_count))) : null,
      masteryAdvantage: hasVexAdvantage,
      opportunityAttack: pendingOpportunityAttack,
      reaction_request_id: pendingReactionRequestId || undefined,
      consumesPool: pendingUnleashIncarnation ? {...pendingUnleashIncarnation} : null,
      elementalOverrideAllowed: attunedUnarmed,
      stunningStrikeAllowed: canUseStunningStrike,
      tacticalMasterAllowed,
    };
    pendingOpportunityAttack = false;
    const advantageText = hasVexAdvantage ? ' <span class="mastery-advantage-text">Vex Advantage: ye have advantage on this attack.</span>' : "";
    const resolvePrompt = String(weapon?.resolve_prompt || "").trim();
    attackResolveBody.innerHTML = `${resolvePrompt || `Attack ${pendingAttackResolve.targetName} with ${pendingAttackResolve.weaponName}.`}`
      + (hintParts.length ? ` ${hintParts.join(" ")}` : "")
      + advantageText;
    attackDamageRows.textContent = "";
    const suggestedTypes = [];
    const pushSuggestedType = (value) => {
      const normalized = String(value || "").trim().toLowerCase();
      if (!normalized || suggestedTypes.includes(normalized)) return;
      suggestedTypes.push(normalized);
    };
    if (mode){
      pushSuggestedType(mode.damage_type);
    }
    if (riderText){
      // Match rider snippets like "1d6 fire damage" (or "d6 fire damage") and collect the extracted damage type.
      const riderRegex = /(\d*d\d+(?:\s*[+\-]\s*\d+)?)\s+([a-zA-Z]+)\s+damage/gi;
      let riderMatch = null;
      while ((riderMatch = riderRegex.exec(riderText))){
        pushSuggestedType(riderMatch[2]);
      }
    }
    if (suggestedTypes.length){
      suggestedTypes.forEach((dtype) => addAttackDamageRow("", dtype));
    } else {
      addAttackDamageRow();
    }
    if (attackResolveHit) attackResolveHit.checked = true;
    if (attackResolveMiss) attackResolveMiss.checked = false;
    if (attackResolveCrit) attackResolveCrit.checked = false;
    syncAttackResolveDamageVisibility();
    setAttackResolveModalOpen(true);
  }

  function summonCellKey(col, row){
    return `${Number(col)},${Number(row)}`;
  }

  function isSummonPlacementCellValid(cell){
    if (!pendingSummonPlacement || !cell) return false;
    return summonValidCells.has(summonCellKey(cell.col, cell.row));
  }

  function clearSummonPlacementState(){
    pendingSummonPlacement = null;
    summonValidCells = new Set();
    if (summonPlacementBanner){
      summonPlacementBanner.classList.add("hidden");
      summonPlacementBanner.textContent = "";
    }
  }


  function clearPendingAoePlacement(shouldRedraw = true){
    pendingAoePlacement = null;
    aoeAimGuide = null;
    hideAoeTargetPreviewPanel();
    renderAimlessAoeConfirm();
    if (shouldRedraw){
      draw();
    }
  }

  
  function isAimlessSelfCenteredAoePlacement(){
    return pendingAoePlacement?.mode === "aimless_self_centered";
  }

  function getPendingAoeCasterPos(){
    if (!pendingAoePlacement) return null;
    const casterCid = Number(pendingAoePlacement.casterCid);
    if (!Number.isFinite(casterCid)) return pendingAoePlacement?.casterPos ? toGridPoint(pendingAoePlacement.casterPos) : null;
    const caster = getUnitByCid(casterCid);
    if (caster?.pos){
      return toGridPoint(caster.pos);
    }
    return pendingAoePlacement?.casterPos ? toGridPoint(pendingAoePlacement.casterPos) : null;
  }

  function renderAimlessAoeConfirm(){
    if (!aimlessAoeConfirm) return;
    const active = isAimlessSelfCenteredAoePlacement();
    aimlessAoeConfirm.classList.toggle("hidden", !active);
    aimlessAoeConfirm.setAttribute("aria-hidden", active ? "false" : "true");
  }

  function computeAoePlacementAimGuide(){
    const casterPos = getPendingAoeCasterPos();
    if (!casterPos) return null;
    const start = toGridPoint(casterPos);
    const cursor = isAimlessSelfCenteredAoePlacement()
      ? (getPendingAoeCasterPos() || {col: Number(pendingAoePlacement.payload?.cx || 0), row: Number(pendingAoePlacement.payload?.cy || 0)})
      : (pendingAoePlacement.cursor || {col: Number(pendingAoePlacement.payload?.cx || 0), row: Number(pendingAoePlacement.payload?.cy || 0)});
    const end = toGridPoint(cursor);
    const blocked = isLineOfSightBlocked(start, end);
    const distFt = distanceFeetBetweenCells(start, end);
    const rawRangeFt = pendingAoePlacement.rangeFt;
    const hasRangeValue = rawRangeFt !== null && rawRangeFt !== undefined && String(rawRangeFt).trim() !== "";
    const rangeFt = hasRangeValue ? Number(rawRangeFt) : NaN;
    const hasFiniteRange = Number.isFinite(rangeFt);
    const outOfRange = hasFiniteRange ? distFt > rangeFt + 1e-6 : false;
    const directionalHeading = Number(pendingAoePlacement?.headingDeg);
    const facingDeg = isDirectionalSelfRangePlacementActive() && Number.isFinite(directionalHeading)
      ? normalizeFacingDeg(directionalHeading)
      : normalizeFacingDeg((Math.atan2(end.row - start.row, end.col - start.col) * 180) / Math.PI);
    return {
      start,
      end,
      blocked,
      outOfRange,
      invalid: blocked || outOfRange,
      distFt,
      rangeFt: hasFiniteRange ? rangeFt : null,
      facingDeg,
      casterCid: Number(pendingAoePlacement.casterCid),
    };
  }

  function refreshAoePlacementAimGuide(){
    aoeAimGuide = computeAoePlacementAimGuide();
  }

  function setPendingAoePlacementCursorFromPointer(pointer){
    if (!pendingAoePlacement || !pointer) return;
    const gridPos = screenToGridFloat(pointer.x, pointer.y);
    pendingAoePlacement.cursor = {col: Number(gridPos.col), row: Number(gridPos.row)};
    if (isDirectionalSelfRangePlacementActive()){
      applyDirectionalSelfRangePlacement();
    }
    refreshAoePlacementAimGuide();
  }

  function getPendingAoePlacementPreview(){
    if (!pendingAoePlacement) return null;
    if (isDirectionalSelfRangePlacementActive()){
      applyDirectionalSelfRangePlacement();
      return buildPlanningAoe({...pendingAoePlacement.payload});
    }
    const cursor = isAimlessSelfCenteredAoePlacement()
      ? (getPendingAoeCasterPos() || {col: Number(pendingAoePlacement.payload?.cx || 0), row: Number(pendingAoePlacement.payload?.cy || 0)})
      : (pendingAoePlacement.cursor || {col: Number(pendingAoePlacement.payload?.cx || 0), row: Number(pendingAoePlacement.payload?.cy || 0)});
    const previewPayload = {
      ...pendingAoePlacement.payload,
      cx: Number(cursor.col),
      cy: Number(cursor.row),
    };
    return buildPlanningAoe(previewPayload);
  }

  function profileHasFeatureId(profile, featureId){
    const target = normalizeLowerValue(featureId);
    if (!profile || typeof profile !== "object" || !target) return false;
    const features = Array.isArray(profile.features) ? profile.features : [];
    return features.some((feature) => (
      feature
      && typeof feature === "object"
      && normalizeLowerValue(feature.id) === target
    ));
  }

  function getSpellPresetForAoeMessage(msg){
    const slug = normalizeTextValue(msg?.spell_slug || msg?.payload?.spell_slug);
    const spellId = normalizeTextValue(msg?.spell_id || msg?.payload?.spell_id);
    const bySlug = slug ? spellPresetBySlug.get(getSpellKey(slug)) : null;
    if (bySlug) return bySlug;
    if (spellId){
      const byId = cachedSpellPresets.find((preset) => getSpellKey(preset?.id) === getSpellKey(spellId));
      if (byId) return byId;
    }
    if (slug){
      return cachedSpellPresets.find((preset) => getSpellKey(getPresetSlug(preset)) === getSpellKey(slug)) || null;
    }
    return null;
  }

  function maybeRunSculptSelectionForPendingAoe(msg, onContinue){
    if (typeof onContinue !== "function"){
      return;
    }
    if (isPlanning || !pendingAoePlacement){
      onContinue();
      return;
    }
    const profile = getPlayerProfile(getClaimedPlayerName());
    if (!profileHasFeatureId(profile, "sculpt_spells")){
      onContinue();
      return;
    }
    const preset = getSpellPresetForAoeMessage(msg);
    if (normalizeLowerValue(preset?.school) !== "evocation"){
      onContinue();
      return;
    }
    const casterCid = Number(pendingAoePlacement?.casterCid);
    const casterUnit = Number.isFinite(casterCid) ? getUnitByCid(casterCid) : null;
    const casterCell = casterUnit?.pos ? toGridPoint(casterUnit.pos) : getPendingAoeCasterPos();
    const preview = getPendingAoePlacementPreview();
    if (!casterCell || !preview || !Array.isArray(state?.units)){
      onContinue();
      return;
    }
    const casterIsAlly = isAoeAllyUnit(casterUnit);
    const eligibleAllies = [];
    state.units.forEach((unit) => {
      if (!unit?.pos) return;
      const unitCid = Number(unit.cid);
      if (!Number.isFinite(unitCid) || unitCid === casterCid) return;
      if (isAoeAllyUnit(unit) !== casterIsAlly) return;
      const unitCell = toGridPoint(unit.pos);
      if (!aoeContainsGridPoint(preview, unitCell)) return;
      if (isLineOfSightBlocked(casterCell, unitCell)) return;
      eligibleAllies.push({
        cid: Number(unitCid),
        name: String(unit.name || `#${unitCid}`),
      });
    });
    if (!eligibleAllies.length){
      onContinue();
      return;
    }
    eligibleAllies.sort((a, b) => String(a.name).localeCompare(String(b.name)));
    const spellLevelRaw = Number(preset?.level);
    const spellLevel = Number.isFinite(spellLevelRaw) ? Math.max(0, Math.floor(spellLevelRaw)) : 0;
    const maxSelections = Math.max(1, 1 + spellLevel);
    openSculptSelectModal(eligibleAllies, maxSelections, (selectedCids) => {
      msg.payload = msg.payload && typeof msg.payload === "object" ? msg.payload : {};
      msg.payload.sculpted_cids = Array.isArray(selectedCids) ? selectedCids : [];
      onContinue();
    });
  }

  function updateSummonPlacementBanner(){
    if (!summonPlacementBanner) return;
    if (!pendingSummonPlacement){
      summonPlacementBanner.classList.add("hidden");
      summonPlacementBanner.textContent = "";
      return;
    }
    const total = Math.max(1, Number(pendingSummonPlacement.summonQuantity || 1));
    const placed = pendingSummonPlacement.positions.length;
    const remaining = Math.max(0, total - placed);
    const hasRange = Number.isFinite(Number(pendingSummonPlacement.maxRangeFt));
    const rangeLabel = hasRange ? `${Math.round(Number(pendingSummonPlacement.maxRangeFt))} ft` : "any range";
    const placementLabel = pendingSummonPlacement.mode === "echo_summon" ? "Johns Echo" : "a summon";
    summonPlacementBanner.textContent = `You're placing ${placementLabel}. Hold Shift and click up to ${remaining} square(s) within ${rangeLabel} of your caster to choose spawn locations.`;
    summonPlacementBanner.classList.remove("hidden");
  }

  function rebuildSummonValidCells(){
    summonValidCells = new Set();
    if (!pendingSummonPlacement || !gridReady()) return;
    const cols = Number(state?.grid?.cols || 0);
    const rows = Number(state?.grid?.rows || 0);
    const blocked = new Set((state?.obstacles || []).map((o) => summonCellKey(o.col, o.row)));
    const maxRangeFt = Number(pendingSummonPlacement.maxRangeFt);
    for (let col = 0; col < cols; col += 1){
      for (let row = 0; row < rows; row += 1){
        const key = summonCellKey(col, row);
        if (blocked.has(key)) continue;
        if (Number.isFinite(maxRangeFt)){
          const distFt = distanceFeetBetweenCells(pendingSummonPlacement.casterPos, {col, row});
          if (distFt > maxRangeFt + 1e-6) continue;
        }
        summonValidCells.add(key);
      }
    }
  }

  function updateMeasurementControls(){
    if (measureToggle){
      measureToggle.textContent = measurementMode ? "Measuring" : "Measure";
      measureToggle.classList.toggle("accent", measurementMode);
      measureToggle.setAttribute("aria-pressed", measurementMode ? "true" : "false");
    }
    if (measureClear){
      measureClear.disabled = !(measurement.start || measurement.end);
    }
  }

  function updateAoeLockButton(){
    if (!lockAoeBtn) return;
    lockAoeBtn.classList.toggle("accent", !lockMyAoes);
    lockAoeBtn.setAttribute("aria-pressed", lockMyAoes ? "true" : "false");
    lockAoeBtn.textContent = "Unlock my AOEs";
    lockAoeBtn.setAttribute(
      "title",
      lockMyAoes ? "AOEs locked (click to unlock)." : "AOEs unlocked (click to lock)."
    );
  }

  function areAurasEnabled(){
    return state?.auras_enabled !== false;
  }

  function isAuraAoe(aoe){
    return !!(aoe?.is_aura);
  }

  function shouldRenderAoe(aoe){
    if (!aoe) return false;
    if (!areAurasEnabled() && isAuraAoe(aoe)) return false;
    return true;
  }

  function updateAurasButton(){
    if (!auraToggleBtn) return;
    const enabled = areAurasEnabled();
    auraToggleBtn.textContent = enabled ? "Auras: On" : "Auras: Off";
    auraToggleBtn.setAttribute("aria-pressed", enabled ? "true" : "false");
    auraToggleBtn.classList.toggle("accent", enabled);
    auraToggleBtn.setAttribute("title", enabled ? "Click to disable always-on auras." : "Click to enable always-on auras.");
  }

  function renderEffectsOverlay(){
    if (!effectsOverlay || !effectsList) return;
    const claimed = getClaimedUnit();
    const effects = Array.isArray(claimed?.effects) ? claimed.effects : [];
    if (!claimed || !effects.length){
      effectsOverlay.classList.add("hidden");
      effectsList.innerHTML = "";
      return;
    }
    effectsList.innerHTML = "";
    effects.forEach((effect) => {
      const icon = document.createElement("div");
      icon.className = "effect-icon";
      icon.textContent = String(effect?.icon || "");
      const name = String(effect?.name || "Effect").trim() || "Effect";
      const desc = String(effect?.description || "").trim();
      icon.title = desc ? `${name}: ${desc}` : name;
      icon.setAttribute("aria-label", icon.title);
      effectsList.appendChild(icon);
    });
    effectsOverlay.classList.remove("hidden");
  }

  function isAdminClient(){
    return false;
  }

  function canInteractWithAoe(aoe){
    if (!aoe) return false;
    if (isPlanning) return true;
    if (isMapView) return isAdminClient();
    if (isAdminClient()) return true;
    if (!claimedCid) return false;
    if (!cidMatches(aoe.owner_cid, claimedCid, "aoe.ownerCid")) return false;
    if (lockMyAoes) return false;
    return true;
  }

  function getClaimedUnit(){
    if (!state || !state.units || claimedCid === null) return null;
    return state.units.find(u => cidMatches(u.cid, claimedCid, "claimedUnit")) || null;
  }

  function getUnitByCid(cid){
    if (!state || !state.units) return null;
    const cidValue = normalizeCid(cid, "getUnitByCid.cid");
    if (cidValue === null) return null;
    return state.units.find(u => cidMatches(u.cid, cidValue, "getUnitByCid.unitCid")) || null;
  }

  function canControlSummonUnit(unit){
    if (!unit || claimedCid === null || claimedCid === undefined) return false;
    return cidMatches(unit.summoned_by_cid, claimedCid, "summonControl.owner");
  }

  function canSelectControlledUnitCid(cid){
    const cidValue = normalizeCid(cid, "controlledSelect.cid");
    if (cidValue === null || claimedCid === null || claimedCid === undefined) return false;
    if (cidMatches(cidValue, claimedCid, "controlledSelect.claimedMatch")) return true;
    return canControlSummonUnit(getUnitByCid(cidValue));
  }

  function unitControllableThisTurn(cid){
    const cidValue = normalizeCid(cid, "controlledTurn.cid");
    const activeCid = normalizeCid(state?.active_cid, "controlledTurn.activeCid");
    if (cidValue === null || activeCid === null || claimedCid === null || claimedCid === undefined){
      return false;
    }
    if (cidMatches(activeCid, claimedCid, "controlledTurn.claimedActive")){
      if (cidMatches(cidValue, claimedCid, "controlledTurn.claimedSelection")){
        return true;
      }
      return canControlSummonUnit(getUnitByCid(cidValue));
    }
    return cidMatches(activeCid, cidValue, "controlledTurn.activeSelection");
  }

  function getMountMovementCid(){
    const rider = getClaimedUnit();
    if (!rider) return null;
    const mountCid = normalizeCid(rider.rider_cid, "mountMove.riderCid");
    if (mountCid === null) return null;
    const mount = getUnitByCid(mountCid);
    if (!mount) return null;
    if (!cidMatches(mount.mounted_by_cid, rider.cid, "mountMove.mountOwner")) return null;
    const mode = normalizeTextValue(mount.mount_controller_mode);
    if (mode !== "rider") return null;
    return mountCid;
  }

  function activeControlledUnitCid(){
    if (claimedCid === null || claimedCid === undefined){
      return null;
    }
    const selectedCid = normalizeCid(selectedTurnCid, "activeControlled.selectedCid");
    if (selectedCid !== null && canSelectControlledUnitCid(selectedCid) && unitControllableThisTurn(selectedCid)){
      return selectedCid;
    }
    if (unitControllableThisTurn(claimedCid)){
      return claimedCid;
    }
    const activeCid = normalizeCid(state?.active_cid, "activeControlled.activeCid");
    if (activeCid !== null && canControlSummonUnit(getUnitByCid(activeCid))){
      return activeCid;
    }
    return null;
  }

  function reactionControlledUnitCid(){
    if (claimedCid === null || claimedCid === undefined){
      return null;
    }
    const selectedCid = normalizeCid(selectedTurnCid, "reactionControlled.selectedCid");
    if (selectedCid !== null && canSelectControlledUnitCid(selectedCid)){
      return selectedCid;
    }
    return normalizeCid(claimedCid, "reactionControlled.claimedCid");
  }

  function isUnitConcentrationLinked(unit){
    if (!unit) return false;
    if (unit.concentrating === true) return true;
    const ownerCid = normalizeCid(unit.summoned_by_cid, "concentration.ownerCid");
    if (ownerCid === null) return false;
    const owner = getUnitByCid(ownerCid);
    if (!owner || owner.concentrating !== true) return false;
    const ownerSpell = normalizeTextValue(owner.concentration_spell);
    const sourceSpell = normalizeTextValue(unit.summon_source_spell);
    return !!ownerSpell && !!sourceSpell && ownerSpell === sourceSpell;
  }

  function isUnitSpellcaster(unit){
    if (!unit) return false;
    if (unit.is_spellcaster !== undefined && unit.is_spellcaster !== null){
      return !!unit.is_spellcaster;
    }
    if (unit.spellcaster !== undefined && unit.spellcaster !== null){
      return !!unit.spellcaster;
    }
    return true;
  }

  function updateSpellPanelVisibility(){
    if (!castPanel) return;
    const claimedUnit = getClaimedUnit();
    const hideForNonCaster = hideSpellMenu && claimedUnit && !isUnitSpellcaster(claimedUnit);
    const wildShaped = !!claimedUnit?.is_wild_shaped;
    castPanel.classList.toggle("hidden", hideForNonCaster);
    if (castMenuTrigger){
      castMenuTrigger.classList.toggle("hidden", hideForNonCaster);
    }
    if (castOverlay){
      castOverlay.classList.toggle("hidden", hideForNonCaster);
    }
    if (hideForNonCaster && castOverlay?.classList.contains("show")){
      setCastOverlayOpen(false);
    }
    if (castOverlayOpenBtn){
      castOverlayOpenBtn.disabled = wildShaped;
      castOverlayOpenBtn.setAttribute("aria-disabled", wildShaped ? "true" : "false");
      castOverlayOpenBtn.title = wildShaped ? "Spellcasting is disabled while Wild Shaped." : "Cast Spell";
    }
    if (castSpellModalOpenBtn){
      castSpellModalOpenBtn.classList.toggle("hidden", hideForNonCaster);
      castSpellModalOpenBtn.disabled = wildShaped;
      castSpellModalOpenBtn.setAttribute("aria-disabled", wildShaped ? "true" : "false");
      castSpellModalOpenBtn.title = wildShaped ? "Spellcasting is disabled while Wild Shaped." : "Cast Spell";
      if (hideForNonCaster && castSpellModal?.classList.contains("show")){
        hideCastSpellModal();
      }
    }
  }

  function setControlDisabledState(control, disabled, reason, fallbackTitle = ""){
    if (!control) return;
    const isDisabled = !!disabled;
    const reasonText = typeof reason === "string" ? reason.trim() : "";
    control.disabled = isDisabled;
    control.setAttribute("aria-disabled", isDisabled ? "true" : "false");
    control.classList.toggle("is-disabled", isDisabled);
    control.toggleAttribute("data-disabled", isDisabled);
    if (isDisabled && reasonText){
      control.setAttribute("data-disabled-reason", reasonText);
      control.title = reasonText;
    } else {
      control.removeAttribute("data-disabled-reason");
      if (fallbackTitle){
        control.title = fallbackTitle;
      } else {
        control.removeAttribute("title");
      }
    }
  }

  function unitHasSpellActionForSpend(unit, spend){
    const spendValue = normalizeLowerValue(spend);
    if (spendValue === "bonus"){
      return normalizeActionList(unit?.bonus_actions, "bonus_action").some((entry) => isSpellActionEntry(entry));
    }
    if (spendValue === "action"){
      return normalizeActionList(unit?.actions, "action").some((entry) => isSpellActionEntry(entry));
    }
    return false;
  }

  function updateResourceGatedControls(){
    if (isPlanning){
      setControlDisabledState(attackOverlayToggleBtn, true, "Planning mode keeps combat actions disabled.", "Attack");
      setControlDisabledState(dashBtn, true, "Planning mode keeps combat actions disabled.", "Dash");
      setControlDisabledState(castOverlayOpenBtn, false, "", "Cast Spell");
      setControlDisabledState(castSpellModalOpenBtn, false, "", "Cast Spell");
      return;
    }
    const unitCid = activeControlledUnitCid();
    const controllableTurn = !isMapView && unitCid !== null;
    const unit = controllableTurn ? getUnitByCid(unitCid) : null;
    const waitReason = isMapView ? "Map view is read-only." : "Wait for your turn, matey.";
    if (!unit){
      const reason = claimedCid == null ? "Claim a character first, matey." : waitReason;
      setControlDisabledState(attackOverlayToggleBtn, true, reason, "Attack");
      setControlDisabledState(dashBtn, true, reason, "Dash");
      setControlDisabledState(castOverlayOpenBtn, true, reason, "Cast Spell");
      setControlDisabledState(castSpellModalOpenBtn, true, reason, "Cast Spell");
      return;
    }

    const actionRemaining = Number(unit.action_remaining || 0);
    const bonusRemaining = Number(unit.bonus_action_remaining || 0);
    const attackRemaining = Number(unit.attack_resource_remaining || 0);
    const spellCastRemaining = Number(unit.spell_cast_remaining || 0);

    const canAttack = actionRemaining > 0 || attackRemaining > 0;
    setControlDisabledState(
      attackOverlayToggleBtn,
      !canAttack,
      "No actions or attacks left, matey.",
      "Attack"
    );

    const actions = normalizeActionList(unit.actions, "action");
    const bonusActions = normalizeActionList(unit.bonus_actions, "bonus_action");
    const hasActionDash = actions.some((entry) => normalizeLowerValue(entry?.name) === "dash");
    const hasBonusDash = bonusActions.some((entry) => normalizeLowerValue(entry?.name) === "dash");
    const canDash = (hasActionDash && actionRemaining > 0) || (hasBonusDash && bonusRemaining > 0);
    const dashReason = (!hasActionDash && !hasBonusDash)
      ? "No Dash option is available for this character."
      : "No action or bonus action left for Dash.";
    setControlDisabledState(dashBtn, !canDash, dashReason, "Dash");

    const wildShaped = !!unit.is_wild_shaped;
    const actionSpellPossible = unitHasSpellActionForSpend(unit, "action") && actionRemaining > 0;
    const bonusSpellPossible = unitHasSpellActionForSpend(unit, "bonus") && bonusRemaining > 0;
    const canCastSpell = !wildShaped && spellCastRemaining > 0 && (actionSpellPossible || bonusSpellPossible);
    let castReason = "No action or bonus action spellcasting option is available.";
    if (wildShaped){
      castReason = "Spellcasting is disabled while Wild Shaped.";
    } else if (spellCastRemaining <= 0){
      castReason = "You already cast a spell this turn.";
    }
    setControlDisabledState(castOverlayOpenBtn, !canCastSpell, castReason, "Cast Spell");
    setControlDisabledState(castSpellModalOpenBtn, !canCastSpell, castReason, "Cast Spell");
  }

  function defaultAoeCenter(){
    const unit = getClaimedUnit();
    if (unit){
      return {cx: Number(unit.pos.col), cy: Number(unit.pos.row)};
    }
    const cols = state?.grid?.cols ?? 0;
    const rows = state?.grid?.rows ?? 0;
    return {cx: Math.max(0, (cols - 1) / 2), cy: Math.max(0, (rows - 1) / 2)};
  }

  function toGridPoint(point){
    if (!point) return {col: 0, row: 0};
    const colValue = point.col ?? point.cx ?? 0;
    const rowValue = point.row ?? point.cy ?? 0;
    return {col: Math.round(Number(colValue)), row: Math.round(Number(rowValue))};
  }

  function isLineOfSightBlocked(startPoint, endPoint){
    if (!state || !state.obstacles || !state.obstacles.length) return false;
    const start = toGridPoint(startPoint);
    const end = toGridPoint(endPoint);
    const obstacles = new Set(state.obstacles.map(o => `${Number(o.col)},${Number(o.row)}`));
    let x0 = start.col;
    let y0 = start.row;
    const x1 = end.col;
    const y1 = end.row;
    const dx = Math.abs(x1 - x0);
    const dy = Math.abs(y1 - y0);
    const sx = x0 < x1 ? 1 : -1;
    const sy = y0 < y1 ? 1 : -1;
    let err = dx - dy;
    let first = true;
    while (true){
      if (!first && obstacles.has(`${x0},${y0}`)){
        return true;
      }
      if (x0 === x1 && y0 === y1){
        break;
      }
      const e2 = 2 * err;
      if (e2 > -dy){
        err -= dy;
        x0 += sx;
      }
      if (e2 < dx){
        err += dx;
        y0 += sy;
      }
      first = false;
    }
    return false;
  }

  function setLosPreview(startPoint, endPoint, blocked){
    losPreview = {
      start: toGridPoint(startPoint),
      end: toGridPoint(endPoint),
      blocked: !!blocked,
      expiresAt: Date.now() + LOS_PREVIEW_MS,
    };
    setTimeout(() => {
      if (losPreview && Date.now() >= losPreview.expiresAt){
        losPreview = null;
        draw();
      }
    }, LOS_PREVIEW_MS + 25);
    draw();
  }

  function clearMeasurement(){
    measurement = {start: null, end: null};
    updateMeasurementControls();
    draw();
  }

  function setMeasurementPoint(p){
    if (!gridReady()) return;
    const g = screenToGrid(p.x, p.y);
    const point = {col: g.col, row: g.row};
    if (!measurement.start || measurement.end){
      measurement = {start: point, end: null};
    } else {
      measurement.end = point;
    }
    updateMeasurementControls();
    draw();
  }

  function cellKey(col, row){
    return `${col},${row}`;
  }

  function buildRoughTerrainMap(list){
    const map = new Map();
    if (Array.isArray(list)){
      list.forEach(cell => {
        map.set(cellKey(Number(cell.col), Number(cell.row)), cell || {});
      });
    }
    return map;
  }

  function buildObstacleSet(list){
    const set = new Set();
    if (Array.isArray(list)){
      list.forEach(cell => {
        set.add(cellKey(Number(cell.col), Number(cell.row)));
      });
    }
    return set;
  }

  function movementCostMap(startCol, startRow, maxFt, unit, roughMap, obstacles, cols, rows, feetPerSquare){
    const step = Number(feetPerSquare) || 5;
    const diag5 = step;
    const diag10 = step * 2;
    const mode = normalizeMovementMode(unit?.movement_mode);
    const landSpeed = Math.max(0, Number(unit?.speed || 0));
    let swimSpeed = Math.max(0, Number(unit?.swim_speed || 0));
    if (swimSpeed <= 0){
      swimSpeed = Math.max(1, Math.floor(landSpeed / 2));
    }
    let waterMultiplier = 1;
    if (mode === "normal" && landSpeed > 0 && swimSpeed > 0){
      waterMultiplier = landSpeed / swimSpeed;
    }

    function inBounds(col, row){
      return col >= 0 && row >= 0 && col < cols && row < rows;
    }

    const best = new Map();
    const bestSq = new Map();
    const heap = [];

    function heapPush(item){
      heap.push(item);
      let i = heap.length - 1;
      while (i > 0){
        const p = Math.floor((i - 1) / 2);
        if (heap[p].cost <= heap[i].cost) break;
        [heap[p], heap[i]] = [heap[i], heap[p]];
        i = p;
      }
    }

    function heapPop(){
      if (!heap.length) return null;
      const top = heap[0];
      const last = heap.pop();
      if (heap.length && last){
        heap[0] = last;
        let i = 0;
        while (true){
          const l = i * 2 + 1;
          const r = i * 2 + 2;
          let smallest = i;
          if (l < heap.length && heap[l].cost < heap[smallest].cost) smallest = l;
          if (r < heap.length && heap[r].cost < heap[smallest].cost) smallest = r;
          if (smallest === i) break;
          [heap[i], heap[smallest]] = [heap[smallest], heap[i]];
          i = smallest;
        }
      }
      return top;
    }

    const startKey = `${startCol},${startRow},0`;
    best.set(startKey, 0);
    heapPush({cost: 0, col: startCol, row: startRow, parity: 0});

    while (heap.length){
      const item = heapPop();
      if (!item) break;
      const {cost, col, row, parity} = item;
      const stateKey = `${col},${row},${parity}`;
      if (cost !== best.get(stateKey)) continue;
      if (cost > maxFt) continue;
      const sqKey = cellKey(col, row);
      const prev = bestSq.get(sqKey);
      if (prev === undefined || cost < prev){
        bestSq.set(sqKey, cost);
      }

      const neighbors = [
        [-1, 0, false], [1, 0, false], [0, -1, false], [0, 1, false],
        [-1, -1, true], [1, -1, true], [-1, 1, true], [1, 1, true],
      ];
      for (const [dc, dr, isDiag] of neighbors){
        const nc = col + dc;
        const nr = row + dr;
        if (!inBounds(nc, nr)) continue;
        if (obstacles.has(cellKey(nc, nr))) continue;
        if (isDiag){
          if (obstacles.has(cellKey(col + dc, row)) || obstacles.has(cellKey(col, row + dr))){
            continue;
          }
        }
        let stepCost;
        let npar;
        if (isDiag){
          stepCost = parity === 0 ? diag5 : diag10;
          npar = 1 - parity;
        } else {
          stepCost = step;
          npar = parity;
        }

        const currentCell = roughMap.get(cellKey(col, row)) || {};
        const targetCell = roughMap.get(cellKey(nc, nr)) || {};
        const currentType = cellMovementType(currentCell);
        const targetType = cellMovementType(targetCell);
        if (mode === "swim" && targetType !== "water") continue;
        if (mode === "burrow" && targetType === "water") continue;
        if (mode !== "fly"){
          if (currentType === "water" || targetType === "water"){
            stepCost = Math.ceil(stepCost * waterMultiplier);
          }
          if (targetCell.is_rough){
            stepCost *= 2;
          }
        }

        const newCost = cost + stepCost;
        if (newCost > maxFt) continue;
        const nextKey = `${nc},${nr},${npar}`;
        if (newCost < (best.get(nextKey) ?? 1e9)){
          best.set(nextKey, newCost);
          heapPush({cost: newCost, col: nc, row: nr, parity: npar});
        }
      }
    }

    return bestSq;
  }

  
  function saveDmUiPrefs(){ try { localStorage.setItem(dmUiPrefsKey, JSON.stringify(dmUiPrefs)); } catch(_) {} }
  function classifyLogLine(text){ const t=(text||"").toLowerCase(); if (t.includes("heal")) return "heal"; if (t.includes("save")||t.includes("concentration")) return "save"; if (t.includes("hits")||t.includes("miss")) return "attack"; if (t.includes("damage")||t.includes("takes")) return "damage"; if (t.includes("spell")||t.includes("")) return "spell"; return "spell"; }
  function parseBattleLine(line){ const m=String(line||"").match(/^\[([^\]]+)\]\s*	?\s*(.*)$/); return {time:m?m[1]:"", msg:m?m[2]:String(line||"")}; }
  function escapeHtml(text){
    return String(text ?? "").replace(/[&<>"']/g, (ch) => {
      if (ch === "&") return "&amp;";
      if (ch === "<") return "&lt;";
      if (ch === ">") return "&gt;";
      if (ch === "\"") return "&quot;";
      if (ch === "'") return "&#39;";
      return ch;
    });
  }
  function isCriticalLine(text){
    const msg = String(text || "").toLowerCase();
    return /\b(crit|critical|nat\s*20|natural\s*20)\b/.test(msg);
  }
  const damageTypeColorByName = {
    acid: "#7CAC00",
    cold: "#348CC4",
    fire: "#EC5400",
    force: "#C83434",
    healing: "#30B8B8",
    lightning: "#3058C0",
    necrotic: "#40AC50",
    poison: "#44B800",
    radiant: "#C8A800",
    thunder: "#8444B8",
    psychic: "#AC7094",
    physical: "#888888",
    piercing: "#888888",
    bludgeoning: "#888888",
    slashing: "#888888",
    hellfire: "#A00000",
  };
  function decorateDamageTypes(message){
    const html = escapeHtml(String(message || ""));
    const typeKeys = Object.keys(damageTypeColorByName).sort((a, b) => b.length - a.length);
    const typePattern = typeKeys.join("|");
    const rx = new RegExp(`\\b(\\d+(?:\\.\\d+)?)\\s+(${typePattern})(\\s+damage\\b)?|\\b(\\d+(?:\\.\\d+)?)\\s+(damage\\b)`, "gi");
    return html.replace(rx, (match, typedAmount, type, typedDamageWord, plainAmount, plainDamageWord) => {
      const amount = String(typedAmount || plainAmount || "").trim();
      const typeText = String(type || "").trim();
      const damageWord = String(typedDamageWord || plainDamageWord || "").trim();
      const key = String(typeText || "physical").toLowerCase();
      const color = damageTypeColorByName[key] || damageTypeColorByName.physical;
      if (typeText){
        return `<span class="damage-type" style="color:${color}"><strong>${amount}</strong> ${typeText}${damageWord ? ` ${damageWord}` : ""}</span>`;
      }
      return `<span class="damage-type" style="color:${color}"><strong>${amount}</strong> ${damageWord || "damage"}</span>`;
    });
  }
  function renderMapViewLogPanel(){
    if (!mapViewLogPanel || !mapViewLogList) return;
    if (!isMapView){
      mapViewLogPanel.style.display = "none";
      return;
    }
    mapViewLogPanel.style.display = "flex";
    const atBottom = mapViewLogList.scrollTop + mapViewLogList.clientHeight >= mapViewLogList.scrollHeight - 20;
    mapViewLogList.textContent = "";
    const visibleLines = dmLogLines.slice(-18);
    visibleLines.forEach((line)=>{
      const parsed = parseBattleLine(line);
      const row = document.createElement('div');
      row.className = "map-view-log-entry";
      const msgClass = isCriticalLine(parsed.msg) ? "map-view-log-msg is-crit" : "map-view-log-msg";
      row.innerHTML = `<div class="map-view-log-time">${parsed.time ? parsed.time.slice(11,19) : ''}</div><div class="${msgClass}">${decorateDamageTypes(parsed.msg)}</div>`;
      mapViewLogList.appendChild(row);
    });
    if (atBottom) mapViewLogList.scrollTop = mapViewLogList.scrollHeight;
  }
  function refreshMapViewLogPolling(){
    const shouldSubscribe = isMapView || battleLogViewPrefs?.visible === true;
    const canSend = ws && ws.readyState === WebSocket.OPEN;
    if (!canSend){
      battleLogSubscribed = false;
      return;
    }
    if (shouldSubscribe && !battleLogSubscribed){
      battleLogSubscribed = true;
      send({type:"log_subscribe", limit: 200});
    } else if (!shouldSubscribe && battleLogSubscribed){
      battleLogSubscribed = false;
      send({type:"log_unsubscribe"});
    }
  }
  function renderDmLogPanel(){
    const isAdmin = isAdminClient();
    if (!dmLogPanel || !dmLogList){
      renderMapViewLogPanel();
      return;
    }
    dmLogPanel.classList.toggle('show', !!(isAdmin && dmUiPrefs.showLogPanel));
    dmMapPreview?.classList.toggle('show', !!(isAdmin && dmUiPrefs.showMapPreview));
    if (!isAdmin){ renderMapViewLogPanel(); return; }
    dmLogList.textContent = "";
    const atBottom = dmLogList.scrollTop + dmLogList.clientHeight >= dmLogList.scrollHeight - 12;
    dmLogLines.forEach((line)=>{
      const parsed = parseBattleLine(line);
      const kind = classifyLogLine(parsed.msg);
      if (dmUiPrefs.filters && dmUiPrefs.filters[kind] === false) return;
      const row = document.createElement('div');
      row.className = `dm-log-entry ${kind}`;
      row.innerHTML = `<div class="dm-log-time">${parsed.time ? parsed.time.slice(11,19) : ''}</div><div class="dm-log-msg">${parsed.msg}</div>`;
      row.addEventListener('click', ()=>{
        const unit=(state?.units||[]).find(u => parsed.msg.includes(u.name));
        if (unit){ centerOn(unit.cid); dmHighlightUntil.set(String(unit.cid), Date.now()+2200); }
      });
      dmLogList.appendChild(row);
    });
    if (dmUiPrefs.autoScroll && (atBottom || dmLogAutoScrollInput?.checked)) dmLogList.scrollTop = dmLogList.scrollHeight;
    renderMapViewLogPanel();
  }
  function renderDmPreview(){
    if (!dmPreviewCanvas || !state?.grid || !dmUiPrefs.showMapPreview || !isAdminClient()) return;
    const pctx = dmPreviewCanvas.getContext('2d');
    const w = dmPreviewCanvas.width, h = dmPreviewCanvas.height;
    pctx.clearRect(0,0,w,h); pctx.fillStyle='#0a0c12'; pctx.fillRect(0,0,w,h);
    const cols=Number(state.grid.cols||1), rows=Number(state.grid.rows||1);
    const cell=Math.max(2, Math.min((w-8)/cols,(h-8)/rows));
    const ox=(w-cols*cell)/2, oy=(h-rows*cell)/2;
    pctx.strokeStyle='rgba(255,255,255,0.08)'; pctx.lineWidth=1;
    for(let c=0;c<=cols;c++){const x=ox+c*cell; pctx.beginPath(); pctx.moveTo(x,oy); pctx.lineTo(x,oy+rows*cell); pctx.stroke();}
    for(let r=0;r<=rows;r++){const y=oy+r*cell; pctx.beginPath(); pctx.moveTo(ox,y); pctx.lineTo(ox+cols*cell,y); pctx.stroke();}
    (state.aoes||[]).forEach(a=>{ if (!shouldRenderAoe(a)) return; pctx.fillStyle='rgba(120,160,255,0.18)'; const cx=ox+(Number(a.cx||0)+0.5)*cell; const cy=oy+(Number(a.cy||0)+0.5)*cell; const rr=Math.max(2, Number(a.radius_sq||1)*cell); pctx.beginPath(); pctx.arc(cx,cy,rr,0,Math.PI*2); pctx.fill(); });
    (state.units||[]).forEach(u=>{ const x=ox+(Number(u.pos.col)+0.5)*cell; const y=oy+(Number(u.pos.row)+0.5)*cell; pctx.fillStyle=(u.role==='enemy')?'rgba(255,91,91,0.9)':'rgba(106,255,176,0.9)'; pctx.beginPath(); pctx.arc(x,y,Math.max(2,cell*0.25),0,Math.PI*2); pctx.fill(); });
  }

  function draw(){
    if (!state) return;
    if (!gridReady()){
      invalidateMovementRangeCache();
      updateWaitingOverlay();
      return;
    }
    updateWaitingOverlay();
    renderDmPreview();
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;

    ctx.clearRect(0,0,w,h);

    // background
    ctx.fillStyle = "#0a0c12";
    ctx.fillRect(0,0,w,h);

    const cols = state.grid.cols, rows = state.grid.rows;
    if (cols !== lastGrid.cols || rows !== lastGrid.rows){
      fittedToGrid = false;
      lastGrid = {cols, rows};
    }

    // auto-fit on first draw
    if (!fittedToGrid){
      const pad = 24;
      const sx = (w - pad*2) / (cols*zoom);
      const sy = (h - pad*2) / (rows*zoom);
      const s = Math.min(1.0, Math.max(0.35, Math.min(sx, sy)));
      zoom = Math.floor(zoom * s);
      panX = Math.floor((w - cols*zoom)/2);
      panY = Math.floor((h - rows*zoom)/2);
      fittedToGrid = true;
    }

    // grid
    ctx.strokeStyle = "rgba(255,255,255,0.07)";
    ctx.lineWidth = 1;
    for(let c=0;c<=cols;c++){
      const x = panX + c*zoom;
      ctx.beginPath(); ctx.moveTo(x, panY); ctx.lineTo(x, panY + rows*zoom); ctx.stroke();
    }
    for(let r=0;r<=rows;r++){
      const y = panY + r*zoom;
      ctx.beginPath(); ctx.moveTo(panX, y); ctx.lineTo(panX + cols*zoom, y); ctx.stroke();
    }

    // rough terrain
    if (state.rough_terrain && state.rough_terrain.length){
      state.rough_terrain.forEach(cell => {
        const x = panX + cell.col*zoom;
        const y = panY + cell.row*zoom;
        const colorHex = normalizeHexColor(cell.color || "");
        const movementType = cellMovementType(cell);
        const isSwim = movementType === "water";
        const isRough = !!cell.is_rough;
        let alpha = isSwim ? 0.35 : 0.25;
        if (isRough && !isSwim){
          alpha = 0.3;
        }
        const fallback = isSwim ? "rgba(74,163,223,0.32)" : "rgba(141,110,99,0.25)";
        ctx.fillStyle = colorHex ? rgbaFromHex(colorHex, alpha) : fallback;
        ctx.fillRect(x+1,y+1,zoom-2,zoom-2);
      });
    }

    // movement range (claimed token or controlled summon)
    const movableCid = activeControlledUnitCid();
    if (movableCid !== null && state.units){
      const me = state.units.find(u => cidMatches(u.cid, movableCid, "movementRange.unitCid"));
      if (me){
        const move = Math.max(0, Number(me.move_remaining || 0));
        const feet = Math.max(1, Number(state.grid.feet_per_square || 5));
        if (move > 0){
          const costMap = getMovementRangeCostMap(me, cols, rows, feet);
          if (costMap){
            costMap.forEach((cost, key) => {
              if (!cost) return;
              const [col, row] = key.split(",").map(Number);
              const x = panX + col * zoom;
              const y = panY + row * zoom;
              ctx.fillStyle = "rgba(106,169,255,0.18)";
              ctx.fillRect(x + 1, y + 1, zoom - 2, zoom - 2);
            });
          }
        }
      }
    }

    if (attackOverlayMode){
      const claimed = getClaimedUnit();
      const controlled = getUnitByCid(activeControlledUnitCid());
      const attackOrigin = pendingUnleashIncarnation ? getUnitByCid(pendingUnleashIncarnation.echoCid) : (controlled || claimed);
      const weapon = (pendingSpellTargeting || pendingBeguilingMagic) ? null : (pendingActionAttackWeapon || getSelectedAttackWeapon());
      const spellRangeFt = Number(pendingSpellTargeting?.rangeFt);
      const layOnHandsRangeFt = Number(pendingLayOnHandsTargeting?.rangeFt);
      const bardicInspirationRangeFt = Number(pendingBardicInspirationTargeting?.rangeFt);
      const beguilingRangeFt = pendingBeguilingMagic ? 60 : NaN;
      const mantleRangeFt = Number(pendingMantleOfInspiration?.rangeFt);
      if (attackOrigin && attackOrigin.pos && (weapon || Number.isFinite(spellRangeFt) || Number.isFinite(layOnHandsRangeFt) || Number.isFinite(bardicInspirationRangeFt) || Number.isFinite(beguilingRangeFt) || Number.isFinite(mantleRangeFt))){
        const rangeFt = Number.isFinite(layOnHandsRangeFt)
          ? layOnHandsRangeFt
          : (Number.isFinite(bardicInspirationRangeFt)
            ? bardicInspirationRangeFt
            : (Number.isFinite(spellRangeFt)
              ? spellRangeFt
              : (Number.isFinite(beguilingRangeFt)
                ? beguilingRangeFt
                : (Number.isFinite(mantleRangeFt)
                  ? mantleRangeFt
                  : effectiveAttackRangeFeetForWeapon(weapon, attackOrigin || claimed)))));
        const feetPerSquare = Math.max(1, Number(state.grid.feet_per_square || 5));
        const radiusCells = Math.max(0, Number(rangeFt) / feetPerSquare);
        const center = gridToScreen(attackOrigin.pos.col, attackOrigin.pos.row);
        const overlayColor = normalizeHexColor(pendingLayOnHandsTargeting ? "#4caf50"
          : ((pendingBardicInspirationTargeting || pendingMantleOfInspiration) ? "#4caf50" : (pendingBeguilingMagic ? "#b388ff" : (pendingSpellTargeting?.overlayColor || "")))
        );
        ctx.save();
        ctx.fillStyle = overlayColor ? rgbaFromHex(overlayColor, 0.15) : "rgba(255,78,78,0.15)";
        ctx.strokeStyle = overlayColor ? rgbaFromHex(overlayColor, 0.72) : "rgba(255,78,78,0.72)";
        ctx.lineWidth = 2;
        ctx.setLineDash([6, 4]);
        ctx.beginPath();
        ctx.arc(center.x, center.y, Math.max(6, radiusCells * zoom), 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();
      }
    }

    if (pendingSummonPlacement){
      rebuildSummonValidCells();
      updateSummonPlacementBanner();
      summonValidCells.forEach((key) => {
        const [col, row] = key.split(",").map(Number);
        const x = panX + col * zoom;
        const y = panY + row * zoom;
        ctx.fillStyle = "rgba(106,169,255,0.22)";
        ctx.fillRect(x + 1, y + 1, zoom - 2, zoom - 2);
      });
      if (pendingSummonPlacement.casterPos && Number.isFinite(Number(pendingSummonPlacement.maxRangeFt))){
        const feetPerSquare = Math.max(1, Number(state.grid.feet_per_square || 5));
        const radiusCells = Number(pendingSummonPlacement.maxRangeFt) / feetPerSquare;
        const caster = gridToScreen(pendingSummonPlacement.casterPos.col, pendingSummonPlacement.casterPos.row);
        ctx.save();
        ctx.strokeStyle = "rgba(106,169,255,0.65)";
        ctx.setLineDash([6, 4]);
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(caster.x, caster.y, Math.max(6, radiusCells * zoom), 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }
    } else {
      updateSummonPlacementBanner();
    }

    // obstacles
    if (state.obstacles && state.obstacles.length){
      ctx.fillStyle = "rgba(255,255,255,0.10)";
      state.obstacles.forEach(o => {
        const x = panX + o.col*zoom;
        const y = panY + o.row*zoom;
        ctx.fillRect(x+1,y+1,zoom-2,zoom-2);
      });
    }

    // AoE overlays
    if (state.aoes && state.aoes.length){
      state.aoes.forEach(a => {
        if (!shouldRenderAoe(a)) return;
        renderAoeOverlay(a);
      });
    }
    if (aoeDragPreview){
      const aoeSource = state?.aoes?.find(a => Number(a.aid) === Number(aoeDragPreview.aid));
      if (aoeSource){
        const override = {};
        if (Number.isFinite(Number(aoeDragPreview.angle_deg))){
          override.angle_deg = Number(aoeDragPreview.angle_deg);
        }
        if (Number.isFinite(Number(aoeDragPreview.spread_deg))){
          override.spread_deg = Number(aoeDragPreview.spread_deg);
        }
        if (Number.isFinite(Number(aoeDragPreview.ax))){
          override.ax = Number(aoeDragPreview.ax);
        }
        if (Number.isFinite(Number(aoeDragPreview.ay))){
          override.ay = Number(aoeDragPreview.ay);
        }
        renderAoeOverlay(aoeSource, {
          cx: aoeDragPreview.cx,
          cy: aoeDragPreview.cy,
          preview: true,
          override: Object.keys(override).length ? override : null,
        });
      }
    }
    if (pendingAoePlacement){
      const previewAoe = getPendingAoePlacementPreview();
      if (previewAoe){
        renderAoeOverlay(previewAoe, {preview: true});
      }
      updateAoeTargetPreviewPanel(previewAoe);
    } else {
      hideAoeTargetPreviewPanel();
    }
    renderAimlessAoeConfirm();

    if (aoeAimGuide){
      const start = gridToScreen(aoeAimGuide.start.col, aoeAimGuide.start.row);
      const end = gridToScreen(aoeAimGuide.end.col, aoeAimGuide.end.row);
      const invalid = !!aoeAimGuide.invalid;
      ctx.save();
      ctx.lineWidth = 3;
      ctx.setLineDash([7, 5]);
      ctx.strokeStyle = invalid ? "rgba(255,91,91,0.98)" : "rgba(123,233,173,0.96)";
      ctx.beginPath();
      ctx.moveTo(start.x, start.y);
      ctx.lineTo(end.x, end.y);
      ctx.stroke();
      if (invalid){
        const xSize = Math.max(12, zoom * 0.22);
        ctx.setLineDash([]);
        ctx.lineWidth = 4;
        ctx.strokeStyle = "rgba(255,64,64,0.98)";
        ctx.beginPath();
        ctx.moveTo(end.x - xSize, end.y - xSize);
        ctx.lineTo(end.x + xSize, end.y + xSize);
        ctx.moveTo(end.x + xSize, end.y - xSize);
        ctx.lineTo(end.x - xSize, end.y + xSize);
        ctx.stroke();
      }
      ctx.restore();
    }

    // measurement line
    if (measurement.start){
      const start = gridToScreen(measurement.start.col, measurement.start.row);
      ctx.save();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(255,233,106,0.9)";
      ctx.fillStyle = "rgba(255,233,106,0.9)";
      ctx.beginPath();
      ctx.arc(start.x, start.y, Math.max(6, zoom * 0.12), 0, Math.PI * 2);
      ctx.fill();
      if (measurement.end){
        const end = gridToScreen(measurement.end.col, measurement.end.row);
        ctx.beginPath();
        ctx.moveTo(start.x, start.y);
        ctx.lineTo(end.x, end.y);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(end.x, end.y, Math.max(6, zoom * 0.12), 0, Math.PI * 2);
        ctx.fill();
        const feetPerSquare = Math.max(1, Number(state.grid.feet_per_square || 5));
        const dx = measurement.end.col - measurement.start.col;
        const dy = measurement.end.row - measurement.start.row;
        const feet = Math.hypot(dx, dy) * feetPerSquare;
        const label = formatFeet(feet);
        const midX = (start.x + end.x) / 2;
        const midY = (start.y + end.y) / 2;
        ctx.font = `700 ${Math.max(11, Math.floor(zoom * 0.32))}px system-ui`;
        ctx.textAlign = "center";
        ctx.textBaseline = "bottom";
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillText(label, midX + 1, midY - 7 + 1);
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.fillText(label, midX, midY - 7);
      }
      ctx.restore();
    }

    if (losPreview && Date.now() <= losPreview.expiresAt){
      const start = gridToScreen(losPreview.start.col, losPreview.start.row);
      const end = gridToScreen(losPreview.end.col, losPreview.end.row);
      ctx.save();
      ctx.lineWidth = 3;
      ctx.setLineDash([8, 6]);
      ctx.strokeStyle = losPreview.blocked ? "rgba(255,120,120,0.95)" : "rgba(123,233,173,0.95)";
      ctx.beginPath();
      ctx.moveTo(start.x, start.y);
      ctx.lineTo(end.x, end.y);
      ctx.stroke();
      ctx.restore();
    }

    // tokens
    const tokens = sortedTokensForRender((state.units || []).filter((unit) => !isUnitHiddenFromClient(unit)));
    // group labels by cell
    const cellMap = new Map();
    tokens.forEach(u => {
      const key = `${u.pos.col},${u.pos.row}`;
      if (!cellMap.has(key)) cellMap.set(key, []);
      cellMap.get(key).push(u);
    });

    // draw token circles first
    tokens.forEach(u => {
      const {x,y} = gridToScreen(u.pos.col,u.pos.row);
      const r = Math.max(10, zoom*0.35);
      const facingRad = (tokenFacingDeg(u) * Math.PI) / 180;
      const active = (state.active_cid !== null && cidMatches(state.active_cid, u.cid, "token.activeCid"));
      const mine = (claimedCid != null && cidMatches(claimedCid, u.cid, "token.claimedCid"));
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);

      // color
      const customFill = u.token_color ? rgbaFromHex(u.token_color, 0.28) : null;
      if (customFill){
        ctx.fillStyle = customFill;
      } else if (u.role === "enemy") {
        ctx.fillStyle = "rgba(255,91,91,0.28)";
      } else {
        ctx.fillStyle = "rgba(106,255,176,0.18)";
      }
      ctx.fill();

      const dmHl = (dmHighlightUntil.get(String(u.cid)) || 0) > Date.now();
      ctx.lineWidth = (active || dmHl) ? 3 : 2;
      const mountStroke = u.is_mount ? "rgba(106,169,255,0.98)" : null;
      const customBorderStroke = u.token_border_color ? rgbaFromHex(u.token_border_color, 0.95) : null;
      ctx.strokeStyle = dmHl ? "rgba(255,218,120,0.98)" : (mountStroke || customBorderStroke || (mine ? "rgba(106,169,255,0.95)" : (active ? "rgba(255,255,255,0.85)" : "rgba(255,255,255,0.25)")));
      ctx.stroke();
      if (u.is_mount){
        ctx.save();
        ctx.font = `${Math.max(10, Math.floor(zoom*0.28))}px system-ui`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(106,169,255,0.95)";
        ctx.fillText("", x, y - (r * 0.55));
        ctx.restore();
      }
      if (isUnitConcentrationLinked(u)){
        ctx.save();
        ctx.font = `${Math.max(10, Math.floor(zoom*0.3))}px system-ui`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(241,201,95,0.98)";
        ctx.fillText("", x + (r * 0.58), y - (r * 0.58));
        ctx.restore();
      }

      // condition markers inside
      const marks = (u.marks || "").trim();
      if (marks){
        ctx.font = `${Math.max(10, Math.floor(zoom*0.33))}px system-ui`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.fillText(marks, x, y);
      }
      const facingDotDistance = Math.max(2, r - Math.max(2, zoom * 0.13));
      const facingDotRadius = Math.max(1.6, zoom * 0.06);
      ctx.beginPath();
      ctx.arc(
        x + Math.cos(facingRad) * facingDotDistance,
        y + Math.sin(facingRad) * facingDotDistance,
        facingDotRadius,
        0,
        Math.PI * 2
      );
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.fill();

      const handle = tokenRotateHandle(u);
      if (handle){
        ctx.save();
        ctx.beginPath();
        ctx.arc(x, y, Math.max(12, handle.orbitR), 0, Math.PI * 2);
        ctx.lineWidth = 1;
        ctx.strokeStyle = "rgba(255,255,255,0.28)";
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(handle.x, handle.y, handle.hitR, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(0,0,0,0.88)";
        ctx.fill();
        ctx.font = `${Math.max(8, Math.floor((zoom * 0.22) * mapRotateHandleScale()))}px system-ui`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.fillText("", handle.x, handle.y);
        ctx.restore();
      }
    });

    // labels above: name or group name
    const labelBoxes = [];
    const labelFontSize = Math.max(11, Math.floor(zoom*0.32));
    const labelOffset = zoom*0.40;
    const labelPad = 2;
    const labelStep = Math.max(6, Math.floor(labelFontSize * 0.7));
    const labelOffsets = [0, -labelStep, labelStep, -2*labelStep, 2*labelStep];
    const labelEntries = [];
    cellMap.forEach((arr, key) => {
      const [col,row] = key.split(",").map(Number);
      const {x,y} = gridToScreen(col,row);
      let label = "";
      if (arr.length >= 2){
        const names = arr.map(a => a.name).join(", ");
        label = `Group (${arr.length}): ${names}`;
      } else {
        label = arr[0].name;
      }
      const isActive = arr.some(a => state.active_cid !== null && cidMatches(state.active_cid, a.cid, "label.activeCid"));
      labelEntries.push({label, x, y: y - labelOffset, isActive});
    });
    labelEntries.sort((a, b) => Number(a.isActive) - Number(b.isActive));
    ctx.textAlign = "center";
    ctx.textBaseline = "bottom";
    ctx.font = `600 ${labelFontSize}px system-ui`;
    const overlaps = (a, b) => !(a.x2 < b.x1 || a.x1 > b.x2 || a.y2 < b.y1 || a.y1 > b.y2);
    labelEntries.forEach(entry => {
      const width = ctx.measureText(entry.label).width;
      let placed = false;
      for (const offset of labelOffsets){
        const y = entry.y + offset;
        const box = {
          x1: entry.x - width / 2 - labelPad,
          x2: entry.x + width / 2 + labelPad,
          y1: y - labelFontSize - labelPad,
          y2: y + labelPad,
        };
        if (!labelBoxes.some(b => overlaps(b, box))){
          // shadow
          ctx.fillStyle = "rgba(0,0,0,0.55)";
          ctx.fillText(entry.label, entry.x + 1, y + 1);
          ctx.fillStyle = "rgba(232,238,247,0.92)";
          ctx.fillText(entry.label, entry.x, y);
          labelBoxes.push(box);
          placed = true;
          break;
        }
      }
      if (!placed && (showAllNames || entry.isActive)){
        const y = entry.y;
        const box = {
          x1: entry.x - width / 2 - labelPad,
          x2: entry.x + width / 2 + labelPad,
          y1: y - labelFontSize - labelPad,
          y2: y + labelPad,
        };
        ctx.fillStyle = "rgba(0,0,0,0.55)";
        ctx.fillText(entry.label, entry.x + 1, y + 1);
        ctx.fillStyle = "rgba(232,238,247,0.92)";
        ctx.fillText(entry.label, entry.x, y);
        labelBoxes.push(box);
      }
    });

  }

  function centerOnPoint(col, row){
    if (!state || !state.grid) return false;
    if (!gridReady()) return false;
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    const cols = state.grid.cols, rows = state.grid.rows;
    const desiredX = (w / 2) - (Number(col) + 0.5) * zoom;
    const desiredY = (h / 2) - (Number(row) + 0.5) * zoom;
    const gridW = cols * zoom;
    const gridH = rows * zoom;
    if (gridW <= w) {
      panX = Math.floor((w - gridW) / 2);
    } else {
      const minX = w - gridW;
      panX = Math.min(0, Math.max(minX, desiredX));
    }
    if (gridH <= h) {
      panY = Math.floor((h - gridH) / 2);
    } else {
      const minY = h - gridH;
      panY = Math.min(0, Math.max(minY, desiredY));
    }
    return true;
  }

  function centerOnClaimed(shouldDraw = true){
    if (!state || !state.units || claimedCid === null || claimedCid === undefined) return false;
    if (!gridReady()) return false;
    const me = state.units.find(u => cidMatches(u.cid, claimedCid, "centerOnClaimed"));
    if (!me) return false;
    const ok = centerOnPoint(me.pos.col, me.pos.row);
    if (ok){
      centeredCid = String(claimedCid);
      if (shouldDraw){
        draw();
      }
    }
    return ok;
  }

  function centerOnGridCenter(shouldDraw = true){
    if (!state || !state.grid) return false;
    if (!gridReady()) return false;
    const cols = Number(state.grid.cols || 0);
    const rows = Number(state.grid.rows || 0);
    const col = Math.max(0, (cols - 1) / 2);
    const row = Math.max(0, (rows - 1) / 2);
    const ok = centerOnPoint(col, row);
    if (ok && shouldDraw){
      draw();
    }
    return ok;
  }

  const PAN_DIRECTION_BY_CODE = Object.freeze({
    KeyW: {x: 0, y: 1},
    ArrowUp: {x: 0, y: 1},
    KeyS: {x: 0, y: -1},
    ArrowDown: {x: 0, y: -1},
    KeyA: {x: 1, y: 0},
    ArrowLeft: {x: 1, y: 0},
    KeyD: {x: -1, y: 0},
    ArrowRight: {x: -1, y: 0},
  });

  function normalizedPanCodeFromKeyboardEvent(event){
    const code = String(event?.code || "");
    if (PAN_KEY_CODES.has(code)) return code;
    const key = String(event?.key || "");
    if (key === "ArrowUp" || key === "ArrowDown" || key === "ArrowLeft" || key === "ArrowRight") return key;
    const lower = key.toLowerCase();
    if (lower === "w") return "KeyW";
    if (lower === "a") return "KeyA";
    if (lower === "s") return "KeyS";
    if (lower === "d") return "KeyD";
    return "";
  }

  function panDirectionFromKeyboardEvent(event){
    const normalizedCode = normalizedPanCodeFromKeyboardEvent(event);
    return PAN_DIRECTION_BY_CODE[normalizedCode] || null;
  }

  function canKeyboardPan(event){
    if (isTypingTarget(event?.target)) return false;
    if (event?.ctrlKey || event?.altKey || event?.metaKey) return false;
    if (lockMap) return false;
    if (!gridReady()) return false;
    return true;
  }

  function nudgeKeyboardPan(direction){
    const dist = Math.max(10, zoom * 0.32);
    panX += direction.x * dist;
    panY += direction.y * dist;
    draw();
  }

  function updateKeyboardPanLoop(ts){
    if (!panLastTs) panLastTs = ts;
    const dt = Math.max(0.001, Math.min(0.05, (ts - panLastTs) / 1000));
    panLastTs = ts;
    let dirX = 0;
    let dirY = 0;
    panHeldKeys.forEach((code) => {
      const direction = PAN_DIRECTION_BY_CODE[code];
      if (!direction) return;
      dirX += direction.x;
      dirY += direction.y;
    });
    const mag = Math.hypot(dirX, dirY);
    if (mag > 0){
      dirX /= mag;
      dirY /= mag;
    }
    const speed = Math.max(320, zoom * 16);
    const targetX = dirX * speed;
    const targetY = dirY * speed;
    const rate = mag > 0 ? 13 : 18;
    const blend = 1 - Math.exp(-rate * dt);
    panVelocityX += (targetX - panVelocityX) * blend;
    panVelocityY += (targetY - panVelocityY) * blend;
    if (Math.abs(panVelocityX) > 0.1 || Math.abs(panVelocityY) > 0.1){
      panX += panVelocityX * dt;
      panY += panVelocityY * dt;
      draw();
    }
    const moving = Math.abs(panVelocityX) > 2 || Math.abs(panVelocityY) > 2;
    if (panHeldKeys.size || moving){
      panLoopId = requestAnimationFrame(updateKeyboardPanLoop);
    } else {
      panLoopId = null;
      panVelocityX = 0;
      panVelocityY = 0;
      panLastTs = 0;
    }
  }

  function ensureKeyboardPanLoop(){
    if (panLoopId !== null) return;
    panLastTs = 0;
    panLoopId = requestAnimationFrame(updateKeyboardPanLoop);
  }

  function clearKeyboardPanState(){
    panHeldKeys.clear();
    panVelocityX = 0;
    panVelocityY = 0;
    panLastTs = 0;
    if (panLoopId !== null){
      cancelAnimationFrame(panLoopId);
      panLoopId = null;
    }
  }

  function autoCenterOnJoin(shouldDraw = true){
    if (!gridReady()) return;
    if (claimedCid !== null && claimedCid !== undefined){
      if (!initialCenterDone || (initialCenterFallback && centeredCid !== String(claimedCid))){
        if (centerOnClaimed(shouldDraw)){
          initialCenterDone = true;
          initialCenterFallback = false;
        }
      }
    } else if (!initialCenterDone) {
      if (centerOnGridCenter(shouldDraw)){
        initialCenterDone = true;
        initialCenterFallback = true;
      }
    }
  }

  function formatTurnOrderLabel(unit){
    if (!unit) return "";
    const role = String(unit.role || "enemy");
    let label = `${unit.name} (${role})`;
    if (unit.summoned_by_cid !== undefined && unit.summoned_by_cid !== null){
      label += `  controlled by #${unit.summoned_by_cid}`;
    }
    if ((role === "pc" || role === "ally") && Number.isFinite(Number(unit.hp))){
      label += ` ${Number(unit.hp)} HP`;
    }
    return label;
  }

  function hideTurnOrderBubble(){
    if (!activeTurnOrderBubbleEl){
      return;
    }
    activeTurnOrderBubbleEl.classList.remove("show");
  }

  function showTurnOrderBubble(chip, unit){
    if (!activeTurnOrderBubbleEl){
      return;
    }
    if (!chip || !unit){
      hideTurnOrderBubble();
      return;
    }
    activeTurnOrderBubbleEl.textContent = formatTurnOrderLabel(unit);
    activeTurnOrderBubbleEl.classList.add("show");
    const container = activeTurnOrderBubbleEl.offsetParent || activeTurnOrderEl;
    if (!container){
      return;
    }
    const containerRect = container.getBoundingClientRect();
    const chipRect = chip.getBoundingClientRect();
    const bubbleRect = activeTurnOrderBubbleEl.getBoundingClientRect();
    let left = chipRect.left - containerRect.left + (chipRect.width / 2);
    let top = chipRect.top - containerRect.top - bubbleRect.height - 8;
    if (top < 0){
      top = chipRect.bottom - containerRect.top + 8;
    }
    const minLeft = bubbleRect.width / 2;
    const maxLeft = containerRect.width - bubbleRect.width / 2;
    if (maxLeft >= minLeft){
      left = Math.min(Math.max(left, minLeft), maxLeft);
    } else {
      left = containerRect.width / 2;
    }
    top = Math.max(top, 0);
    const maxTop = Math.max(0, containerRect.height - bubbleRect.height);
    top = Math.min(top, maxTop);
    activeTurnOrderBubbleEl.style.left = `${left}px`;
    activeTurnOrderBubbleEl.style.top = `${top}px`;
  }

  function updateTurnOrder(){
    if (!activeTurnOrderEl){
      return;
    }
    const TURN_CHIP_NAME_MAX = 20;
    const TURN_CHIP_CONDITION_MAX = 24;
    const formatTurnChipName = (name) => {
      const fullName = String(name ?? "");
      if (fullName.length <= TURN_CHIP_NAME_MAX){
        return fullName;
      }
      return `${fullName.slice(0, TURN_CHIP_NAME_MAX - 1).trimEnd()}`;
    };
    const formatTurnChipConditions = (text) => {
      const fullText = normalizeTextValue(text);
      if (!fullText) return "";
      if (fullText.length <= TURN_CHIP_CONDITION_MAX){
        return fullText;
      }
      return `${fullText.slice(0, TURN_CHIP_CONDITION_MAX - 1).trimEnd()}`;
    };
    const order = Array.isArray(state?.turn_order) ? state.turn_order : [];
    activeTurnOrderEl.innerHTML = "";
    if (!order.length){
      if (activeTurnOrderStatusEl){
        activeTurnOrderStatusEl.textContent = "";
      }
      if (activeTurnOrderBubbleEl){
        hideTurnOrderBubble();
      }
      return;
    }
    const activeCid = normalizeCid(state?.active_cid, "turnOrder.activeCid");
    const activeIndex = activeCid === null
      ? -1
      : order.findIndex(cid => cidMatches(cid, activeCid, "turnOrder.activeIndex"));
    const claimedIndex = (claimedCid === null || claimedCid === undefined)
      ? -1
      : order.findIndex(cid => cidMatches(cid, claimedCid, "turnOrder.claimedIndex"));
    const unitsByCid = new Map();
    if (Array.isArray(state?.units)){
      state.units.forEach((unit) => {
        if (unit && unit.cid !== undefined && unit.cid !== null){
          const unitCid = normalizeCid(unit.cid, "turnOrder.unitCid");
          if (unitCid !== null){
            unitsByCid.set(unitCid, unit);
          }
        }
      });
    }
    const chipByCid = new Map();
    order.forEach((cid, idx) => {
      const cidValue = normalizeCid(cid, "turnOrder.orderCid");
      const unit = cidValue !== null ? unitsByCid.get(cidValue) : undefined;
      const chip = document.createElement("div");
      chip.className = "turn-chip";
      const role = String(unit?.role || "enemy");
      const isFriendly = role !== "enemy";
      chip.classList.add(isFriendly ? "friendly" : "enemy");
      if (idx === claimedIndex){
        chip.classList.add("claimed");
      }
      if (idx === activeIndex){
        chip.classList.add("active");
      }
      chip.setAttribute("role", "button");
      chip.setAttribute("tabindex", "0");
      const baseUnitName = unit?.name ? String(unit.name) : `#${cid}`;
      const unitName = unit?.is_mount ? `${baseUnitName} (steed)` : baseUnitName;
      const truncatedUnitName = formatTurnChipName(unitName);
      const conditionText = formatTurnChipConditions(unit?.marks);
      const fullLabel = conditionText ? `${unitName}  ${conditionText}` : unitName;
      chip.setAttribute("aria-label", `Turn ${idx + 1}: ${fullLabel}`);
      chip.setAttribute("data-full-name", unitName);
      chip.setAttribute("title", fullLabel);
      if (cidValue !== null){
        chip.dataset.cid = String(cidValue);
      }
      if (idx === claimedIndex){
        const claimedMarker = document.createElement("span");
        claimedMarker.className = "turn-chip-marker claimed-marker";
        claimedMarker.setAttribute("aria-hidden", "true");
        chip.appendChild(claimedMarker);
      }
      if (idx === activeIndex){
        const activeMarker = document.createElement("span");
        activeMarker.className = "turn-chip-marker active-marker";
        activeMarker.setAttribute("aria-hidden", "true");
        chip.appendChild(activeMarker);
      }
      const indexEl = document.createElement("span");
      indexEl.className = "turn-chip-index";
      indexEl.textContent = String(idx + 1);
      chip.appendChild(indexEl);
      const nameEl = document.createElement("span");
      nameEl.className = "turn-chip-name";
      const concentrationLabel = isUnitConcentrationLinked(unit) ? `${truncatedUnitName} ` : truncatedUnitName;
      nameEl.textContent = conditionText ? `${concentrationLabel}  ${conditionText}` : concentrationLabel;
      nameEl.setAttribute("data-full-name", unitName);
      nameEl.setAttribute("title", fullLabel);
      chip.appendChild(nameEl);
      chip.addEventListener("click", () => {
        if (cidValue === null) return;
        setSelectedTurnCid(cidValue);
      });
      chip.addEventListener("keydown", (ev) => {
        if (ev.key === "Enter" || ev.key === " "){
          ev.preventDefault();
          if (cidValue === null) return;
          setSelectedTurnCid(cidValue);
        }
      });
      chip.addEventListener("mouseenter", () => {
        if (cidValue === null) return;
        hoveredTurnCid = cidValue;
        showTurnOrderBubble(chip, unit);
      });
      chip.addEventListener("mouseleave", () => {
        if (cidValue !== null && hoveredTurnCid === cidValue){
          hoveredTurnCid = null;
        }
        hideTurnOrderBubble();
      });
      activeTurnOrderEl.appendChild(chip);
      if (cidValue !== null){
        chipByCid.set(cidValue, chip);
      }
    });
    const setSelectedTurnCid = (cid) => {
      const prev = activeControlledUnitCid();
      selectedTurnCid = cid;
      const next = activeControlledUnitCid();
      if (prev !== next && pendingActionAttackWeapon){
        pendingActionAttackWeapon = null;
      }
      chipByCid.forEach((chip, key) => {
        chip.classList.toggle("selected", key === cid);
      });
    };
    const claimedUnit = (claimedIndex >= 0 && claimedCid != null) ? unitsByCid.get(claimedCid) : null;
    if (activeTurnOrderStatusEl){
      const activeOrderCid = activeIndex >= 0 ? normalizeCid(order[activeIndex], "turnOrder.activeDisplayCid") : null;
      const activeUnit = activeOrderCid !== null ? unitsByCid.get(activeOrderCid) : null;
      const roundLabel = Number.isFinite(Number(state?.round_num)) ? `Round ${state.round_num}` : "";
      const isClaimedTurn = claimedCid !== null && activeOrderCid !== null && claimedCid === activeOrderCid;
      const activeLabel = isClaimedTurn
        ? "Your turn"
        : activeUnit?.name ? `${activeUnit.name}'s turn` : "Turn: ";
      let statusText = roundLabel ? `${activeLabel}  ${roundLabel}` : activeLabel;
      if (claimedIndex >= 0 && claimedUnit && !isMapView && !isClaimedTurn){
        statusText = `${statusText}  You are #${claimedIndex + 1}: ${claimedUnit.name}`;
      }
      activeTurnOrderStatusEl.textContent = statusText;
    }
    let fallbackCid = selectedTurnCid;
    if (fallbackCid === null || !chipByCid.has(fallbackCid)){
      if (claimedIndex >= 0){
        fallbackCid = claimedCid;
      } else if (activeIndex >= 0){
        fallbackCid = normalizeCid(order[activeIndex], "turnOrder.fallbackActiveCid");
      } else {
        fallbackCid = normalizeCid(order[0], "turnOrder.fallbackFirstCid");
      }
    }
    setSelectedTurnCid(fallbackCid);
  }

  function normalizeActionEntry(entry, defaultType){
    if (!entry) return null;
    if (typeof entry === "string"){
      const name = String(entry || "").trim();
      if (!name) return null;
      return {name, description: "", type: defaultType};
    }
    if (typeof entry !== "object") return null;
    const name = normalizeTextValue(entry.name);
    if (!name) return null;
    const description = normalizeTextValue(entry.description || entry.desc) || "";
    const type = normalizeLowerValue(entry.type) || defaultType;
    const normalized = {name, description, type};
    if (entry.id != null) normalized.id = String(entry.id);
    if (entry.attack_overlay_mode != null) normalized.attack_overlay_mode = String(entry.attack_overlay_mode);
    if (entry.attack_count != null) normalized.attack_count = Number(entry.attack_count);
    if (entry.resolve_prompt != null) normalized.resolve_prompt = String(entry.resolve_prompt);
    if (entry.attack_weapon && typeof entry.attack_weapon === "object") normalized.attack_weapon = {...entry.attack_weapon};
    if (entry.uses && typeof entry.uses === "object") normalized.uses = {...entry.uses};
    return normalized;
  }

  function normalizeActionList(entries, defaultType){
    const list = Array.isArray(entries) ? entries : [];
    return list
      .map((entry) => normalizeActionEntry(entry, defaultType))
      .filter(Boolean);
  }

  function isSpellActionEntry(entry){
    const name = normalizeLowerValue(entry?.name);
    return name === "magic" || name === "cast a spell" || name === "cast spell" || name === "spellcasting";
  }

  function getWildShapeAttackCount(unit){
    const actions = normalizeActionList(unit?.actions, "action");
    const multi = actions.find((entry) => normalizeLowerValue(entry?.name) === "multiattack");
    if (!multi) return 1;
    const explicit = Number(multi.attack_count);
    if (Number.isFinite(explicit) && explicit >= 2) return Math.max(2, Math.floor(explicit));
    const text = normalizeLowerValue(multi.description);
    if (!text) return 1;
    const words = {one: 1, two: 2, three: 3, four: 4, five: 5};
    let total = 0;
    Object.entries(words).forEach(([word, value]) => {
      const matches = text.match(new RegExp(`\\b${word}\\b[^.]*?\\battack\\b`, "g"));
      if (Array.isArray(matches)) total += matches.length * value;
    });
    const digitMatches = text.match(/\b(\d+)\b[^.]*?\battack\b/g);
    if (Array.isArray(digitMatches)){
      digitMatches.forEach((chunk) => {
        const match = chunk.match(/\b(\d+)\b/);
        const value = Number(match?.[1]);
        if (Number.isFinite(value) && value > 0) total += value;
      });
    }
    return total >= 2 ? Math.min(10, total) : 1;
  }

  function weaponFromWildShapeAction(entry, unit){
    if (!entry || typeof entry !== "object") return null;
    if (entry.attack_weapon && typeof entry.attack_weapon === "object"){
      return {
        ...entry.attack_weapon,
        id: String(entry.attack_weapon.id || entry.id || entry.name || "").trim(),
        name: String(entry.attack_weapon.name || entry.name || "Wild Shape Attack").trim(),
      };
    }
    const desc = String(entry.description || "").trim();
    if (!desc) return null;
    const lower = normalizeLowerValue(desc);
    if (!lower.includes("attack roll") || !lower.includes("hit")) return null;
    const toHitMatch = desc.match(/attack roll\s*:\s*([+\-]?\d+)/i);
    const rangeMatch = desc.match(/(?:reach|range)\s*(\d+)\s*ft/i);
    const damageMatch = desc.match(/hit\s*:\s*[^.]*?\(([^)]+)\)\s*([a-zA-Z]+)\s+damage/i);
    const name = String(entry.name || "Wild Shape Attack").trim() || "Wild Shape Attack";
    const idBase = String(entry.id || name).trim().toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "");
    const weapon = {
      id: idBase || "wild-shape-attack",
      name,
      category: lower.includes("ranged attack roll") ? "ranged_weapon" : "melee_weapon",
      range: rangeMatch ? `${Math.floor(Number(rangeMatch[1]) || 5)} ft` : (lower.includes("ranged attack roll") ? "60 ft" : "5 ft"),
    };
    if (toHitMatch){
      const toHit = Number(toHitMatch[1]);
      if (Number.isFinite(toHit)) weapon.to_hit = Math.floor(toHit);
    }
    if (damageMatch){
      weapon.one_handed = {
        damage_formula: String(damageMatch[1] || "").trim(),
        damage_type: String(damageMatch[2] || "").trim().toLowerCase(),
      };
    }
    const multiattackCount = getWildShapeAttackCount(unit);
    return {
      ...weapon,
      attack_count: multiattackCount,
      resolve_prompt: String(entry.resolve_prompt || `Attack target with ${name}.`).trim(),
    };
  }

  function weaponFromSummonAction(entry, unit){
    if (!entry || typeof entry !== "object") return null;
    if (entry.attack_weapon && typeof entry.attack_weapon === "object"){
      const base = {
        ...entry.attack_weapon,
        id: String(entry.attack_weapon.id || entry.id || entry.name || "").trim(),
        name: String(entry.attack_weapon.name || entry.name || "Summon Attack").trim(),
      };
      if (!base.id) base.id = base.name.toLowerCase().replace(/[^a-z0-9]+/g, "-");
      return base;
    }
    const desc = String(entry.description || "").trim();
    if (!desc) return null;
    const marker = /(Melee|Ranged|Melee or Ranged)\s+Weapon Attack:/i;
    if (!marker.test(desc)) return null;
    const toHitMatch = desc.match(/Weapon Attack:\s*([+\-]?\d+)\s*to hit/i);
    const rangeMatch = desc.match(/(?:reach|range)\s*(\d+)\s*ft/i);
    const damageMatch = desc.match(/Hit:\s*[^.]*?\(([^)]+)\)\s*([A-Za-z]+)\s+damage/i);
    const lower = normalizeLowerValue(desc);
    const name = String(entry.name || "Summon Attack").trim() || "Summon Attack";
    const weapon = {
      id: String(entry.id || name).trim().toLowerCase().replace(/[^a-z0-9]+/g, "-"),
      name,
      category: lower.includes("ranged") ? "ranged_weapon" : "melee_weapon",
      range: rangeMatch ? `${Math.floor(Number(rangeMatch[1]) || 5)} ft` : (lower.includes("ranged") ? "60 ft" : "5 ft"),
    };
    if (toHitMatch){
      const toHit = Number(toHitMatch[1]);
      if (Number.isFinite(toHit)) weapon.to_hit = Math.floor(toHit);
    }
    if (damageMatch){
      weapon.one_handed = {
        damage_formula: String(damageMatch[1] || "").trim(),
        damage_type: String(damageMatch[2] || "").trim().toLowerCase(),
      };
    }
    return weapon;
  }

  function summonAttackOptionsForUnit(unit){
    const actions = normalizeActionList(unit?.actions, "action");
    return actions.map((entry) => ({
      weapon: weaponFromSummonAction(entry, unit),
      entry,
    })).filter((x) => !!x.weapon);
  }

  function chooseSummonAttackOption(options){
    if (!Array.isArray(options) || !options.length) return null;
    if (options.length === 1) return options[0];
    const text = options.map((opt, idx) => `${idx + 1}. ${opt.weapon.name}`).join("\n");
    const raw = window.prompt(`Choose summon attack:\n${text}`, "1");
    const choice = Number(raw);
    if (!Number.isFinite(choice) || choice < 1 || choice > options.length) return null;
    return options[Math.floor(choice) - 1];
  }

  function populateActionSelect(selectEl, options, placeholder){
    if (!selectEl) return;
    const previousValue = selectEl.value;
    selectEl.textContent = "";
    const placeholderOption = document.createElement("option");
    placeholderOption.value = "";
    placeholderOption.textContent = placeholder;
    selectEl.appendChild(placeholderOption);
    const normalized = normalizeActionList(options, "action");
    normalized.forEach((item) => {
      const option = document.createElement("option");
      option.value = item.name;
      option.textContent = item.name;
      selectEl.appendChild(option);
    });
    if (previousValue && normalized.some((item) => item.name === previousValue)){
      selectEl.value = previousValue;
    } else {
      selectEl.value = "";
    }
  }


  function isFriendlyToMe(unit, me){
    if (!unit) return false;
    if (unit.ally === true) return true;
    const role = normalizeTextValue(unit.role);
    if (role === "pc" || role === "ally") return true;
    if (me && unit.summoned_by_cid != null && Number(unit.summoned_by_cid) === Number(me.cid)) return true;
    return false;
  }

  function isMountableFor(unit, me){
    if (!unit) return false;
    if (unit.can_be_mounted || unit.is_mount) return true;
    if (me && unit.summoned_by_cid != null && Number(unit.summoned_by_cid) === Number(me.cid)) return true;
    return false;
  }

  function mountCandidatePair(){
    const me = getClaimedUnit();
    const units = state?.units || state?.combatants || [];
    if (!me || !Array.isArray(units)) return null;
    if (me.rider_cid || me.mounted_by_cid) return null;
    const sameTile = units.filter(u =>
      u &&
      Number(u?.pos?.col)===Number(me?.pos?.col) &&
      Number(u?.pos?.row)===Number(me?.pos?.row) &&
      Number(u?.cid)!==Number(me?.cid)
    );
    if (!sameTile.length) return null;
    const mount = sameTile
      .filter(u => !u.rider_cid && !u.mounted_by_cid)
      .sort((a, b) => {
        const aTrueMount = (a?.can_be_mounted || a?.is_mount) ? 0 : 1;
        const bTrueMount = (b?.can_be_mounted || b?.is_mount) ? 0 : 1;
        if (aTrueMount !== bTrueMount) return aTrueMount - bTrueMount;
        return Number(a?.cid ?? 0) - Number(b?.cid ?? 0);
      })[0];
    if (!mount) return null;
    return {rider: me, mount};
  }

  function updateMountControls(){
    const me = getClaimedUnit();
    const pair = mountCandidatePair();
    pendingMountPair = pair;
    if (mountBtn){
      mountBtn.classList.toggle("hidden", !pair);
      mountBtn.classList.toggle("glow", !!pair);
    }
    if (dismountBtn){
      dismountBtn.classList.toggle("hidden", !(me && me.rider_cid));
    }
  }


  function tokenPriorityScore(unit){
    if (!unit) return -1;
    const cid = normalizeCid(unit.cid, "token.priority.cid");
    if (cid === null) return -1;
    const activeCid = normalizeCid(state?.active_cid, "token.priority.active");
    const claimed = normalizeCid(claimedCid, "token.priority.claimed");
    const scoreBase = Number(cid) * -0.001;
    if (activeCid !== null && cidMatches(activeCid, cid, "token.priority.activeMatch")) return 4000 + scoreBase;
    if (claimed !== null && cidMatches(claimed, cid, "token.priority.claimedMatch")) return 3000 + scoreBase;
    return 1000 + scoreBase;
  }

  function sortedTokensForRender(tokens){
    const list = Array.isArray(tokens) ? tokens.slice() : [];
    list.sort((a, b) => tokenPriorityScore(a) - tokenPriorityScore(b));
    return list;
  }

  function setMeLabel(unit, controlling = false){
    if (!meEl) return;
    if (!unit){
      meEl.textContent = "(unclaimed)";
      return;
    }
    const name = String(unit?.name || `#${unit?.cid || "?"}`);
    if (!controlling){
      meEl.textContent = name;
      return;
    }
    meEl.innerHTML = "";
    const wrap = document.createElement("span");
    wrap.className = "me-label";
    const title = document.createElement("span");
    title.textContent = name;
    const sub = document.createElement("span");
    sub.className = "me-sub";
    sub.textContent = "Controlling";
    wrap.appendChild(title);
    wrap.appendChild(sub);
    meEl.appendChild(wrap);
  }

  function updateHud(){
    if (!state){ return; }
    const active = state.active_cid;
    const round = state.round_num;
    turnEl.textContent = (active === null) ? "Turn: (not started)" : `Round ${round}`;
    const controlledCid = activeControlledUnitCid();
    const myTurn = controlledCid !== null;
    if (resetTurnBtn){
      resetTurnBtn.disabled = !myTurn;
    }
    if (dismissSummonsBtn){
      dismissSummonsBtn.disabled = claimedCid == null;
      const hasOwnedSummons = !!claimedCid && Array.isArray(state?.units)
        && state.units.some(u => cidMatches(u?.summoned_by_cid, claimedCid, "dismissSummons.owner"));
      dismissSummonsBtn.classList.toggle("hidden", !hasOwnedSummons);
    }
    const updatePlayerHpBar = (unit) => {
      if (!playerHpBarWrap || !playerHpBarFill || !playerHpBarLabel){
        return;
      }
      const hp = Number(unit?.hp ?? NaN);
      const maxHpRaw = Number(unit?.max_hp ?? NaN);
      const maxHp = Number.isFinite(maxHpRaw) && maxHpRaw > 0
        ? maxHpRaw
        : (Number.isFinite(hp) && hp > 0 ? hp : 0);
      if (!Number.isFinite(hp) || maxHp <= 0){
        playerHpBarWrap.classList.remove("show");
        return;
      }
      const pct = Math.max(0, Math.min(100, (hp / maxHp) * 100));
      playerHpBarWrap.classList.add("show");
      playerHpBarFill.style.width = `${pct}%`;
      playerHpBarFill.classList.toggle("mid", pct <= 50 && pct > 20);
      playerHpBarFill.classList.toggle("low", pct <= 20);
      playerHpBarLabel.textContent = `HP ${Math.round(hp)}/${Math.round(maxHp)}`;
    };
    let meForHud = null;
    ensureWeaponSelectionCharacterLoaded();
    if (claimedCid && state.units){
      const reactionCid = reactionControlledUnitCid();
      const me = controlledCid !== null
        ? state.units.find(u => cidMatches(u.cid, controlledCid, "hud.controlledUnit"))
        : null;
      const reactionUnit = reactionCid !== null
        ? state.units.find(u => cidMatches(u.cid, reactionCid, "hud.reactionUnit"))
        : null;
      const claimed = state.units.find(u => cidMatches(u.cid, claimedCid, "hud.claimedUnit"));
      if (me){
        meForHud = me;
        setMeLabel(me, claimed && !cidMatches(me.cid, claimed.cid, "hud.controlling"));
        const modeLabel = movementModeLabel(me.movement_mode);
        moveEl.textContent = `Move: ${me.move_remaining}/${me.move_total} (${modeLabel})`;
        moveEl.setAttribute("title", "Click to cycle movement mode");
        actionEl.textContent = `Action: ${me.action_remaining ?? 0}`;
        if (attackResourceEl){
          attackResourceEl.textContent = `Attacks: ${me.attack_resource_remaining ?? 0}`;
        }
        bonusActionEl.textContent = `Bonus Action: ${me.bonus_action_remaining ?? 0}`;
        if (reactionEl){
          const reactionOwner = reactionUnit || me;
          reactionEl.textContent = `Reaction: ${reactionOwner.reaction_remaining ?? 0}`;
        }
        if (useActionBtn){
          useActionBtn.disabled = Number(me.action_remaining || 0) <= 0;
        }
        useBonusActionBtn.disabled = Number(me.bonus_action_remaining || 0) <= 0;
        if (useReactionBtn){
          useReactionBtn.disabled = Number((reactionUnit || me).reaction_remaining || 0) <= 0;
        }
        populateActionSelect(actionSelectEl, me.actions, "None/Custom");
        populateActionSelect(bonusActionSelectEl, me.bonus_actions, "None/Custom");
        if (actionSelectEl){
          actionSelectEl.disabled = false;
        }
        if (bonusActionSelectEl){
          bonusActionSelectEl.disabled = false;
        }
        refreshWeaponSelectors();
        if (mainhandWeaponSelectEl){
          mainhandWeaponSelectEl.disabled = false;
        }
        if (offhandWeaponSelectEl){
          offhandWeaponSelectEl.disabled = isMainhandSelectionTwoHanded();
        }
        if (attackOverlayToggleBtn){
          attackOverlayToggleBtn.disabled = false;
        }
        if (standUpBtn){
          standUpBtn.disabled = !(myTurn && me.is_prone);
        }
        updatePlayerHpBar(me);
      } else {
        setMeLabel(claimed || null, false);
        updatePlayerHpBar(null);
        moveEl.removeAttribute("title");
        actionEl.textContent = "Action: ";
        if (attackResourceEl){
          attackResourceEl.textContent = "Attacks: ";
        }
        bonusActionEl.textContent = "Bonus Action: ";
        if (reactionEl){
          reactionEl.textContent = `Reaction: ${reactionUnit?.reaction_remaining ?? ""}`;
        }
        if (useActionBtn){
          useActionBtn.disabled = true;
        }
        useBonusActionBtn.disabled = true;
        if (useReactionBtn){
          useReactionBtn.disabled = !reactionUnit || Number(reactionUnit.reaction_remaining || 0) <= 0;
        }
        populateActionSelect(actionSelectEl, [], "None/Custom");
        populateActionSelect(bonusActionSelectEl, [], "None/Custom");
        if (actionSelectEl){
          actionSelectEl.disabled = true;
        }
        if (bonusActionSelectEl){
          bonusActionSelectEl.disabled = true;
        }
        refreshWeaponSelectors();
        if (mainhandWeaponSelectEl){
          mainhandWeaponSelectEl.disabled = true;
        }
        if (offhandWeaponSelectEl){
          offhandWeaponSelectEl.disabled = true;
        }
        if (attackOverlayToggleBtn){
          attackOverlayToggleBtn.disabled = false;
        }
        if (standUpBtn){
          standUpBtn.disabled = true;
        }
      }
    } else {
      setMeLabel(null, false);
      updatePlayerHpBar(null);
      moveEl.removeAttribute("title");
      actionEl.textContent = "Action: ";
      if (attackResourceEl){
        attackResourceEl.textContent = "Attacks: ";
      }
      bonusActionEl.textContent = "Bonus Action: ";
      if (reactionEl){
        reactionEl.textContent = "Reaction: ";
      }
      if (useActionBtn){
        useActionBtn.disabled = true;
      }
      useBonusActionBtn.disabled = true;
      if (useReactionBtn){
        useReactionBtn.disabled = true;
      }
      populateActionSelect(actionSelectEl, [], "None/Custom");
      populateActionSelect(bonusActionSelectEl, [], "None/Custom");
      if (actionSelectEl){
        actionSelectEl.disabled = true;
      }
      if (bonusActionSelectEl){
        bonusActionSelectEl.disabled = true;
      }
      refreshWeaponSelectors();
      if (mainhandWeaponSelectEl){
        mainhandWeaponSelectEl.disabled = true;
      }
      if (offhandWeaponSelectEl){
        offhandWeaponSelectEl.disabled = true;
      }
      if (attackOverlayToggleBtn){
        attackOverlayToggleBtn.disabled = false;
      }
      if (standUpBtn){
        standUpBtn.disabled = true;
      }
    }
    if (endTurnSheetBtn){
      const actionTotal = Number(meForHud?.action_total || 0);
      const actionRemaining = Number(meForHud?.action_remaining || 0);
      const usedAction = actionTotal > 0 && actionRemaining < actionTotal;
      endTurnSheetBtn.classList.toggle("hidden", !(myTurn && usedAction));
    }
    renderSpellSlotMonitor();
    renderResourcePools();
    updateTurnOrder();
    updateSpellPanelVisibility();
    updateResourceGatedControls();
    applyMapViewReadOnlyControls();
    updateEndTurnState();
    updateEndTurnReadyVisual(meForHud, myTurn);
    updateAurasButton();
    renderEffectsOverlay();
    updateClaimOverlay();
  }

  function showActionPicker(){
    if (!actionPickerModal) return;
    actionPickerModal.classList.add("show");
    actionPickerModal.setAttribute("aria-hidden", "false");
  }

  function hideActionPicker(){
    if (!actionPickerModal) return;
    actionPickerModal.classList.remove("show");
    actionPickerModal.setAttribute("aria-hidden", "true");
    if (actionPickerList){
      actionPickerList.textContent = "";
    }
  }

  function setWarCasterModalOpen(open){
    if (!warCasterModal) return;
    warCasterModal.classList.toggle("show", !!open);
    warCasterModal.setAttribute("aria-hidden", open ? "false" : "true");
  }

  function reactionPrefsStorageKey(cid){
    const claimed = String(cid ?? claimedCid ?? "").trim();
    return `lanReactionPrefs:${claimed}`;
  }

  function getReactionPrefs(cid){
    const key = reactionPrefsStorageKey(cid);
    try {
      const parsed = JSON.parse(localStorage.getItem(key) || "{}");
      return parsed && typeof parsed === "object" ? parsed : {};
    } catch(_e){
      return {};
    }
  }

  function setReactionPref(cid, kind, mode){
    const prefs = getReactionPrefs(cid);
    prefs[String(kind)] = String(mode);
    localStorage.setItem(reactionPrefsStorageKey(cid), JSON.stringify(prefs));
    sendReactionPrefsUpdate();
  }

  function reactionModeForEntry(entry, cid){
    const key = entry?.kindKey || "";
    const prefs = getReactionPrefs(cid);
    if (prefs && typeof prefs[key] === "string"){
      return prefs[key];
    }
    if (key === "opportunity_attack") return "auto";
    return "ask";
  }

  function sendReactionPrefsUpdate(){
    const unit = getClaimedUnit();
    if (!unit || claimedCid === null) return;
    const prefs = getReactionPrefs(claimedCid);
    const payload = {
      opportunity_attack: String(prefs.opportunity_attack || "auto"),
      war_caster: String(prefs.war_caster || "ask"),
    };
    send({type:"reaction_prefs_update", cid: claimedCid, prefs: payload});
  }

  function playerHasWarCasterFeat(){
    const profile = getPlayerProfile(getClaimedPlayerName());
    if (!profile || typeof profile !== "object"){
      return false;
    }
    const hasWarCasterName = (value) => normalizeLowerValue(value) === "war caster";
    const features = Array.isArray(profile.features) ? profile.features : [];
    for (const feature of features){
      if (typeof feature === "string" && hasWarCasterName(feature)){
        return true;
      }
      if (feature && typeof feature === "object"){
        if (hasWarCasterName(feature.name) || hasWarCasterName(feature.id)){
          return true;
        }
      }
    }
    return false;
  }

  function getPreparedReactionSpellEntries(){
    const preparedSet = getPreparedSpellFilterSet();
    if (!(preparedSet instanceof Set) || !preparedSet.size){
      return [];
    }
    return cachedSpellPresets
      .filter((preset) => {
        const slug = getPresetSlug(preset);
        return slug && preparedSet.has(getSpellKey(slug)) && getSpellActionType(preset) === "reaction";
      })
      .sort((a, b) => normalizeTextValue(a?.name).localeCompare(normalizeTextValue(b?.name)))
      .map((preset) => ({
        name: normalizeTextValue(preset.name),
        description: normalizeTextValue(preset.description),
        spend: "reaction",
        kind: "reaction_spell",
        spellSlug: getPresetSlug(preset),
      }))
      .filter((entry) => entry.name && entry.spellSlug);
  }

  function isWarCasterEligibleSpellPreset(preset){
    if (!preset || getSpellActionType(preset) !== "action"){
      return false;
    }
    if (isAoePreset(preset) || isSummonPreset(preset)){
      return false;
    }
    const baseSlotLevel = Number.isFinite(Number(preset?.level)) ? Math.max(0, Math.floor(Number(preset.level))) : 0;
    const targeting = getSpellTargetingConfig(preset, baseSlotLevel);
    return Boolean(targeting && Number(targeting.projectileCount || 1) === 1);
  }

  function getWarCasterEligibleSpellPresets(){
    const preparedSet = getPreparedSpellFilterSet();
    if (!(preparedSet instanceof Set) || !preparedSet.size){
      return [];
    }
    return cachedSpellPresets
      .filter((preset) => {
        const slug = getPresetSlug(preset);
        return slug && preparedSet.has(getSpellKey(slug)) && isWarCasterEligibleSpellPreset(preset);
      })
      .sort((a, b) => normalizeTextValue(a?.name).localeCompare(normalizeTextValue(b?.name)));
  }

  function getWarCasterTargets(){
    const me = getClaimedUnit();
    const units = Array.isArray(state?.units) ? state.units : [];
    return units.filter((entry) => {
      if (!entry || !me || cidMatches(entry.cid, me.cid, "warCaster.self")){
        return false;
      }
      return !isFriendlyToMe(entry, me);
    });
  }

  function populateWarCasterModal(){
    if (!warCasterSpellSelect || !warCasterTargetSelect){
      return {spells: [], targets: []};
    }
    const spells = getWarCasterEligibleSpellPresets();
    const targets = getWarCasterTargets();
    warCasterSpellSelect.textContent = "";
    spells.forEach((preset) => {
      const opt = document.createElement("option");
      opt.value = getPresetSlug(preset);
      opt.textContent = normalizeTextValue(preset.name);
      warCasterSpellSelect.appendChild(opt);
    });
    warCasterTargetSelect.textContent = "";
    targets.forEach((target) => {
      const opt = document.createElement("option");
      opt.value = String(target.cid);
      opt.textContent = `${target.name || `#${target.cid}`} (CID ${target.cid})`;
      warCasterTargetSelect.appendChild(opt);
    });
    const activeEnemy = targets.find((entry) => cidMatches(entry.cid, state?.active_cid, "warCaster.defaultTarget"));
    if (activeEnemy){
      warCasterTargetSelect.value = String(activeEnemy.cid);
    }
    return {spells, targets};
  }

  function runSpellTargetingAgainstTarget(target){
    if (!target){
      return;
    }
    const me = getClaimedUnit();
    const isFriendlyTarget = !!me && (cidMatches(target.cid, me.cid, "spellTargeting.self") || isFriendlyToMe(target, me));
    if (!pendingMantleOfInspiration && !pendingSpellTargeting){
      return;
    }
    const targetSide = normalizeLowerValue((pendingSpellTargetSelection?.targetSide || pendingSpellTargeting?.targetSide || "any"));
    if (!pendingMantleOfInspiration && targetSide === "friendly" && !isFriendlyTarget){
      localToast("Pick a friendly target, matey.");
      return;
    }
    if (!pendingMantleOfInspiration && targetSide === "enemy" && isFriendlyTarget){
      localToast("Pick an enemy target, matey.");
      return;
    }
    if (pendingSpellTargetSelection){
      const selection = pendingSpellTargetSelection;
      const selected = Array.isArray(selection.selectedTargets) ? selection.selectedTargets : [];
      if (selected.length >= selection.maxTargets){
        localToast("Target list already full.");
        return;
      }
      if (pendingSpellTargeting.requireUniqueTargets && selected.includes(Number(target.cid))){
        localToast("That spell needs unique targets, matey.");
        return;
      }
      selected.push(Number(target.cid));
      selection.selectedTargets = selected;
      renderSpellTargetSelectionUi();
      return;
    }
    if (pendingMantleOfInspiration){
      const selected = Array.isArray(pendingMantleOfInspiration.targetCids) ? pendingMantleOfInspiration.targetCids : [];
      const mantleCasterCid = normalizeCid(pendingMantleOfInspiration.casterCid, "mantle.targeting.casterCid") ?? activeControlledUnitCid();
      const mantleCaster = mantleCasterCid === null ? null : getUnitByCid(mantleCasterCid);
      if (!mantleCaster){
        localToast("Could not find Mantle caster, matey.");
        return;
      }
      if (!isFriendlyToMe(target, mantleCaster)){
        localToast("Mantle of Inspiration only targets friendly creatures.");
        return;
      }
      const mantleRangeFt = Number(pendingMantleOfInspiration.rangeFt || 0);
      if (Number.isFinite(mantleRangeFt) && mantleRangeFt > 0 && target.pos && mantleCaster.pos){
        const distanceFt = distanceFeetBetweenCells(mantleCaster.pos, target.pos);
        if (distanceFt > mantleRangeFt){
          localToast(`That target is out of range (${Math.round(distanceFt)} ft > ${Math.round(mantleRangeFt)} ft).`);
          return;
        }
      }
      if (selected.length >= Number(pendingMantleOfInspiration.maxTargets || 1)){
        localToast("Target list already full.");
        return;
      }
      if (selected.includes(Number(target.cid))){
        localToast("That target be selected already.");
        return;
      }
      selected.push(Number(target.cid));
      pendingMantleOfInspiration.targetCids = selected;
      renderSpellTargetSelectionUi();
      return;
    }
    if (isCommandSpellTargeting()){
      queueCommandResolution([Number(target.cid)], null);
      return;
    }
    if (pendingSpellTargeting.mode === "save"){
      const actionCid = activeControlledUnitCid();
      if (actionCid === null){
        localToast("Not yer turn yet, matey.");
        return;
      }
      if (isPolymorphSpellTargeting()){
        pendingPolymorphSelection = {
          cid: actionCid,
          targetCid: Number(target.cid),
          spellName: pendingSpellTargeting.spellName,
          spellSlug: pendingSpellTargeting.spellSlug || null,
          spellId: pendingSpellTargeting.spellId || null,
          saveType: pendingSpellTargeting.saveType || "wis",
          saveDc: pendingSpellTargeting.saveDc,
        };
        setPolymorphFormOverlayOpen(true);
        localToast("Pick a beast form before resolving Polymorph.");
        return;
      }
      send({
        type: "spell_target_request",
        cid: actionCid,
        target_cid: Number(target.cid),
        spell_name: pendingSpellTargeting.spellName,
        spell_slug: pendingSpellTargeting.spellSlug || null,
        spell_id: pendingSpellTargeting.spellId || null,
        spell_mode: "save",
        save_type: pendingSpellTargeting.saveType || null,
        save_dc: Number.isFinite(Number(pendingSpellTargeting.saveDc)) ? Number(pendingSpellTargeting.saveDc) : null,
        roll_save: true,
      });
      return;
    }
    if (pendingSpellTargeting.mode === "effect"){
      send({
        type: "spell_target_request",
        cid: activeControlledUnitCid(),
        target_cid: Number(target.cid),
        spell_name: pendingSpellTargeting.spellName,
        spell_slug: pendingSpellTargeting.spellSlug || null,
        spell_id: pendingSpellTargeting.spellId || null,
        spell_mode: "effect",
      });
      return;
    }
    const autoHit = pendingSpellTargeting.mode === "auto_hit";
    if (autoHit && pendingSpellTargeting.skipResolveAttack){
      const actionCid = activeControlledUnitCid();
      if (actionCid === null){
        localToast("Not yer turn yet, matey.");
        return;
      }
      send({
        type: "spell_target_request",
        cid: actionCid,
        target_cid: Number(target.cid),
        spell_name: pendingSpellTargeting.spellName,
        spell_slug: pendingSpellTargeting.spellSlug || null,
        spell_id: pendingSpellTargeting.spellId || null,
        spell_mode: pendingSpellTargeting.mode,
        save_type: pendingSpellTargeting.saveType || null,
        save_dc: Number.isFinite(Number(pendingSpellTargeting.saveDc)) ? Number(pendingSpellTargeting.saveDc) : null,
        roll_save: false,
        hit: true,
        critical: false,
        damage_entries: [],
        damage_dice: String(pendingSpellTargeting.damageDice || "").trim() || null,
        damage_type: String(pendingSpellTargeting.damageType || "").trim().toLowerCase() || null,
      });
      return;
    }
    pendingAttackResolve = {
      mode: "spell",
      targetCid: Number(target.cid),
      targetName: String(target.name || "target"),
      spellName: pendingSpellTargeting.spellName,
      spellSlug: pendingSpellTargeting.spellSlug || null,
      spellId: pendingSpellTargeting.spellId || null,
      spellMode: pendingSpellTargeting.mode,
      saveType: pendingSpellTargeting.saveType || "",
      saveDc: pendingSpellTargeting.saveDc,
      forceHit: autoHit,
      rollSave: false,
      damageDice: pendingSpellTargeting.damageDice || "",
      damageType: pendingSpellTargeting.damageType || "",
    };
    if (attackResolveBody){
      const details = [
        pendingSpellTargeting.damageDice ? `Damage: ${pendingSpellTargeting.damageDice}${pendingSpellTargeting.damageType ? ` ${pendingSpellTargeting.damageType}` : ""}.` : "",
        pendingSpellTargeting.description ? pendingSpellTargeting.description : "",
      ].filter(Boolean).join(" ");
      attackResolveBody.textContent = `Resolve ${pendingSpellTargeting.spellName} on ${pendingAttackResolve.targetName}.`
        + (details ? ` ${details}` : "");
    }
    if (attackDamageRows){
      attackDamageRows.textContent = "";
      addAttackDamageRow("", pendingSpellTargeting.damageType || "");
    }
    if (attackResolveHit) attackResolveHit.checked = autoHit;
    if (attackResolveMiss) attackResolveMiss.checked = !autoHit;
    if (attackResolveHit) attackResolveHit.disabled = autoHit;
    if (attackResolveMiss) attackResolveMiss.disabled = autoHit;
    syncAttackResolveDamageVisibility();
    setAttackResolveModalOpen(true);
  }


  function openWarCasterModal(){
    if (!playerHasWarCasterFeat()){
      localToast("War Caster feat not found on your sheet.");
      return;
    }
    const {spells, targets} = populateWarCasterModal();
    if (!spells.length){
      localToast("No War Caster eligible prepared spells.");
      return;
    }
    if (!targets.length){
      localToast("No enemy targets available.");
      return;
    }
    setWarCasterModalOpen(true);
  }

  function buildActionPickerItem(entry, sourceUnit = null){
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "action-picker-item";
    const entryUnitCid = normalizeCid(entry?.sourceCid, "actionPicker.entry.sourceCid") ?? activeControlledUnitCid();
    const entryUnit = sourceUnit || (entryUnitCid === null ? null : getUnitByCid(entryUnitCid));
    const actionRemaining = Number(entryUnit?.action_remaining || 0);
    const bonusRemaining = Number(entryUnit?.bonus_action_remaining || 0);
    const reactionRemaining = Number(entryUnit?.reaction_remaining || 0);
    const spellCastRemaining = Number(entryUnit?.spell_cast_remaining || 0);
    const isBeguilingMagicEntry = entry.kind === "beguiling_magic";
    let disabledReason = "";
    if (isBeguilingMagicEntry){
      const windowS = getClaimedBeguilingMagicWindowSeconds();
      if (windowS <= 0){
        disabledReason = "Beguiling Magic window expired.";
      }
    }
    if (entry.spend === "action" && actionRemaining <= 0){
      disabledReason = "No actions left, matey.";
    } else if (entry.spend === "bonus" && bonusRemaining <= 0){
      disabledReason = "No bonus actions left, matey.";
    } else if (entry.spend === "reaction" && reactionRemaining <= 0){
      disabledReason = "No reactions left, matey.";
    }
    if (!disabledReason && isSpellActionEntry(entry) && (entry.spend === "action" || entry.spend === "bonus") && spellCastRemaining <= 0){
      disabledReason = "You already cast a spell this turn.";
    }
    const isDisabled = !!disabledReason;
    btn.disabled = isDisabled;
    btn.setAttribute("aria-disabled", isDisabled ? "true" : "false");
    btn.classList.toggle("is-disabled", isDisabled);
    btn.toggleAttribute("data-disabled", isDisabled);
    if (isDisabled){
      btn.setAttribute("data-disabled-reason", disabledReason);
      btn.title = disabledReason;
    } else {
      btn.removeAttribute("data-disabled-reason");
      btn.removeAttribute("title");
    }
    const nameEl = document.createElement("div");
    nameEl.className = "action-picker-name";
    const spendLabel = entry.spend === "bonus" ? "Bonus Action" : (entry.spend === "reaction" ? "Reaction" : "Action");
    nameEl.textContent = `${entry.name} (${spendLabel})`;
    btn.appendChild(nameEl);
    if (entry.description){
      const descEl = document.createElement("div");
      descEl.className = "action-picker-meta";
      descEl.textContent = entry.description;
      btn.appendChild(descEl);
    }
    if (entry.spend === "reaction"){
      const prefWrap = document.createElement("div");
      prefWrap.className = "action-picker-meta";
      const currentMode = reactionModeForEntry(entry, entryUnitCid);
      const select = document.createElement("select");
      ["off", "ask", "auto"].forEach((mode) => {
        const opt = document.createElement("option");
        opt.value = mode;
        opt.textContent = mode.toUpperCase();
        if (mode === currentMode) opt.selected = true;
        select.appendChild(opt);
      });
      select.addEventListener("change", (ev) => {
        if (entry.kindKey){
          setReactionPref(entryUnitCid, entry.kindKey, String(ev.target.value || "ask"));
        }
      });
      prefWrap.textContent = "Mode: ";
      prefWrap.appendChild(select);
      btn.appendChild(prefWrap);
    }
    btn.addEventListener("click", () => {
      hideActionPicker();
      const actionName = normalizeLowerValue(entry?.name);
      const normalizedActionKey = String(entry?.name || "").toLowerCase().replace(/[^a-z0-9]+/g, " ").trim();
      const actionCid = activeControlledUnitCid();
      const reactionCid = normalizeCid(entry?.sourceCid, "actionPicker.reaction.sourceCid") ?? reactionControlledUnitCid();
      const performCid = entry.spend === "reaction" ? reactionCid : actionCid;
      const activeUnit = actionCid === null ? null : getUnitByCid(actionCid);
      const performUnit = performCid === null ? null : getUnitByCid(performCid);
      const claimedUnit = getClaimedUnit();
      const claimedName = normalizeLowerValue(claimedUnit?.name);
      const isJohnTwilight = claimedName === "john twilight" || claimedName.startsWith("john twilight (");
      const isManifestEcho = actionName === "summon johns echo" || actionName === "manifest echo";
      const isSwapEcho = actionName === "swap with johns echo" || actionName === "swap with echo";
      if (isJohnTwilight && isManifestEcho){
        if (claimedCid == null || !claimedUnit || !claimedUnit.pos){
          localToast("Could not find caster position, matey.");
          return;
        }
        pendingSummonPlacement = {
          mode: "echo_summon",
          actionType: "bonus_action",
          summonQuantity: 1,
          positions: [],
          casterPos: {col: Number(claimedUnit.pos.col), row: Number(claimedUnit.pos.row)},
          maxRangeFt: 15,
        };
        rebuildSummonValidCells();
        updateSummonPlacementBanner();
        draw();
        localToast("Echo placement started. Choose a valid highlighted square.");
        return;
      }
      if (isJohnTwilight && isSwapEcho){
        if (claimedCid == null) return;
        const msg = {type: "echo_swap", cid: claimedCid};
        if (isPlanning){
          planningMutate(msg);
          draw();
          updateHud();
        }
        send(msg);
        return;
      }
      if (entry.kind === "war_caster"){
        openWarCasterModal();
        return;
      }
      if (entry.kind === "beguiling_magic"){
        beginBeguilingMagicFlow(false);
        return;
      }
      if (entry.kind === "lay_on_hands"){
        const me = getClaimedUnit();
        if (!me || !me.pos){
          localToast("Claim a character first, matey.");
          return;
        }
        pendingLayOnHandsTargeting = {
          poolCurrent: Number(getPlayerResourcePools(getClaimedPlayerName()).find((pool) => normalizeLowerValue(pool?.id) === "lay_on_hands")?.current || 0),
          poolMax: Number(getPlayerResourcePools(getClaimedPlayerName()).find((pool) => normalizeLowerValue(pool?.id) === "lay_on_hands")?.max || 0),
          rangeFt: 5,
        };
        pendingLayOnHandsResolve = null;
        setLayOnHandsOverlayOpen(false);
        setAttackOverlayMode(true);
        localToast("Select a creature within 5 ft for Lay on Hands.");
        draw();
        return;
      }
      if (entry.spend === "reaction" && actionName === "opportunity attack"){
        const unit = getClaimedUnit();
        if (Number(unit?.reaction_remaining || 0) <= 0){
          localToast("No reactions left, matey.");
          return;
        }
        const meleeWeapon = getPrimaryMeleeAttackWeapon();
        if (!meleeWeapon){
          localToast("No melee weapon configured for opportunity attacks.");
          return;
        }
        const meleeWeaponId = String(meleeWeapon.id || "").trim();
        if (meleeWeaponId){
          const preferredValue = `${meleeWeaponId}|one`;
          const fallbackValue = `${meleeWeaponId}|two`;
          const mainhandOptions = buildMainhandOptions(getClaimedWeapons());
          selectedMainhandWeaponValue = mainhandOptions.some((entry) => entry.value === preferredValue)
            ? preferredValue
            : (mainhandOptions.some((entry) => entry.value === fallbackValue) ? fallbackValue : selectedMainhandWeaponValue);
          refreshWeaponSelectors();
        }
        pendingOpportunityAttack = true;
        setAttackOverlayMode(true);
        localToast(`Opportunity attack ready with ${String(meleeWeapon.name || "weapon")}. Pick an enemy target.`);
        return;
      }
      if (entry.kind === "reaction_spell"){
        const preset = spellPresetBySlug.get(getSpellKey(entry.spellSlug))
          || cachedSpellPresets.find((candidate) => getSpellKey(getPresetSlug(candidate)) === getSpellKey(entry.spellSlug));
        if (!preset){
          localToast("Could not find that spell preset, matey.");
          return;
        }
        if (castPresetInput){
          castPresetInput.value = normalizeTextValue(preset.name);
        }
        applySpellPreset(preset);
        pendingSpellActionType = "reaction";
        setCastOverlayOpen(true);
        return;
      }
      if (normalizedActionKey === "patient defense disengage"){
        sendMonkFocusAction("monk_patient_defense", "free");
        return;
      }
      if (entry.spend === "bonus" && normalizedActionKey.startsWith("bardic inspiration")){
        startBardicInspirationGrantTargeting(entry);
        return;
      }
      if (entry.spend === "bonus" && normalizedActionKey.startsWith("mantle of inspiration")){
        startMantleOfInspirationTargeting(entry);
        return;
      }
      if (normalizedActionKey === "patient defense disengage dodge"){
        sendMonkFocusAction("monk_patient_defense", "focus");
        return;
      }
      if (normalizedActionKey === "step of the wind dash"){
        sendMonkFocusAction("monk_step_of_wind", "free");
        return;
      }
      if (normalizedActionKey === "step of the wind dash disengage"){
        sendMonkFocusAction("monk_step_of_wind", "focus");
        return;
      }
      if (normalizedActionKey === "martial arts bonus unarmed strike"){
        startMonkBonusAttackSequence("martial_arts", 1, 0);
        return;
      }
      if (normalizedActionKey === "flurry of blows"){
        const profile = getPlayerProfile(getClaimedPlayerName());
        const monkLevel = getMonkLevelFromProfile(profile);
        startMonkBonusAttackSequence("flurry", monkLevel >= 10 ? 3 : 2, 1);
        return;
      }
      if (normalizedActionKey === "uncanny metabolism"){
        sendMonkFocusAction("monk_uncanny_metabolism", "");
        return;
      }
      if (isSpellActionEntry(entry)){
        pendingSpellActionType = entry.spend === "bonus" ? "bonus_action" : (entry.spend === "reaction" ? "reaction" : "action");
        setCastOverlayOpen(true);
        return;
      }
      if (entry.spend === "action" && claimedUnit?.is_wild_shaped){
        const wildShapeWeapon = weaponFromWildShapeAction(entry, claimedUnit);
        if (wildShapeWeapon){
          pendingActionAttackWeapon = {
            ...wildShapeWeapon,
            attack_count: Number.isFinite(Number(entry.attack_count)) ? Math.max(1, Math.floor(Number(entry.attack_count))) : Number(wildShapeWeapon.attack_count || 1),
            resolve_prompt: String(entry.resolve_prompt || wildShapeWeapon.resolve_prompt || "").trim(),
          };
          setAttackOverlayMode(true);
          localToast(pendingActionAttackWeapon.resolve_prompt || `Pick a target for ${String(wildShapeWeapon.name || "attack")}.`);
          return;
        }
      }
      if (actionName === "wild shape"){
        if (!isClaimedUnitDruid()){
          localToast("Only Druids level 2+ can use Wild Shape.");
          return;
        }
        setWildShapePickOverlayOpen(true);
        return;
      }
      if (actionName === "end wildshape early"){
        if (claimedCid == null){
          localToast("Claim a character first, matey.");
          return;
        }
        send({type:"wild_shape_revert", cid: claimedCid});
        return;
      }
      if (performCid === null || !performUnit) return;
      const msg = {
        type: "perform_action",
        cid: performCid,
        spend: entry.spend,
        action: entry.name,
      };
      if (isPlanning){
        planningMutate(msg);
        draw();
        updateHud();
      }
      send(msg);
    });
    return btn;
  }

  function openActionPicker(mode){
    const unitCid = mode === "reaction" ? reactionControlledUnitCid() : activeControlledUnitCid();
    const unit = unitCid === null ? null : getUnitByCid(unitCid);
    if (!unit || unitCid === null){
      localToast("Claim a character first, matey.");
      return;
    }
    if (!actionPickerList || !actionPickerTitle){
      return;
    }
    const actions = normalizeActionList(unit.actions, "action");
    const bonusActions = normalizeActionList(unit.bonus_actions, "bonus_action");
    const reactions = normalizeActionList(unit.reactions, "reaction");
    const items = [];
    if (mode === "action"){
      actionPickerTitle.textContent = "Choose an Action";
      actions.forEach((entry) => items.push({...entry, spend: "action"}));
    } else if (mode === "bonus"){
      actionPickerTitle.textContent = "Choose a Bonus Action";
      bonusActions.forEach((entry) => items.push({...entry, spend: "bonus"}));
      const layOnHandsPool = getPlayerResourcePools(getClaimedPlayerName()).find((entry) => normalizeLowerValue(entry?.id) === "lay_on_hands");
      if (layOnHandsPool){
        items.push({
          name: "Lay on Hands",
          description: "Select a creature within 5 ft, then heal HP or spend 5 points to remove Poisoned.",
          spend: "bonus",
          kind: "lay_on_hands",
        });
      }
      const windowS = getClaimedBeguilingMagicWindowSeconds();
      if (windowS > 0){
        items.push({
          name: `Beguiling Magic (${formatShortDuration(windowS)})`,
          description: "Free rider after an eligible spell; choose Charmed or Frightened, then select a target within 60 ft.",
          spend: "free",
          kind: "beguiling_magic",
        });
      }
    } else if (mode === "reaction"){
      actionPickerTitle.textContent = "Reaction Manager";
      reactions.forEach((entry) => items.push({...entry, spend: "reaction", kindKey: normalizeLowerValue(entry.name) === "opportunity attack" ? "opportunity_attack" : normalizeLowerValue(entry.name).replace(/\s+/g, "_")}));
      getPreparedReactionSpellEntries().forEach((entry) => items.push({...entry, kindKey:"reaction_spell"}));
      if (playerHasWarCasterFeat()){
        items.push({
          name: "War Caster Spell",
          description: "Cast a qualifying action spell as a reaction against a single enemy target.",
          spend: "reaction",
          kind: "war_caster",
          kindKey: "war_caster",
        });
      }
    } else {
      actionPickerTitle.textContent = "Choose Dash";
      const dashEntries = (list, spend) => {
        list.forEach((entry) => {
          if (normalizeLowerValue(entry.name) === "dash"){
            items.push({...entry, spend});
          }
        });
      };
      dashEntries(actions, "action");
      dashEntries(bonusActions, "bonus");
    }
    actionPickerList.textContent = "";
    if (!items.length){
      const empty = document.createElement("div");
      empty.className = "action-picker-meta";
      empty.textContent = "No available actions.";
      actionPickerList.appendChild(empty);
    } else {
      items.forEach((entry) => {
        actionPickerList.appendChild(buildActionPickerItem({...entry, sourceCid: unitCid}, unit));
      });
    }
    showActionPicker();
  }

  function clearTurnModalAttention(){
    if (turnModalCountdownInterval){
      clearInterval(turnModalCountdownInterval);
      turnModalCountdownInterval = null;
    }
    if (turnModalAttentionTimeout){
      clearTimeout(turnModalAttentionTimeout);
      turnModalAttentionTimeout = null;
    }
  }

  function updateTurnModalCountdown(seconds){
    if (!turnModalCountdown) return;
    turnModalCountdownValue = Math.max(0, Number(seconds) || 0);
    turnModalCountdown.textContent = `Alert repeats in ${turnModalCountdownValue}s`;
  }

  function triggerTurnAttentionFlash(){
    if (!turnFlash) return;
    turnFlash.classList.remove("active");
    void turnFlash.offsetWidth;
    turnFlash.classList.add("active");
  }

  function hideTurnModal(){
    clearTurnModalAttention();
    if (turnModalCountdown){
      updateTurnModalCountdown(5);
    }
    if (!turnModal) return;
    turnModal.classList.remove("show");
    turnModal.setAttribute("aria-hidden", "true");
  }

  function playTurnAlert(volume = 0.78){
    const nextVolume = Number.isFinite(Number(volume)) ? Math.min(1, Math.max(0, Number(volume))) : 0.78;
    turnAlertAudio.volume = nextVolume;
    turnAlertAudio.currentTime = 0;
    turnAlertAudio.play().catch((err) => {
      console.warn("Turn alert audio failed to play.", err);
    }).finally(() => {
      turnAlertAudio.volume = 0.78;
    });
  }

  function startTurnModalCountdown(){
    clearTurnModalAttention();
    updateTurnModalCountdown(5);
    turnModalAttentionTimeout = setTimeout(() => {
      turnModalAttentionTimeout = null;
      if (!turnModal || !turnModal.classList.contains("show")) return;
      playTurnAlert(1);
      triggerTurnAttentionFlash();
    }, 5000);
    turnModalCountdownInterval = setInterval(() => {
      if (!turnModal || !turnModal.classList.contains("show")){
        clearTurnModalAttention();
        return;
      }
      updateTurnModalCountdown(turnModalCountdownValue - 1);
      if (turnModalCountdownValue <= 0 && turnModalCountdownInterval){
        clearInterval(turnModalCountdownInterval);
        turnModalCountdownInterval = null;
      }
    }, 1000);
  }

  function playKoAlert(){
    koAlertAudio.currentTime = 0;
    koAlertAudio.play().catch((err) => {
      console.warn("KO audio failed to play.", err);
    });
  }

  function fireVibrate(){
    if (!lastVibrateSupported) return false;
    const didVibrate = vibrate([200, 120, 200]);
    if (!didVibrate){
      lastVibrateSupported = false;
      console.debug("Vibration blocked or unsupported.");
    }
    return didVibrate;
  }

  async function unlockTurnAudio(){
    userHasInteracted = true;
    try {
      turnAlertAudio.muted = true;
      turnAlertAudio.currentTime = 0;
      await turnAlertAudio.play();
      turnAlertAudio.pause();
      turnAlertAudio.currentTime = 0;
      turnAlertAudio.muted = false;
      audioUnlocked = true;
      localToast('Turn sounds enabled.');
    } catch (err){
      turnAlertAudio.muted = false;
      console.warn('Turn alert audio unlock failed.', err);
    }
    if (pendingTurnAlert){
      pendingTurnAlert = false;
      playTurnAlert();
    }
    if (pendingVibrate){
      fireVibrate();
      pendingVibrate = false;
    }
  }

  function handleUserGesture(){
    userHasInteracted = true;
    if (!notificationPermissionAsked){
      maybeRequestNotificationPermission();
    }
    if (!audioUnlocked){
      unlockTurnAudio();
      return;
    }
    if (pendingTurnAlert){
      pendingTurnAlert = false;
      playTurnAlert();
    }
    if (pendingVibrate){
      fireVibrate();
      pendingVibrate = false;
    }
  }

  async function maybeNotifyTurnStart(){
    if (!("Notification" in window)) return;
    if (Notification.permission !== "granted") return;
    const title = "It's your turn!";
    const body = "Act now in Initiative Tracker.";
    const options = {
      body,
      tag: "turn-alert",
      renotify: true,
      data: { url: "/" },
    };
    try {
      const registration = swRegistration || ("serviceWorker" in navigator ? await navigator.serviceWorker.ready : null);
      if (registration && typeof registration.showNotification === "function"){
        await registration.showNotification(title, options);
        window.setTimeout(() => {
          registration.getNotifications({ tag: "turn-alert" }).then((notifs) => {
            notifs.forEach((entry) => entry.close());
          }).catch((err) => {
            console.debug("Turn notification auto-close failed.", err);
          });
        }, turnNotificationAutoCloseMs);
        return;
      }
    } catch (err){
      console.warn("Service-worker turn notification failed; falling back to page notification.", err);
    }
    try {
      const notification = new Notification(title, options);
      notification.onclick = () => {
        window.focus();
        notification.close();
      };
      window.setTimeout(() => {
        notification.close();
      }, turnNotificationAutoCloseMs);
    } catch (err){
      console.warn("Turn notification failed.", err);
    }
  }

  async function maybeRequestNotificationPermission(){
    if (notificationPermissionAsked) return;
    notificationPermissionAsked = true;
    localStorage.setItem(notificationPermissionAskedKey, "1");
    if (!("Notification" in window)) return;
    if (Notification.permission !== "default") return;
    try {
      await Notification.requestPermission();
    } catch (err){
      console.warn("Notification permission prompt failed.", err);
    }
  }

  function showTurnModal(){
    if (!turnModal) return;
    if (focusTabOnTurn){
      try { window.focus(); } catch (err){ console.debug('window.focus blocked.', err); }
    }
    maybeNotifyTurnStart();
    if (document.visibilityState === "hidden") return;
    turnModal.classList.add("show");
    turnModal.setAttribute("aria-hidden", "false");
    startTurnModalCountdown();
    if (audioUnlocked){
      playTurnAlert(0.78);
    } else {
      pendingTurnAlert = true;
    }
    if (userHasInteracted || navigator.userActivation?.hasBeenActive){
      fireVibrate();
    } else {
      pendingVibrate = true;
    }
  }

  function maybeShowTurnAlert(){
    if (!state || !claimedCid) return;
    const activeCid = state.active_cid;
    const roundRaw = state.round_num;
    const round = Number.isFinite(Number(roundRaw)) ? Number(roundRaw) : roundRaw;
    const activeCidValue = normalizeCid(activeCid, "turnAlert.activeCid");
    const lastActiveCidValue = normalizeCid(lastActiveCid, "turnAlert.lastActiveCid");
    const lastRound = Number.isFinite(Number(lastTurnRound)) ? Number(lastTurnRound) : lastTurnRound;
    const isNowMyTurn = activeCidValue !== null && activeCidValue === claimedCid;
    const activeChanged = activeCidValue !== lastActiveCidValue;
    const roundChanged = round !== lastRound;
    if (!turnAlertPrimed){
      lastActiveCid = activeCid;
      lastTurnRound = round;
      turnAlertPrimed = true;
      return;
    }
    if (isNowMyTurn && (activeChanged || roundChanged)){
      showTurnModal();
    }
    lastActiveCid = activeCid;
    lastTurnRound = round;
  }

  const planningFreezeTypes = new Set([
    "state",
    "unit_update",
    "units_snapshot",
    "terrain_update",
    "terrain_patch",
    "grid_update",
    "aoe_patch",
  ]);

  let uiFlushQueued = false;
  let uiNeedsDraw = false;
  let uiNeedsHud = false;
  let uiNeedsMount = false;
  let uiNeedsTurnAlert = false;
  let uiNeedsAutoCenter = false;

  function scheduleUiFlush({draw = false, hud = false, mount = false, turnAlert = false, autoCenter = false} = {}){
    uiNeedsDraw = uiNeedsDraw || !!draw;
    uiNeedsHud = uiNeedsHud || !!hud;
    uiNeedsMount = uiNeedsMount || !!mount;
    uiNeedsTurnAlert = uiNeedsTurnAlert || !!turnAlert;
    uiNeedsAutoCenter = uiNeedsAutoCenter || !!autoCenter;
    if (uiFlushQueued){
      return;
    }
    uiFlushQueued = true;
    if (document.visibilityState === "hidden"){
      window.setTimeout(() => {
        flushUiUpdates();
      }, 0);
      return;
    }
    requestAnimationFrame(flushUiUpdates);
  }

  function flushUiUpdates(){
    const needsHud = uiNeedsHud;
    const needsDraw = uiNeedsDraw;
    const needsMount = uiNeedsMount;
    const needsTurnAlert = uiNeedsTurnAlert;
    const needsAutoCenter = uiNeedsAutoCenter;
    uiFlushQueued = false;
    uiNeedsDraw = false;
    uiNeedsHud = false;
    uiNeedsMount = false;
    uiNeedsTurnAlert = false;
    uiNeedsAutoCenter = false;
    const isHidden = document.visibilityState === "hidden";
    if (isHidden){
      if (needsTurnAlert){
        maybeShowTurnAlert();
      }
      return;
    }
    if (needsHud){
      updateHud();
    }
    if (needsDraw){
      draw();
    }
    if (needsMount){
      updateMountControls();
    }
    if (needsTurnAlert){
      maybeShowTurnAlert();
    }
    if (needsAutoCenter){
      autoCenterOnJoin(false);
    }
  }

  function connect(){
    if (!wsUrl){
      setConn(false, "Disconnected");
      scheduleReconnect(1000);
      return;
    }
    try {
      ws = new WebSocket(wsUrl);
    } catch (err){
      console.warn("WebSocket connect failed.", err);
      setConn(false, "Disconnected");
      scheduleReconnect(1000);
      return;
    }
    ws.addEventListener("open", () => {
      reconnecting = false;
      setConn(true, "Connected");
      if (!isMapView){
        send({type:"client_hello", client_id: clientId});
      }
      send({type:"planning_hello"});
      send({type:"grid_request"});
      send({type:"terrain_request"});
      refreshMapViewLogPolling();
    });
    ws.addEventListener("close", (ev) => {
      battleLogSubscribed = false;
      const wasReconnect = reconnecting;
      reconnecting = false;
      const serverError = ev && ev.code === 1011;
      if (serverError){
        setConn(false, "Server error while preparing state.");
        scheduleReconnect(1000);
      } else if (wasReconnect){
        setConn(false, "Reconnecting");
        scheduleReconnect(200);
      } else {
        setConn(false, "Disconnected");
        scheduleReconnect(1000);
      }
    });
    ws.addEventListener("message", (ev) => {
      let msg = null;
      try { msg = JSON.parse(ev.data); } catch(e){ return; }
      if (isPlanning && planningSnapshotLocked && planningFreezeTypes.has(msg.type)){
        return;
      }
      if (msg.type === "planning_chat") {
        appendPlanningChatMessage(msg);
        return;
      }
      if (msg.type === "static_data"){
        // Merge static data into state (sent once on connection)
        if (!state){ state = {}; }
        if (Object.prototype.hasOwnProperty.call(msg || {}, "pcs") || Object.prototype.hasOwnProperty.call(msg || {}, "claimable")){
          lastPcList = msg.pcs || msg.claimable || [];
        }
        markClaimMessageSeen("static_data");
        logClaimMessage("static_data", lastPcList);
        if (msg.data && typeof msg.data === "object"){
          if (Array.isArray(msg.data.spell_presets)){
            state.spell_presets = msg.data.spell_presets;
            requestAnimationFrame(() => {
              updateSpellPresetOptions(state?.spell_presets || []);
            });
          }
          if (msg.data.player_spells && typeof msg.data.player_spells === "object"){
            state.player_spells = msg.data.player_spells;
          }
          if (msg.data.player_profiles && typeof msg.data.player_profiles === "object"){
            state.player_profiles = msg.data.player_profiles;
          }
          if (msg.data.resource_pools && typeof msg.data.resource_pools === "object"){
            state.resource_pools = msg.data.resource_pools;
          }
          if (Array.isArray(msg.data.monster_choices)){
            state.monster_choices = msg.data.monster_choices;
          }
          }
        updateClaimOverlay();
      } else if (msg.type === "preset"){
        if (msg.preset && typeof msg.preset === "object"){
          applyGuiPreset(msg.preset, {persist: true});
          persistLocalPreset(msg.preset);
        } else {
          setPresetStatus("No preset saved.", 2500);
        }
      } else if (msg.type === "preset_saved"){
        setPresetStatus("Saved!");
      } else if (msg.type === "preset_error"){
        setPresetStatus(msg.error || "Preset error.", 2500);
      } else if (msg.type === "state"){
        stateUpdateCounter += 1;
        const oldSpellPresets = state?.spell_presets;
        const oldPlayerSpells = state?.player_spells;
        const oldPlayerProfiles = state?.player_profiles;
        const oldMonsterChoices = state?.monster_choices;
        const oldResourcePools = state?.resource_pools;
        const oldGrid = state?.grid;
        const oldTerrain = state?.rough_terrain;
        const oldObstacles = state?.obstacles;
        state = (msg.state && typeof msg.state === "object") ? msg.state : {};
        // Preserve static data from previous state if not in new message
        // Only preserve if old values exist and new values are undefined (not just missing)
        if (!state.spell_presets && Array.isArray(oldSpellPresets)){
          state.spell_presets = oldSpellPresets;
        }
        if (!state.player_spells && oldPlayerSpells && typeof oldPlayerSpells === "object"){
          state.player_spells = oldPlayerSpells;
        }
        if (!state.player_profiles && oldPlayerProfiles && typeof oldPlayerProfiles === "object"){
          state.player_profiles = oldPlayerProfiles;
        }
        if (!state.monster_choices && Array.isArray(oldMonsterChoices)){
          state.monster_choices = oldMonsterChoices;
        }
        if (!state.resource_pools && oldResourcePools && typeof oldResourcePools === "object"){
          state.resource_pools = oldResourcePools;
        }
        if (!state.grid && oldGrid){
          state.grid = oldGrid;
        }
        if (!state.rough_terrain && Array.isArray(oldTerrain)){
          state.rough_terrain = oldTerrain;
        }
        if (!state.obstacles && Array.isArray(oldObstacles)){
          state.obstacles = oldObstacles;
        }
        let movementTerrainChanged = false;
        if (state.rough_terrain !== oldTerrain){
          roughTerrainVersion += 1;
          cachedRoughMapVersion = -1;
          movementTerrainChanged = true;
        }
        if (state.obstacles !== oldObstacles){
          obstacleVersion += 1;
          cachedObstacleSetVersion = -1;
          movementTerrainChanged = true;
        }
        if (movementTerrainChanged){
          invalidateMovementRangeCache();
        }
        if (isMapView){
          claimedCid = null;
          claimStatus = "unclaimed";
        }
        if (!Array.isArray(state.spell_presets)){
          state.spell_presets = [];
        }
        requestAnimationFrame(() => {
          updateSpellPresetOptions(state.spell_presets);
        });
        if (Object.prototype.hasOwnProperty.call(msg || {}, "pcs") || Object.prototype.hasOwnProperty.call(msg || {}, "claimable")){
          lastPcList = msg.pcs || msg.claimable || [];
        }
        markClaimMessageSeen("state");
        logClaimMessage("state", lastPcList);
        maybeAutoClaimFromState(msg, lastPcList);
        updateWaitingOverlay();
        scheduleUiFlush({hud:true, draw:true, mount:true, turnAlert:true, autoCenter:true});
        
        // Use server-authoritative claim state from "you" field
        if (msg.you && "claimed_cid" in msg.you){
          applyServerClaim(msg.you.claimed_cid, msg.you.claimed_name, msg.you.claim_rev);
          sendReactionPrefsUpdate();
        } else {
          // Fallback to old logic if "you" field not present (backwards compatibility)
          const claimsMap = (state && typeof state.claims === "object" && state.claims) ? state.claims : {};
          const serverClaimedCid = Object.entries(claimsMap).reduce((found, entry) => {
            if (found !== null && found !== undefined) return found;
            const [cidKey, ownerClientId] = entry;
            if (String(ownerClientId || "") !== clientId) return null;  // Not mine, continue searching
            return normalizeCid(cidKey, "state.claimsCid");
          }, null);
          if (serverClaimedCid !== null && serverClaimedCid !== undefined){
            claimedCid = serverClaimedCid;
            claimStatus = "claimed";
            clearClaimInFlight();
            const claimedName = getClaimablePcName(claimedCid, lastPcList || []) || `#${claimedCid}`;
            if (meEl){
              setMeLabel({name: claimedName}, false);
            }
          } else if (!claimInFlight){
            claimedCid = null;
            claimStatus = "unclaimed";
            if (meEl){
              setMeLabel(null, false);
            }
          }
        }
        
        if (!claimedCid){
          showNoOwnedPcToast(msg.pcs || msg.claimable || []);
        }
        refreshTurnAlertStatus();
        if (isPlanning){
          planningSnapshotLocked = true;
        }
        handleAutoClaimStateUpdate();
      } else if (msg.type === "turn_update"){
        if (!state){ state = {}; }
        if ("active_cid" in msg){
          state.active_cid = msg.active_cid;
        }
        if ("round_num" in msg){
          state.round_num = msg.round_num;
        }
        if ("turn_order" in msg){
          state.turn_order = msg.turn_order;
        }
        scheduleUiFlush({hud:true, draw:true, mount:true, turnAlert:true});
      } else if (msg.type === "units_snapshot"){
        if (!state){ state = {}; }
        state.units = Array.isArray(msg.units) ? msg.units : [];
        scheduleUiFlush({hud:true, draw:true, mount:true});
      } else if (msg.type === "unit_update"){
        const updates = Array.isArray(msg.updates) ? msg.updates : [];
        if (updates.length){
          applyUnitUpdates(updates);
          scheduleUiFlush({hud:true, draw:true, mount:true});
        }
      } else if (msg.type === "force_claim"){
        if (isMapView) return;
        const applied = applyServerClaim(
          msg.you && Object.prototype.hasOwnProperty.call(msg.you, "claimed_cid") ? msg.you.claimed_cid : msg.cid,
          msg.you?.claimed_name,
          msg.you?.claim_rev ?? msg.claim_rev,
        );
        if (applied && claimedCid !== null && claimedCid !== undefined){
          autoCenterOnJoin();
          if (spellbookOverlay?.classList.contains("show")){
            syncSpellbookClaimedPlayer();
            renderSpellbook();
          }
        }
        updateHud();
        localToast(msg.text || "Assigned by the DM.");
        refreshTurnAlertStatus();
        checkAutoClaimResolved();
      } else if (msg.type === "force_unclaim"){
        if (isMapView) return;
        applyServerClaim(null, null, msg.claim_rev);
        shownNoOwnedToast = false;
        showNoOwnedPcToast(msg.pcs || lastPcList || []);
        if (spellbookOverlay?.classList.contains("show")){
          renderSpellbook();
        }
        refreshTurnAlertStatus();
        updateHud();
        handleAutoClaimFailure();
      } else if (msg.type === "claim_ack"){
        if (isMapView) return;
        if (msg.ok === false){
          claimStatus = "unclaimed";
          clearClaimInFlight();
        }
        if (msg.you && Object.prototype.hasOwnProperty.call(msg.you, "claimed_cid")){
          applyServerClaim(msg.you.claimed_cid, msg.you.claimed_name, msg.you.claim_rev ?? msg.claim_rev);
        } else {
          applyServerClaim(msg.claimed_cid, null, msg.claim_rev);
        }
        if (claimedCid !== null && claimedCid !== undefined){
          autoCenterOnJoin();
        }
        refreshTurnAlertStatus();
        updateHud();
      } else if (msg.type === "unclaim_ack"){
        if (isMapView) return;
        applyServerClaim(null, null, msg.claim_rev);
        refreshTurnAlertStatus();
        updateHud();
      } else if (msg.type === "command_result"){
        const results = Array.isArray(msg.results) ? msg.results : [];
        const applied = results.filter((entry) => entry && entry.applied).map((entry) => String(entry.target_name || `#${entry.target_cid}`));
        if (applied.length){
          localToast(`Command ${String(msg.command_option || "")} applied to ${applied.join(", ")}.`);
        } else {
          localToast("Command resolved.");
        }
        scheduleUiFlush({hud:true, draw:true, mount:true});
      } else if (msg.type === "bardic_inspiration_use_result"){
        const roll = Number(msg.roll || 0);
        if (Number.isFinite(roll) && roll > 0){
          localToast(`Bardic Inspiration die rolled ${Math.floor(roll)}.`);
        }
        scheduleUiFlush({hud:true, draw:true, mount:true});
      } else if (msg.type === "toast"){
        localToast(msg.text || "");
      } else if (msg.type === "mount_prompt"){
        pendingMountRequestId = msg.request_id || null;
        if (mountPromptBody){
          mountPromptBody.textContent = `${msg.rider_name || "Someone"} wants to mount you. OK?`;
        }
        if (mountPromptModal){
          mountPromptModal.classList.add("show");
          mountPromptModal.setAttribute("aria-hidden", "false");
        }
      } else if (msg.type === "echo_tether_prompt") {
        pendingEchoTetherRequestId = msg.request_id || null;
        if (echoTetherPromptBody){
          echoTetherPromptBody.textContent = String(msg.text || "Warning. Moving here will destroy your echo. Proceed?");
        }
        if (echoTetherPromptModal){
          echoTetherPromptModal.classList.add("show");
          echoTetherPromptModal.setAttribute("aria-hidden", "false");
        }
      } else if (msg.type === "initiative_prompt"){
        const targetCid = Number(msg.cid);
        pendingInitiativeCid = Number.isFinite(targetCid) ? targetCid : claimedCid;
        if (initiativePromptBody){
          const who = typeof msg.name === "string" && msg.name.trim() ? msg.name.trim() : "your character";
          initiativePromptBody.textContent = `Roll initiative for ${who} and enter your total.`;
        }
        if (initiativePromptInput){
          initiativePromptInput.value = "";
        }
        if (initiativePromptModal){
          initiativePromptModal.classList.add("show");
          initiativePromptModal.setAttribute("aria-hidden", "false");
        }
      } else if (msg.type === "battle_log"){
        const lines = Array.isArray(msg.lines) ? msg.lines : [];
        dmLogLines = lines;
        trimDmLogLines();
        renderBattleLogOverlay(dmLogLines);
        const units = state?.units || [];
        const now = Date.now();
        dmLogLines.slice(-4).forEach((line)=>{ const text=String(line||""); const unit=units.find(u=>text.includes(u.name)); if (unit){ dmHighlightUntil.set(String(unit.cid), now+2200); }});
        renderDmLogPanel();
      } else if (msg.type === "battle_log_append"){
        const lines = Array.isArray(msg.lines) ? msg.lines : [];
        if (lines.length){
          dmLogLines = dmLogLines.concat(lines);
          trimDmLogLines();
          renderBattleLogOverlay(dmLogLines);
          const units = state?.units || [];
          const now = Date.now();
          lines.slice(-4).forEach((line)=>{ const text=String(line||""); const unit=units.find(u=>text.includes(u.name)); if (unit){ dmHighlightUntil.set(String(unit.cid), now+2200); }});
          renderDmLogPanel();
        }
      } else if (msg.type === "reaction_offer"){
        pendingReactionOffer = msg;
        pendingReactionRequestId = String(msg.request_id || "");
        if (reactionOfferBody){
          const src = getUnitByCid(msg.source_cid);
          const trg = getUnitByCid(msg.target_cid);
          const srcName = src?.name || `#${msg.source_cid}`;
          const trgName = trg?.name || `#${msg.target_cid}`;
          if (msg.trigger === "leave_reach"){
            reactionOfferBody.textContent = `${srcName} is leaving your reach.`;
          } else if (msg.trigger === "sentinel_disengage"){
            reactionOfferBody.textContent = `${srcName} disengaged within Sentinel range.`;
          } else {
            reactionOfferBody.textContent = `${srcName} hit ${trgName} within Sentinel range.`;
          }
        }
        if (reactionOfferList){
          reactionOfferList.textContent = "";
          const choices = Array.isArray(msg.choices) ? msg.choices : [];
          choices.forEach((choice)=>{
            const btn = document.createElement("button");
            btn.className = "btn action-picker-item";
            btn.type = "button";
            btn.textContent = String(choice.label || choice.kind || "Reaction");
            btn.addEventListener("click", ()=>{
              send({type:"reaction_response", cid: claimedCid, request_id: pendingReactionRequestId, choice: String(choice.kind || "")});
              if (String(choice.kind||"") === "opportunity_attack"){
                const target = getUnitByCid(msg.target_cid);
                const weapon = getPrimaryMeleeAttackWeapon(getClaimedUnit());
                if (target && weapon){
                  pendingOpportunityAttack = true;
                  openAttackResolveModal(target, weapon);
                }
              } else if (String(choice.kind||"") === "war_caster"){
                populateWarCasterModal();
                if (warCasterTargetSelect){ warCasterTargetSelect.value = String(msg.target_cid); }
                setWarCasterModalOpen(true);
              }
              if (reactionOfferModal){ reactionOfferModal.classList.remove("show"); reactionOfferModal.setAttribute("aria-hidden", "true"); }
            });
            reactionOfferList.appendChild(btn);
          });
        }
        if (reactionOfferModal){ reactionOfferModal.classList.add("show"); reactionOfferModal.setAttribute("aria-hidden", "false"); }
        if (msg.mode === "auto" && msg.auto_choice){
          setTimeout(()=>{
            const button = reactionOfferList?.querySelector("button");
            if (button) button.click();
          }, 120);
        }
      } else if (msg.type === "attack_result"){
        const me = getClaimedUnit();
        if (me && cidMatches(msg.attacker_cid, me.cid, "attackResult.attacker")){
          if (Number.isFinite(Number(msg.action_remaining))){
            me.action_remaining = Number(msg.action_remaining);
          }
          if (Number.isFinite(Number(msg.attack_resource_remaining))){
            me.attack_resource_remaining = Number(msg.attack_resource_remaining);
          }
          if (Number.isFinite(Number(msg.bonus_action_remaining))){
            me.bonus_action_remaining = Number(msg.bonus_action_remaining);
          }
          updateHud();
          draw();
        }
        if (Array.isArray(msg.weapon_property_notes) && msg.weapon_property_notes.length){
          localToast(msg.weapon_property_notes.join(" "));
        }
        if (Array.isArray(msg.cleave_candidates) && msg.cleave_candidates.length){
          openCleavePrompt(msg);
        }
      } else if (msg.type === "spell_target_result"){
        if (msg.needs_polymorph_form){
          const target = getUnitByCid(msg.target_cid);
          const actionCid = activeControlledUnitCid();
          if (pendingSpellTargeting && target && actionCid !== null){
            pendingPolymorphSelection = {
              cid: actionCid,
              targetCid: Number(msg.target_cid),
              spellName: pendingSpellTargeting.spellName,
              spellSlug: pendingSpellTargeting.spellSlug || null,
              spellId: pendingSpellTargeting.spellId || null,
              saveType: pendingSpellTargeting.saveType || "wis",
              saveDc: pendingSpellTargeting.saveDc,
            };
            setPolymorphFormOverlayOpen(true);
            localToast("Choose a beast form to continue Polymorph.");
          }
        } else if (msg.needs_damage_prompt){
          const target = getUnitByCid(msg.target_cid);
          if (pendingSpellTargeting && target){
            const wounded = Number(target.hp || 0) < Number(target.max_hp || target.hp || 0);
            const damageDice = wounded && pendingSpellTargeting.damageDiceWhenWounded
              ? pendingSpellTargeting.damageDiceWhenWounded
              : pendingSpellTargeting.damageDice;
            pendingAttackResolve = {
              mode: "spell",
              targetCid: Number(msg.target_cid),
              targetName: String(msg.target_name || target.name || "target"),
              spellName: pendingSpellTargeting.spellName,
              spellSlug: pendingSpellTargeting.spellSlug || null,
              spellId: pendingSpellTargeting.spellId || null,
              spellMode: "save",
              saveType: pendingSpellTargeting.saveType || "",
              saveDc: pendingSpellTargeting.saveDc,
              forceHit: true,
              rollSave: false,
              damageDice: damageDice || "",
              damageType: pendingSpellTargeting.damageType || "",
            };
            if (attackResolveBody){
              const details = [
                damageDice ? `Damage: ${damageDice}${pendingSpellTargeting.damageType ? ` ${pendingSpellTargeting.damageType}` : ""}.` : "",
                pendingSpellTargeting.description ? pendingSpellTargeting.description : "",
              ].filter(Boolean).join(" ");
              attackResolveBody.textContent = `Target failed save. Resolve ${pendingSpellTargeting.spellName} on ${pendingAttackResolve.targetName}.`
                + (details ? ` ${details}` : "");
            }
            if (attackDamageRows){
              attackDamageRows.textContent = "";
              addAttackDamageRow("", pendingSpellTargeting.damageType || "");
            }
            if (attackResolveHit) attackResolveHit.checked = true;
            if (attackResolveMiss) attackResolveMiss.checked = false;
            if (attackResolveHit) attackResolveHit.disabled = true;
            if (attackResolveMiss) attackResolveMiss.disabled = true;
            if (attackResolveCrit) attackResolveCrit.checked = false;
            syncAttackResolveDamageVisibility();
            setAttackResolveModalOpen(true);
          }
        } else if (pendingSpellTargeting){
          pendingSpellTargeting.remainingShots = Math.max(0, Number(pendingSpellTargeting.remainingShots || 0) - 1);
          if (pendingSpellTargeting.remainingShots <= 0 && !(pendingSpellTargeting.queue && pendingSpellTargeting.queue.length)){
            clearSpellTargetingSession("");
          } else {
            processNextSpellTarget();
            if (!(pendingSpellTargeting?.queue && pendingSpellTargeting.queue.length)){
              localToast(`${pendingSpellTargeting.remainingShots} target${pendingSpellTargeting.remainingShots === 1 ? "" : "s"} remaining.`);
            }
          }
        }
      } else if (msg.type === "grid_update"){
        if (!state){ state = {}; }
        if ("grid" in msg){
          state.grid = msg.grid;
          invalidateMovementRangeCache();
        }
        if (gridReady()){
          const cols = state.grid.cols;
          const rows = state.grid.rows;
          const gridChanged = cols !== lastGrid.cols || rows !== lastGrid.rows;
          if (gridChanged){
            fittedToGrid = false;
            lastGrid = {cols, rows};
          }
        }
        updateWaitingOverlay();
        lastGridVersion = msg.version ?? lastGridVersion;
        send({type:"grid_ack", version: msg.version});
        scheduleUiFlush({draw:true});
      } else if (msg.type === "terrain_update"){
        applyTerrainPayload(msg.terrain);
        updateWaitingOverlay();
        send({type:"terrain_ack", version: msg.version});
        scheduleUiFlush({draw:true});
      } else if (msg.type === "terrain_patch"){
        applyTerrainPatch(msg);
        updateWaitingOverlay();
        scheduleUiFlush({draw:true});
      } else if (msg.type === "aoe_patch"){
        applyAoePatch(msg);
        scheduleUiFlush({draw:true});
      } else if (msg.type === "aoe_move_ack"){
        console.log("[AOE move ack]", msg);
        if (msg.ok === false){
          const reasonCode = typeof msg.reason_code === "string" ? msg.reason_code : "";
          if (reasonCode === "reject_fixed_to_caster"){
            localToast("That self-range spell is fixed to the caster.");
          } else {
            const reason = reasonCode ? reasonCode.replace(/_/g, " ").toLowerCase() : "";
            const reasonText = reason ? reason[0].toUpperCase() + reason.slice(1) : "";
            localToast(reasonText ? `AOE move rejected (${reasonText}).` : "AOE move rejected.");
          }
        }
      } else if (msg.type === "play_audio"){
        if (!msg.audio) return;
        if (msg.audio !== "ko") return;
        if (!audioUnlocked) return;
        if (msg.cid !== undefined && msg.cid !== null){
          if (!claimedCid || !cidMatches(msg.cid, claimedCid, "playAudio.cid")) return;
        }
        playKoAlert();
      }
    });
  }

  // input
  function pointerPos(ev){
    const r = canvas.getBoundingClientRect();
    return {x: ev.clientX - r.left, y: ev.clientY - r.top};
  }

  function normalizeFacingDeg(value){
    const num = Number(value);
    if (!Number.isFinite(num)) return 0;
    let normalized = num % 360;
    if (normalized < 0) normalized += 360;
    return normalized;
  }

  function tokenFacingDeg(unit){
    if (rotatingToken && Number(rotatingToken.cid) === Number(unit?.cid) && Number.isFinite(Number(rotatePreviewDeg))){
      return normalizeFacingDeg(rotatePreviewDeg);
    }
    if (aoeAimGuide && Number(aoeAimGuide.casterCid) === Number(unit?.cid) && Number.isFinite(Number(aoeAimGuide.facingDeg))){
      return normalizeFacingDeg(aoeAimGuide.facingDeg);
    }
    return normalizeFacingDeg(unit?.facing_deg);
  }

  function isUnitHiddenFromClient(unit){
    if (!unit) return false;
    const claimed = normalizeCid(claimedCid, "hidden.claimed");
    const unitCid = normalizeCid(unit.cid, "hidden.unitCid");
    if (claimed !== null && unitCid !== null && cidMatches(claimed, unitCid, "hidden.claimedUnit")){
      return false;
    }
    const summonedBy = normalizeCid(unit?.summoned_by_cid, "hidden.summonedBy");
    if (claimed !== null && summonedBy !== null && cidMatches(claimed, summonedBy, "hidden.summonedControl")){
      return false;
    }
    const mountedBy = normalizeCid(unit?.mounted_by_cid, "hidden.mountedBy");
    if (claimed !== null && mountedBy !== null && cidMatches(claimed, mountedBy, "hidden.mountControl")){
      return false;
    }
    return !!(unit.is_invisible || unit.is_unseen || unit.is_hidden);
  }

  function tokenRotateHandle(unit){
    if (!unit || !unit.pos) return null;
    const isCurrentlyRotating = rotatingToken && Number(rotatingToken.cid) === Number(unit?.cid);
    if (!shiftMoveMode && !isCurrentlyRotating) return null;
    const rotationCid = normalizeCid(activeControlledUnitCid(), "rotateHandle.controlledCid");
    if (rotationCid === null || !cidMatches(unit.cid, rotationCid, "rotateHandle.cid")) return null;
    const {x, y} = gridToScreen(unit.pos.col, unit.pos.row);
    const r = Math.max(10, zoom * 0.35);
    const handleScale = mapRotateHandleScale();
    const orbitR = r + (Math.max(7, zoom * 0.2) * handleScale);
    const facingRad = (tokenFacingDeg(unit) * Math.PI) / 180;
    return {
      x: x + Math.cos(facingRad) * orbitR,
      y: y + Math.sin(facingRad) * orbitR,
      centerX: x,
      centerY: y,
      orbitR,
      hitR: Math.max(6, zoom * 0.15) * handleScale,
    };
  }

  function hitTestRotateHandle(p){
    const units = state?.units || [];
    for (let i = 0; i < units.length; i++){
      const handle = tokenRotateHandle(units[i]);
      if (!handle) continue;
      const dx = p.x - handle.x;
      const dy = p.y - handle.y;
      if (dx * dx + dy * dy <= handle.hitR * handle.hitR){
        return units[i];
      }
    }
    return null;
  }

  function isRotatableAoeKind(kind){
    const token = String(kind || "").toLowerCase();
    return token === "line" || token === "cone" || token === "cube" || token === "wall" || token === "square";
  }

  function syncOwnedRotatableAoesWithFacing(cid, facingDeg){
    if (!state || !Array.isArray(state.aoes)) return;
    const ownerCid = Number(cid);
    if (!Number.isFinite(ownerCid)) return;
    const facing = normalizeFacingDeg(facingDeg);
    state.aoes = state.aoes.map((aoe) => {
      if (
        !aoe
        || Number(aoe.owner_cid) !== ownerCid
        || !isRotatableAoeKind(aoe.kind)
        || aoe.fixed_to_caster !== true
      ){
        return aoe;
      }
      const next = {...aoe, angle_deg: facing};
      if ((next.kind === "line" || next.kind === "wall") && Number.isFinite(Number(next.ax)) && Number.isFinite(Number(next.ay))){
        const halfLengthSquares = Number(next.length_sq || 0) / 2;
        if (Number.isFinite(halfLengthSquares) && halfLengthSquares > 0){
          const rad = (facing * Math.PI) / 180;
          next.cx = Number(next.ax) + Math.cos(rad) * halfLengthSquares;
          next.cy = Number(next.ay) + Math.sin(rad) * halfLengthSquares;
        }
      } else if (next.kind === "cone" && Number.isFinite(Number(next.ax)) && Number.isFinite(Number(next.ay))){
        next.cx = Number(next.ax);
        next.cy = Number(next.ay);
      }
      return next;
    });
  }

  function syncFacingFromRotatableAoe(aoe, angleDeg){
    if (!aoe || !isRotatableAoeKind(aoe.kind)) return;
    const ownerCid = Number(aoe.owner_cid);
    if (!Number.isFinite(ownerCid)) return;
    const unit = getUnitByCid(ownerCid);
    if (!unit) return;
    unit.facing_deg = normalizeFacingDeg(angleDeg);
  }

  function hitTestToken(p){
    if (!state || !state.units) return null;
    const hits = [];
    for (let i = 0; i < state.units.length; i++){
      const u = state.units[i];
      if (isUnitHiddenFromClient(u)) continue;
      const {x,y} = gridToScreen(u.pos.col,u.pos.row);
      const r = Math.max(12, zoom*0.45);
      const dx = p.x - x, dy = p.y - y;
      if (dx*dx + dy*dy <= r*r){
        hits.push(u);
      }
    }
    if (!hits.length) return null;
    const activeCid = normalizeCid(state?.active_cid, "hitTest.active");
    if (activeCid !== null){
      const activeHit = hits.find((u) => cidMatches(u.cid, activeCid, "hitTest.activeMatch"));
      if (activeHit) return activeHit;
    }
    const claimed = normalizeCid(claimedCid, "hitTest.claimed");
    if (claimed !== null){
      const claimedHit = hits.find((u) => cidMatches(u.cid, claimed, "hitTest.claimedMatch"));
      if (claimedHit) return claimedHit;
      const mountHit = hits.find((u) => {
        const riderCid = normalizeCid(u?.mounted_by_cid, "hitTest.mountRider");
        const summonedBy = normalizeCid(u?.summoned_by_cid, "hitTest.mountSummoned");
        return (
          (riderCid !== null && cidMatches(riderCid, claimed, "hitTest.mountByClaimed"))
          || (summonedBy !== null && cidMatches(summonedBy, claimed, "hitTest.mountSummonByClaimed"))
        );
      });
      if (mountHit) return mountHit;
    }
    const renderSorted = sortedTokensForRender(hits);
    return renderSorted[renderSorted.length - 1] || null;
  }


  function buildCellMap(tokens){
    const cellMap = new Map();
    tokens.forEach(u => {
      const key = `${u.pos.col},${u.pos.row}`;
      if (!cellMap.has(key)) cellMap.set(key, []);
      cellMap.get(key).push(u);
    });
    return cellMap;
  }

  function groupLabelFromTokens(arr){
    if (!arr || !arr.length) return "";
    const groupName = arr.find(a => a.group_name || a.group_label || a.group)
      ?.group_name
      ?? arr.find(a => a.group_label)?.group_label
      ?? arr.find(a => a.group)?.group;
    if (groupName) return groupName;
    const names = arr.map(a => a.name).filter(Boolean);
    if (!names.length) return `Group (${arr.length})`;
    const first = names[0];
    const allSame = names.every(n => n === first);
    if (allSame){
      return `${arr.length}x ${first}`;
    }
    if (showAllNames){
      return `Group (${arr.length}): ${names.join(", ")}`;
    }
    return `Group (${arr.length})`;
  }

  function setTokenTooltip(text, clientX, clientY){
    if (!tokenTooltip) return;
    if (!text){
      tokenTooltip.classList.remove("show");
      tokenTooltip.setAttribute("aria-hidden", "true");
      return;
    }
    const wrapRect = mapWrap?.getBoundingClientRect();
    if (!wrapRect) return;
    tokenTooltip.textContent = text;
    const pad = 12;
    const left = clientX - wrapRect.left + pad;
    const top = clientY - wrapRect.top + pad;
    tokenTooltip.style.left = `${left}px`;
    tokenTooltip.style.top = `${top}px`;
    tokenTooltip.classList.add("show");
    tokenTooltip.setAttribute("aria-hidden", "false");
  }

  function clampZoom(value){
    return Math.min(90, Math.max(0.1, value));
  }

  function zoomAt(newZoom, focusX, focusY){
    const preZoom = zoom;
    const nextZoom = clampZoom(newZoom);
    if (Math.abs(nextZoom - preZoom) < 0.01) return;
    const col = (focusX - panX) / preZoom;
    const row = (focusY - panY) / preZoom;
    zoom = nextZoom;
    panX = focusX - col * zoom;
    panY = focusY - row * zoom;
    draw();
  }

  const activePointers = new Map();
  let pinchState = null;
  const AOE_TOUCH_HOLD_MS = 320;
  const AOE_TOUCH_MOVE_THRESHOLD = 8;

  function enforceLoginGate(){
    return false;
  }

  function startPinch(){
    if (activePointers.size < 2) return;
    const pts = Array.from(activePointers.values());
    const dx = pts[0].x - pts[1].x;
    const dy = pts[0].y - pts[1].y;
    const dist = Math.hypot(dx, dy);
    pinchState = {startDist: dist || 1, startZoom: zoom};
  }

  function updatePinch(){
    if (!pinchState || activePointers.size < 2) return;
    const pts = Array.from(activePointers.values());
    const midX = (pts[0].x + pts[1].x) / 2;
    const midY = (pts[0].y + pts[1].y) / 2;
    const dx = pts[0].x - pts[1].x;
    const dy = pts[0].y - pts[1].y;
    const dist = Math.hypot(dx, dy);
    if (pinchState.startDist <= 0) return;
    const scale = dist / pinchState.startDist;
    zoomAt(pinchState.startZoom * scale, midX, midY);
  }

  function clearAoeDragPending(){
    if (aoeDragPending?.timerId){
      clearTimeout(aoeDragPending.timerId);
    }
    aoeDragPending = null;
  }

  function beginAoeDrag({aid, offsetCol, offsetRow, centerCol, centerRow}){
    aoeDragging = {aid, offsetCol, offsetRow, isRotating: false};
    aoeDragPreview = {aid, cx: centerCol, cy: centerRow};
  }

  function getAoeById(aid){
    if (!state || !Array.isArray(state.aoes)) return null;
    return state.aoes.find(a => Number(a?.aid) === Number(aid)) || null;
  }

  function resolveAoeAnchor(aoe){
    const ax = Number(aoe?.ax);
    const ay = Number(aoe?.ay);
    if (Number.isFinite(ax) && Number.isFinite(ay)){
      return {ax, ay};
    }
    const cx = Number(aoe?.cx ?? 0);
    const cy = Number(aoe?.cy ?? 0);
    return {
      ax: Number.isFinite(cx) ? cx : 0,
      ay: Number.isFinite(cy) ? cy : 0,
    };
  }

  function isAoeRotateMode(ev, aoe){
    if (!aoe) return false;
    const kind = String(aoe.kind || "");
    if (kind !== "line" && kind !== "cone" && kind !== "cube" && kind !== "wall" && kind !== "square") return false;
    return !!(ev?.shiftKey || shiftMoveMode);
  }

  function activateAoeDragPending(){
    if (!aoeDragPending) return;
    const pending = aoeDragPending;
    clearAoeDragPending();
    beginAoeDrag(pending);
  }

  function allowAoeDrag(ev){
    if (isMapView) return false;
    if (isPlanning) return true;
    if (isAdminClient()) return true;
    if (!claimedCid) return false;
    if (lockMyAoes) return false;
    if (ev.pointerType === "touch") return true;
    if (isPlanning) return true;
    return true;
  }

  canvas.addEventListener("pointerdown", (ev) => {
    if (enforceLoginGate()) return;
    setTokenTooltip(null);
    canvas.setPointerCapture(ev.pointerId);
    const p = pointerPos(ev);
    activePointers.set(ev.pointerId, p);
    if (activePointers.size >= 2){
      dragging = null;
      rotatingToken = null;
      rotatePreviewDeg = null;
      panning = null;
      clearAoeDragPending();
      startPinch();
      return;
    }
    if (measurementMode){
      setMeasurementPoint(p);
      return;
    }
    if (isMapView){
      if (!lockMap){
        panning = {x: p.x, y: p.y, panX, panY};
      }
      return;
    }
    if (attackOverlayMode){
      return;
    }
    if (pendingAoePlacement){
      if (pendingAoePlacement?.mode === "aimless_self_centered"){
        return;
      }
      if (ev.button !== 0 && ev.pointerType === "mouse") return;
      setPendingAoePlacementCursorFromPointer(p);
      if (isDirectionalSelfRangePlacementActive()){
        applyDirectionalSelfRangePlacement();
      }
      const aimGuide = computeAoePlacementAimGuide();
      aoeAimGuide = aimGuide;
      if (!isPlanning && aimGuide?.blocked){
        localToast("No line of sight to that point.");
        draw();
        return;
      }
      if (!isPlanning && aimGuide?.outOfRange){
        const rangeLabel = Number.isFinite(Number(aimGuide.rangeFt)) ? formatFeet(aimGuide.rangeFt) : "spell range";
        localToast(`Out of range (${rangeLabel} max).`);
        draw();
        return;
      }
      if (!isPlanning && pendingAoePlacement.castConfirmMessage && !window.confirm(pendingAoePlacement.castConfirmMessage)){
        return;
      }
      if (!isPlanning && pendingAoePlacement.concentrationConfirmMessage && !window.confirm(pendingAoePlacement.concentrationConfirmMessage)){
        return;
      }
      const msg = {...pendingAoePlacement.msg, payload: {...(pendingAoePlacement.msg?.payload || {})}};
      const placementPayload = pendingAoePlacement.payload || {};
      if (isDirectionalSelfRangePlacementActive()){
        msg.payload.cx = Number(placementPayload.cx);
        msg.payload.cy = Number(placementPayload.cy);
        msg.payload.ax = Number(placementPayload.ax);
        msg.payload.ay = Number(placementPayload.ay);
        if (Number.isFinite(Number(placementPayload.angle_deg))){
          msg.payload.angle_deg = Number(placementPayload.angle_deg);
        }
        if (Number.isFinite(Number(placementPayload.spread_deg))){
          msg.payload.spread_deg = Number(placementPayload.spread_deg);
        }
      } else {
        const cursor = pendingAoePlacement.cursor || {col: 0, row: 0};
        msg.payload.cx = Number(cursor.col);
        msg.payload.cy = Number(cursor.row);
      }
      const submitAoe = (damageEntries = []) => {
        if (Array.isArray(damageEntries) && damageEntries.length){
          msg.damage_entries = damageEntries;
        }
        const finalFacingDeg = Number(aimGuide?.facingDeg);
        const casterCid = Number(pendingAoePlacement?.casterCid);
        if (Number.isFinite(casterCid) && Number.isFinite(finalFacingDeg)){
          const casterUnit = getUnitByCid(casterCid);
          const currentFacing = normalizeFacingDeg(casterUnit?.facing_deg);
          if (Math.abs(currentFacing - normalizeFacingDeg(finalFacingDeg)) > 0.5){
            send({type:"set_facing", cid: casterCid, facing_deg: normalizeFacingDeg(finalFacingDeg)});
          }
        }
        if (isPlanning){
          planningMutate(msg);
          draw();
          updateHud();
        }
        send(msg);
        clearPendingAoePlacement(false);
        draw();
      };
      maybeRunSculptSelectionForPendingAoe(msg, () => {
        if (isPlanning || castAutomationIsEnabled()){
          submitAoe();
        } else {
          const resolveContext = pendingAoePlacement.resolveContext || {};
          openSpellResolveModal(resolveContext, (damageEntries) => submitAoe(damageEntries));
        }
      });
      return;
    }

    const isTouchPointer = ev.pointerType === "touch";
    const isAoeDragMouse = ev.pointerType === "mouse" && (ev.button === 0 || ev.button === 1);
    if ((shiftMoveMode || ev.shiftKey) && (isAoeDragMouse || isTouchPointer) && allowAoeDrag(ev)){
      const hitAoe = hitTestAoe(p);
      if (hitAoe){
        ev.preventDefault();
        const gridPos = screenToGridFloat(p.x, p.y);
        const centerCol = Number(hitAoe.cx ?? 0);
        const centerRow = Number(hitAoe.cy ?? 0);
        const pendingPayload = {
          pointerId: ev.pointerId,
          aid: Number(hitAoe.aid),
          offsetCol: gridPos.col - centerCol,
          offsetRow: gridPos.row - centerRow,
          centerCol,
          centerRow,
          startX: p.x,
          startY: p.y,
        };
        clearAoeDragPending();
        if (isTouchPointer){
          aoeDragPending = {
            ...pendingPayload,
            timerId: setTimeout(() => {
              if (aoeDragPending?.pointerId !== ev.pointerId) return;
              activateAoeDragPending();
            }, AOE_TOUCH_HOLD_MS),
          };
        } else {
          beginAoeDrag(pendingPayload);
        }
        return;
      }
    }
    const rotateHit = hitTestRotateHandle(p);
    if (rotateHit){
      if (!isPlanning){
        const rotationCid = normalizeCid(activeControlledUnitCid(), "rotate.hit.controlledCid");
        if (rotationCid === null || !cidMatches(rotateHit.cid, rotationCid, "rotate.hitCid")){
          localToast("Arrr, that token aint yers.");
          return;
        }
      }
      rotatingToken = {cid: Number(rotateHit.cid)};
      const {x, y} = gridToScreen(rotateHit.pos.col, rotateHit.pos.row);
      rotatePreviewDeg = normalizeFacingDeg((Math.atan2(p.y - y, p.x - x) * 180) / Math.PI);
      draw();
      return;
    }
    const hit = hitTestToken(p);
    if (hit){
      const controlledCid = activeControlledUnitCid();
      const mountMoveCid = getMountMovementCid();
      const canDragMount = mountMoveCid !== null && cidMatches(hit.cid, mountMoveCid, "dragToken.mountCid");
      const canDragSelf = controlledCid !== null && cidMatches(hit.cid, controlledCid, "dragToken.hitCid");
      if (!isPlanning){
        if (!claimedCid || (!canDragSelf && !canDragMount)){
          localToast("Arrr, that token aint yers.");
          return;
        }
        if (controlledCid === null){
          localToast("Not yer turn yet, matey.");
          return;
        }
      }
      const mountUnitForDrag = mountMoveCid !== null ? getUnitByCid(mountMoveCid) : null;
      // When mounted, dragging either the rider or mount should move the mount token.
      const shouldDragMount = !!mountUnitForDrag && (
        canDragMount || (claimedCid !== null && cidMatches(hit.cid, claimedCid, "dragToken.claimedCid"))
      );
      const dragCid = shouldDragMount ? mountMoveCid : hit.cid;
      const dragUnit = shouldDragMount ? mountUnitForDrag : hit;
      const dragCol = Number(dragUnit?.pos?.col ?? hit.pos.col);
      const dragRow = Number(dragUnit?.pos?.row ?? hit.pos.row);
      dragging = {cid: dragCid, startX: p.x, startY: p.y, origCol: dragCol, origRow: dragRow};
      return;
    }
    if ((isAoeDragMouse || isTouchPointer) && allowAoeDrag(ev)){
      const hitAoe = hitTestAoe(p);
      if (hitAoe){
        ev.preventDefault();
        const gridPos = screenToGridFloat(p.x, p.y);
        const centerCol = Number(hitAoe.cx ?? 0);
        const centerRow = Number(hitAoe.cy ?? 0);
        const pendingPayload = {
          pointerId: ev.pointerId,
          aid: Number(hitAoe.aid),
          offsetCol: gridPos.col - centerCol,
          offsetRow: gridPos.row - centerRow,
          centerCol,
          centerRow,
          startX: p.x,
          startY: p.y,
        };
        clearAoeDragPending();
        if (isTouchPointer){
          aoeDragPending = {
            ...pendingPayload,
            timerId: setTimeout(() => {
              if (aoeDragPending?.pointerId !== ev.pointerId) return;
              activateAoeDragPending();
            }, AOE_TOUCH_HOLD_MS),
          };
        } else {
          beginAoeDrag(pendingPayload);
        }
        return;
      }
    }
    // else pan (if map not locked)
    if (shiftMoveMode){
      return;
    }
    if (!lockMap){
      panning = {x: p.x, y: p.y, panX, panY};
    }
  });

  canvas.addEventListener("pointermove", (ev) => {
    if (enforceLoginGate()) return;
    const p = pointerPos(ev);
    if (activePointers.has(ev.pointerId)){
      activePointers.set(ev.pointerId, p);
    }
    if (aoeDragPending && aoeDragPending.pointerId === ev.pointerId){
      const dx = p.x - aoeDragPending.startX;
      const dy = p.y - aoeDragPending.startY;
      if (Math.hypot(dx, dy) >= AOE_TOUCH_MOVE_THRESHOLD){
        activateAoeDragPending();
      } else {
        setTokenTooltip(null);
        return;
      }
    }
    if (pinchState && activePointers.size >= 2){
      updatePinch();
      setTokenTooltip(null);
      return;
    }
    if (pendingAoePlacement){
      if (pendingAoePlacement?.mode !== "aimless_self_centered"){
        setPendingAoePlacementCursorFromPointer(p);
      }
      draw();
      setTokenTooltip(null);
      return;
    }
    if (aoeDragging){
      const gridPos = screenToGridFloat(p.x, p.y);
      const aoe = getAoeById(aoeDragging.aid);
      const shouldRotate = isAoeRotateMode(ev, aoe);
      aoeDragging.isRotating = shouldRotate;
      if (shouldRotate && aoe){
        const kind = String(aoe.kind || "");
        const anchor = resolveAoeAnchor(aoe);
        const dx = gridPos.col - anchor.ax;
        const dy = gridPos.row - anchor.ay;
        if (Math.abs(dx) + Math.abs(dy) < 0.01){
          return;
        }
        const angleDeg = (Math.atan2(dy, dx) * 180) / Math.PI;
        const preview = {
          aid: aoeDragging.aid,
          angle_deg: angleDeg,
          ax: anchor.ax,
          ay: anchor.ay,
        };
        if (kind === "cone"){
          if (!Number.isFinite(Number(aoe.spread_deg)) && Number.isFinite(Number(aoe.angle_deg))){
            preview.spread_deg = Number(aoe.angle_deg);
          }
          preview.cx = anchor.ax;
          preview.cy = anchor.ay;
        } else if (kind === "cube"){
          preview.cx = Number(aoe.cx ?? 0);
          preview.cy = Number(aoe.cy ?? 0);
        } else {
          const lengthSq = Number(aoe.length_sq || 0);
          const halfLen = lengthSq / 2;
          const rad = (angleDeg * Math.PI) / 180;
          const cx = anchor.ax + Math.cos(rad) * halfLen;
          const cy = anchor.ay + Math.sin(rad) * halfLen;
          preview.cx = cx;
          preview.cy = cy;
        }
        aoeDragPreview = preview;
      } else {
        const cx = gridPos.col - aoeDragging.offsetCol;
        const cy = gridPos.row - aoeDragging.offsetRow;
        aoeDragPreview = {aid: aoeDragging.aid, cx, cy};
      }
      draw();
      setTokenTooltip(null);
      return;
    }
    if (rotatingToken){
      const unit = getUnitByCid(rotatingToken.cid);
      if (unit && unit.pos){
        const {x, y} = gridToScreen(unit.pos.col, unit.pos.row);
        rotatePreviewDeg = normalizeFacingDeg((Math.atan2(p.y - y, p.x - x) * 180) / Math.PI);
        draw();
      }
      setTokenTooltip(null);
      return;
    }
    if (dragging){
      // update local preview by shifting pan temporarily? simplest: draw ghost at pointer
      draw();
      // ghost
      ctx.save();
      ctx.globalAlpha = 0.85;
      ctx.beginPath();
      ctx.arc(p.x, p.y, Math.max(10, zoom*0.35), 0, Math.PI*2);
      ctx.fillStyle = "rgba(106,169,255,0.25)";
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(106,169,255,0.95)";
      ctx.stroke();
      ctx.restore();
      setTokenTooltip(null);
    } else if (panning){
      panX = panning.panX + (p.x - panning.x);
      panY = panning.panY + (p.y - panning.y);
      draw();
      setTokenTooltip(null);
    } else if (measurementMode){
      setTokenTooltip(null);
    } else {
      if (ev.pointerType === "touch"){
        setTokenTooltip(null);
        return;
      }
      const tokens = state?.units || [];
      const hit = hitTestToken(p);
      if (hit){
        const cellMap = buildCellMap(tokens);
        const key = `${hit.pos.col},${hit.pos.row}`;
        const group = cellMap.get(key) || [];
        const label = group.length > 1 ? groupLabelFromTokens(group) : (hit.name || "Unknown");
        setTokenTooltip(label, ev.clientX, ev.clientY);
      } else {
        setTokenTooltip(null);
      }
    }
  });

  canvas.addEventListener("pointerup", (ev) => {
    if (enforceLoginGate()) return;
    const p = pointerPos(ev);
    activePointers.delete(ev.pointerId);
    if (activePointers.size < 2){
      pinchState = null;
    }
    if (aoeDragPending?.pointerId === ev.pointerId){
      clearAoeDragPending();
    }
    setTokenTooltip(null);
    if (attackOverlayMode && !isMapView && !pendingSummonPlacement && !dragging && !panning && !aoeDragging){
      const me = getClaimedUnit();
      const controlledUnit = getUnitByCid(activeControlledUnitCid());
      const overlayOrigin = pendingUnleashIncarnation ? getUnitByCid(pendingUnleashIncarnation.echoCid) : (controlledUnit || me);
      if (!me || !overlayOrigin){
        localToast("Claim a character first, matey.");
        return;
      }
      if (pendingUnleashIncarnation && (!overlayOrigin || !overlayOrigin.pos)){
        localToast("Arr... I dont be seeing no echo, matey");
        setAttackOverlayMode(false);
        return;
      }
      const hit = hitTestToken(p);
      const selectingSpellTarget = !!pendingSpellTargeting;
      const selectingLayOnHandsTarget = !!pendingLayOnHandsTargeting;
      const selectingBardicInspirationTarget = !!pendingBardicInspirationTargeting;
      const selectingBeguilingMagicTarget = !!pendingBeguilingMagic;
      const selectingMantleTarget = !!pendingMantleOfInspiration;
      if (hit && (selectingSpellTarget || selectingLayOnHandsTarget || selectingBardicInspirationTarget || selectingBeguilingMagicTarget || selectingMantleTarget || !cidMatches(hit.cid, me.cid, "attackOverlay.target"))){
        const isFriendlyTarget = cidMatches(hit.cid, me.cid, "attackOverlay.selfTarget") || isFriendlyToMe(hit, me);
        if (!pendingSpellTargeting && !pendingLayOnHandsTargeting && !pendingBardicInspirationTargeting && !pendingBeguilingMagic && !pendingMantleOfInspiration && isFriendlyTarget){
          localToast("Pick an enemy target, matey.");
          return;
        }
        if (pendingSpellTargeting){
          const targetSide = normalizeLowerValue(pendingSpellTargeting.targetSide || "enemy");
          if (targetSide === "friendly" && !isFriendlyTarget){
            localToast("Pick a friendly target, matey.");
            return;
          }
          if (targetSide === "enemy" && isFriendlyTarget){
            localToast("Pick an enemy target, matey.");
            return;
          }
        }
        if (pendingLayOnHandsTargeting){
          const rangeFt = Number.isFinite(Number(pendingLayOnHandsTargeting?.rangeFt))
            ? Number(pendingLayOnHandsTargeting.rangeFt)
            : 5;
          const distFt = distanceFeetBetweenCells(overlayOrigin.pos, hit.pos);
          if (distFt - rangeFt > 1e-6){
            localToast("Target be out of Lay on Hands range.");
            return;
          }
          pendingLayOnHandsResolve = {
            targetCid: Number(hit.cid),
            targetName: String(hit.name || "target"),
          };
          setLayOnHandsOverlayOpen(true);
          return;
        }
        if (pendingBardicInspirationTargeting){
          const rangeFt = Number.isFinite(Number(pendingBardicInspirationTargeting?.rangeFt))
            ? Number(pendingBardicInspirationTargeting.rangeFt)
            : 60;
          const distFt = distanceFeetBetweenCells(overlayOrigin.pos, hit.pos);
          if (distFt - rangeFt > 1e-6){
            localToast("Target be out of Bardic Inspiration range.");
            return;
          }
          send({
            type: "bardic_inspiration_grant",
            cid: activeControlledUnitCid(),
            target_cid: Number(hit.cid),
          });
          setAttackOverlayMode(false);
          localToast(`Bardic Inspiration sent to ${String(hit.name || "target")}.`);
          return;
        }
        if (pendingBeguilingMagic){
          const distFt = distanceFeetBetweenCells(overlayOrigin.pos, hit.pos);
          if (distFt - 60 > 1e-6){
            localToast("Target be out of Beguiling Magic range.");
            return;
          }
          const condition = normalizeLowerValue(pendingBeguilingMagic.condition || "charmed") || "charmed";
          send({
            type: "beguiling_magic_use",
            cid: activeControlledUnitCid(),
            target_cid: Number(hit.cid),
            condition,
            restore_with_bi: !!pendingBeguilingMagic.fromPool,
          });
          setAttackOverlayMode(false);
          localToast("Beguiling Magic sent.");
          return;
        }
        if (pendingMantleOfInspiration){
          const rangeFt = Number.isFinite(Number(pendingMantleOfInspiration?.rangeFt))
            ? Number(pendingMantleOfInspiration.rangeFt)
            : 60;
          const distFt = distanceFeetBetweenCells(overlayOrigin.pos, hit.pos);
          if (distFt - rangeFt > 1e-6){
            localToast("Target be out of Mantle of Inspiration range.");
            return;
          }
          runSpellTargetingAgainstTarget(hit);
          return;
        }
        const weapon = pendingSpellTargeting ? null : (pendingActionAttackWeapon || getSelectedAttackWeapon());
        if (!pendingSpellTargeting && !weapon){
          localToast("No configured weapon found, matey.");
          return;
        }
        const rangeFt = Number.isFinite(Number(pendingSpellTargeting?.rangeFt))
          ? Number(pendingSpellTargeting.rangeFt)
          : effectiveAttackRangeFeetForWeapon(weapon, overlayOrigin || me);
        const distFt = distanceFeetBetweenCells((overlayOrigin && overlayOrigin.pos) ? overlayOrigin.pos : me.pos, hit.pos);
        if (distFt - rangeFt > 1e-6){
          localToast("Target be out of attack range.");
          return;
        }
        if (!pendingSpellTargeting){
          openAttackResolveModal(hit, weapon);
          return;
        }
        runSpellTargetingAgainstTarget(hit);
        return;
      }
    }
    if (pendingSummonPlacement && !isMapView && !dragging && !panning && !aoeDragging){
      if (!ev.shiftKey){
        localToast("Hold Shift while clicking to place summons.");
        return;
      }
      const g = screenToGrid(p.x, p.y);
      if (!gridReady()){
        localToast("Map not ready yet, matey.");
        return;
      }
      const cols = Number(state?.grid?.cols || 0);
      const rows = Number(state?.grid?.rows || 0);
      if (g.col < 0 || g.row < 0 || g.col >= cols || g.row >= rows){
        localToast("That square be off the map.");
        return;
      }
      if (!isSummonPlacementCellValid(g)){
        localToast("That square is out of rangeselect a valid square.");
        return;
      }
      pendingSummonPlacement.positions.push({col: g.col, row: g.row});
      if (pendingSummonPlacement.mode === "echo_summon"){
        if (claimedCid == null){
          clearSummonPlacementState();
          return;
        }
        const pos = pendingSummonPlacement.positions[0] || {col: g.col, row: g.row};
        const msg = {type: "echo_summon", cid: claimedCid, to: {col: Number(pos.col), row: Number(pos.row)}};
        if (isPlanning){
          planningMutate(msg);
          draw();
          updateHud();
        }
        send(msg);
        clearSummonPlacementState();
        return;
      }
      const remaining = pendingSummonPlacement.summonQuantity - pendingSummonPlacement.positions.length;
      if (remaining > 0){
        localToast(`${remaining} summon placement(s) remaining.`);
        return;
      }
      const payload = {
        ...pendingSummonPlacement.payload,
        summon_positions: pendingSummonPlacement.positions.slice(),
      };
      const castType = pendingSummonPlacement.mode === "custom_summon" ? "cast_aoe" : "cast_spell";
      const msg = {type: castType, payload, action_type: pendingSummonPlacement.actionType};
      if (pendingSummonPlacement.spellSlug){
        msg.spell_slug = pendingSummonPlacement.spellSlug;
      }
      if (pendingSummonPlacement.spellId){
        msg.spell_id = pendingSummonPlacement.spellId;
      }
      if (Number.isFinite(pendingSummonPlacement.slotLevel)){
        msg.slot_level = pendingSummonPlacement.slotLevel;
      }
      msg.summon_choice = pendingSummonPlacement.summonChoice;
      msg.summon_quantity = pendingSummonPlacement.summonQuantity;
      msg.variant = pendingSummonPlacement.summonVariant || null;
      if (pendingSummonPlacement.mode === "custom_summon"){
        msg.payload.shape = "summon";
      }
      if (isPlanning){
        planningMutate(msg);
        draw();
        updateHud();
      }
      send(msg);
      clearSummonPlacementState();
      return;
    }

    if (aoeDragging){
      const gridPos = screenToGridFloat(p.x, p.y);
      const preview = aoeDragPreview || {};
      let targetCol = Number(gridPos.col - aoeDragging.offsetCol);
      let targetRow = Number(gridPos.row - aoeDragging.offsetRow);
      const toPayload = {};
      if (aoeDragging.isRotating && Number.isFinite(Number(preview?.angle_deg))){
        if (Number.isFinite(Number(preview?.cx))) targetCol = Number(preview.cx);
        if (Number.isFinite(Number(preview?.cy))) targetRow = Number(preview.cy);
        toPayload.angle_deg = Number(preview.angle_deg);
        if (Number.isFinite(Number(preview?.ax))) toPayload.ax = Number(preview.ax);
        if (Number.isFinite(Number(preview?.ay))) toPayload.ay = Number(preview.ay);
        if (Number.isFinite(Number(preview?.spread_deg))) toPayload.spread_deg = Number(preview.spread_deg);
      }
      toPayload.cx = targetCol;
      toPayload.cy = targetRow;
      const msg = {type:"aoe_move", aid: Number(aoeDragging.aid), to: toPayload};
      if (isPlanning){
        planningMutate(msg);
        draw();
        updateHud();
      }
      send(msg);
      aoeDragging = null;
      aoeDragPreview = null;
      draw();
      return;
    }
    if (rotatingToken){
      const facingDeg = Number.isFinite(Number(rotatePreviewDeg)) ? normalizeFacingDeg(rotatePreviewDeg) : 0;
      const unit = getUnitByCid(rotatingToken.cid);
      if (unit){
        unit.facing_deg = facingDeg;
        syncOwnedRotatableAoesWithFacing(unit.cid, facingDeg);
      }
      const msg = {type:"set_facing", cid: Number(rotatingToken.cid), facing_deg: facingDeg};
      if (isPlanning){
        planningMutate(msg);
        draw();
        updateHud();
      }
      send(msg);
      rotatingToken = null;
      rotatePreviewDeg = null;
      draw();
      return;
    }
    dragging && (function(){
      const g = screenToGrid(p.x, p.y);
      const msg = {type:"move", cid: Number(dragging.cid), to: {col: g.col, row: g.row}};
      if (isPlanning){
        planningMutate(msg);
        draw();
        updateHud();
      }
      send(msg);
      dragging = null;
    })();
    panning = null;
  });

  canvas.addEventListener("pointercancel", (ev) => {
    if (enforceLoginGate()) return;
    activePointers.delete(ev.pointerId);
    if (activePointers.size < 2){
      pinchState = null;
    }
    if (aoeDragPending?.pointerId === ev.pointerId){
      clearAoeDragPending();
    }
    if (aoeDragging){
      aoeDragging = null;
      aoeDragPreview = null;
      draw();
    }
    if (rotatingToken){
      rotatingToken = null;
      rotatePreviewDeg = null;
      draw();
    }
    setTokenTooltip(null);
  });

  canvas.addEventListener("pointerleave", () => {
    setTokenTooltip(null);
  });

  canvas.addEventListener("wheel", (ev) => {
    if (enforceLoginGate()) return;
    if (pinchState) return;
    if (
      pendingAoePlacement
      && isPlacementSquareOrCube()
      && !isDirectionalSelfRangePlacementActive()
    ){
      ev.preventDefault();
      const delta = ev.deltaY || 0;
      const step = delta > 0 ? 15 : -15;
      const base = Number.isFinite(Number(pendingAoePlacement?.payload?.angle_deg))
        ? Number(pendingAoePlacement.payload.angle_deg)
        : 0;
      pendingAoePlacement.payload.angle_deg = normalizeFacingDeg(base + step);
      refreshAoePlacementAimGuide();
      draw();
      return;
    }
    ev.preventDefault();
    const p = pointerPos(ev);
    const delta = ev.deltaY || 0;
    const factor = delta > 0 ? 0.9 : 1.1;
    zoomAt(zoom * factor, p.x, p.y);
  }, {passive: false});

  if (zoomInBtn){
    zoomInBtn.addEventListener("click", () => {
      if (enforceLoginGate()) return;
      const r = canvas.getBoundingClientRect();
      zoomAt(zoom + 4, r.width / 2, r.height / 2);
    });
  }
  if (zoomOutBtn){
    zoomOutBtn.addEventListener("click", () => {
      if (enforceLoginGate()) return;
      const r = canvas.getBoundingClientRect();
      zoomAt(zoom - 4, r.width / 2, r.height / 2);
    });
  }
  if (lockMapBtn){
    lockMapBtn.addEventListener("click", (ev) => {
      if (enforceLoginGate()) return;
      lockMap = !lockMap;
      ev.target.textContent = lockMap ? "Unlock Map" : "Lock Map";
    });
  }
  if (lockAoeBtn){
    lockAoeBtn.addEventListener("click", () => {
      if (enforceLoginGate()) return;
      lockMyAoes = !lockMyAoes;
      persistToggle(lockMyAoesKey, lockMyAoes);
      updateAoeLockButton();
    });
  }
  if (auraToggleBtn){
    auraToggleBtn.addEventListener("click", () => {
      if (enforceLoginGate()) return;
      const next = !areAurasEnabled();
      if (!state || typeof state !== "object") state = {};
      state.auras_enabled = next;
      updateAurasButton();
      draw();
      send({type:"set_auras_enabled", enabled: next});
    });
  }
  if (centerMapBtn){
    centerMapBtn.addEventListener("click", () => {
      if (enforceLoginGate()) return;
      if (!centerOnClaimed()){
        centerOnGridCenter();
      }
    });
  }
  if (measureToggle){
    measureToggle.addEventListener("click", () => {
      if (enforceLoginGate()) return;
      measurementMode = !measurementMode;
      updateMeasurementControls();
    });
  }
  if (measureClear){
    measureClear.addEventListener("click", () => {
      if (enforceLoginGate()) return;
      clearMeasurement();
    });
  }
  if (tokenColorModeBtn){
    tokenColorModeBtn.addEventListener("click", () => {
      if (enforceLoginGate()) return;
      openClaimedColorModal();
    });
  }

  if (tokenColorInput){
    tokenColorInput.addEventListener("input", (ev) => {
      updateTokenColorSwatch(ev.target.value);
    });
  }
  if (tokenBorderColorInput){
    tokenBorderColorInput.addEventListener("input", (ev) => {
      updateTokenBorderColorSwatch(ev.target.value);
    });
  }
  if (tokenColorConfirm){
    tokenColorConfirm.addEventListener("click", () => {
      const claimedUnit = getClaimedUnit();
      if (!claimedUnit){
        localToast("Claim a character first, matey.");
        closeColorModal();
        return;
      }
      pendingClaim = claimedUnit;
      const color = validateTokenColor(tokenColorInput ? tokenColorInput.value : "");
      if (!color) return;
      const borderColor = normalizeHexColor(tokenBorderColorInput ? tokenBorderColorInput.value : "") || "#ffffff";
      localStorage.setItem("inittracker_tokenColor", color);
      localStorage.setItem("inittracker_tokenBorderColor", borderColor);
      const pendingCid = normalizeCid(pendingClaim.cid, "tokenColor.pendingCid");
      if (pendingCid === null) return;
      if (state?.units){
        const unit = state.units.find(u => cidMatches(u.cid, pendingCid, "tokenColor.unitCid"));
        if (unit){
          unit.token_color = color;
          unit.token_border_color = borderColor;
          draw();
        }
      }
      send({type:"set_color", cid: pendingCid, color, border_color: borderColor});
      setMeLabel({name: pendingClaim.name}, false);
      closeColorModal();
    });
  }
  if (tokenColorCancel){
    tokenColorCancel.addEventListener("click", () => {
      closeColorModal();
      showNoOwnedPcToast(lastPcList || []);
    });
  }
  if (switchCharacterBtn){
    switchCharacterBtn.addEventListener("click", () => {
      if (enforceLoginGate()) return;
      requestCharacterSwitch();
    });
  }
  if (claimConfirmBtn){
    claimConfirmBtn.addEventListener("click", () => {
      if (selectedClaimCid === null || selectedClaimCid === undefined){
        localToast("Pick a character first, matey.");
        return;
      }
      const cidValue = normalizeCid(selectedClaimCid, "confirm.selectedCid");
      if (cidValue === null) return;
      if (claimInFlight){
        return;
      }
      allowUnclaimed = false;
      storeLanSelection(cidValue, lastPcList || []);
      setClaimInFlight(cidValue);
      send({type:"claim", cid: cidValue, client_id: clientId});
      clearSpellFilters();
      clearAutoClaimPending();
      updateClaimOverlay();
      // Don't optimistically set claimedCid here - wait for server confirmation via "you" field
    });
  }
  if (claimContinueBtn){
    claimContinueBtn.addEventListener("click", () => {
      enterUnclaimedSpectatorMode();
    });
  }
  if (claimSpectatorBtn){
    claimSpectatorBtn.addEventListener("click", () => {
      enterUnclaimedSpectatorMode();
    });
  }

  let lastSpellPresetSignature = "";
  let cachedSpellPresets = [];
  let spellPresetBySlug = new Map();
  const normalizeSpellPresets = (presets) => {
    if (!Array.isArray(presets)) return [];
    return presets.filter(p => p && typeof p === "object").map((preset) => {
      const shape = String(preset?.shape || "").trim().toLowerCase();
      const summon = preset.summon && typeof preset.summon === "object" ? preset.summon : null;
      return {
        ...preset,
        isAoE: Boolean(shape && AOE_SHAPES.has(shape)),
        isSummon: Boolean(summon),
      };
    });
  };
  const formatSpellLevelLabel = (level) => {
    const num = Number(level);
    if (!Number.isFinite(num)) return "Unknown";
    if (num === 0) return "Cantrip";
    const suffix = num === 1 ? "st" : num === 2 ? "nd" : num === 3 ? "rd" : "th";
    return `${num}${suffix}`;
  };
  const formatListGroupLabel = (value) => String(value || "")
    .replace(/_/g, " ")
    .replace(/\\b\\w/g, (char) => char.toUpperCase());
  const normalizeTextValue = (value) => String(value || "").trim();
  const normalizeLowerValue = (value) => normalizeTextValue(value).toLowerCase();
  const getSpellTagSet = (preset) => {
    const tags = Array.isArray(preset?.tags) ? preset.tags.map((tag) => normalizeLowerValue(tag)) : [];
    return new Set(tags.filter(Boolean));
  };
  const hasSpellTag = (preset, tag) => getSpellTagSet(preset).has(normalizeLowerValue(tag));
  const resolveSpellActionTag = (preset) => {
    const tagSet = getSpellTagSet(preset);
    if (tagSet.has("aoe")) return "aoe";
    if (tagSet.has("attack") || tagSet.has("spell_attack_target")) return "attack";
    if (tagSet.has("save") || tagSet.has("spell_save_target")) return "save";
    if (tagSet.has("auto_hit") || tagSet.has("spell_auto_hit_target")) return "auto_hit";
    const areaShape = normalizeLowerValue(preset?.mechanics?.targeting?.area?.shape || preset?.shape);
    if (areaShape && AOE_SHAPES.has(areaShape)) return "aoe";
    const sequence = Array.isArray(preset?.mechanics?.sequence) ? preset.mechanics.sequence : [];
    for (const step of sequence){
      const kind = normalizeLowerValue(step?.check?.kind);
      if (kind === "spell_attack") return "attack";
      if (kind === "saving_throw") return "save";
    }
    return "";
  };
  const reportSpellTagMissing = (preset, extra = {}) => {
    const payload = {
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      url: location.href,
      message: "Spell cast blocked: missing spell action tag",
      level: "error",
      spell_name: normalizeTextValue(preset?.name) || "",
      spell_slug: normalizeTextValue(preset?.slug) || "",
      tags: Array.isArray(preset?.tags) ? preset.tags.filter(Boolean) : [],
      ...extra,
    };
    try {
      console.error("Spell cast missing tag", payload);
      fetch("/api/client-log", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify(payload),
      }).catch(() => {});
    } catch (err) {
      console.warn("Failed to report spell tag error.", err);
    }
  };
  const getSpellKey = (value) => normalizeLowerValue(value);
  const getPresetSlug = (preset) => {
    const slug = normalizeTextValue(preset?.slug);
    if (slug) return slug;
    return normalizeLowerValue(preset?.name).replace(/\\s+/g, "-");
  };
  const AOE_SHAPES = new Set(["circle", "square", "line", "sphere", "cube", "cone", "cylinder", "wall"]);
  const isAoePreset = (preset) => Boolean(preset?.isAoE);
  const isSummonPreset = (preset) => Boolean(preset?.isSummon);
  const CUSTOM_SUMMON_PRESET_NAME = "Custom Summon";
  const CUSTOM_SUMMON_PRESET = {
    name: CUSTOM_SUMMON_PRESET_NAME,
    slug: "custom-summon",
    isSummon: true,
    isCustomSummon: true,
    shape: "summon",
    summon: {choices: [{monster_slug: "custom-summon", name: "Custom Summon"}], quantities: [{quantity: 1}]},
  };
  const DEFAULT_CUSTOM_SUMMON_TEMPLATE = {
    name: "Custom summon",
    type: "construct",
    hp: 30,
    ac: 10,
    speeds: {walk: 30, swim: 0, fly: 0, burrow: 0, climb: 0},
    abilities: {str: 10, dex: 10, con: 10, int: 10, wis: 10, cha: 10},
  };
  const parseIntOrFallback = (value, fallback) => {
    const num = Number(value);
    return Number.isFinite(num) ? Math.floor(num) : fallback;
  };
  const clampInt = (value, min, max, fallback) => {
    const parsed = parseIntOrFallback(value, fallback);
    return Math.max(min, Math.min(max, parsed));
  };
  const normalizeMonsterChoiceTemplate = (choice) => {
    const template = choice?.template && typeof choice.template === "object" ? choice.template : {};
    const speeds = template.speeds && typeof template.speeds === "object" ? template.speeds : {};
    const abilities = template.abilities && typeof template.abilities === "object" ? template.abilities : {};
    return {
      name: normalizeTextValue(template.name || choice?.name || DEFAULT_CUSTOM_SUMMON_TEMPLATE.name),
      type: normalizeTextValue(template.type || DEFAULT_CUSTOM_SUMMON_TEMPLATE.type) || DEFAULT_CUSTOM_SUMMON_TEMPLATE.type,
      hp: Math.max(1, parseIntOrFallback(template.hp, DEFAULT_CUSTOM_SUMMON_TEMPLATE.hp)),
      ac: Math.max(1, parseIntOrFallback(template.ac, DEFAULT_CUSTOM_SUMMON_TEMPLATE.ac)),
      speeds: {
        walk: Math.max(1, parseIntOrFallback(speeds.walk, DEFAULT_CUSTOM_SUMMON_TEMPLATE.speeds.walk)),
        swim: Math.max(0, parseIntOrFallback(speeds.swim, DEFAULT_CUSTOM_SUMMON_TEMPLATE.speeds.swim)),
        fly: Math.max(0, parseIntOrFallback(speeds.fly, DEFAULT_CUSTOM_SUMMON_TEMPLATE.speeds.fly)),
        burrow: Math.max(0, parseIntOrFallback(speeds.burrow, DEFAULT_CUSTOM_SUMMON_TEMPLATE.speeds.burrow)),
        climb: Math.max(0, parseIntOrFallback(speeds.climb, DEFAULT_CUSTOM_SUMMON_TEMPLATE.speeds.climb)),
      },
      abilities: {
        str: clampInt(abilities.str, 1, 30, DEFAULT_CUSTOM_SUMMON_TEMPLATE.abilities.str),
        dex: clampInt(abilities.dex, 1, 30, DEFAULT_CUSTOM_SUMMON_TEMPLATE.abilities.dex),
        con: clampInt(abilities.con, 1, 30, DEFAULT_CUSTOM_SUMMON_TEMPLATE.abilities.con),
        int: clampInt(abilities.int, 1, 30, DEFAULT_CUSTOM_SUMMON_TEMPLATE.abilities.int),
        wis: clampInt(abilities.wis, 1, 30, DEFAULT_CUSTOM_SUMMON_TEMPLATE.abilities.wis),
        cha: clampInt(abilities.cha, 1, 30, DEFAULT_CUSTOM_SUMMON_TEMPLATE.abilities.cha),
      },
    };
  };
  const getCustomSummonMonsterChoices = () => {
    const list = Array.isArray(state?.monster_choices) ? state.monster_choices : [];
    return list
      .filter((entry) => entry && typeof entry === "object")
      .map((entry) => ({
        name: normalizeTextValue(entry.name),
        slug: normalizeTextValue(entry.slug),
        template: normalizeMonsterChoiceTemplate(entry),
      }))
      .filter((entry) => entry.slug && entry.name)
      .sort((a, b) => a.name.localeCompare(b.name));
  };
  const refreshCustomSummonMonsterOptions = () => {
    if (!castCustomSummonMonsterInput) return;
    const currentValue = normalizeTextValue(castCustomSummonMonsterInput.value);
    const searchText = normalizeLowerValue(castCustomSummonMonsterSearchInput?.value || "");
    const choices = getCustomSummonMonsterChoices().filter((entry) => {
      if (!searchText) return true;
      return normalizeLowerValue(entry.name).includes(searchText) || normalizeLowerValue(entry.slug).includes(searchText);
    });
    castCustomSummonMonsterInput.textContent = "";
    choices.forEach((entry) => {
      const opt = document.createElement("option");
      opt.value = entry.slug;
      opt.textContent = `${entry.name} (${entry.slug})`;
      castCustomSummonMonsterInput.appendChild(opt);
    });
    castCustomSummonMonsterInput.value = choices.some((entry) => entry.slug === currentValue)
      ? currentValue
      : (choices[0]?.slug || "");
  };
  const getSelectedCustomSummonChoice = () => {
    const slug = normalizeTextValue(castCustomSummonMonsterInput?.value);
    if (!slug) return null;
    return getCustomSummonMonsterChoices().find((entry) => entry.slug === slug) || null;
  };
  const applyCustomSummonTemplate = (choice, overwriteName = false) => {
    const template = normalizeMonsterChoiceTemplate(choice || {});
    if (castCustomSummonNameInput && (overwriteName || !normalizeTextValue(castCustomSummonNameInput.value))){
      castCustomSummonNameInput.value = template.name || DEFAULT_CUSTOM_SUMMON_TEMPLATE.name;
    }
    if (castNameInput && (overwriteName || !normalizeTextValue(castNameInput.value))){
      castNameInput.value = castCustomSummonNameInput?.value || template.name || DEFAULT_CUSTOM_SUMMON_TEMPLATE.name;
    }
    if (castCustomSummonTypeInput) castCustomSummonTypeInput.value = template.type;
    if (castCustomSummonHpInput) castCustomSummonHpInput.value = String(template.hp);
    if (castCustomSummonAcInput) castCustomSummonAcInput.value = String(template.ac);
    if (castCustomSummonWalkInput) castCustomSummonWalkInput.value = String(template.speeds.walk);
    if (castCustomSummonSwimInput) castCustomSummonSwimInput.value = String(template.speeds.swim);
    if (castCustomSummonFlyInput) castCustomSummonFlyInput.value = String(template.speeds.fly);
    if (castCustomSummonBurrowInput) castCustomSummonBurrowInput.value = String(template.speeds.burrow);
    if (castCustomSummonClimbInput) castCustomSummonClimbInput.value = String(template.speeds.climb);
    if (castCustomSummonStrInput) castCustomSummonStrInput.value = String(template.abilities.str);
    if (castCustomSummonDexInput) castCustomSummonDexInput.value = String(template.abilities.dex);
    if (castCustomSummonConInput) castCustomSummonConInput.value = String(template.abilities.con);
    if (castCustomSummonIntInput) castCustomSummonIntInput.value = String(template.abilities.int);
    if (castCustomSummonWisInput) castCustomSummonWisInput.value = String(template.abilities.wis);
    if (castCustomSummonChaInput) castCustomSummonChaInput.value = String(template.abilities.cha);
  };
  const loadPreparedSpellFilterList = () => {
    const name = getClaimedPlayerName();
    if (!name) return null;
    const config = getSpellbookConfig(name);
    const cantrips = config.cantrips || [];
    if (!config.prepared.length && !cantrips.length) return null;
    const merged = new Set([
      ...config.prepared.map(normalizeTextValue),
      ...cantrips.map(normalizeTextValue),
    ]);
    return Array.from(merged).filter(Boolean);
  };
  const getPreparedSpellFilterSet = () => {
    if (!claimedCid) return null;
    const list = loadPreparedSpellFilterList();
    return list ? new Set(list.map(getSpellKey)) : new Set();
  };
  const filterPresetsByKnownList = (presets, knownSpellSet) => {
    if (!knownSpellSet) return presets;
    if (knownSpellSet.size === 0) return [];
    return presets.filter((preset) => {
      const slug = getPresetSlug(preset);
      if (!slug) return false;
      return knownSpellSet.has(getSpellKey(slug));
    });
  };
  const getSpellListEntries = (lists) => {
    if (!lists || typeof lists !== "object") return [];
    const entries = [];
    Object.entries(lists).forEach(([group, values]) => {
      if (!Array.isArray(values)) return;
      values.forEach((value) => {
        const trimmed = normalizeTextValue(value);
        if (!trimmed) return;
        entries.push({group, value: trimmed});
      });
    });
    return entries;
  };
  const getPresetLevelNumber = (preset) => {
    const num = Number(preset?.level);
    return Number.isFinite(num) ? num : null;
  };
  const updateManualEntryBadge = (preset) => {
    if (!castManualEntryBadge) return;
    if (!preset){
      castManualEntryBadge.classList.remove("show");
      castManualEntryBadge.setAttribute("aria-hidden", "true");
      castManualEntryBadge.removeAttribute("title");
      castManualEntryBadge.removeAttribute("aria-label");
      return;
    }
    const reasons = [];
    const automation = normalizeLowerValue(preset.automation);
    if (automation === "partial" || automation === "manual"){
      reasons.push(`automation is ${automation}`);
    }
    if (!preset.shape && !isSummonPreset(preset)){
      reasons.push("shape is missing");
    }
    if (preset.incomplete){
      const missing = Array.isArray(preset.incomplete_fields)
        ? preset.incomplete_fields.map((field) => String(field || "").trim()).filter(Boolean)
        : [];
      if (missing.length){
        reasons.push(`missing ${missing.join(", ")}`);
      } else {
        reasons.push("missing dimensions");
      }
    }
    if (reasons.length){
      const tooltip = `Manual entry required: ${reasons.join("; ")}.`;
      castManualEntryBadge.classList.add("show");
      castManualEntryBadge.setAttribute("aria-hidden", "false");
      castManualEntryBadge.title = tooltip;
      castManualEntryBadge.setAttribute("aria-label", tooltip);
    } else {
      castManualEntryBadge.classList.remove("show");
      castManualEntryBadge.setAttribute("aria-hidden", "true");
      castManualEntryBadge.removeAttribute("title");
      castManualEntryBadge.removeAttribute("aria-label");
    }
  };
  function getSelectedSpellPreset(){
    if (forcedPoolCastContext?.preset){
      return forcedPoolCastContext.preset;
    }
    const name = normalizeTextValue(castPresetInput?.value);
    if (!name) return null;
    if (name === CUSTOM_SUMMON_PRESET_NAME){
      return {...CUSTOM_SUMMON_PRESET};
    }
    return cachedSpellPresets.find(preset => normalizeTextValue(preset.name) === name) || null;
  }
  function normalizeSpellActionType(value){
    const raw = normalizeLowerValue(value);
    // Order matters: keep bonus action/reaction checks before generic action.
    if (/\bbonus[\s\-_]*action\b/.test(raw)) return "bonus_action";
    if (/\breaction\b/.test(raw)) return "reaction";
    if (/\baction\b/.test(raw)) return "action";
    return "action";
  }
  function getSpellActionType(preset){
    if (!preset) return "action";
    const castingTime = normalizeTextValue(preset.casting_time || preset.castingTime);
    return normalizeSpellActionType(castingTime);
  }
  function unitHasMagicAction(unit, actionType){
    const actions = normalizeActionList(unit?.actions, "action");
    const bonusActions = normalizeActionList(unit?.bonus_actions, "bonus_action");
    if (actionType === "bonus_action"){
      return [...bonusActions, ...actions].some((entry) => isSpellActionEntry(entry));
    }
    return actions.some((entry) => isSpellActionEntry(entry));
  }
  function canSpendSpellAction(unit, actionType){
    if (!unit) return {ok: false, reason: "Claim a character first, matey."};
    if (actionType === "bonus_action"){
      const remaining = Number(unit.spell_cast_remaining || 0);
      if (remaining <= 0){
        return {ok: false, reason: "You already cast a spell this turn."};
      }
      if (!unitHasMagicAction(unit, actionType)){
        return {ok: false, reason: "No bonus-action spellcasting available."};
      }
      if (Number(unit.bonus_action_remaining || 0) <= 0){
        return {ok: false, reason: "No bonus actions left, matey."};
      }
      return {ok: true};
    }
    if (actionType === "reaction"){
      if (Number(unit.reaction_remaining || 0) <= 0){
        return {ok: false, reason: "No reactions left, matey."};
      }
      return {ok: true};
    }
    const remaining = Number(unit.spell_cast_remaining || 0);
    if (remaining <= 0){
      return {ok: false, reason: "You already cast a spell this turn."};
    }
    if (!unitHasMagicAction(unit, actionType)){
      return {ok: false, reason: "No spellcasting action available."};
    }
    if (Number(unit.action_remaining || 0) <= 0){
      return {ok: false, reason: "No actions left, matey."};
    }
    return {ok: true};
  }

  let spellLibraryRecords = [];
  let spellLibraryLoadPromise = null;
  let spellLibraryLoadError = "";
  let spellLibrarySearchTerm = "";
  let spellLibrarySortMode = "alpha";
  let spellLibraryAoeOnly = false;
  let spellLibraryPreviousFocus = null;
  let spellbookMode = "known";
  let spellbookSearchTerm = "";
  let spellbookSortMode = "alpha";
  let spellbookKnownEnabled = true;
  let spellbookKnownLimit = null;
  let spellbookPreparedLimit = null;
  let spellbookCantripsMax = null;
  let pendingKnownSet = new Set();
  let pendingPreparedSet = new Set();
  let pendingKnownFreeSet = new Set();
  let pendingPreparedFreeSet = new Set();
  let pendingCantripsSet = new Set();
  let spellbookLeftSelection = new Set();
  let spellbookRightSelection = new Set();
  let spellbookPreviousFocus = null;
  let spellDetailPreviousFocus = null;
  let activeSpellDetailSlug = null;
  let rulesStatusCache = null;
  let rulesTocCache = [];
  let rulesSpellPagesCache = null;
  let rulesViewerLoaded = false;
  let rulesViewerReady = false;
  let rulesLastPage = Number(localStorage.getItem(rulesLastPageStorageKey) || 1) || 1;

  function getPlayerLevel(profile){
    const raw = profile?.leveling?.level ?? profile?.leveling?.total_level ?? profile?.leveling?.lvl;
    const value = Number(raw);
    return Number.isFinite(value) ? Math.max(0, Math.floor(value)) : 0;
  }

  function maxSpellLevelForCharacter(level){
    if (level >= 17) return 9;
    if (level >= 15) return 8;
    if (level >= 13) return 7;
    if (level >= 11) return 6;
    if (level >= 9) return 5;
    if (level >= 7) return 4;
    if (level >= 5) return 3;
    if (level >= 3) return 2;
    if (level >= 1) return 1;
    return 0;
  }

  function getPresetLevelBySlug(slug){
    const preset = spellPresetBySlug.get(getSpellKey(slug));
    return preset ? getPresetLevelNumber(preset) : null;
  }

  function sortSlugsByName(slugs){
    return slugs.slice().sort((a, b) => {
      const presetA = spellPresetBySlug.get(getSpellKey(a));
      const presetB = spellPresetBySlug.get(getSpellKey(b));
      const nameA = normalizeTextValue(presetA?.name || a);
      const nameB = normalizeTextValue(presetB?.name || b);
      return nameA.localeCompare(nameB);
    });
  }

  function getSpellbookSearchText(slug){
    const preset = spellPresetBySlug.get(getSpellKey(slug));
    const tags = Array.isArray(preset?.tags) ? preset.tags.filter(Boolean).join(" ") : "";
    return [
      preset?.name,
      slug,
      preset?.school,
      preset?.casting_time,
      preset?.range,
      tags,
    ].filter(Boolean).join(" ").toLowerCase();
  }

  function filterSpellbookSlugs(slugs){
    const query = spellbookSearchTerm.trim().toLowerCase();
    if (!query) return slugs.slice();
    return slugs.filter((slug) => getSpellbookSearchText(slug).includes(query));
  }

  function sortSpellbookSlugs(slugs){
    return slugs.slice().sort((a, b) => {
      const presetA = spellPresetBySlug.get(getSpellKey(a));
      const presetB = spellPresetBySlug.get(getSpellKey(b));
      const nameA = normalizeTextValue(presetA?.name || a);
      const nameB = normalizeTextValue(presetB?.name || b);
      if (spellbookSortMode === "level"){
        const levelA = Number.isFinite(getPresetLevelNumber(presetA)) ? getPresetLevelNumber(presetA) : 99;
        const levelB = Number.isFinite(getPresetLevelNumber(presetB)) ? getPresetLevelNumber(presetB) : 99;
        if (levelA !== levelB) return levelA - levelB;
      }
      return nameA.localeCompare(nameB);
    });
  }

  function getEligibleSpellSlugs(profile){
    const allowedLevel = maxSpellLevelForCharacter(getPlayerLevel(profile));
    const slugs = [];
    cachedSpellPresets.forEach((preset) => {
      const level = getPresetLevelNumber(preset);
      if (Number.isFinite(level) && level > allowedLevel){
        return;
      }
      const slug = getPresetSlug(preset);
      if (slug){
        slugs.push(slug);
      }
    });
    return sortSlugsByName(Array.from(new Set(slugs.map(normalizeTextValue).filter(Boolean))));
  }

  function getSpellLibraryDescription(data){
    if (!data || typeof data !== "object") return "";
    const text = data.text && typeof data.text === "object" ? data.text : null;
    const importRaw = data.import && typeof data.import === "object" ? data.import.raw : null;
    const summary = normalizeTextValue(text?.summary);
    if (summary) return summary;
    const rules = normalizeTextValue(text?.rules);
    if (rules) return rules;
    const description = normalizeTextValue(importRaw?.description);
    if (description) return description;
    return "";
  }

  function formatSpellLibraryLevel(level){
    const num = Number(level);
    if (!Number.isFinite(num)) return "Level ?";
    if (num === 0) return "Cantrip";
    return `Level ${num}`;
  }

  function formatSpellLibraryList(values){
    if (!Array.isArray(values) || !values.length) return "";
    return values.map((value) => formatListGroupLabel(value)).join(", ");
  }

  function normalizeSpellSourceKey(value){
    return String(value || "")
      .toLowerCase()
      .replaceAll("", "'")
      .replace(/\[[^\]]*\]/g, "")
      .replace(/[^a-z0-9]+/g, " ")
      .trim()
      .replace(/\s+/g, " ");
  }

  function spellSourcePageForRecord(record){
    const pages = rulesSpellPagesCache && typeof rulesSpellPagesCache === "object" ? rulesSpellPagesCache : null;
    if (!pages) return null;
    const candidates = [record?.name, record?.id ? String(record.id).replace(/[-_]+/g, " ") : ""];
    for (const candidate of candidates){
      const key = normalizeSpellSourceKey(candidate);
      if (!key) continue;
      const page = Number(pages[key]);
      if (Number.isFinite(page) && page > 0){
        return page;
      }
    }
    return null;
  }

  function buildSpellLibrarySearchText(record){
    const parts = [
      record.id,
      record.name,
      record.school,
      record.castingTime,
      record.range,
      record.duration,
      record.components,
      record.classes.join(" "),
      record.tags.join(" "),
      record.description,
    ];
    return parts.filter(Boolean).join(" ").toLowerCase();
  }

  function buildSpellLibraryRecord(entry){
    const parsed = entry && typeof entry === "object" ? entry.parsed : null;
    const data = parsed && typeof parsed === "object" ? parsed : null;
    const id = String(entry?.id || data?.id || "").trim();
    const name = typeof data?.name === "string" ? data.name : (id || "Unknown Spell");
    const level = Number.isFinite(data?.level) ? Number(data.level) : null;
    const classes = Array.isArray(data?.lists?.classes) ? data.lists.classes.filter(Boolean) : [];
    const tags = Array.isArray(data?.tags) ? data.tags.filter(Boolean) : [];
    const record = {
      id,
      name,
      level,
      classes,
      tags,
      school: normalizeTextValue(data?.school),
      castingTime: normalizeTextValue(data?.casting_time),
      range: normalizeTextValue(data?.range),
      duration: normalizeTextValue(data?.duration),
      components: normalizeTextValue(data?.components),
      ritual: data?.ritual,
      concentration: data?.concentration,
      description: getSpellLibraryDescription(data),
      color: normalizeHexColor(data?.color || ""),
      data,
      error: entry?.error,
    };
    record.searchText = buildSpellLibrarySearchText(record);
    return record;
  }

  function getSpellLibraryAreaShape(record){
    const shape = normalizeLowerValue(record?.data?.mechanics?.targeting?.area?.shape);
    return AOE_SHAPES.has(shape) ? shape : "";
  }

  function isSpellLibraryAoeRecord(record){
    return Boolean(getSpellLibraryAreaShape(record));
  }

  function startPlanningAoePreview(record){
    if (!isPlanning){
      return;
    }
    if (!state){
      localToast("Map not ready yet, matey.");
      return;
    }
    const shape = getSpellLibraryAreaShape(record);
    const area = record?.data?.mechanics?.targeting?.area || null;
    if (!shape || !area){
      localToast("Unsupported AoE shape for this spell.");
      return;
    }
    const parsePositive = (value) => {
      const num = Number(value);
      return Number.isFinite(num) && num > 0 ? num : null;
    };
    const payload = {
      shape,
      name: normalizeTextValue(record?.name) || normalizeTextValue(record?.id) || "Spell",
      color: resolveSpellColor(record?.color || ""),
    };
    const radiusFt = parsePositive(area.radius_ft);
    const heightFt = parsePositive(area.height_ft);
    const sideFt = parsePositive(area.side_ft);
    const lengthFt = parsePositive(area.length_ft);
    const widthFt = parsePositive(area.width_ft);
    const thicknessFt = parsePositive(area.thickness_ft);
    const angleDeg = parsePositive(area.angle_deg);
    if (shape === "circle" || shape === "sphere" || shape === "cylinder"){
      if (radiusFt === null){
        localToast("Spell is missing AoE radius.");
        return;
      }
      payload.radius_ft = radiusFt;
      if ((shape === "sphere" || shape === "cylinder") && heightFt !== null){
        payload.height_ft = heightFt;
      }
    } else if (shape === "square" || shape === "cube"){
      if (sideFt === null){
        localToast("Spell is missing AoE side length.");
        return;
      }
      payload.side_ft = sideFt;
    } else if (shape === "cone"){
      if (lengthFt === null){
        localToast("Spell is missing cone length.");
        return;
      }
      payload.length_ft = lengthFt;
      payload.angle_deg = angleDeg !== null ? angleDeg : 90;
      payload.orient = normalizeLowerValue(area.orient) === "horizontal" ? "horizontal" : "vertical";
    } else if (shape === "line"){
      if (lengthFt === null || widthFt === null){
        localToast("Spell is missing line dimensions.");
        return;
      }
      payload.length_ft = lengthFt;
      payload.width_ft = widthFt;
      payload.orient = normalizeLowerValue(area.orient) === "horizontal" ? "horizontal" : "vertical";
      if (angleDeg !== null){
        payload.angle_deg = angleDeg;
      }
    } else if (shape === "wall"){
      if (lengthFt === null){
        localToast("Spell is missing wall length.");
        return;
      }
      const wallWidth = widthFt !== null ? widthFt : thicknessFt;
      if (wallWidth === null && heightFt === null){
        localToast("Spell is missing wall dimensions.");
        return;
      }
      payload.length_ft = lengthFt;
      if (wallWidth !== null){
        payload.width_ft = wallWidth;
      }
      if (thicknessFt !== null){
        payload.thickness_ft = thicknessFt;
      }
      if (heightFt !== null){
        payload.height_ft = heightFt;
      }
      payload.orient = normalizeLowerValue(area.orient) === "horizontal" ? "horizontal" : "vertical";
      if (angleDeg !== null){
        payload.angle_deg = angleDeg;
      }
    } else {
      localToast("Unsupported AoE shape for this spell.");
      return;
    }
    const center = defaultAoeCenter();
    payload.cx = center.cx;
    payload.cy = center.cy;
    const caster = getClaimedUnit();
    const msg = {type: "cast_aoe", payload, action_type: null};
    pendingAoePlacement = {
      msg,
      payload: {...payload},
      cursor: {col: Number(payload.cx), row: Number(payload.cy)},
      casterPos: caster?.pos ? toGridPoint(caster.pos) : null,
      casterCid: Number(caster?.cid),
      rangeFt: null,
      castConfirmMessage: null,
      concentrationConfirmMessage: null,
      resolveContext: null,
    };
    refreshAoePlacementAimGuide();
    openSpellLibraryOverlay(false);
    localToast("AoE preview: move cursor, click to place. ESC cancels.");
    draw();
  }

  async function loadSpellLibrary(){
    if (spellLibraryLoadPromise) return spellLibraryLoadPromise;
    spellLibraryLoadPromise = (async () => {
      if (spellLibraryStatus) spellLibraryStatus.textContent = "Loading spells";
      let ids = [];
      let bulkRecords = null;
      try {
        const response = await fetch("/api/spells?details=true");
        const payload = await response.json();
        if (Array.isArray(payload?.ids)){
          ids = payload.ids;
        }
        if (Array.isArray(payload?.spells)){
          bulkRecords = payload.spells;
        }
        spellLibraryLoadError = "";
      } catch (err){
        spellLibraryLoadError = "Unable to load spells.";
        if (spellLibraryStatus) spellLibraryStatus.textContent = spellLibraryLoadError;
        return [];
      }
      let results = bulkRecords;
      if (!Array.isArray(results) || !results.length){
        results = await Promise.all(
          ids.map(async (spellId) => {
            try {
              const response = await fetch(`/api/spells/${encodeURIComponent(spellId)}`);
              if (!response.ok){
                throw new Error(`HTTP ${response.status}`);
              }
              return await response.json();
            } catch (err){
              return {id: spellId, raw: null, parsed: null, error: String(err)};
            }
          })
        );
      }
      spellLibraryRecords = results.map(buildSpellLibraryRecord);
      return spellLibraryRecords;
    })();
    return spellLibraryLoadPromise;
  }

  function renderSpellLibrary(){
    if (!spellLibraryList) return;
    const query = spellLibrarySearchTerm.trim().toLowerCase();
    let records = spellLibraryRecords;
    if (isPlanning && spellLibraryAoeOnly){
      records = records.filter((record) => isSpellLibraryAoeRecord(record));
    }
    if (query){
      records = records.filter((record) => record.searchText.includes(query));
    }
    if (!records.length && spellLibraryLoadError){
      if (spellLibraryStatus) spellLibraryStatus.textContent = spellLibraryLoadError;
      spellLibraryList.innerHTML = "";
      return;
    }
    const sorted = records.slice().sort((a, b) => {
      if (spellLibrarySortMode === "level"){
        const levelA = Number.isFinite(a.level) ? a.level : 999;
        const levelB = Number.isFinite(b.level) ? b.level : 999;
        if (levelA !== levelB) return levelA - levelB;
      }
      return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
    });
    spellLibraryList.innerHTML = "";
    if (spellLibraryStatus){
      spellLibraryStatus.textContent = sorted.length
        ? `${sorted.length} spell${sorted.length === 1 ? "" : "s"}`
        : "No spells match that search.";
    }
    if (!sorted.length) return;
    const fragment = document.createDocumentFragment();
    sorted.forEach((record) => {
      const details = document.createElement("details");
      details.className = "spell-library-card";
      const summary = document.createElement("summary");
      summary.className = "spell-library-summary";
      const title = document.createElement("span");
      title.className = "spell-library-summary-title";
      title.textContent = record.name || record.id || "Unnamed Spell";
      const meta = document.createElement("span");
      meta.className = "spell-library-summary-meta";
      meta.textContent = formatSpellLibraryLevel(record.level);
      summary.appendChild(title);
      summary.appendChild(meta);
      const isAoeRecord = isSpellLibraryAoeRecord(record);
      if (isPlanning && isAoeRecord){
        const previewBtn = document.createElement("button");
        previewBtn.className = "btn";
        previewBtn.type = "button";
        previewBtn.textContent = "Preview AoE";
        previewBtn.addEventListener("click", (event) => {
          event.preventDefault();
          event.stopPropagation();
          startPlanningAoePreview(record);
        });
        summary.appendChild(previewBtn);
      }
      details.appendChild(summary);

      const body = document.createElement("div");
      body.className = "spell-library-detail-body";
      if (record.error && !record.data){
        const errorText = document.createElement("div");
        errorText.className = "spell-library-detail-description";
        errorText.textContent = "Spell data unavailable.";
        body.appendChild(errorText);
        details.appendChild(body);
        fragment.appendChild(details);
        return;
      }

      const grid = document.createElement("div");
      grid.className = "spell-library-detail-grid";
      const addRow = (label, value) => {
        if (!value && value !== 0) return;
        const labelEl = document.createElement("div");
        labelEl.className = "spell-library-detail-label";
        labelEl.textContent = label;
        const valueEl = document.createElement("div");
        valueEl.className = "spell-library-detail-value";
        valueEl.textContent = String(value);
        grid.appendChild(labelEl);
        grid.appendChild(valueEl);
      };

      addRow("Level", formatSpellLevelLabel(record.level));
      addRow("School", record.school);
      addRow("Casting Time", record.castingTime);
      addRow("Range", record.range);
      addRow("Duration", record.duration);
      addRow("Components", record.components);
      addRow("Classes", formatSpellLibraryList(record.classes));
      addRow("Tags", formatSpellLibraryList(record.tags));
      addRow("Ritual", record.ritual === true ? "Yes" : record.ritual === false ? "No" : "");
      addRow("Concentration", record.concentration === true ? "Yes" : record.concentration === false ? "No" : "");
      body.appendChild(grid);

      if (record.description){
        const description = document.createElement("div");
        description.className = "spell-library-detail-description";
        description.textContent = record.description;
        body.appendChild(description);
      }

      const sourcePage = spellSourcePageForRecord(record);
      if (sourcePage){
        const sourceRow = document.createElement("div");
        sourceRow.className = "spell-library-action-row";
        const sourceBtn = document.createElement("button");
        sourceBtn.className = "btn";
        sourceBtn.type = "button";
        sourceBtn.textContent = "Open Source";
        sourceBtn.addEventListener("click", (event) => {
          event.stopPropagation();
          showHelpModal();
          ensureRulesData()
            .then(() => jumpRulesPage(sourcePage))
            .catch(() => setHelpMessage("Failed to load rules metadata."));
        });
        sourceRow.appendChild(sourceBtn);
        body.appendChild(sourceRow);
      }

      const preset = spellPresetBySlug.get(getSpellKey(record.id))
        || cachedSpellPresets.find((entry) => normalizeLowerValue(entry?.name) === normalizeLowerValue(record.name));
      if (preset){
        const colorRow = document.createElement("div");
        colorRow.className = "spell-library-action-row";
        const colorWrap = document.createElement("div");
        colorWrap.className = "spell-library-color-row";
        const swatch = document.createElement("span");
        swatch.className = "spell-color-swatch";
        swatch.style.background = resolveSpellColor(preset.color);
        const colorLabel = document.createElement("span");
        colorLabel.className = "spell-library-detail-value";
        colorLabel.textContent = normalizeHexColor(preset.color || "") || "Default";
        colorWrap.appendChild(swatch);
        colorWrap.appendChild(colorLabel);
        const colorBtn = document.createElement("button");
        colorBtn.className = "btn";
        colorBtn.type = "button";
        colorBtn.textContent = "Edit Color";
        colorBtn.addEventListener("click", (event) => {
          event.stopPropagation();
          openSpellDetailOverlay(preset);
        });
        colorRow.appendChild(colorWrap);
        colorRow.appendChild(colorBtn);
        body.appendChild(colorRow);
      }

      details.appendChild(body);
      fragment.appendChild(details);
    });
    spellLibraryList.appendChild(fragment);
  }

  function openSpellLibraryOverlay(open, options = {}){
    if (!spellLibraryOverlay) return;
    const planningAoeFlow = options.mode === "planning_aoe";
    spellLibraryOverlay.classList.toggle("show", open);
    spellLibraryOverlay.setAttribute("aria-hidden", open ? "false" : "true");
    if (open){
      if (isPlanning && planningAoeFlow){
        spellLibraryAoeOnly = true;
      }
      spellLibraryPreviousFocus = document.activeElement instanceof HTMLElement
        ? document.activeElement
        : null;
      if (spellLibrarySearchInput) spellLibrarySearchInput.value = spellLibrarySearchTerm;
      if (spellLibrarySortSelect) spellLibrarySortSelect.value = spellLibrarySortMode;
      if (spellLibraryAoeOnlyInput){
        spellLibraryAoeOnlyInput.checked = isPlanning && spellLibraryAoeOnly;
      }
      if (spellLibraryAoeOnlyWrap){
        spellLibraryAoeOnlyWrap.style.display = isPlanning ? "inline-flex" : "none";
      }
      loadSpellLibrary().then(() => renderSpellLibrary());
      if (spellLibrarySearchInput) spellLibrarySearchInput.focus();
    } else {
      if (spellLibraryPreviousFocus){
        spellLibraryPreviousFocus.focus();
        spellLibraryPreviousFocus = null;
      }
    }
  }

  function setSpellbookStatus(text){
    if (!spellbookStatus) return;
    spellbookStatus.textContent = text || "";
  }

  function toggleSpellbookSelection(slug, selectionSet){
    if (selectionSet.has(slug)){
      selectionSet.delete(slug);
    } else {
      selectionSet.add(slug);
    }
  }

  function renderSpellbookList(listEl, slugs, selectionSet, emptyLabel, options = {}){
    if (!listEl) return;
    const {locked = false} = options;
    listEl.textContent = "";
    if (!slugs.length){
      const empty = document.createElement("div");
      empty.className = "spellbook-item";
      empty.textContent = emptyLabel || "No spells available.";
      empty.style.opacity = "0.6";
      listEl.appendChild(empty);
      return;
    }
    slugs.forEach((slug) => {
      const preset = spellPresetBySlug.get(getSpellKey(slug));
      const label = normalizeTextValue(preset?.name || slug);
      const level = getPresetLevelNumber(preset);
      const displayColor = resolveSpellColor(preset?.color);
      const item = document.createElement("button");
      item.type = "button";
      item.className = "spellbook-item";
      if (locked){
        item.classList.add("locked");
        item.setAttribute("aria-disabled", "true");
      }
      if (selectionSet.has(slug)){
        item.classList.add("selected");
        item.style.borderColor = displayColor;
        const highlight = rgbaFromHex(displayColor, 0.18);
        if (highlight){
          item.style.background = highlight;
        }
      }
      if (!locked){
        item.addEventListener("click", () => {
          toggleSpellbookSelection(slug, selectionSet);
          renderSpellbook();
        });
      }
      const nameWrap = document.createElement("span");
      nameWrap.className = "spellbook-item-name";
      const colorDot = document.createElement("span");
      colorDot.className = "spellbook-color-dot";
      colorDot.style.background = displayColor;
      nameWrap.appendChild(colorDot);
      const nameSpan = document.createElement("span");
      nameSpan.textContent = label;
      nameWrap.appendChild(nameSpan);
      item.appendChild(nameWrap);
      const meta = document.createElement("small");
      if (Number.isFinite(level)){
        meta.textContent = level === 0 ? "Cantrip" : `Lv ${level}`;
      } else {
        meta.textContent = "Level ?";
      }
      item.appendChild(meta);
      listEl.appendChild(item);
    });
  }

  function resetSpellbookSelections(){
    spellbookLeftSelection = new Set();
    spellbookRightSelection = new Set();
  }

  function renderSpellbook(){
    const playerName = getClaimedPlayerName();
    const profile = playerName ? getPlayerProfile(playerName) : null;
    if (!profile){
      setSpellbookStatus("Claim a character to manage spells.");
      return;
    }
    if (spellbookKnownEnabledToggle){
      spellbookKnownEnabledToggle.checked = spellbookKnownEnabled;
    }
    if (spellbookTabKnown){
      spellbookTabKnown.classList.toggle("hidden", !spellbookKnownEnabled);
      spellbookTabKnown.classList.toggle("accent", spellbookMode === "known");
    }
    if (!spellbookKnownEnabled && spellbookMode === "known"){
      spellbookMode = "prepared";
    }
    if (spellbookTabPrepared){
      spellbookTabPrepared.classList.toggle("accent", spellbookMode === "prepared");
    }
    const eligibleSlugs = getEligibleSpellSlugs(profile);
    const freePreparedSlugs = spellbookMode === "prepared"
      ? Array.from(pendingPreparedFreeSet)
      : [];
    const freePreparedSet = new Set(freePreparedSlugs.map(getSpellKey));
    const paidPreparedSlugs = spellbookMode === "prepared"
      ? Array.from(pendingPreparedSet).filter((slug) => !freePreparedSet.has(getSpellKey(slug)))
      : [];
    const rightSlugs = spellbookMode === "prepared"
      ? paidPreparedSlugs
      : Array.from(new Set([...pendingKnownSet, ...pendingCantripsSet]));
    const rightSet = new Set((spellbookMode === "prepared" ? [...rightSlugs, ...freePreparedSlugs] : rightSlugs).map(getSpellKey));
    const emptyLabel = spellbookSearchTerm.trim() ? "No spells match that search." : "No spells available.";
    let leftSlugs = [];
    if (spellbookMode === "known"){
      leftSlugs = eligibleSlugs.filter((slug) => !rightSet.has(getSpellKey(slug)));
      if (spellbookLeftTitle) spellbookLeftTitle.textContent = "Eligible Spells";
      if (spellbookRightTitle) spellbookRightTitle.textContent = "Known & Cantrips";
    } else {
      if (spellbookKnownEnabled){
        const knownSlugs = sortSlugsByName(Array.from(new Set([...pendingKnownSet, ...pendingCantripsSet])));
        leftSlugs = knownSlugs.filter((slug) => !rightSet.has(getSpellKey(slug)));
        if (spellbookLeftTitle) spellbookLeftTitle.textContent = "Known & Cantrips";
      } else {
        leftSlugs = eligibleSlugs.filter((slug) => !rightSet.has(getSpellKey(slug)));
        if (spellbookLeftTitle) spellbookLeftTitle.textContent = "Eligible Spells";
      }
      if (spellbookRightTitle) spellbookRightTitle.textContent = "Prepared Spells";
      const filteredFreePrepared = filterSpellbookSlugs(freePreparedSlugs);
      const sortedFreePrepared = sortSpellbookSlugs(filteredFreePrepared);
      if (spellbookFreePreparedTitle){
        spellbookFreePreparedTitle.classList.toggle("hidden", !sortedFreePrepared.length);
      }
      if (spellbookFreePreparedList){
        spellbookFreePreparedList.classList.toggle("hidden", !sortedFreePrepared.length);
      }
      renderSpellbookList(
        spellbookFreePreparedList,
        sortedFreePrepared,
        new Set(),
        emptyLabel,
        {locked: true},
      );
    }
    if (spellbookMode !== "prepared"){
      if (spellbookFreePreparedTitle) spellbookFreePreparedTitle.classList.add("hidden");
      if (spellbookFreePreparedList) spellbookFreePreparedList.classList.add("hidden");
    }
    const filteredLeft = filterSpellbookSlugs(leftSlugs);
    const filteredRight = filterSpellbookSlugs(rightSlugs);
    renderSpellbookList(spellbookLeftList, sortSpellbookSlugs(filteredLeft), spellbookLeftSelection, emptyLabel);
    renderSpellbookList(spellbookRightList, sortSpellbookSlugs(filteredRight), spellbookRightSelection, emptyLabel);
    const preparedCount = Array.from(pendingPreparedSet).filter((slug) => !pendingPreparedFreeSet.has(slug)).length;
    const preparedLimitLabel = Number.isFinite(spellbookPreparedLimit)
      ? `${preparedCount}/${spellbookPreparedLimit} prepared`
      : `${preparedCount} prepared`;
    const knownCount = Array.from(pendingKnownSet).filter((slug) => !pendingKnownFreeSet.has(slug)).length;
    const knownLimitLabel = Number.isFinite(spellbookKnownLimit)
      ? `${knownCount}/${spellbookKnownLimit} known`
      : `${knownCount} known`;
    const cantripCount = pendingCantripsSet.size;
    const cantripLimitLabel = Number.isFinite(spellbookCantripsMax)
      ? `${cantripCount}/${spellbookCantripsMax} cantrips`
      : `${cantripCount} cantrips`;
    setSpellbookStatus(`${knownLimitLabel}  ${cantripLimitLabel}  ${preparedLimitLabel}`);
  }

  function syncSpellbookClaimedPlayer(){
    const playerName = getClaimedPlayerName();
    const config = getSpellbookConfig(playerName);
    spellbookKnownEnabled = config.knownEnabled !== false;
    spellbookKnownLimit = config.knownLimit;
    spellbookPreparedLimit = config.max;
    spellbookCantripsMax = config.cantripsMax;
    pendingKnownSet = new Set(config.known.map(normalizeTextValue).filter(Boolean));
    pendingPreparedSet = new Set(config.prepared.map(normalizeTextValue).filter(Boolean));
    pendingKnownFreeSet = new Set(
      config.knownFree
        .map(normalizeTextValue)
        .filter((slug) => Boolean(slug) && pendingKnownSet.has(slug))
    );
    pendingPreparedFreeSet = new Set(
      config.preparedFree
        .map(normalizeTextValue)
        .filter((slug) => Boolean(slug) && pendingPreparedSet.has(slug))
    );
    pendingCantripsSet = new Set(config.cantrips.map(normalizeTextValue).filter(Boolean));
    spellbookMode = spellbookKnownEnabled ? "known" : "prepared";
    resetSpellbookSelections();
  }

  function openSpellbookOverlay(open){
    if (!spellbookOverlay) return;
    if (open && (claimedCid === null || claimedCid === undefined)){
      allowUnclaimed = false;
      localToast("Select your character to manage spells.");
      updateClaimOverlay();
      return;
    }
    spellbookOverlay.classList.toggle("show", open);
    spellbookOverlay.setAttribute("aria-hidden", open ? "false" : "true");
    if (open){
      spellbookPreviousFocus = document.activeElement instanceof HTMLElement
        ? document.activeElement
        : null;
      syncSpellbookClaimedPlayer();
      if (spellbookSearchInput) spellbookSearchInput.value = spellbookSearchTerm;
      if (spellbookSortSelect) spellbookSortSelect.value = spellbookSortMode;
      renderSpellbook();
      requestAnimationFrame(() => {
        spellbookBackBtn?.focus();
      });
    } else if (spellbookPreviousFocus){
      closeSpellDetailOverlay();
      spellbookPreviousFocus.focus();
      spellbookPreviousFocus = null;
    }
    updateModalOffsets();
    resize();
  }

  function applySpellbookAdd(){
    if (!spellbookLeftSelection.size) return;
    const additions = Array.from(spellbookLeftSelection);
    if (spellbookMode === "prepared"){
      additions.forEach((slug) => {
        if (pendingPreparedSet.has(slug)) return;
        const nextCount = Array.from(pendingPreparedSet).filter((item) => !pendingPreparedFreeSet.has(item)).length + 1;
        if (Number.isFinite(spellbookPreparedLimit) && nextCount > spellbookPreparedLimit){
          localToast(`Prepared spells limited to ${spellbookPreparedLimit}.`);
          return;
        }
        pendingPreparedSet.add(slug);
      });
    } else {
      additions.forEach((slug) => {
        const level = getPresetLevelBySlug(slug);
        if (level === 0){
          const nextCount = pendingCantripsSet.size + 1;
          if (Number.isFinite(spellbookCantripsMax) && nextCount > spellbookCantripsMax){
            localToast(`Cantrips limited to ${spellbookCantripsMax}.`);
            return;
          }
          pendingCantripsSet.add(slug);
        } else {
          if (!spellbookKnownEnabled){
            return;
          }
          const nextCount = Array.from(pendingKnownSet).filter((item) => !pendingKnownFreeSet.has(item)).length + 1;
          if (Number.isFinite(spellbookKnownLimit) && nextCount > spellbookKnownLimit){
            localToast(`Known spells limited to ${spellbookKnownLimit}.`);
            return;
          }
          pendingKnownSet.add(slug);
        }
      });
    }
    resetSpellbookSelections();
    renderSpellbook();
  }

  function applySpellbookRemove(){
    if (!spellbookRightSelection.size) return;
    const removals = Array.from(spellbookRightSelection);
    if (spellbookMode === "prepared"){
      removals.forEach((slug) => {
        if (pendingPreparedFreeSet.has(slug)) return;
        pendingPreparedSet.delete(slug);
      });
    } else {
      removals.forEach((slug) => {
        const level = getPresetLevelBySlug(slug);
        if (level === 0){
          pendingCantripsSet.delete(slug);
        } else {
          pendingKnownSet.delete(slug);
          pendingKnownFreeSet.delete(slug);
        }
      });
    }
    resetSpellbookSelections();
    renderSpellbook();
  }

  function showSpellbookConfirm(){
    if (!spellbookConfirmModal) return;
    const playerName = getClaimedPlayerName() || "player";
    const fileName = playerName.replace(/[^a-z0-9._-]+/gi, "-");
    if (spellbookConfirmText){
      spellbookConfirmText.textContent = `Overwrite players/${fileName}.yaml?`;
    }
    spellbookConfirmModal.classList.add("show");
    spellbookConfirmModal.setAttribute("aria-hidden", "false");
  }

  function hideSpellbookConfirm(){
    if (!spellbookConfirmModal) return;
    spellbookConfirmModal.classList.remove("show");
    spellbookConfirmModal.setAttribute("aria-hidden", "true");
  }

  async function saveSpellbookChanges(){
    const playerName = getClaimedPlayerName();
    if (!playerName){
      localToast("Claim a character first.");
      return;
    }
    const payload = {
      known_enabled: spellbookKnownEnabled,
      known_list: Array.from(pendingKnownSet),
      prepared_list: Array.from(pendingPreparedSet),
      cantrips_list: Array.from(pendingCantripsSet),
    };
    try {
      const response = await fetch(`/api/players/${encodeURIComponent(playerName)}/spellbook`, {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify(payload),
      });
      if (!response.ok){
        throw new Error(`Failed (${response.status})`);
      }
      const data = await response.json();
      if (data?.player && state?.player_profiles){
        state.player_profiles[data.player.name] = data.player;
      }
      localToast("Spellbook saved.");
      hideSpellbookConfirm();
      refreshSpellPresetOptions();
    } catch (err){
      console.warn("Failed to save spellbook.", err);
      localToast("Unable to save spellbook.");
    }
  }

  function setSpellDetailStatus(text){
    if (!spellDetailStatus) return;
    spellDetailStatus.textContent = text || "";
  }

  function updateSpellDetailColorInputs(color){
    const fallback = color || DEFAULT_SPELL_COLOR;
    if (spellDetailColorSwatch){
      spellDetailColorSwatch.style.background = fallback;
    }
    if (spellDetailColorInput){
      spellDetailColorInput.value = fallback;
    }
    if (spellDetailColorValue){
      spellDetailColorValue.value = color ? color.toUpperCase() : fallback.toUpperCase();
    }
  }

  async function saveSpellDetailColor(slug, color){
    if (!slug) return;
    setSpellDetailStatus("Saving color");
    try {
      const response = await fetch(`/api/spells/${encodeURIComponent(slug)}/color`, {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({color}),
      });
      if (!response.ok){
        throw new Error(`Failed (${response.status})`);
      }
      const data = await response.json();
      const updatedColor = normalizeHexColor(data?.spell?.color || color) || color;
      const preset = spellPresetBySlug.get(getSpellKey(slug));
      if (preset){
        preset.color = updatedColor;
      }
      updateSpellPresetOptions(cachedSpellPresets);
      updateSpellPresetDetails(preset || null);
      if (spellDetailOverlay?.classList.contains("show")){
        renderSpellDetailOverlay(preset || null);
      }
      setSpellDetailStatus("Color saved.");
    } catch (err){
      console.warn("Failed to save spell color.", err);
      setSpellDetailStatus("Unable to save color.");
      localToast("Unable to save spell color.");
    }
  }

  function renderSpellDetailOverlay(preset){
    if (!spellDetailGrid || !spellDetailName || !spellDetailMeta) return;
    if (!preset){
      spellDetailName.textContent = "Spell";
      spellDetailMeta.textContent = "";
      spellDetailGrid.textContent = "";
      updateSpellDetailColorInputs("");
      setSpellDetailStatus("");
      return;
    }
    const name = normalizeTextValue(preset.name) || normalizeTextValue(preset.slug) || "Spell";
    const levelLabel = formatSpellLevelLabel(preset.level);
    const school = normalizeTextValue(preset.school) || "Unknown";
    spellDetailName.textContent = name;
    spellDetailMeta.textContent = `${levelLabel}  ${school}`;
    const color = normalizeHexColor(preset.color || "");
    const displayColor = resolveSpellColor(preset.color);
    updateSpellDetailColorInputs(displayColor || "");
    setSpellDetailStatus("");
    const fields = [
      {label: "Level", value: levelLabel},
      {label: "School", value: school},
    ];
    const optionalFields = buildOptionalSpellDetails(preset);
    spellDetailGrid.textContent = "";
    [...fields, ...optionalFields].forEach((field) => {
      if (!field || (!field.value && field.value !== 0)) return;
      const row = document.createElement("div");
      row.className = "spell-details-row";
      const label = document.createElement("span");
      label.className = "spell-details-label";
      label.textContent = field.label;
      const value = document.createElement("span");
      value.className = "spell-details-value";
      value.textContent = field.value || "";
      row.appendChild(label);
      row.appendChild(value);
      spellDetailGrid.appendChild(row);
    });
  }

  function openSpellDetailOverlay(preset){
    if (!spellDetailOverlay) return;
    if (!preset){
      return;
    }
    activeSpellDetailSlug = getPresetSlug(preset);
    spellDetailOverlay.classList.add("show");
    spellDetailOverlay.setAttribute("aria-hidden", "false");
    spellDetailPreviousFocus = document.activeElement instanceof HTMLElement ? document.activeElement : null;
    if (spellDetailTitle){
      spellDetailTitle.textContent = normalizeTextValue(preset.name) || "Spell Details";
    }
    renderSpellDetailOverlay(preset);
    if (spellDetailBackBtn){
      spellDetailBackBtn.focus();
    }
  }

  function closeSpellDetailOverlay(){
    if (!spellDetailOverlay) return;
    spellDetailOverlay.classList.remove("show");
    spellDetailOverlay.setAttribute("aria-hidden", "true");
    activeSpellDetailSlug = null;
    if (spellDetailPreviousFocus){
      spellDetailPreviousFocus.focus();
      spellDetailPreviousFocus = null;
    }
  }

  function commitSpellDetailColor(raw){
    const color = normalizeHexColor(raw || "");
    if (!color){
      localToast("Pick a valid hex color, matey.");
      return;
    }
    updateSpellDetailColorInputs(color);
    if (activeSpellDetailSlug){
      saveSpellDetailColor(activeSpellDetailSlug, color);
    }
  }

  const updateSpellPresetDetails = (preset) => {
    if (!spellPresetDetails) return;
    if (!preset){
      spellPresetDetails.textContent = "Select a preset to see spell details.";
      updateManualEntryBadge(null);
      return;
    }
    updateManualEntryBadge(preset);
    const detailsGrid = document.createElement("div");
    detailsGrid.className = "spell-details-grid";
    const levelLabel = formatSpellLevelLabel(preset.level);
    const tags = Array.isArray(preset.tags) ? preset.tags.filter(Boolean) : [];
    const tagLabel = tags.length ? tags.join(", ") : "";
    const castingTime = normalizeTextValue(preset.casting_time) || "";
    const range = normalizeTextValue(preset.range) || "";
    const ritual = preset.ritual === true ? "Yes" : preset.ritual === false ? "No" : "";
    const concentration = preset.concentration === true ? "Yes" : preset.concentration === false ? "No" : "";
    const color = normalizeHexColor(preset.color || "");
    const displayColor = resolveSpellColor(preset.color);
    const lists = getSpellListEntries(preset.lists);
    const listLabel = lists.length
      ? lists.map((entry) => `${formatListGroupLabel(entry.group)}: ${entry.value}`).join("  ")
      : "";
    const fields = [
      {label: "Level", value: levelLabel},
      {label: "School", value: normalizeTextValue(preset.school) || ""},
      {label: "Tags", value: tagLabel},
      {label: "Casting", value: castingTime},
      {label: "Range", value: range},
      {label: "Ritual", value: ritual},
      {label: "Concentration", value: concentration},
      {label: "Lists", value: listLabel},
      {label: "Color", value: color || displayColor, color: displayColor},
    ];
    fields.forEach((field) => {
      const row = document.createElement("div");
      row.className = "spell-details-row";
      const label = document.createElement("span");
      label.className = "spell-details-label";
      label.textContent = field.label;
      const value = document.createElement("span");
      value.className = "spell-details-value";
      if (field.color){
        const swatch = document.createElement("span");
        swatch.className = "spell-color-swatch";
        swatch.style.background = field.color;
        value.appendChild(swatch);
        const text = document.createElement("span");
        text.textContent = ` ${field.value}`;
        value.appendChild(text);
      } else {
        value.textContent = field.value;
      }
      row.appendChild(label);
      row.appendChild(value);
      detailsGrid.appendChild(row);
    });
    spellPresetDetails.textContent = "";
    spellPresetDetails.appendChild(detailsGrid);
  };
  function formatSpellDamageLabel(preset){
    const base = preset?.default_damage ?? preset?.dice ?? "";
    const baseLabel = base !== null && base !== undefined && String(base).trim() ? String(base).trim() : "";
    const damageTypes = Array.isArray(preset?.damage_types)
      ? preset.damage_types.map((entry) => String(entry || "").trim()).filter(Boolean)
      : [];
    if (baseLabel && damageTypes.length){
      return `${baseLabel} (${damageTypes.join(", ")})`;
    }
    if (baseLabel) return baseLabel;
    if (damageTypes.length) return damageTypes.join(", ");
    return "";
  }
  function hasAoeShape(preset){
    if (!preset || typeof preset !== "object") return false;
    return Boolean(
      preset.shape ||
      preset.radius_ft ||
      preset.side_ft ||
      preset.length_ft ||
      preset.width_ft ||
      preset.angle_deg ||
      preset.height_ft ||
      preset.thickness_ft
    );
  }
  function buildOptionalSpellDetails(preset){
    if (!preset || typeof preset !== "object") return [];
    const tags = Array.isArray(preset.tags) ? preset.tags.filter(Boolean) : [];
    const lists = getSpellListEntries(preset.lists);
    const listLabel = lists.length
      ? lists.map((entry) => `${formatListGroupLabel(entry.group)}: ${entry.value}`).join("  ")
      : "";
    const fields = [
      {label: "Casting Time", value: normalizeTextValue(preset.casting_time)},
      {label: "Range", value: normalizeTextValue(preset.range)},
      {label: "Ritual", value: preset.ritual === true ? "Yes" : preset.ritual === false ? "No" : ""},
      {label: "Concentration", value: preset.concentration === true ? "Yes" : preset.concentration === false ? "No" : ""},
      {label: "Tags", value: tags.length ? tags.join(", ") : ""},
      {label: "Lists", value: listLabel},
      {label: "Shape", value: normalizeTextValue(preset.shape)},
      {label: "Radius (ft)", value: Number.isFinite(Number(preset.radius_ft)) ? String(preset.radius_ft) : ""},
      {label: "Side (ft)", value: Number.isFinite(Number(preset.side_ft)) ? String(preset.side_ft) : ""},
      {label: "Length (ft)", value: Number.isFinite(Number(preset.length_ft)) ? String(preset.length_ft) : ""},
      {label: "Width (ft)", value: Number.isFinite(Number(preset.width_ft)) ? String(preset.width_ft) : ""},
      {label: "Angle (deg)", value: Number.isFinite(Number(preset.angle_deg)) ? String(preset.angle_deg) : ""},
      {label: "Height (ft)", value: Number.isFinite(Number(preset.height_ft)) ? String(preset.height_ft) : ""},
      {label: "Duration (turns)", value: Number.isFinite(Number(preset.duration_turns)) ? String(preset.duration_turns) : ""},
      {label: "Save", value: preset.save_type ? String(preset.save_type || "").toUpperCase() : ""},
      {label: "Save DC", value: Number.isFinite(Number(preset.save_dc)) ? String(preset.save_dc) : ""},
      {label: "Damage", value: formatSpellDamageLabel(preset)},
      {label: "Half on Save", value: preset.half_on_pass ? "Yes" : ""},
      {label: "Automation", value: normalizeTextValue(preset.automation)},
    ];
    return fields.filter((field) => field.value);
  }
  const spellFilterState = {
    search: "",
    levelMin: "",
    levelMax: "",
    schools: [],
    tags: [],
    castingTime: "",
    range: "",
    ritualOnly: false,
    concentrationOnly: false,
    lists: [],
  };

  const readCheckedValues = (container) => {
    if (!container) return [];
    return Array.from(container.querySelectorAll('input[type="checkbox"]:checked')).map((input) => String(input.value || "")).filter(Boolean);
  };

  const updateMultiSelectSummary = (detailsEl, label, values) => {
    if (!detailsEl) return;
    const summary = detailsEl.querySelector('summary');
    if (!summary) return;
    summary.textContent = values.length ? `${label}: ${values.join(', ')}` : `${label}: Any`;
  };

  const renderCheckboxOptions = (container, values, selectedValues, name) => {
    if (!container) return;
    const selected = new Set((selectedValues || []).map(normalizeLowerValue));
    container.textContent = "";
    values.forEach((value, idx) => {
      const id = `${name}_${idx}`;
      const label = document.createElement('label');
      const input = document.createElement('input');
      input.type = 'checkbox';
      input.id = id;
      input.value = value;
      input.checked = selected.has(normalizeLowerValue(value));
      label.appendChild(input);
      const span = document.createElement('span');
      span.textContent = value;
      label.appendChild(span);
      container.appendChild(label);
    });
  };

  const updateSelectOptions = (selectEl, values) => {
    if (!selectEl) return;
    const currentValue = selectEl.value;
    selectEl.textContent = '';
    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = 'Any';
    selectEl.appendChild(placeholder);
    values.forEach((value) => {
      const opt = document.createElement('option');
      opt.value = value;
      opt.textContent = value;
      selectEl.appendChild(opt);
    });
    selectEl.value = values.includes(currentValue) ? currentValue : '';
  };

  const loadSpellFilterState = () => {
    try {
      const raw = localStorage.getItem(spellFilterStorageKey);
      if (!raw) return;
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== 'object') return;
      spellFilterState.search = normalizeTextValue(parsed.search);
      spellFilterState.levelMin = normalizeTextValue(parsed.levelMin);
      spellFilterState.levelMax = normalizeTextValue(parsed.levelMax);
      spellFilterState.schools = Array.isArray(parsed.schools) ? parsed.schools.map(normalizeTextValue).filter(Boolean) : [];
      spellFilterState.tags = Array.isArray(parsed.tags) ? parsed.tags.map(normalizeTextValue).filter(Boolean) : [];
      spellFilterState.castingTime = normalizeTextValue(parsed.castingTime);
      spellFilterState.range = normalizeTextValue(parsed.range);
      spellFilterState.ritualOnly = parsed.ritualOnly === true;
      spellFilterState.concentrationOnly = parsed.concentrationOnly === true;
      spellFilterState.lists = Array.isArray(parsed.lists) ? parsed.lists.map(normalizeTextValue).filter(Boolean) : [];
    } catch (err){
      console.warn('Unable to load spell filter state.', err);
    }
  };

  const saveSpellFilterState = () => {
    try {
      localStorage.setItem(spellFilterStorageKey, JSON.stringify(spellFilterState));
    } catch (err){
      console.warn('Unable to save spell filter state.', err);
    }
  };

  const syncSpellFilterInputsFromState = () => {
    if (castSearchInput) castSearchInput.value = spellFilterState.search;
    if (castFilterLevelMinInput) castFilterLevelMinInput.value = spellFilterState.levelMin;
    if (castFilterLevelMaxInput) castFilterLevelMaxInput.value = spellFilterState.levelMax;
    if (castFilterCastingTimeInput) castFilterCastingTimeInput.value = spellFilterState.castingTime;
    if (castFilterRangeInput) castFilterRangeInput.value = spellFilterState.range;
    if (castFilterRitualInput) castFilterRitualInput.checked = spellFilterState.ritualOnly;
    if (castFilterConcentrationInput) castFilterConcentrationInput.checked = spellFilterState.concentrationOnly;
  };

  const applySpellFilterStateFromInputs = () => {
    spellFilterState.search = normalizeTextValue(castSearchInput?.value);
    spellFilterState.levelMin = normalizeTextValue(castFilterLevelMinInput?.value);
    spellFilterState.levelMax = normalizeTextValue(castFilterLevelMaxInput?.value);
    spellFilterState.schools = readCheckedValues(castFilterSchoolOptions);
    spellFilterState.tags = readCheckedValues(castFilterTagOptions);
    spellFilterState.castingTime = normalizeTextValue(castFilterCastingTimeInput?.value);
    spellFilterState.range = normalizeTextValue(castFilterRangeInput?.value);
    spellFilterState.ritualOnly = castFilterRitualInput?.checked === true;
    spellFilterState.concentrationOnly = castFilterConcentrationInput?.checked === true;
    spellFilterState.lists = readCheckedValues(castFilterListOptions);
    saveSpellFilterState();
  };

  const updateSpellFilterSummary = () => {
    const parts = [];
    if (spellFilterState.search) parts.push(`Search: ${spellFilterState.search}`);
    if (spellFilterState.levelMin || spellFilterState.levelMax){
      const from = spellFilterState.levelMin || 'Any';
      const to = spellFilterState.levelMax || 'Any';
      parts.push(`Level: ${from}-${to}`);
    }
    if (spellFilterState.schools.length) parts.push(`School: ${spellFilterState.schools.join(', ')}`);
    if (spellFilterState.tags.length) parts.push(`Tags: ${spellFilterState.tags.join(', ')}`);
    if (spellFilterState.lists.length) parts.push(`Lists: ${spellFilterState.lists.join(', ')}`);
    if (spellFilterState.castingTime) parts.push(`Casting: ${spellFilterState.castingTime}`);
    if (spellFilterState.range) parts.push(`Range: ${spellFilterState.range}`);
    if (spellFilterState.ritualOnly) parts.push('Ritual only');
    if (spellFilterState.concentrationOnly) parts.push('Concentration only');
    if (spellFilterSummary){
      spellFilterSummary.textContent = parts.length ? parts.join('  ') : 'No filters active.';
    }
    updateMultiSelectSummary(castFilterSchoolMulti, 'Schools', spellFilterState.schools);
    updateMultiSelectSummary(castFilterTagMulti, 'Tags', spellFilterState.tags);
    updateMultiSelectSummary(castFilterListMulti, 'Lists', spellFilterState.lists);
  };

  const updateSpellFilterOptions = () => {
    const schools = new Set();
    const castingTimes = new Set();
    const ranges = new Set();
    const tags = new Set();
    const lists = new Set();
    cachedSpellPresets.forEach((preset) => {
      const school = normalizeTextValue(preset.school);
      if (school) schools.add(school);
      const castingTime = normalizeTextValue(preset.casting_time);
      if (castingTime) castingTimes.add(castingTime);
      const range = normalizeTextValue(preset.range);
      if (range) ranges.add(range);
      (Array.isArray(preset.tags) ? preset.tags : []).forEach((tag) => {
        const value = normalizeTextValue(tag);
        if (value) tags.add(value);
      });
      getSpellListEntries(preset.lists).forEach((entry) => {
        lists.add(`${formatListGroupLabel(entry.group)}: ${entry.value}`);
      });
    });
    renderCheckboxOptions(castFilterSchoolOptions, Array.from(schools).sort((a,b)=>a.localeCompare(b)), spellFilterState.schools, 'school_filter');
    renderCheckboxOptions(castFilterTagOptions, Array.from(tags).sort((a,b)=>a.localeCompare(b)), spellFilterState.tags, 'tag_filter');
    renderCheckboxOptions(castFilterListOptions, Array.from(lists).sort((a,b)=>a.localeCompare(b)), spellFilterState.lists, 'list_filter');
    updateSelectOptions(castFilterCastingTimeInput, Array.from(castingTimes).sort((a,b)=>a.localeCompare(b)));
    updateSelectOptions(castFilterRangeInput, Array.from(ranges).sort((a,b)=>a.localeCompare(b)));
    syncSpellFilterInputsFromState();
    updateSpellFilterSummary();
  };

  const matchesSpellFilters = (preset) => {
    const levelNum = getPresetLevelNumber(preset);
    const min = spellFilterState.levelMin === '' ? null : Number(spellFilterState.levelMin);
    const max = spellFilterState.levelMax === '' ? null : Number(spellFilterState.levelMax);
    if (Number.isFinite(levelNum)){
      if (min !== null && levelNum < min) return false;
      if (max !== null && levelNum > max) return false;
    }

    if (spellFilterState.schools.length){
      const selected = spellFilterState.schools.map(normalizeLowerValue);
      if (!selected.includes(normalizeLowerValue(preset.school))) return false;
    }

    if (spellFilterState.castingTime){
      if (!normalizeLowerValue(preset.casting_time).includes(normalizeLowerValue(spellFilterState.castingTime))) return false;
    }
    if (spellFilterState.range){
      if (!normalizeLowerValue(preset.range).includes(normalizeLowerValue(spellFilterState.range))) return false;
    }
    if (spellFilterState.ritualOnly && preset.ritual !== true) return false;
    if (spellFilterState.concentrationOnly && preset.concentration !== true) return false;

    if (spellFilterState.tags.length){
      const presetTags = Array.isArray(preset.tags) ? preset.tags.map(normalizeLowerValue) : [];
      if (!spellFilterState.tags.every((tag) => presetTags.includes(normalizeLowerValue(tag)))) return false;
    }

    if (spellFilterState.lists.length){
      const presetLists = getSpellListEntries(preset.lists).map((entry) => `${formatListGroupLabel(entry.group)}: ${entry.value}`.toLowerCase());
      if (!spellFilterState.lists.every((item) => presetLists.includes(item.toLowerCase()))) return false;
    }

    if (spellFilterState.search){
      const haystack = [preset.name, preset.description, preset.casting_time, preset.range, preset.school, ...(Array.isArray(preset.tags) ? preset.tags : [])]
        .map(normalizeLowerValue)
        .join(' ');
      if (!haystack.includes(normalizeLowerValue(spellFilterState.search))) return false;
    }
    return true;
  };

  loadSpellFilterState();

  const refreshSpellPresetOptions = () => {
    if (!castPresetInput) return;
    const currentValue = String(castPresetInput.value || "");
    castPresetInput.textContent = "";
    castPresetInput.disabled = false;

    const customOption = document.createElement("option");
    customOption.value = "";
    customOption.textContent = "Custom";
    castPresetInput.appendChild(customOption);

    const customSummonOption = document.createElement("option");
    customSummonOption.value = CUSTOM_SUMMON_PRESET_NAME;
    customSummonOption.textContent = CUSTOM_SUMMON_PRESET_NAME;
    castPresetInput.appendChild(customSummonOption);

    const availablePresets = cachedSpellPresets.slice();
    const preparedSpellSet = getPreparedSpellFilterSet();
    const filtered = filterPresetsByKnownList(availablePresets, preparedSpellSet)
      .filter(matchesSpellFilters);

    const groups = new Map();
    filtered.forEach((preset) => {
      const level = getPresetLevelNumber(preset);
      const key = level === null ? "unknown" : String(level);
      if (!groups.has(key)){
        groups.set(key, []);
      }
      groups.get(key).push(preset);
    });
    const orderedLevels = [];
    for (let i = 0; i <= 9; i += 1){
      if (groups.has(String(i))){
        orderedLevels.push(String(i));
      }
    }
    if (groups.has("unknown")){
      orderedLevels.push("unknown");
    }
    orderedLevels.forEach((levelKey) => {
      const list = groups.get(levelKey) || [];
      list.sort((a, b) => normalizeTextValue(a.name).localeCompare(normalizeTextValue(b.name)));
      const optgroup = document.createElement("optgroup");
      optgroup.label = levelKey === "unknown"
        ? "Unknown Level"
        : formatSpellLevelLabel(Number(levelKey));
      list.forEach((preset) => {
        const name = normalizeTextValue(preset.name);
        if (!name) return;
        const opt = document.createElement("option");
        opt.value = name;
        opt.textContent = name;
        optgroup.appendChild(opt);
      });
      if (optgroup.children.length){
        castPresetInput.appendChild(optgroup);
      }
    });

    if (!filtered.length){
      const empty = document.createElement("option");
      empty.value = "";
      empty.textContent = "No spells match filters";
      empty.disabled = true;
      castPresetInput.appendChild(empty);
    }

    const validValues = new Set(filtered.map((preset) => normalizeTextValue(preset.name)));
    validValues.add("");
    validValues.add(CUSTOM_SUMMON_PRESET_NAME);
    castPresetInput.value = validValues.has(currentValue) ? currentValue : "";
    updateSpellPresetDetails(getSelectedSpellPreset());
    if (castSpellModal?.classList.contains("show")){
      renderCastSpellModalPresetList();
      renderCastSpellPreview();
    }
  };

  const updateSpellPresetOptions = (presets) => {
    const list = normalizeSpellPresets(presets);
    refreshCustomSummonMonsterOptions();
    const signature = JSON.stringify(list.map(p => [
      String(p.slug || ""),
      String(p.name || ""),
      String(p.shape || ""),
      String(p.level || ""),
      String(p.school || ""),
      String(p.casting_time || ""),
      String(p.range || ""),
      String(p.ritual || ""),
      String(p.concentration || ""),
      String(p.color || ""),
      String(p.is_aoe || ""),
      String(p.action_type || ""),
      JSON.stringify(p.tags || []),
      JSON.stringify(p.lists || {}),
      JSON.stringify(p.upcast || {}),
      JSON.stringify(p.scaling || {}),
      JSON.stringify(p.summon || {}),
      JSON.stringify(p.mechanics?.aoe_behavior || {}),
      JSON.stringify(p.mechanics?.targeting?.range || {}),
      String(p.isAoE || ""),
      String(p.isSummon || ""),
    ]));
    if (signature === lastSpellPresetSignature){
      return;
    }
    lastSpellPresetSignature = signature;
    cachedSpellPresets = list;
    spellPresetBySlug = new Map();
    list.forEach((preset) => {
      const slug = getPresetSlug(preset);
      if (slug){
        spellPresetBySlug.set(getSpellKey(slug), preset);
      }
    });
    updateSpellFilterOptions();
    refreshSpellPresetOptions();
    if (spellbookOverlay?.classList.contains("show")){
      renderSpellbook();
    }
  };

  const registerSpellFilterListener = (input, useInputEvent = false) => {
    if (!input) return;
    const handler = () => {
      applySpellFilterStateFromInputs();
      updateSpellFilterSummary();
      refreshSpellPresetOptions();
    };
    input.addEventListener('change', handler);
    if (useInputEvent){
      input.addEventListener('input', handler);
    }
  };

  registerSpellFilterListener(castSearchInput, true);
  registerSpellFilterListener(castFilterLevelMinInput);
  registerSpellFilterListener(castFilterLevelMaxInput);
  registerSpellFilterListener(castFilterCastingTimeInput);
  registerSpellFilterListener(castFilterRangeInput);
  registerSpellFilterListener(castFilterRitualInput);
  registerSpellFilterListener(castFilterConcentrationInput);

  [castFilterSchoolOptions, castFilterTagOptions, castFilterListOptions].forEach((container) => {
    container?.addEventListener('change', () => {
      applySpellFilterStateFromInputs();
      updateSpellFilterSummary();
      refreshSpellPresetOptions();
    });
  });

  openSpellFiltersBtn?.addEventListener('click', () => {
    spellFilterModal?.classList.add('show');
    spellFilterModal?.setAttribute('aria-hidden', 'false');
  });
  closeSpellFiltersBtn?.addEventListener('click', () => {
    spellFilterModal?.classList.remove('show');
    spellFilterModal?.setAttribute('aria-hidden', 'true');
  });
  applySpellFiltersBtn?.addEventListener('click', () => {
    applySpellFilterStateFromInputs();
    updateSpellFilterSummary();
    refreshSpellPresetOptions();
    spellFilterModal?.classList.remove('show');
    spellFilterModal?.setAttribute('aria-hidden', 'true');
  });
  const clearSpellFilters = () => {
    Object.assign(spellFilterState, {
      search: '', levelMin: '', levelMax: '', schools: [], tags: [], castingTime: '', range: '', ritualOnly: false, concentrationOnly: false, lists: [],
    });
    saveSpellFilterState();
    updateSpellFilterOptions();
    refreshSpellPresetOptions();
  };
  clearSpellFiltersBtn?.addEventListener('click', () => {
    clearSpellFilters();
  });

  const setCastFieldEnabled = (input, enabled) => {
    if (!input) return;
    input.disabled = !enabled;
    input.readOnly = !enabled;
  };

  const setCastFieldVisible = (field, visible) => {
    if (!field) return;
    field.style.display = visible ? "" : "none";
  };

  const titleCaseFromSlug = (value) => normalizeTextValue(value)
    .split("-")
    .filter(Boolean)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join(" ");

  const getSummonChoices = (preset) => {
    const choices = Array.isArray(preset?.summon?.choices) ? preset.summon.choices : [];
    return choices.filter((choice) => choice && typeof choice === "object").map((choice) => {
      const slug = normalizeTextValue(choice.monster_slug);
      const fallback = titleCaseFromSlug(slug);
      return {
        ...choice,
        monster_slug: slug,
        variants: Array.isArray(choice.variants) ? choice.variants.map(v => normalizeTextValue(v)).filter(Boolean) : [],
        name: normalizeTextValue(choice.name) || fallback || "Unknown creature",
      };
    });
  };

  const getSpellAppearanceOptions = (preset) => {
    const topLevelOptions = preset?.appearance_options;
    const mechanicsOptions = preset?.mechanics?.ui?.appearance_options;
    const options = Array.isArray(topLevelOptions)
      ? topLevelOptions
      : (Array.isArray(mechanicsOptions) ? mechanicsOptions : []);
    return options.map((option) => String(option || "").trim()).filter(Boolean);
  };

  const getSummonQuantityRule = (preset, slotLevel, selectedChoice) => {
    const count = preset?.summon?.count;
    if (!count || typeof count !== "object") return {min: 1, max: 1, fixed: 1};
    const selectedSlug = normalizeTextValue(selectedChoice);
    const parseEntries = (entry) => {
      if (!entry || typeof entry !== "object") return [];
      const options = Array.isArray(entry.options) ? entry.options : [entry];
      return options
        .filter(opt => opt && typeof opt === "object")
        .map((opt) => {
          const qty = Number(opt.quantity);
          const creatureOptions = Array.isArray(opt.creature_options)
            ? opt.creature_options.map((slug) => normalizeTextValue(slug)).filter(Boolean)
            : [];
          return {
            quantity: Number.isFinite(qty) && qty > 0 ? Math.floor(qty) : null,
            creature_options: creatureOptions,
          };
        })
        .filter(opt => Number.isFinite(opt.quantity));
    };
    const pickBySlot = () => {
      const base = count.base && typeof count.base === "object" ? count.base : null;
      const overrides = Array.isArray(count.slot_overrides) ? count.slot_overrides : [];
      const slot = Number.isFinite(Number(slotLevel)) ? Math.floor(Number(slotLevel)) : Number(base?.slot_level || preset?.level || 0);
      const match = overrides.find((entry) => Number(entry?.slot_level) === slot);
      return parseEntries(match || base);
    };
    let quantities = [];
    if (count.kind === "variable_by_slot"){
      quantities = pickBySlot();
    } else {
      const min = Number(count.min);
      const max = Number(count.max);
      if (Number.isFinite(min) && Number.isFinite(max)){
        return {min: Math.floor(min), max: Math.floor(max), fixed: min === max ? Math.floor(min) : null};
      }
      quantities = parseEntries(count);
    }
    if (!quantities.length){
      return {min: 1, max: 1, fixed: 1};
    }
    const matching = selectedSlug
      ? quantities.filter((item) => !item.creature_options.length || item.creature_options.includes(selectedSlug))
      : quantities;
    const pool = matching.length ? matching : quantities;
    const values = Array.from(new Set(pool.map(item => item.quantity))).sort((a, b) => a - b);
    if (!values.length){
      return {min: 1, max: 1, fixed: 1};
    }
    return {
      min: values[0],
      max: values[values.length - 1],
      fixed: values.length === 1 ? values[0] : null,
    };
  };

  let castSummonValidation = {ok: true, reason: ""};
  const validateSummonForm = (preset, showToast = false) => {
    if (!isSummonPreset(preset)){
      castSummonValidation = {ok: true, reason: ""};
      if (castSubmitBtn) castSubmitBtn.disabled = false;
      return castSummonValidation;
    }
    const choices = getSummonChoices(preset);
    const selectedChoice = normalizeTextValue(castSummonChoiceInput?.value || choices[0]?.monster_slug || "");
    const quantityRule = getSummonQuantityRule(preset, Number(castSlotLevelInput?.value), selectedChoice);
    const rawQty = Number(castSummonQuantityInput?.value);
    const selectedVariant = normalizeTextValue(castSummonVariantInput?.value || "");
    const quantity = Number.isFinite(rawQty) ? Math.floor(rawQty) : null;
    let reason = "";
    if (!selectedChoice){
      reason = "Pick a summon option first, matey.";
    } else if (preset?.summon?.mount && !selectedVariant){
      reason = "Pick a mount variant first, matey.";
    } else if (!Number.isFinite(quantity) || quantity <= 0){
      reason = "Enter a valid summon quantity, matey.";
    } else if (quantityRule.fixed !== null && quantity !== quantityRule.fixed){
      reason = `This spell summons exactly ${quantityRule.fixed}.`;
    } else if (quantity < quantityRule.min || quantity > quantityRule.max){
      reason = `Summon quantity must be between ${quantityRule.min} and ${quantityRule.max}.`;
    }
    castSummonValidation = {ok: !reason, reason};
    if (castSubmitBtn) castSubmitBtn.disabled = !castSummonValidation.ok;
    if (showToast && reason){
      localToast(reason);
    }
    return castSummonValidation;
  };

  const updateSummonOptions = (preset) => {
    const summonSpell = isSummonPreset(preset);
    const customSummon = Boolean(preset?.isCustomSummon);
    const appearanceOptions = getSpellAppearanceOptions(preset);
    const hasAppearanceOptions = !summonSpell && appearanceOptions.length > 0;
    if (summonOptions){
      summonOptions.classList.toggle("hidden", !summonSpell);
    }
    if (aoeOptions){
      aoeOptions.classList.toggle("hidden", summonSpell);
    }
    castSummonChoiceField?.classList.toggle("hidden", customSummon || !summonSpell);
    castSummonQuantityField?.classList.toggle("hidden", !summonSpell);
    castSummonVariantField?.classList.toggle("hidden", customSummon || (!summonSpell && !hasAppearanceOptions));
    castCustomSummonNameField?.classList.toggle("hidden", !customSummon);
    castCustomSummonMonsterSearchField?.classList.toggle("hidden", !customSummon);
    castCustomSummonMonsterField?.classList.toggle("hidden", !customSummon);
    castCustomSummonTypeField?.classList.toggle("hidden", !customSummon);
    castCustomSummonHpField?.classList.toggle("hidden", !customSummon);
    castCustomSummonAcField?.classList.toggle("hidden", !customSummon);
    castCustomSummonWalkField?.classList.toggle("hidden", !customSummon);
    castCustomSummonSwimField?.classList.toggle("hidden", !customSummon);
    castCustomSummonFlyField?.classList.toggle("hidden", !customSummon);
    castCustomSummonBurrowField?.classList.toggle("hidden", !customSummon);
    castCustomSummonClimbField?.classList.toggle("hidden", !customSummon);
    castCustomSummonStrField?.classList.toggle("hidden", !customSummon);
    castCustomSummonDexField?.classList.toggle("hidden", !customSummon);
    castCustomSummonConField?.classList.toggle("hidden", !customSummon);
    castCustomSummonIntField?.classList.toggle("hidden", !customSummon);
    castCustomSummonWisField?.classList.toggle("hidden", !customSummon);
    castCustomSummonChaField?.classList.toggle("hidden", !customSummon);
    castCustomSummonRangeField?.classList.toggle("hidden", !customSummon);

    const disableForSummon = (input) => {
      if (!input) return;
      input.disabled = summonSpell;
      if (summonSpell && !customSummon){
        input.readOnly = true;
      }
    };
    [castShapeInput, castDefaultDamageInput, castDiceInput, castDamageTypeInput, castAddDamageTypeBtn, castColorInput].forEach(disableForSummon);
    if (!summonSpell){
      if (castSummonVariantLabel){
        castSummonVariantLabel.textContent = hasAppearanceOptions ? "Appearance" : "Variant";
      }
      if (castSummonVariantInput){
        const currentAppearance = String(castSummonVariantInput.value || "").trim();
        castSummonVariantInput.innerHTML = "";
        if (hasAppearanceOptions){
          appearanceOptions.forEach((option) => {
            const opt = document.createElement("option");
            opt.value = option;
            opt.textContent = option;
            castSummonVariantInput.appendChild(opt);
          });
          castSummonVariantInput.value = currentAppearance || appearanceOptions[0] || "";
        } else {
          castSummonVariantInput.value = "";
        }
      }
      if (castShapeInput) castShapeInput.readOnly = false;
      if (castDefaultDamageInput) castDefaultDamageInput.readOnly = false;
      if (castDiceInput) castDiceInput.readOnly = false;
      if (castDamageTypeInput) castDamageTypeInput.readOnly = false;
      if (castColorInput) castColorInput.readOnly = false;
      if (castSummonMeta) castSummonMeta.textContent = "";
      if (castSubmitBtn) castSubmitBtn.disabled = false;
      return;
    }

    if (customSummon){
      const hasMonsterSelection = normalizeTextValue(castCustomSummonMonsterInput?.value);
      refreshCustomSummonMonsterOptions();
      const selectedChoice = getSelectedCustomSummonChoice();
      if (!hasMonsterSelection || !selectedChoice || selectedChoice.slug !== hasMonsterSelection){
        applyCustomSummonTemplate(selectedChoice || null, !hasMonsterSelection);
      }
      if (castSummonQuantityInput){
        const currentQty = Number(castSummonQuantityInput.value);
        castSummonQuantityInput.min = "1";
        castSummonQuantityInput.max = "20";
        castSummonQuantityInput.value = String(Number.isFinite(currentQty) && currentQty > 0 ? Math.floor(currentQty) : 1);
        castSummonQuantityInput.readOnly = false;
      }
      if (castCustomSummonRangeInput){
        const currentRange = Number(castCustomSummonRangeInput.value);
        castCustomSummonRangeInput.value = String(Number.isFinite(currentRange) && currentRange >= 0 ? Math.floor(currentRange) : 30);
      }
      if (castSummonMeta){
        const qty = Math.max(1, Math.floor(Number(castSummonQuantityInput?.value || 1)));
        const range = Math.max(0, Math.floor(Number(castCustomSummonRangeInput?.value || 30)));
        const monsterLabel = selectedChoice ? `${selectedChoice.name} (${selectedChoice.slug})` : "manual";
        castSummonMeta.textContent = `Custom summon placement  Source: ${monsterLabel}  Quantity: ${qty}  Range: ${range} ft`;
      }
      castSummonValidation = {ok: true, reason: ""};
      if (castSubmitBtn) castSubmitBtn.disabled = false;
      return;
    }

    const choices = getSummonChoices(preset);
    if (castSummonChoiceInput){
      const current = normalizeTextValue(castSummonChoiceInput.value);
      castSummonChoiceInput.innerHTML = "";
      choices.forEach((choice) => {
        const opt = document.createElement("option");
        opt.value = choice.monster_slug;
        const desc = normalizeTextValue(choice.description || choice.notes);
        opt.textContent = desc ? `${choice.name}  ${desc}` : choice.name;
        castSummonChoiceInput.appendChild(opt);
      });
      castSummonChoiceInput.value = current || choices[0]?.monster_slug || "";
      if (!castSummonChoiceInput.value && choices[0]?.monster_slug){
        castSummonChoiceInput.value = choices[0].monster_slug;
      }
    }
    const selectedChoice = normalizeTextValue(castSummonChoiceInput?.value || choices[0]?.monster_slug || "");
    const selectedChoiceEntry = choices.find((choice) => normalizeTextValue(choice.monster_slug) === selectedChoice) || choices[0] || null;
    const variants = Array.isArray(selectedChoiceEntry?.variants) ? selectedChoiceEntry.variants : [];
    if (castSummonVariantInput){
      const currentVariant = normalizeTextValue(castSummonVariantInput.value || "");
      castSummonVariantInput.innerHTML = "";
      const mountMode = Boolean(preset?.summon?.mount);
      if (castSummonVariantLabel){
        castSummonVariantLabel.textContent = "Variant";
      }
      castSummonVariantField?.classList.toggle("hidden", !mountMode);
      if (mountMode){
        variants.forEach((variant) => {
          const opt = document.createElement("option");
          opt.value = variant;
          opt.textContent = variant;
          castSummonVariantInput.appendChild(opt);
        });
        castSummonVariantInput.value = currentVariant || variants[0] || "";
      }
    }
    const rule = getSummonQuantityRule(preset, Number(castSlotLevelInput?.value), selectedChoice);
    if (castSummonQuantityInput){
      castSummonQuantityInput.min = String(rule.min);
      castSummonQuantityInput.max = String(rule.max);
      if (rule.fixed !== null){
        castSummonQuantityInput.value = String(rule.fixed);
        castSummonQuantityInput.readOnly = true;
      } else {
        const currentQty = Number(castSummonQuantityInput.value);
        const nextQty = Number.isFinite(currentQty)
          ? Math.min(rule.max, Math.max(rule.min, Math.floor(currentQty)))
          : rule.min;
        castSummonQuantityInput.value = String(nextQty);
        castSummonQuantityInput.readOnly = false;
      }
    }
    if (castSummonMeta){
      const initiativeMode = normalizeTextValue(preset?.summon?.initiative?.mode);
      const controlCommands = normalizeTextValue(preset?.summon?.control?.commands);
      const quantityInfo = rule.fixed !== null
        ? `Quantity: fixed at ${rule.fixed}`
        : `Quantity: ${rule.min}${rule.max}`;
      const metaBits = [quantityInfo];
      if (initiativeMode){
        metaBits.push(`Initiative: ${initiativeMode.replace(/_/g, " ")}`);
      }
      if (controlCommands){
        metaBits.push(`Control: ${controlCommands}`);
      }
      castSummonMeta.textContent = metaBits.join("  ");
    }
    validateSummonForm(preset, false);
  };

  const updateCastShapeFields = () => {
    const preset = getSelectedSpellPreset();
    if (isSummonPreset(preset)){
      [castRadiusField, castSideField, castLengthField, castWidthField, castAngleField, castOrientField, castThicknessField, castHeightField].forEach((field) => setCastFieldVisible(field, false));
      [castRadiusInput, castSideInput, castLengthInput, castWidthInput, castAngleInput, castOrientInput, castThicknessInput, castHeightInput].forEach((input) => setCastFieldEnabled(input, false));
      return;
    }
    const isAoeSpell = resolveSpellActionTag(preset) === "aoe";
    const automationLevel = normalizeLowerValue(preset?.automation || preset?.mechanics?.automation);
    if ((preset && !isAoeSpell) || automationLevel === "full"){
      [castRadiusField, castSideField, castLengthField, castWidthField, castAngleField, castOrientField, castThicknessField, castHeightField].forEach((field) => setCastFieldVisible(field, false));
      [castRadiusInput, castSideInput, castLengthInput, castWidthInput, castAngleInput, castOrientInput, castThicknessInput, castHeightInput].forEach((input) => setCastFieldEnabled(input, false));
      return;
    }
    const shape = String(castShapeInput?.value || "").toLowerCase();
    const usesRadius = shape === "circle" || shape === "sphere" || shape === "cylinder";
    const usesSide = shape === "square" || shape === "cube";
    const usesLength = shape === "line" || shape === "cone" || shape === "wall";
    const usesWidth = shape === "line" || shape === "wall";
    const usesAngle = shape === "line" || shape === "cone" || shape === "wall";
    const usesOrient = shape === "line" || shape === "cone" || shape === "wall";
    const usesThickness = shape === "wall";
    const usesHeight = shape === "wall" || shape === "cylinder";
    setCastFieldVisible(castRadiusField, usesRadius);
    setCastFieldVisible(castSideField, usesSide);
    setCastFieldVisible(castLengthField, usesLength);
    setCastFieldVisible(castWidthField, usesWidth);
    setCastFieldVisible(castAngleField, usesAngle);
    setCastFieldVisible(castOrientField, usesOrient);
    setCastFieldVisible(castThicknessField, usesThickness);
    setCastFieldVisible(castHeightField, usesHeight);
    setCastFieldEnabled(castRadiusInput, usesRadius);
    setCastFieldEnabled(castSideInput, usesSide);
    setCastFieldEnabled(castLengthInput, usesLength);
    setCastFieldEnabled(castWidthInput, usesWidth);
    setCastFieldEnabled(castAngleInput, usesAngle);
    setCastFieldEnabled(castOrientInput, usesOrient);
    setCastFieldEnabled(castThicknessInput, usesThickness);
    setCastFieldEnabled(castHeightInput, usesHeight);
  };

  const updateCastAutomationFields = (preset) => {
    if (!preset){
      setCastFieldVisible(castShapeField, true);
      setCastFieldEnabled(castShapeInput, true);
      [castDcTypeField, castDcValueField, castDefaultDamageField, castDiceField].forEach((field) => setCastFieldVisible(field, true));
      [castDcTypeInput, castDcValueInput, castDefaultDamageInput, castDiceInput].forEach((input) => setCastFieldEnabled(input, true));
      return;
    }
    const summonSpell = isSummonPreset(preset);
    const spellActionTag = resolveSpellActionTag(preset);
    const isAoeSpell = spellActionTag === "aoe";
    const automationLevel = normalizeLowerValue(preset?.automation || preset?.mechanics?.automation);
    const fullyAutomated = automationLevel === "full";
    const showShapeField = !summonSpell && isAoeSpell && !fullyAutomated;
    setCastFieldVisible(castShapeField, showShapeField);
    setCastFieldEnabled(castShapeInput, showShapeField);
    const showManualDamageFields = !summonSpell && !fullyAutomated;
    setCastFieldVisible(castDcTypeField, showManualDamageFields);
    setCastFieldEnabled(castDcTypeInput, showManualDamageFields);
    setCastFieldVisible(castDcValueField, showManualDamageFields);
    setCastFieldEnabled(castDcValueInput, showManualDamageFields);
    setCastFieldVisible(castDefaultDamageField, showManualDamageFields);
    setCastFieldEnabled(castDefaultDamageInput, showManualDamageFields);
    setCastFieldVisible(castDiceField, showManualDamageFields);
    setCastFieldEnabled(castDiceInput, showManualDamageFields);
  };

  if (castShapeInput){
    castShapeInput.addEventListener("change", updateCastShapeFields);
    updateCastShapeFields();
  }
  updateSummonOptions(null);
  updateCastAutomationFields(getSelectedSpellPreset());

  const parseDiceSpec = (value) => {
    if (typeof value !== "string") return null;
    const raw = value.trim().toLowerCase();
    const match = raw.match(/^(\\d+)d(4|6|8|10|12)$/);
    if (!match) return null;
    const count = Number(match[1]);
    const sides = Number(match[2]);
    if (!Number.isFinite(count) || count <= 0) return null;
    return {count, sides};
  };

  const formatDiceSpec = (spec) => `${spec.count}d${spec.sides}`;

  const normalizeUpcastConfig = (upcast) => {
    if (!upcast || typeof upcast !== "object") return null;
    const baseLevel = Number(upcast.base_level);
    if (!Number.isFinite(baseLevel) || baseLevel < 0){
      console.warn("Invalid upcast base_level; ignoring upcast config.", upcast);
      return null;
    }
    const rawIncrements = Array.isArray(upcast.increments) ? upcast.increments : [];
    const increments = [];
    const slotAddDice = typeof upcast.add_per_slot_above === "string" ? upcast.add_per_slot_above : "";
    if (slotAddDice && parseDiceSpec(slotAddDice)){
      increments.push({
        levels_per_increment: 1,
        add_dice: slotAddDice,
      });
    }
    rawIncrements.forEach((entry) => {
      if (!entry || typeof entry !== "object"){
        console.warn("Invalid upcast increment entry; skipping.", entry);
        return;
      }
      const addDice = typeof entry.add_dice === "string" ? entry.add_dice : "";
      if (!parseDiceSpec(addDice)){
        console.warn("Invalid upcast add_dice; skipping.", entry);
        return;
      }
      const levelsPer = Number(entry.levels_per_increment);
      if (Number.isFinite(levelsPer) && levelsPer > 0){
        increments.push({
          levels_per_increment: levelsPer,
          add_dice: addDice,
        });
        return;
      }
      const levelThreshold = Number(entry.level);
      if (Number.isFinite(levelThreshold) && levelThreshold > baseLevel){
        increments.push({
          level: levelThreshold,
          add_dice: addDice,
        });
        return;
      }
      console.warn("Invalid upcast increment entry; skipping.", entry);
    });
    if (!increments.length){
      console.warn("Upcast increments contained no valid entries; ignoring upcast config.", upcast);
      return null;
    }
    return {base_level: baseLevel, increments};
  };

  const computeUpcastValues = (baseDice, baseDefaultDamage, upcastConfig, slotLevel) => {
    if (!upcastConfig || !Number.isFinite(slotLevel)) return {dice: baseDice, defaultDamage: baseDefaultDamage};
    const baseLevel = Number(upcastConfig.base_level);
    if (!Number.isFinite(baseLevel)) return {dice: baseDice, defaultDamage: baseDefaultDamage};
    const deltaLevels = Math.floor(slotLevel - baseLevel);
    if (deltaLevels <= 0) return {dice: baseDice, defaultDamage: baseDefaultDamage};
    const baseDiceSpec = parseDiceSpec(baseDice) || parseDiceSpec(baseDefaultDamage);
    let totalDiceSpec = baseDiceSpec ? {count: baseDiceSpec.count, sides: baseDiceSpec.sides} : null;
    let applied = false;
    (upcastConfig.increments || []).forEach((inc) => {
      const addDiceSpec = parseDiceSpec(inc.add_dice);
      if (!addDiceSpec) return;
      let steps = 0;
      const levelsPer = Number(inc.levels_per_increment);
      if (Number.isFinite(levelsPer) && levelsPer > 0){
        steps = Math.floor(deltaLevels / levelsPer);
      } else {
        const levelThreshold = Number(inc.level);
        if (Number.isFinite(levelThreshold) && slotLevel >= levelThreshold){
          steps = 1;
        }
      }
      if (steps <= 0) return;
      const addCount = addDiceSpec.count * steps;
      if (!totalDiceSpec){
        totalDiceSpec = {count: addCount, sides: addDiceSpec.sides};
        applied = true;
        return;
      }
      if (totalDiceSpec.sides !== addDiceSpec.sides){
        console.warn("Upcast dice sides mismatch; skipping increment.", inc);
        return;
      }
      totalDiceSpec.count += addCount;
      applied = true;
    });
    const dice = totalDiceSpec ? formatDiceSpec(totalDiceSpec) : baseDice;
    let defaultDamage = baseDefaultDamage;
    if (applied){
      const defaultDamageDice = parseDiceSpec(baseDefaultDamage);
      if (defaultDamageDice || baseDefaultDamage === null || baseDefaultDamage === ""){
        defaultDamage = dice;
      }
    }
    return {dice, defaultDamage};
  };

  const scaleDiceForCharacterLevel = (diceText, preset) => {
    const raw = String(diceText || "").trim().toLowerCase();
    if (!raw) return "";
    const scaling = preset?.scaling;
    if (!scaling || scaling.kind !== "character_level") return raw;
    const match = raw.match(/^(\d+)d(\d+)(\s*[+\-]\s*\d+)?$/);
    if (!match) return raw;
    const baseCount = Number(match[1]);
    const sides = Number(match[2]);
    const modifier = String(match[3] || "").replace(/\s+/g, "");
    const playerName = getClaimedPlayerName();
    const profile = getPlayerProfile(playerName);
    const level = getPlayerLevel(profile);
    const thresholds = scaling && typeof scaling.thresholds === "object" ? scaling.thresholds : {};
    const parsedThresholds = [];
    Object.entries(thresholds).forEach(([threshold, addData]) => {
      const thresholdLevel = Number(threshold);
      if (!Number.isFinite(thresholdLevel) || level < thresholdLevel) return;
      const addExpr = String(addData?.add || "").trim().toLowerCase();
      const addMatch = addExpr.match(/^(\d+)d(\d+)$/);
      if (!addMatch) return;
      if (Number(addMatch[2]) !== sides) return;
      parsedThresholds.push({level: thresholdLevel, count: Number(addMatch[1])});
    });
    if (!parsedThresholds.length) return raw;
    parsedThresholds.sort((a, b) => a.level - b.level);
    let treatThresholdsAsTotals = false;
    if (parsedThresholds[0].count > baseCount){
      treatThresholdsAsTotals = parsedThresholds.every((entry, idx) => idx === 0 || entry.count >= parsedThresholds[idx - 1].count);
    }
    let totalCount = Number.isFinite(baseCount) ? baseCount : 0;
    parsedThresholds.forEach((entry) => {
      if (treatThresholdsAsTotals){
        totalCount = entry.count;
      } else {
        totalCount += entry.count;
      }
    });
    if (!Number.isFinite(totalCount) || totalCount <= 0) return raw;
    return `${Math.floor(totalCount)}d${Math.floor(sides)}${modifier}`;
  };

  const castDamageTypes = new Set();
  let castDurationTurns = null;
  let castOverTime = null;
  let castMovePerTurnFt = null;
  let castTriggerOnStartOrEnter = null;
  let castPersistent = null;
  let castPinnedDefault = null;
  let castMoveActionType = null;
  let castHazardBehavior = null;
  let castUpcastConfig = null;
  let castBaseDice = null;
  let castBaseDefaultDamage = null;
  function setPolymorphFormOverlayOpen(open){
    setModalOpen(polymorphFormOverlay, open);
    if (!open){
      return;
    }
    renderPolymorphFormList();
  }
  function availablePolymorphForms(){
    const forms = Array.isArray(state?.beast_forms) ? state.beast_forms : [];
    return forms.filter((entry) => entry && String(entry.id || "").trim());
  }
  function renderPolymorphFormList(){
    if (!polymorphFormList) return;
    const query = String(polymorphFormSearchInput?.value || "").trim().toLowerCase();
    const forms = availablePolymorphForms().filter((entry) => {
      if (!query) return true;
      const id = String(entry?.id || "").toLowerCase();
      const name = String(entry?.name || "").toLowerCase();
      return id.includes(query) || name.includes(query);
    });
    polymorphFormList.textContent = "";
    if (!forms.length){
      const empty = document.createElement("div");
      empty.className = "spellbook-item";
      empty.textContent = "No beast forms available.";
      polymorphFormList.appendChild(empty);
      return;
    }
    forms.forEach((entry) => {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "spellbook-item";
      btn.textContent = `${entry?.name || entry?.id}  CR ${entry?.challenge_rating ?? 0}  HP ${entry?.hp ?? 0}`;
      btn.addEventListener("click", () => {
        if (!pendingPolymorphSelection){
          setPolymorphFormOverlayOpen(false);
          return;
        }
        send({
          type: "spell_target_request",
          cid: pendingPolymorphSelection.cid,
          target_cid: pendingPolymorphSelection.targetCid,
          spell_name: pendingPolymorphSelection.spellName,
          spell_slug: pendingPolymorphSelection.spellSlug || null,
          spell_id: pendingPolymorphSelection.spellId || null,
          spell_mode: "save",
          save_type: pendingPolymorphSelection.saveType || "wis",
          save_dc: Number.isFinite(Number(pendingPolymorphSelection.saveDc)) ? Number(pendingPolymorphSelection.saveDc) : null,
          roll_save: true,
          polymorph_form_id: String(entry?.id || "").trim().toLowerCase(),
        });
        pendingPolymorphSelection = null;
        setPolymorphFormOverlayOpen(false);
      });
      polymorphFormList.appendChild(btn);
    });
  }
  function clearSpellTargetingSession(showToastMessage = ""){
    pendingSpellTargeting = null;
    pendingSpellTargetSelection = null;
    pendingPolymorphSelection = null;
    pendingCommandResolution = null;
    pendingMantleOfInspiration = null;
    setPolymorphFormOverlayOpen(false);
    setMantleResolveModalOpen(false);
    setCommandOptionModalOpen(false);
    renderSpellTargetSelectionUi();
    if (attackOverlayMode){
      setAttackOverlayMode(false);
    }
    if (showToastMessage){
      localToast(showToastMessage);
    }
  }
  function consumeSpellTargetingShot(){
    if (!pendingSpellTargeting){
      return;
    }
    pendingSpellTargeting.remainingShots = Math.max(0, Number(pendingSpellTargeting.remainingShots || 0) - 1);
    if (pendingSpellTargeting.remainingShots <= 0){
      clearSpellTargetingSession("");
    } else if (!(pendingSpellTargeting.queue && pendingSpellTargeting.queue.length)) {
      localToast(`${pendingSpellTargeting.remainingShots} target${pendingSpellTargeting.remainingShots === 1 ? "" : "s"} remaining.`);
    }
  }
  function getSpellTargetingDescriptionText(preset){
    const primary = normalizeTextValue(preset?.description);
    if (primary) return primary;
    return normalizeTextValue(preset?.import?.raw?.description) || "";
  }
  function inferSpellTargetingFromDescription(preset, mode, slotLevel){
    const description = getSpellTargetingDescriptionText(preset);
    const lower = description.toLowerCase();
    const inferred = {
      baseCount: 1,
      addPerSlotAbove: 0,
      baseSlotLevel: Math.max(0, Math.floor(Number(preset?.level || 0))),
      targetSide: "any",
      description,
      cantripDynamicCount: null,
    };
    const upcast = lower.match(/additional[^.]*for each spell slot level above\s+(\d+)/i);
    if (upcast){
      inferred.addPerSlotAbove = 1;
      inferred.baseSlotLevel = Math.max(0, Number(upcast[1]));
    }
    const upTo = lower.match(/(?:choose\s+)?up to\s+(\d+)\s+creatures?/i);
    if (upTo){
      inferred.baseCount = Math.max(1, Number(upTo[1]));
    } else if (/\bchoose\s+(?:an|a)\b/i.test(lower)){
      inferred.baseCount = 1;
    }
    const dartsRays = lower.match(/you create\s+(\d+)\s+(?:darts?|rays?)/i);
    if (dartsRays){
      inferred.baseCount = Math.max(inferred.baseCount, Number(dartsRays[1]));
    }
    if (/willing creature/i.test(lower)){
      inferred.targetSide = "friendly";
    } else if (/(enemy|hostile|creature you can see that is not willing|of your choice that you can see)/i.test(lower)){
      inferred.targetSide = "enemy";
    }
    const ebPattern = /two\s+beams?\s+at\s+level\s+5[^.]*three\s+beams?\s+at\s+level\s+11[^.]*four\s+beams?\s+at\s+level\s+17/i;
    if (ebPattern.test(lower)){
      inferred.cantripDynamicCount = () => {
        const playerName = getClaimedPlayerName();
        const profile = getPlayerProfile(playerName);
        const level = getPlayerLevel(profile);
        if (level >= 17) return 4;
        if (level >= 11) return 3;
        if (level >= 5) return 2;
        return 1;
      };
    }
    const selectedSlot = Number.isFinite(Number(slotLevel)) ? Math.floor(Number(slotLevel)) : inferred.baseSlotLevel;
    const count = inferred.cantripDynamicCount
      ? inferred.cantripDynamicCount()
      : Math.max(1, inferred.baseCount + Math.max(0, selectedSlot - inferred.baseSlotLevel) * inferred.addPerSlotAbove);
    inferred.projectileCount = Math.max(1, Number(count) || 1);
    return inferred;
  }
  function getSpellTargetingConfig(preset, slotLevel){
    if (!preset || isAoePreset(preset) || isSummonPreset(preset)){
      return null;
    }
    const uiConfig = preset?.mechanics?.ui?.spell_targeting;
    const modeRaw = normalizeLowerValue(uiConfig?.mode);
    const resolvedMode = resolveSpellActionTag(preset);
    const mode = modeRaw || resolvedMode || "effect";
    if (!["attack", "auto_hit", "save", "effect"].includes(mode)) return null;

    const inferred = inferSpellTargetingFromDescription(preset, mode, slotLevel);
    const baseCount = Number(uiConfig?.projectiles_base);
    const addPerSlot = Number(uiConfig?.add_per_slot_above);
    const baseSlotLevel = Number.isFinite(Number(uiConfig?.base_slot_level))
      ? Math.floor(Number(uiConfig.base_slot_level))
      : inferred.baseSlotLevel;
    const selectedSlot = Number.isFinite(Number(slotLevel)) ? Math.floor(Number(slotLevel)) : baseSlotLevel;
    const countBase = Number.isFinite(baseCount) && baseCount > 0 ? Math.floor(baseCount) : inferred.baseCount;
    const countAdd = Number.isFinite(addPerSlot) ? Math.floor(addPerSlot) : inferred.addPerSlotAbove;
    let projectileCount = inferred.cantripDynamicCount && !Number.isFinite(baseCount)
      ? inferred.projectileCount
      : Math.max(1, countBase + Math.max(0, selectedSlot - baseSlotLevel) * countAdd);
    const presetSlug = normalizeLowerValue(getPresetSlug(preset));
    if (presetSlug === "command"){
      projectileCount = Math.max(1, 1 + Math.max(0, selectedSlot - 1));
    }
    const damageTypes = Array.from(castDamageTypes);
    const fallbackType = String((Array.isArray(preset?.damage_types) ? preset.damage_types[0] : "") || "").trim().toLowerCase();
    if (!damageTypes.length && fallbackType){
      damageTypes.push(fallbackType);
    }
    const description = inferred.description || normalizeTextValue(preset?.description) || "";
    const targetSideRaw = normalizeLowerValue(uiConfig?.target_side);
    const targetSide = ["friendly", "enemy", "any"].includes(targetSideRaw) ? targetSideRaw : inferred.targetSide;
    const overlayColor = normalizeHexColor(uiConfig?.overlay_color || "");
    const skipResolveAttack = hasSpellTag(preset, "skip_resolve_attack");
    const allowDuplicateTargetsExplicit = (typeof uiConfig?.allow_duplicate_targets === "boolean") ? uiConfig.allow_duplicate_targets : null;
    const requireUniqueTargetsExplicit = (typeof uiConfig?.require_unique_targets === "boolean") ? uiConfig.require_unique_targets : null;
    const allowDuplicateTargetsDefault = mode === "attack" || mode === "auto_hit";
    const allowDuplicateTargets = requireUniqueTargetsExplicit === true
      ? false
      : (allowDuplicateTargetsExplicit === null ? allowDuplicateTargetsDefault : allowDuplicateTargetsExplicit);
    const requireUniqueTargets = allowDuplicateTargets ? false : true;
    const scaledDamageDice = scaleDiceForCharacterLevel(
      String(castDiceInput?.value || castDefaultDamageInput?.value || "").trim(),
      preset,
    );
    return {
      mode,
      rangeFt: parseSpellTargetRangeFeet(preset),
      saveType: normalizeLowerValue(preset?.save_type) || (presetSlug === "command" ? "wis" : ""),
      saveDc: Number.isFinite(Number(castDcValueInput?.value)) ? Math.floor(Number(castDcValueInput.value)) : null,
      damageType: damageTypes[0] || "",
      damageDice: scaledDamageDice,
      damageDiceWhenWounded: String(uiConfig?.damage_dice_when_wounded || "").trim(),
      description,
      projectileCount,
      maxTargets: projectileCount,
      targetSide,
      overlayColor,
      skipResolveAttack,
      allowDuplicateTargets,
      requireUniqueTargets,
    };
  }
  function renderSpellTargetSelectionUi(){
    if (!spellTargetSelectionUi) return;
    const active = !!(pendingSpellTargetSelection || pendingMantleOfInspiration);
    spellTargetSelectionUi.classList.toggle("hidden", !active);
    spellTargetSelectionUi.setAttribute("aria-hidden", active ? "false" : "true");
    if (!active) return;
    const selected = pendingSpellTargetSelection
      ? (Array.isArray(pendingSpellTargetSelection.selectedTargets) ? pendingSpellTargetSelection.selectedTargets : [])
      : (Array.isArray(pendingMantleOfInspiration?.targetCids) ? pendingMantleOfInspiration.targetCids : []);
    const max = pendingSpellTargetSelection
      ? Math.max(1, Number(pendingSpellTargetSelection.maxTargets || 1))
      : Math.max(1, Number(pendingMantleOfInspiration?.maxTargets || 1));
    if (spellTargetSelectionCounter){
      spellTargetSelectionCounter.textContent = `${selected.length}/${max}`;
    }
    if (spellTargetSelectionList){
      spellTargetSelectionList.textContent = "";
      selected.forEach((cid, idx) => {
        const unit = getUnitByCid(cid);
        const row = document.createElement("div");
        row.className = "spell-target-selection-entry";
        const name = document.createElement("span");
        name.textContent = `${idx + 1}. ${unit?.name || `#${cid}`}`;
        const removeBtn = document.createElement("button");
        removeBtn.type = "button";
        removeBtn.className = "btn";
        removeBtn.textContent = "";
        removeBtn.addEventListener("click", () => {
          if (!pendingSpellTargetSelection) return;
          pendingSpellTargetSelection.selectedTargets.splice(idx, 1);
          renderSpellTargetSelectionUi();
        });
        row.appendChild(name);
        row.appendChild(removeBtn);
        spellTargetSelectionList.appendChild(row);
      });
    }
    if (spellTargetSelectionConfirmBtn){
      spellTargetSelectionConfirmBtn.disabled = selected.length < 1;
    }
    if (spellTargetSelectionRemoveLastBtn){
      spellTargetSelectionRemoveLastBtn.disabled = selected.length < 1;
    }
  }
  function processNextSpellTarget(){
    if (!pendingSpellTargeting) return;
    const queue = Array.isArray(pendingSpellTargeting.queue) ? pendingSpellTargeting.queue : [];
    if (!queue.length){
      if (!pendingSpellTargeting.remainingShots || pendingSpellTargeting.remainingShots <= 0){
        clearSpellTargetingSession("");
      }
      return;
    }
    const nextCid = Number(queue.shift());
    const target = getUnitByCid(nextCid);
    if (!target){
      consumeSpellTargetingShot();
      processNextSpellTarget();
      return;
    }
    runSpellTargetingAgainstTarget(target);
  }
  function startSpellTargetingSession(config, preset, slotLevel, castMsg = null){
    if (!config) return;
    pendingSpellTargeting = {
      mode: config.mode,
      spellName: String(castNameInput?.value || preset?.name || "Spell").trim() || "Spell",
      spellSlug: normalizeTextValue(preset?.slug) || null,
      spellId: normalizeTextValue(preset?.id) || null,
      slotLevel: Number.isFinite(Number(slotLevel)) ? Math.floor(Number(slotLevel)) : null,
      rangeFt: Number.isFinite(config.rangeFt) ? config.rangeFt : null,
      saveType: config.saveType || "",
      saveDc: Number.isFinite(Number(config.saveDc)) ? Number(config.saveDc) : null,
      damageType: String(config.damageType || "").trim().toLowerCase(),
      damageDice: String(config.damageDice || "").trim(),
      damageDiceWhenWounded: String(config.damageDiceWhenWounded || "").trim(),
      description: String(config.description || "").trim(),
      remainingShots: Math.max(1, Number(config.projectileCount || 1)),
      targetSide: ["friendly", "enemy", "any"].includes(String(config.targetSide || "any").toLowerCase()) ? String(config.targetSide || "any").toLowerCase() : "any",
      overlayColor: normalizeHexColor(config.overlayColor || "") || null,
      skipResolveAttack: config.skipResolveAttack === true,
      allowDuplicateTargets: config.allowDuplicateTargets === true,
      requireUniqueTargets: config.requireUniqueTargets !== false,
      maxTargets: Math.max(1, Number(config.maxTargets || config.projectileCount || 1)),
      queue: [],
    };
    const needsSelection = pendingSpellTargeting.maxTargets > 1;
    setCastOverlayOpen(false);
    if (needsSelection){
      pendingSpellTargetSelection = {
        spellName: pendingSpellTargeting.spellName,
        mode: pendingSpellTargeting.mode,
        maxTargets: pendingSpellTargeting.maxTargets,
        selectedTargets: [],
        targetSide: pendingSpellTargeting.targetSide,
        rangeFt: pendingSpellTargeting.rangeFt,
        castMsg,
      };
      setAttackOverlayMode(true);
      renderSpellTargetSelectionUi();
      localToast(`Select targets (${0}/${pendingSpellTargetSelection.maxTargets}) for ${pendingSpellTargeting.spellName}.`);
      return;
    }
    pendingSpellTargetSelection = null;
    renderSpellTargetSelectionUi();
    setAttackOverlayMode(true);
    const shotLabel = pendingSpellTargeting.remainingShots > 1
      ? ` (${pendingSpellTargeting.remainingShots} targets)`
      : "";
    localToast(`Select target${shotLabel} for ${pendingSpellTargeting.spellName}.`);
  }
  const setCastDamageTypes = (types) => {
    castDamageTypes.clear();
    if (Array.isArray(types)){
      types.forEach((entry) => {
        const dtype = String(entry || "").trim();
        if (dtype){
          castDamageTypes.add(dtype);
        }
      });
    }
    if (castDamageTypeInput){
      const firstType = Array.from(castDamageTypes)[0] || "";
      const selectValues = Array.from(castDamageTypeInput.options || []).map((opt) => String(opt?.value || "").trim());
      castDamageTypeInput.value = firstType && selectValues.includes(firstType) ? firstType : "";
    }
    renderCastDamageTypes();
  };
  const renderCastDamageTypes = () => {
    if (!castDamageTypeList) return;
    castDamageTypeList.textContent = "";
    for (const dtype of castDamageTypes){
      const chip = document.createElement("span");
      chip.className = "chip damage-type-chip";
      const label = document.createElement("span");
      label.textContent = dtype;
      const removeBtn = document.createElement("button");
      removeBtn.type = "button";
      removeBtn.setAttribute("aria-label", `Remove ${dtype}`);
      removeBtn.textContent = "";
      removeBtn.addEventListener("click", () => {
        castDamageTypes.delete(dtype);
        renderCastDamageTypes();
      });
      chip.appendChild(label);
      chip.appendChild(removeBtn);
      castDamageTypeList.appendChild(chip);
    }
  };
  const addCastDamageType = (value) => {
    const dtype = String(value || "").trim();
    if (!dtype){
      localToast("Choose a damage type first, matey.");
      return;
    }
    if (castDamageTypes.has(dtype)){
      localToast("That damage type be added already.");
      return;
    }
    castDamageTypes.add(dtype);
    renderCastDamageTypes();
  };

  const applySpellPreset = (preset) => {
    if (!preset || typeof preset !== "object") return;
    if (castNameInput && preset.name){
      castNameInput.value = String(preset.name || "");
    }
    if (preset?.isCustomSummon && castCustomSummonNameInput){
      refreshCustomSummonMonsterOptions();
      applyCustomSummonTemplate(getSelectedCustomSummonChoice(), false);
      castCustomSummonNameInput.value = normalizeTextValue(castCustomSummonNameInput.value) || "Custom summon";
      if (castNameInput) castNameInput.value = castCustomSummonNameInput.value;
    }
    if (castShapeInput){
      castShapeInput.value = preset.shape ? String(preset.shape || "").toLowerCase() : "";
    }
    updateSummonOptions(preset);
    updateCastAutomationFields(preset);
    updateCastShapeFields();
    if (castRadiusInput){
      castRadiusInput.value = Number.isFinite(Number(preset.radius_ft)) ? Number(preset.radius_ft) : "";
    }
    if (castSideInput){
      castSideInput.value = Number.isFinite(Number(preset.side_ft)) ? Number(preset.side_ft) : "";
    }
    if (castLengthInput){
      castLengthInput.value = Number.isFinite(Number(preset.length_ft)) ? Number(preset.length_ft) : "";
    }
    if (castWidthInput){
      castWidthInput.value = Number.isFinite(Number(preset.width_ft)) ? Number(preset.width_ft) : "";
    }
    if (castAngleInput){
      castAngleInput.value = Number.isFinite(Number(preset.angle_deg)) ? Number(preset.angle_deg) : "";
    }
    if (castOrientInput){
      castOrientInput.value = preset.orient ? String(preset.orient || "").toLowerCase() : "vertical";
    }
    if (castThicknessInput){
      castThicknessInput.value = Number.isFinite(Number(preset.thickness_ft)) ? Number(preset.thickness_ft) : "";
    }
    if (castHeightInput){
      castHeightInput.value = Number.isFinite(Number(preset.height_ft)) ? Number(preset.height_ft) : "";
    }
    if (castDcTypeInput){
      castDcTypeInput.value = preset.save_type ? String(preset.save_type || "").toLowerCase() : "";
    }
    if (castDcValueInput){
      const presetDc = Number(preset.save_dc);
      castDcValueInput.value = Number.isFinite(presetDc) ? Number(presetDc) : "";
      if (!Number.isFinite(presetDc)){
        applyDefaultSpellSaveDc();
      }
    }
    if (castDefaultDamageInput){
      const defaultDamage = preset.default_damage;
      castDefaultDamageInput.value = defaultDamage !== undefined && defaultDamage !== null ? String(defaultDamage) : "";
      castBaseDefaultDamage = defaultDamage !== undefined && defaultDamage !== null ? String(defaultDamage) : "";
    }
    if (castDiceInput){
      const dice = preset.dice;
      castDiceInput.value = dice !== undefined && dice !== null ? String(dice) : "";
      castBaseDice = dice !== undefined && dice !== null ? String(dice) : "";
    }
    if (castColorInput){
      castColorInput.value = normalizeHexColor(preset.color || "") || DEFAULT_SPELL_COLOR;
    }
    setCastDamageTypes(preset.damage_types);
    if (Number.isFinite(Number(preset.duration_turns))){
      castDurationTurns = Number(preset.duration_turns);
    } else {
      castDurationTurns = null;
    }
    const aoeBehavior = preset?.mechanics?.aoe_behavior && typeof preset.mechanics.aoe_behavior === "object"
      ? preset.mechanics.aoe_behavior
      : null;
    castHazardBehavior = aoeBehavior;
    if (typeof aoeBehavior?.over_time_default === "boolean"){
      castOverTime = aoeBehavior.over_time_default;
    } else if (typeof preset.over_time === "boolean"){
      castOverTime = preset.over_time;
    } else {
      castOverTime = null;
    }
    const movePerTurnBehavior = Number(aoeBehavior?.move_per_turn_ft);
    const movePerTurnTop = Number(preset.move_per_turn_ft);
    if (Number.isFinite(movePerTurnBehavior)){
      castMovePerTurnFt = movePerTurnBehavior;
    } else if (Number.isFinite(movePerTurnTop)){
      castMovePerTurnFt = movePerTurnTop;
    } else {
      castMovePerTurnFt = null;
    }
    if (aoeBehavior?.trigger_mode){
      castTriggerOnStartOrEnter = String(aoeBehavior.trigger_mode || "").toLowerCase();
    } else if (preset.trigger_on_start_or_enter){
      castTriggerOnStartOrEnter = String(preset.trigger_on_start_or_enter || "").toLowerCase();
    } else {
      castTriggerOnStartOrEnter = null;
    }
    if (typeof aoeBehavior?.persistent_default === "boolean"){
      castPersistent = aoeBehavior.persistent_default;
    } else if (typeof preset.persistent === "boolean"){
      castPersistent = preset.persistent;
    } else {
      castPersistent = null;
    }
    if (typeof aoeBehavior?.pinned_default === "boolean"){
      castPinnedDefault = aoeBehavior.pinned_default;
    } else if (typeof preset.pinned_default === "boolean"){
      castPinnedDefault = preset.pinned_default;
    } else {
      castPinnedDefault = null;
    }
    if (aoeBehavior?.move_action_type){
      castMoveActionType = String(aoeBehavior.move_action_type || "").toLowerCase();
    } else {
      castMoveActionType = null;
    }
    castUpcastConfig = normalizeUpcastConfig(preset.upcast);
    if (castSlotLevelInput){
      const presetLevel = Number.isFinite(Number(preset.level)) ? Math.max(0, Math.floor(Number(preset.level))) : 0;
      const baseLevel = castUpcastConfig && Number.isFinite(Number(castUpcastConfig.base_level))
        ? Math.max(0, Math.floor(Number(castUpcastConfig.base_level)))
        : presetLevel;
      castSlotLevelInput.disabled = false;
      castSlotLevelInput.readOnly = false;
      castSlotLevelInput.min = String(Math.max(0, baseLevel));
      castSlotLevelInput.value = String(Math.max(0, baseLevel));
    }
    const slotLevelValue = Number(castSlotLevelInput?.value);
    const upcastValues = computeUpcastValues(castBaseDice, castBaseDefaultDamage, castUpcastConfig, slotLevelValue);
    if (castDiceInput && upcastValues.dice !== undefined && upcastValues.dice !== null){
      castDiceInput.value = String(upcastValues.dice || "");
    }
    if (castDefaultDamageInput && upcastValues.defaultDamage !== undefined && upcastValues.defaultDamage !== null){
      castDefaultDamageInput.value = String(upcastValues.defaultDamage || "");
    }
  };

  const updateUpcastFields = () => {
    if (!castUpcastConfig) return;
    const slotLevelValue = Number(castSlotLevelInput?.value);
    const upcastValues = computeUpcastValues(castBaseDice, castBaseDefaultDamage, castUpcastConfig, slotLevelValue);
    if (castDiceInput && upcastValues.dice !== undefined && upcastValues.dice !== null){
      castDiceInput.value = String(upcastValues.dice || "");
    }
    if (castDefaultDamageInput && upcastValues.defaultDamage !== undefined && upcastValues.defaultDamage !== null){
      castDefaultDamageInput.value = String(upcastValues.defaultDamage || "");
    }
  };

  function validateCastSlotSelection(preset, showToast = false){
    const playerName = getClaimedPlayerName();
    if (forcedPoolCastContext?.consumesPool){
      const poolId = normalizeTextValue(forcedPoolCastContext.consumesPool.id);
      const cost = Number.isFinite(Number(forcedPoolCastContext.consumesPool.cost))
        ? Math.max(1, Math.floor(Number(forcedPoolCastContext.consumesPool.cost)))
        : 1;
      const pool = getPlayerResourcePools(playerName).find((entry) => getSpellKey(entry.id) === getSpellKey(poolId));
      if (!pool || Number(pool.current) < cost){
        const msg = "That resource pool be exhausted, matey.";
        if (showToast) localToast(msg);
        return {ok: false, reason: msg};
      }
      return {ok: true, slotLevel: null, consumesPool: {id: poolId, cost}};
    }
    const baseLevel = Number.isFinite(Number(preset?.level)) ? Math.max(0, Math.floor(Number(preset.level))) : 0;
    const rawLevel = Number(castSlotLevelInput?.value);
    const slotLevel = Number.isFinite(rawLevel) ? Math.floor(rawLevel) : baseLevel;
    if (slotLevel < baseLevel){
      const msg = "Ye can't downcast that spell, matey.";
      if (showToast) localToast(msg);
      return {ok: false, reason: msg};
    }
    const profile = getPlayerProfile(playerName);
    if (slotLevel >= 1 && getAvailableSlotCountAtOrAbove(profile, slotLevel) <= 0){
      const msg = "No spell slots left for that level, matey.";
      if (showToast) localToast(msg);
      return {ok: false, reason: msg};
    }
    return {ok: true, slotLevel};
  }

  if (castPresetInput){
    castPresetInput.addEventListener("change", () => {
      const name = String(castPresetInput.value || "").trim();
      if (!name){
        castDurationTurns = null;
        castOverTime = null;
        castMovePerTurnFt = null;
        castTriggerOnStartOrEnter = null;
        castPersistent = null;
        castPinnedDefault = null;
        castMoveActionType = null;
        castHazardBehavior = null;
        castUpcastConfig = null;
        castBaseDice = null;
        castBaseDefaultDamage = null;
        if (castDefaultDamageInput){
          castDefaultDamageInput.value = "";
        }
        if (castDiceInput){
          castDiceInput.value = "";
        }
        if (castDcValueInput){
          castDcValueInput.value = "";
          applyDefaultSpellSaveDc();
        }
        if (castSlotLevelInput){
          castSlotLevelInput.value = "";
          castSlotLevelInput.min = "0";
          castSlotLevelInput.disabled = false;
          castSlotLevelInput.readOnly = false;
        }
        updateSummonOptions(null);
        updateCastAutomationFields(null);
        updateCastShapeFields();
        updateSpellPresetDetails(null);
        return;
      }
      const preset = getSelectedSpellPreset();
      updateSpellPresetDetails(preset || null);
      applySpellPreset(preset);
      if (castSpellModal?.classList.contains("show")){
        renderCastSpellPreview();
      }
    });
  }

  if (castSlotLevelInput){
    castSlotLevelInput.addEventListener("input", () => {
      updateUpcastFields();
      const preset = getSelectedSpellPreset();
      const check = validateCastSlotSelection(preset, false);
      castSlotLevelInput.setCustomValidity(check.ok ? "" : (check.reason || "Invalid slot level"));
      updateSummonOptions(preset);
      validateSummonForm(preset, false);
    });
  }

  if (castSummonChoiceInput){
    castSummonChoiceInput.addEventListener("change", () => {
      const preset = getSelectedSpellPreset();
      updateSummonOptions(preset);
      validateSummonForm(preset, false);
    });
  }

  if (castSummonVariantInput){
    castSummonVariantInput.addEventListener("change", () => {
      const preset = getSelectedSpellPreset();
      validateSummonForm(preset, false);
    });
  }

  if (castSummonQuantityInput){
    castSummonQuantityInput.addEventListener("input", () => {
      const preset = getSelectedSpellPreset();
      updateSummonOptions(preset);
      validateSummonForm(preset, false);
    });
  }

  if (castCustomSummonRangeInput){
    castCustomSummonRangeInput.addEventListener("input", () => {
      const preset = getSelectedSpellPreset();
      updateSummonOptions(preset);
    });
  }

  if (castCustomSummonMonsterSearchInput){
    castCustomSummonMonsterSearchInput.addEventListener("input", () => {
      refreshCustomSummonMonsterOptions();
      const preset = getSelectedSpellPreset();
      if (preset?.isCustomSummon){
        updateSummonOptions(preset);
      }
    });
  }

  if (castCustomSummonMonsterInput){
    castCustomSummonMonsterInput.addEventListener("change", () => {
      applyCustomSummonTemplate(getSelectedCustomSummonChoice(), true);
      const preset = getSelectedSpellPreset();
      if (preset?.isCustomSummon){
        updateSummonOptions(preset);
      }
    });
  }

  if (castCustomSummonNameInput){
    castCustomSummonNameInput.addEventListener("input", () => {
      const preset = getSelectedSpellPreset();
      if (preset?.isCustomSummon && castNameInput){
        castNameInput.value = normalizeTextValue(castCustomSummonNameInput.value) || "Custom summon";
      }
    });
  }

  if (aimlessAoeCancelBtn){
    aimlessAoeCancelBtn.addEventListener("click", () => {
      if (!isAimlessSelfCenteredAoePlacement()) return;
      clearPendingAoePlacement();
      localToast("AoE cast cancelled.");
    });
  }

  if (aimlessAoeConfirmBtn){
    aimlessAoeConfirmBtn.addEventListener("click", () => {
      if (!isAimlessSelfCenteredAoePlacement()) return;
      if (!isPlanning && pendingAoePlacement.castConfirmMessage && !window.confirm(pendingAoePlacement.castConfirmMessage)){
        return;
      }
      if (!isPlanning && pendingAoePlacement.concentrationConfirmMessage && !window.confirm(pendingAoePlacement.concentrationConfirmMessage)){
        return;
      }
      const msg = {...pendingAoePlacement.msg, payload: {...(pendingAoePlacement.msg?.payload || {})}};
      const casterPos = getPendingAoeCasterPos();
      if (!casterPos){
        localToast("Could not find caster position, matey.");
        return;
      }
      msg.payload.cx = Math.round(Number(casterPos.col));
      msg.payload.cy = Math.round(Number(casterPos.row));
      msg.payload.fixed_to_caster = true;
      const submitAoe = (damageEntries = []) => {
        if (Array.isArray(damageEntries) && damageEntries.length){
          msg.damage_entries = damageEntries;
        }
        if (isPlanning){
          planningMutate(msg);
          draw();
          updateHud();
        }
        send(msg);
        clearPendingAoePlacement(false);
        draw();
      };
      maybeRunSculptSelectionForPendingAoe(msg, () => {
        if (isPlanning || castAutomationIsEnabled()){
          submitAoe();
        } else {
          const resolveContext = pendingAoePlacement.resolveContext || {};
          openSpellResolveModal(resolveContext, (damageEntries) => submitAoe(damageEntries));
        }
      });
    });
  }

  if (castForm){
    castForm.addEventListener("submit", (ev) => {
      ev.preventDefault();
      try {
      const clearForcedContext = () => clearForcedPoolCastContext();
      if (!isPlanning && !claimedCid){
        localToast("Claim a character first, matey.");
        clearForcedContext();
        return;
      }
      if (!state){
        localToast("Map not ready yet, matey.");
        clearForcedContext();
        return;
      }
      const preset = getSelectedSpellPreset();
      const spellActionType = getSpellActionType(preset);
      const forcedActionType = normalizeSpellActionType(forcedPoolCastContext?.actionType || "");
      const actionType = pendingSpellActionType || forcedActionType || spellActionType;
      if (pendingSpellActionType && pendingSpellActionType !== spellActionType && !forcedPoolCastContext){
        const expectedLabel = spellActionType === "bonus_action" ? "bonus action" : spellActionType;
        localToast(`That spell uses a ${expectedLabel}.`);
        clearForcedContext();
        pendingSpellActionType = null;
        return;
      }
      pendingSpellActionType = null;
      const unit = getClaimedUnit();
      if (!isPlanning){
        const actionCheck = canSpendSpellAction(unit, actionType);
        if (!actionCheck.ok){
          localToast(actionCheck.reason || "You can't cast right now.");
          clearForcedContext();
          return;
        }
      }
      const actionLabel = actionType === "bonus_action" ? "bonus action" : actionType;
      const spellName = normalizeTextValue(castNameInput?.value) || "this spell";
      const castConfirmMessage = `Cast ${spellName} using your ${actionLabel}?`;
      const concentrationSpell = normalizeTextValue(unit?.concentration_spell || unit?.concentrationSpell || "");
      const concentrationKey = normalizeLowerValue(concentrationSpell);
      const pendingConcentrationKey = normalizeLowerValue(preset?.slug || spellName);
      let concentrationConfirmMessage = null;
      if (
        preset?.concentration === true
        && unit?.concentrating
        && concentrationKey
        && concentrationKey !== pendingConcentrationKey
      ){
        const concentrationLabel = concentrationSpell
          .split(/[-_\\s]+/)
          .filter(Boolean)
          .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
          .join(" ");
        concentrationConfirmMessage = `You're concentrating on ${concentrationLabel}. Casting ${spellName} will end it. Continue?`;
      }
      const shape = String(castShapeInput?.value || "").toLowerCase();
      const spellActionTag = resolveSpellActionTag(preset);
      const aoeSpell = spellActionTag === "aoe";
      const summonSpell = isSummonPreset(preset);
      if (isPlanning && !aoeSpell){
        localToast("Planning mode: only AoE preview is supported right now.");
        clearForcedContext();
        return;
      }
      const customSummon = Boolean(preset?.isCustomSummon);
      const smiteSpell = hasSpellTag(preset, "smite");
      const provisionalSlotLevel = Number.isFinite(Number(castSlotLevelInput?.value)) ? Math.floor(Number(castSlotLevelInput.value)) : null;
      const inferredTargetConfig = (!aoeSpell && !smiteSpell) ? getSpellTargetingConfig(preset, provisionalSlotLevel) : null;
      if (!customSummon && !summonSpell && !smiteSpell && !spellActionTag && !inferredTargetConfig){
        localToast("No tag found for that spell, matey.");
        reportSpellTagMissing(preset, {source: "cast_form_submit"});
        clearForcedContext();
        return;
      }
      if (aoeSpell && !shape){
        localToast("Pick a spell shape first, matey.");
        clearForcedContext();
        return;
      }
      const slotCheck = validateCastSlotSelection(preset, true);
      if (!slotCheck.ok){
        clearForcedContext();
        return;
      }
      const slotLevel = Number.isFinite(slotCheck.slotLevel) ? Math.floor(Number(slotCheck.slotLevel)) : null;
      if (summonSpell && !customSummon){
        const summonValidation = validateSummonForm(preset, true);
        if (!summonValidation.ok){
          clearForcedContext();
          return;
        }
        const choices = getSummonChoices(preset);
        const summonChoice = normalizeTextValue(castSummonChoiceInput?.value || choices[0]?.monster_slug || "");
        const summonVariant = normalizeTextValue(castSummonVariantInput?.value || "");
        const summonQuantity = Number(castSummonQuantityInput?.value);
        const presetSlug = normalizeTextValue(preset?.slug);
        const presetId = normalizeTextValue(preset?.id);
        const normalizedQuantity = Number.isFinite(summonQuantity) && summonQuantity > 0 ? Math.floor(summonQuantity) : 1;
        const payload = {
          action_type: actionType,
          name: String(castNameInput?.value || "").trim() || null,
          slot_level: slotLevel,
          spell_slug: presetSlug || null,
          spell_id: presetId || null,
          summon_choice: summonChoice || null,
          summon_quantity: normalizedQuantity,
          variant: summonVariant || null,
        };
        const caster = getClaimedUnit();
        if (!caster || !caster.pos){
          localToast("Could not find caster position, matey.");
          clearForcedContext();
          return;
        }
        pendingSummonPlacement = {
          actionType,
          slotLevel,
          spellSlug: presetSlug || null,
          spellId: presetId || null,
          summonChoice: summonChoice || null,
          summonVariant: summonVariant || null,
          summonQuantity: normalizedQuantity,
          casterPos: {col: Number(caster.pos.col), row: Number(caster.pos.row)},
          maxRangeFt: parseSpellRangeFeet(preset?.range),
          positions: [],
          payload,
          spellName,
        };
        rebuildSummonValidCells();
        updateSummonPlacementBanner();
        draw();
        localToast("Summon placement started. Choose valid highlighted squares.");
        clearForcedContext();
        return;
      }
      if (customSummon){
        const summonQuantity = Number(castSummonQuantityInput?.value);
        const normalizedQuantity = Number.isFinite(summonQuantity) && summonQuantity > 0 ? Math.floor(summonQuantity) : 1;
        const customRangeRaw = Number(castCustomSummonRangeInput?.value);
        const customRangeFt = Number.isFinite(customRangeRaw) && customRangeRaw >= 0 ? Math.floor(customRangeRaw) : 30;
        const customMonsterSlug = normalizeTextValue(castCustomSummonMonsterInput?.value);
        const summonName = normalizeTextValue(castCustomSummonNameInput?.value) || normalizeTextValue(castNameInput?.value) || "Custom summon";
        const hp = Math.max(1, parseIntOrFallback(castCustomSummonHpInput?.value, DEFAULT_CUSTOM_SUMMON_TEMPLATE.hp));
        const ac = Math.max(1, parseIntOrFallback(castCustomSummonAcInput?.value, DEFAULT_CUSTOM_SUMMON_TEMPLATE.ac));
        const summonType = normalizeTextValue(castCustomSummonTypeInput?.value) || DEFAULT_CUSTOM_SUMMON_TEMPLATE.type;
        const speeds = {
          walk: Math.max(1, parseIntOrFallback(castCustomSummonWalkInput?.value, DEFAULT_CUSTOM_SUMMON_TEMPLATE.speeds.walk)),
          swim: Math.max(0, parseIntOrFallback(castCustomSummonSwimInput?.value, DEFAULT_CUSTOM_SUMMON_TEMPLATE.speeds.swim)),
          fly: Math.max(0, parseIntOrFallback(castCustomSummonFlyInput?.value, DEFAULT_CUSTOM_SUMMON_TEMPLATE.speeds.fly)),
          burrow: Math.max(0, parseIntOrFallback(castCustomSummonBurrowInput?.value, DEFAULT_CUSTOM_SUMMON_TEMPLATE.speeds.burrow)),
          climb: Math.max(0, parseIntOrFallback(castCustomSummonClimbInput?.value, DEFAULT_CUSTOM_SUMMON_TEMPLATE.speeds.climb)),
        };
        const abilities = {
          str: clampInt(castCustomSummonStrInput?.value, 1, 30, DEFAULT_CUSTOM_SUMMON_TEMPLATE.abilities.str),
          dex: clampInt(castCustomSummonDexInput?.value, 1, 30, DEFAULT_CUSTOM_SUMMON_TEMPLATE.abilities.dex),
          con: clampInt(castCustomSummonConInput?.value, 1, 30, DEFAULT_CUSTOM_SUMMON_TEMPLATE.abilities.con),
          int: clampInt(castCustomSummonIntInput?.value, 1, 30, DEFAULT_CUSTOM_SUMMON_TEMPLATE.abilities.int),
          wis: clampInt(castCustomSummonWisInput?.value, 1, 30, DEFAULT_CUSTOM_SUMMON_TEMPLATE.abilities.wis),
          cha: clampInt(castCustomSummonChaInput?.value, 1, 30, DEFAULT_CUSTOM_SUMMON_TEMPLATE.abilities.cha),
        };
        const payload = {
          action_type: actionType,
          shape: "summon",
          name: summonName,
          monster_slug: customMonsterSlug || null,
          type: summonType,
          hp,
          ac,
          speeds,
          abilities,
          summon_choice: "custom",
          summon_quantity: normalizedQuantity,
          summon_range_ft: customRangeFt,
          slot_level: slotLevel,
        };
        const caster = getClaimedUnit();
        if (!caster || !caster.pos){
          localToast("Could not find caster position, matey.");
          clearForcedContext();
          return;
        }
        pendingSummonPlacement = {
          mode: "custom_summon",
          actionType,
          slotLevel,
          spellSlug: null,
          spellId: null,
          summonChoice: "custom",
          summonVariant: null,
          summonQuantity: normalizedQuantity,
          casterPos: {col: Number(caster.pos.col), row: Number(caster.pos.row)},
          maxRangeFt: customRangeFt,
          positions: [],
          payload,
          spellName: summonName,
        };
        rebuildSummonValidCells();
        updateSummonPlacementBanner();
        draw();
        localToast("Custom summon placement started. Choose valid highlighted squares.");
        return;
      }
      const parsePositive = (value) => {
        const num = parseFloat(value || "");
        return Number.isFinite(num) && num > 0 ? num : null;
      };
      const parseNonnegative = (value) => {
        const num = parseFloat(value || "");
        return Number.isFinite(num) && num >= 0 ? num : null;
      };
      const radiusFt = parsePositive(castRadiusInput?.value);
      const sideFt = parsePositive(castSideInput?.value);
      const lengthFt = parsePositive(castLengthInput?.value);
      const widthFt = parsePositive(castWidthInput?.value);
      const angleRaw = String(castAngleInput?.value || "").trim();
      const angleDegInput = angleRaw ? parseNonnegative(castAngleInput?.value) : null;
      const casterFacingDeg = normalizeFacingDeg(getClaimedUnit()?.facing_deg);
      const angleDeg = angleDegInput !== null ? angleDegInput : casterFacingDeg;
      const widthRaw = String(castWidthInput?.value || "").trim();
      const thicknessFt = parsePositive(castThicknessInput?.value);
      const thicknessRaw = String(castThicknessInput?.value || "").trim();
      const heightFt = parsePositive(castHeightInput?.value);
      const heightRaw = String(castHeightInput?.value || "").trim();
      const orientValue = String(castOrientInput?.value || "vertical").toLowerCase();
      const orient = orientValue === "horizontal" ? "horizontal" : "vertical";
      if (shape === "circle" && radiusFt === null){
        localToast("Enter a valid radius, matey.");
        return;
      }
      if ((shape === "sphere" || shape === "cylinder") && radiusFt === null){
        localToast("Enter a valid radius, matey.");
        return;
      }
      if (shape === "cylinder" && heightRaw && heightFt === null){
        localToast("Enter a valid height, matey.");
        return;
      }
      if (shape === "square" && sideFt === null){
        localToast("Enter a valid side length, matey.");
        return;
      }
      if (shape === "cube" && sideFt === null){
        localToast("Enter a valid side length, matey.");
        return;
      }
      if (shape === "line" && (lengthFt === null || widthFt === null)){
        localToast("Enter a valid line size, matey.");
        return;
      }
      if (shape === "cone" && lengthFt === null){
        localToast("Enter a valid cone length, matey.");
        return;
      }
      if (shape === "cone" && angleRaw && (angleDeg === null || angleDeg <= 0)){
        localToast("Enter a valid cone angle, matey.");
        return;
      }
      if ((shape === "line" || shape === "wall") && angleRaw && angleDeg === null){
        localToast("Enter a valid angle, matey.");
        return;
      }
      if (shape === "wall" && widthRaw && widthFt === null){
        localToast("Enter a valid wall width, matey.");
        return;
      }
      if (shape === "wall" && thicknessRaw && thicknessFt === null){
        localToast("Enter a valid wall thickness, matey.");
        return;
      }
      if (shape === "wall" && heightRaw && heightFt === null){
        localToast("Enter a valid wall height, matey.");
        return;
      }
      if (shape === "wall"){
        if (lengthFt === null){
          localToast("Enter a valid wall length, matey.");
          return;
        }
        if (widthFt === null && (thicknessFt === null || heightFt === null)){
          localToast("Enter a valid wall thickness and height (or width), matey.");
          return;
        }
      }
      const dcType = String(castDcTypeInput?.value || "").trim().toLowerCase();
      const dcValue = parseInt(castDcValueInput?.value || "", 10);
      const damageTypes = Array.from(castDamageTypes);
      if (!damageTypes.length){
        const fallbackType = String(castDamageTypeInput?.value || "").trim();
        if (fallbackType){
          damageTypes.push(fallbackType);
        }
      }
      const damageType = damageTypes.length === 1 ? damageTypes[0] : "";
      const name = String(castNameInput?.value || "").trim();
      const appearanceSelection = aoeSpell ? String(castSummonVariantInput?.value || "").trim() : "";
      const baseName = name || String(castNameInput?.placeholder || "Spell").trim();
      const appearanceName = appearanceSelection
        ? `${baseName} (${appearanceSelection})`
        : name;
      const color = normalizeHexColor(castColorInput?.value || "") || null;
      let defaultDamage = String(castDefaultDamageInput?.value || "").trim();
      let dice = String(castDiceInput?.value || "").trim();
      if (castUpcastConfig){
        const slotLevelValue = Number(castSlotLevelInput?.value);
        const upcastValues = computeUpcastValues(
          castBaseDice || dice,
          castBaseDefaultDamage || defaultDamage,
          castUpcastConfig,
          slotLevelValue
        );
        if (upcastValues.dice !== undefined && upcastValues.dice !== null){
          dice = String(upcastValues.dice || "");
        }
        if (upcastValues.defaultDamage !== undefined && upcastValues.defaultDamage !== null){
          defaultDamage = String(upcastValues.defaultDamage || "");
        }
      }
      const center = defaultAoeCenter();
      if (aoeSpell && shape !== "line"){
        const caster = getClaimedUnit();
        if (caster && caster.pos){
          const start = {col: Number(caster.pos.col), row: Number(caster.pos.row)};
          const end = {col: Number(center.cx), row: Number(center.cy)};
          const blocked = isLineOfSightBlocked(start, end);
          setLosPreview(start, end, blocked);
          if (!isPlanning && blocked){
            localToast("No line of sight to spell center.");
            return;
          }
        }
      }
      const payload = {
        shape,
        action_type: actionType,
        dc: Number.isFinite(dcValue) ? dcValue : null,
        save_type: dcType || null,
        damage_type: damageType || null,
        damage_types: damageTypes,
        name: appearanceName || null,
        color,
        cx: center.cx,
        cy: center.cy,
      };
      if (typeof preset?.concentration === "boolean"){
        payload.concentration = preset.concentration;
      }
      if (Number.isFinite(preset?.level)){
        payload.level = Math.max(0, Math.floor(Number(preset.level)));
      }
      if (defaultDamage){
        payload.default_damage = defaultDamage;
      }
      if (dice){
        payload.dice = dice;
      }
      if (Number.isFinite(Number(castDurationTurns)) && Number(castDurationTurns) >= 0){
        payload.duration_turns = Number(castDurationTurns);
      }
      const hazardPreset = !!(castHazardBehavior && typeof castHazardBehavior === "object");
      if (hazardPreset){
        payload.persistent = true;
        if (castAutomationIsEnabled()){
          payload.over_time = true;
          payload.trigger_on_start_or_enter = "enter_or_end";
        }
      } else if (typeof castOverTime === "boolean"){
        payload.over_time = castOverTime;
      }
      if (Number.isFinite(Number(castMovePerTurnFt)) && Number(castMovePerTurnFt) >= 0){
        payload.move_per_turn_ft = Number(castMovePerTurnFt);
      }
      if (!hazardPreset && castTriggerOnStartOrEnter){
        payload.trigger_on_start_or_enter = castTriggerOnStartOrEnter;
      }
      if (!hazardPreset && typeof castPersistent === "boolean"){
        payload.persistent = castPersistent;
      }
      if (typeof castPinnedDefault === "boolean"){
        payload.pinned_default = castPinnedDefault;
      }
      if (castMoveActionType){
        payload.move_action_type = castMoveActionType;
      }
      if (aoeSpell && shape === "circle"){
        payload.radius_ft = radiusFt;
      } else if (aoeSpell && (shape === "sphere" || shape === "cylinder")){
        payload.radius_ft = radiusFt;
        if (heightFt !== null){
          payload.height_ft = heightFt;
        }
      } else if (aoeSpell && (shape === "square" || shape === "cube")){
        payload.side_ft = sideFt;
        payload.angle_deg = angleDegInput !== null ? angleDegInput : 0;
      } else if (aoeSpell && shape === "line"){
        payload.length_ft = lengthFt;
        payload.width_ft = widthFt;
        payload.orient = orient;
        payload.angle_deg = angleDeg !== null ? angleDeg : 0;
      } else if (aoeSpell && shape === "cone"){
        payload.length_ft = lengthFt;
        payload.angle_deg = angleDeg !== null ? angleDeg : 90;
        payload.orient = orient;
      } else if (aoeSpell && shape === "wall"){
        payload.length_ft = lengthFt;
        payload.orient = orient;
        if (widthFt !== null){
          payload.width_ft = widthFt;
        }
        if (thicknessFt !== null){
          payload.thickness_ft = thicknessFt;
        }
        if (heightFt !== null){
          payload.height_ft = heightFt;
        }
        if (angleDeg !== null){
          payload.angle_deg = angleDeg;
        }
      }
      const msg = {type: aoeSpell ? "cast_aoe" : "cast_spell", payload, action_type: actionType};
      const actionCid = activeControlledUnitCid();
      if (actionCid !== null){
        msg.cid = actionCid;
      }
      const spellTargetConfig = (!aoeSpell && !smiteSpell) ? (inferredTargetConfig || getSpellTargetingConfig(preset, slotLevel)) : null;
      const presetSlug = normalizeTextValue(preset?.slug);
      const presetId = normalizeTextValue(preset?.id);
      if (presetSlug){
        msg.spell_slug = presetSlug;
      }
      if (presetId){
        msg.spell_id = presetId;
      }
      if (Number.isFinite(slotLevel)){
        msg.slot_level = slotLevel;
      }
      if (slotCheck.consumesPool){
        msg.payload = msg.payload || {};
        msg.payload.consumes_pool = {id: slotCheck.consumesPool.id, cost: slotCheck.consumesPool.cost};
        msg.consumes_pool_id = slotCheck.consumesPool.id;
        msg.consumes_pool_cost = slotCheck.consumesPool.cost;
      }
      if (aoeSpell){
        const caster = getClaimedUnit();
        const directionalSelfRange = isDirectionalSelfRangeAoePlacement(preset, shape);
        const selfRangeCentered = isSelfRangeAoePreset(preset) && isCenteredAoeShape(shape);
        if (selfRangeCentered && caster?.pos){
          if (castSpellModal?.classList.contains("show")){
            hideCastSpellModal();
          }
          if (castOverlay?.classList.contains("show")){
            setCastOverlayOpen(false);
          }
          msg.payload = msg.payload || {};
          const casterCol = Number(caster.pos.col);
          const casterRow = Number(caster.pos.row);
          msg.payload.cx = casterCol;
          msg.payload.cy = casterRow;
          msg.payload.fixed_to_caster = true;
          pendingAoePlacement = {
            mode: "aimless_self_centered",
            msg,
            payload: {...payload, cx: casterCol, cy: casterRow, fixed_to_caster: true},
            cursor: {col: casterCol, row: casterRow},
            casterPos: toGridPoint(caster.pos),
            casterCid: Number(caster?.cid),
            castConfirmMessage: isPlanning ? null : castConfirmMessage,
            concentrationConfirmMessage: isPlanning ? null : concentrationConfirmMessage,
            resolveContext: isPlanning ? null : {
              spellName: payload.name || appearanceName || castName || preset?.name || "Spell",
              slotLevel,
              baseLevel: Number.isFinite(Number(preset?.level)) ? Math.floor(Number(preset.level)) : null,
              dice: payload.dice || "",
              damageTypes,
            },
          };
          refreshAoePlacementAimGuide();
          renderAimlessAoeConfirm();
          localToast("AoE preview active: reposition your token, then Confirm.");
          draw();
          return;
        }
        if (castSpellModal?.classList.contains("show")){
          hideCastSpellModal();
        }
        if (castOverlay?.classList.contains("show")){
          setCastOverlayOpen(false);
        }
        try {
          let placementRangeFt = directionalSelfRange ? null : parseSpellTargetRangeFeet(preset);
          if (!directionalSelfRange && !Number.isFinite(placementRangeFt)){
            const promptValue = window.prompt("Spell range is unknown. Enter range in feet:", "30");
            if (promptValue === null){
              localToast("AoE cast cancelled: range is required.");
              return;
            }
            const parsedPromptRange = Number(promptValue);
            if (!Number.isFinite(parsedPromptRange) || parsedPromptRange < 0){
              localToast("Invalid spell range. Enter a number in feet.");
              return;
            }
            placementRangeFt = parsedPromptRange;
          }
          pendingAoePlacement = {
            mode: directionalSelfRange ? "directional_self_range" : null,
            msg,
            payload: {...payload},
            cursor: {col: Number(payload.cx), row: Number(payload.cy)},
            casterPos: caster?.pos ? toGridPoint(caster.pos) : null,
            casterCid: Number(caster?.cid),
            rangeFt: placementRangeFt,
            headingDeg: (directionalSelfRange && String(shape).toLowerCase() === "cone")
              ? normalizeFacingDeg(caster?.facing_deg ?? 0)
              : (Number.isFinite(Number(payload.angle_deg)) ? Number(payload.angle_deg) : 0),
            coneSpreadDeg: directionalSelfRange && String(shape).toLowerCase() === "cone" && Number.isFinite(Number(payload.angle_deg))
              ? Number(payload.angle_deg)
              : null,
            castConfirmMessage: (isPlanning || directionalSelfRange) ? null : castConfirmMessage,
            concentrationConfirmMessage: (isPlanning || directionalSelfRange) ? null : concentrationConfirmMessage,
            resolveContext: isPlanning ? null : {
              spellName: payload.name || appearanceName || castName || preset?.name || "Spell",
              slotLevel,
              baseLevel: Number.isFinite(Number(preset?.level)) ? Math.floor(Number(preset.level)) : null,
              dice: payload.dice || "",
              damageTypes,
            },
          };
          if (directionalSelfRange){
            applyDirectionalSelfRangePlacement();
          }
          refreshAoePlacementAimGuide();
          localToast(directionalSelfRange
            ? "Directional AoE: aim with cursor and click to cast."
            : "AoE placement: move cursor, click to place (youll confirm on placement).");
          draw();
        } catch (err) {
          const details = {
            timestamp: new Date().toISOString(),
            userAgent: navigator.userAgent,
            url: location.href,
            message: "AoE placement initialization failed",
            level: "error",
            spell_name: spellName,
            spell_slug: presetSlug || "",
            stack: err?.stack ? String(err.stack) : String(err || ""),
          };
          try {
            fetch("/api/client-log", {
              method: "POST",
              headers: {"Content-Type": "application/json"},
              body: JSON.stringify(details),
            }).catch(() => {});
          } catch (_logErr) {}
          console.error("AoE placement initialization failed", err);
          localToast("Cast failed while starting AoE placement.");
        }
        return;
      }
      if (!isPlanning && !window.confirm(castConfirmMessage)){
        return;
      }
      if (!isPlanning && concentrationConfirmMessage && !window.confirm(concentrationConfirmMessage)){
        return;
      }
      const shouldBufferSelection = !!(spellTargetConfig && Number(spellTargetConfig.maxTargets || 1) > 1);
      if (shouldBufferSelection){
        if (castSpellModal?.classList.contains("show")){
          hideCastSpellModal();
        }
        if (castOverlay?.classList.contains("show")){
          setCastOverlayOpen(false);
        }
        startSpellTargetingSession(spellTargetConfig, preset, slotLevel, msg);
        return;
      }
      if (isPlanning){
        planningMutate(msg);
        draw();
        updateHud();
      }
      send(msg);
      if (castSpellModal?.classList.contains("show")){
        hideCastSpellModal();
      }
      if (castOverlay?.classList.contains("show")){
        setCastOverlayOpen(false);
      }
      if (spellTargetConfig){
        startSpellTargetingSession(spellTargetConfig, preset, slotLevel, null);
      }
      } finally {
        clearForcedPoolCastContext();
      }
    });
  }

  if (dashBtn){
    dashBtn.addEventListener("click", () => {
      if (isMapView) return;
      if (!claimedCid) return;
      openActionPicker("dash");
    });
  }
  if (dashActionBtn){
    dashActionBtn.addEventListener("click", () => {
      if (isMapView) return;
      const actionCid = activeControlledUnitCid();
      if (actionCid === null) return;
      const msg = {type:"dash", cid: actionCid, spend:"action"};
      if (isPlanning){
        planningMutate(msg);
        draw();
        updateHud();
      }
      send(msg);
      hideDashModal();
    });
  }
  if (dashBonusActionBtn){
    dashBonusActionBtn.addEventListener("click", () => {
      if (isMapView) return;
      const actionCid = activeControlledUnitCid();
      if (actionCid === null) return;
      const msg = {type:"dash", cid: actionCid, spend:"bonus"};
      if (isPlanning){
        planningMutate(msg);
        draw();
        updateHud();
      }
      send(msg);
      hideDashModal();
    });
  }
  if (dashCancelBtn){
    dashCancelBtn.addEventListener("click", () => {
      hideDashModal();
    });
  }
  if (actionPickerCancelBtn){
    actionPickerCancelBtn.addEventListener("click", () => {
      hideActionPicker();
    });
  }
  if (battleLogBtn){
    battleLogBtn.addEventListener("click", () => {
      if (battleLogViewPrefs?.visible){
        hideLogModal();
      } else {
        showLogModal();
      }
    });
  }
  if (logCloseBtn){
    logCloseBtn.addEventListener("click", () => {
      hideLogModal();
    });
  }
  if (logHeader && logModal){
    let dragState = null;
    const endLogDrag = () => {
      if (!dragState) return;
      battleLogViewPrefs.left = dragState.left;
      battleLogViewPrefs.top = dragState.top;
      persistBattleLogViewPrefs();
      dragState = null;
    };
    logHeader.addEventListener("pointerdown", (event) => {
      if (event.pointerType === "mouse" && event.button !== 0) return;
      const target = event.target instanceof Element ? event.target : null;
      if (target?.closest("button")) return;
      const modalRect = logModal.getBoundingClientRect();
      const minTop = 0;
      const maxLeft = Math.max(0, window.innerWidth - modalRect.width);
      const maxTop = Math.max(minTop, window.innerHeight - modalRect.height);
      dragState = {
        pointerId: event.pointerId,
        offsetX: event.clientX - modalRect.left,
        offsetY: event.clientY - modalRect.top,
        minTop,
        maxLeft,
        maxTop,
        left: Math.min(maxLeft, Math.max(0, modalRect.left)),
        top: Math.min(maxTop, Math.max(minTop, modalRect.top)),
      };
      logModal.style.right = "auto";
      logModal.style.bottom = "auto";
      logHeader.setPointerCapture?.(event.pointerId);
      event.preventDefault();
    });
    logHeader.addEventListener("pointermove", (event) => {
      if (!dragState || event.pointerId !== dragState.pointerId) return;
      const modalRect = logModal.getBoundingClientRect();
      dragState.maxLeft = Math.max(0, window.innerWidth - modalRect.width);
      dragState.maxTop = Math.max(dragState.minTop, window.innerHeight - modalRect.height);
      const left = Math.min(dragState.maxLeft, Math.max(0, event.clientX - dragState.offsetX));
      const top = Math.min(dragState.maxTop, Math.max(dragState.minTop, event.clientY - dragState.offsetY));
      dragState.left = Math.round(left);
      dragState.top = Math.round(top);
      logModal.style.left = `${dragState.left}px`;
      logModal.style.top = `${dragState.top}px`;
    });
    logHeader.addEventListener("pointerup", endLogDrag);
    logHeader.addEventListener("pointercancel", endLogDrag);
    logHeader.addEventListener("lostpointercapture", endLogDrag);
  }
  if (logResizeHandle && logModal){
    let resizeState = null;
    const endLogResize = () => {
      if (!resizeState) return;
      persistBattleLogViewPrefs();
      resizeState = null;
    };
    logResizeHandle.addEventListener("pointerdown", (event) => {
      if (event.pointerType === "mouse" && event.button !== 0) return;
      const modalRect = logModal.getBoundingClientRect();
      resizeState = {
        pointerId: event.pointerId,
        startX: event.clientX,
        startY: event.clientY,
        width: modalRect.width,
        height: modalRect.height,
      };
      logResizeHandle.setPointerCapture?.(event.pointerId);
      event.preventDefault();
    });
    logResizeHandle.addEventListener("pointermove", (event) => {
      if (!resizeState || event.pointerId !== resizeState.pointerId) return;
      const width = Math.max(260, resizeState.width + (event.clientX - resizeState.startX));
      const height = Math.max(180, resizeState.height + (event.clientY - resizeState.startY));
      logModal.style.width = `${Math.round(width)}px`;
      logModal.style.height = `${Math.round(height)}px`;
      battleLogViewPrefs.width = Math.round(width);
      battleLogViewPrefs.height = Math.round(height);
    });
    logResizeHandle.addEventListener("pointerup", endLogResize);
    logResizeHandle.addEventListener("pointercancel", endLogResize);
  }
  if (planningChatHeader && planningChatOverlay){
    let dragState = null;
    const endChatDrag = () => {
      if (!dragState) return;
      chatViewPrefs.left = dragState.left;
      chatViewPrefs.top = dragState.top;
      persistChatViewPrefs();
      dragState = null;
    };
    planningChatHeader.addEventListener("pointerdown", (event) => {
      if (event.pointerType === "mouse" && event.button !== 0) return;
      const target = event.target instanceof Element ? event.target : null;
      if (target?.closest("button")) return;
      const modalRect = planningChatOverlay.getBoundingClientRect();
      const topbarHeight = document.querySelector(".topbar")?.getBoundingClientRect().height || 0;
      const sheetHeight = sheetWrap && !sheetWrap.classList.contains("hidden")
        ? sheetWrap.getBoundingClientRect().height
        : 0;
      const minTop = Math.max(0, topbarHeight + 8);
      const maxLeft = Math.max(0, window.innerWidth - modalRect.width);
      const maxTop = Math.max(minTop, window.innerHeight - sheetHeight - modalRect.height - 8);
      dragState = {
        pointerId: event.pointerId,
        offsetX: event.clientX - modalRect.left,
        offsetY: event.clientY - modalRect.top,
        minTop,
        maxLeft,
        maxTop,
        left: Math.min(maxLeft, Math.max(0, modalRect.left)),
        top: Math.min(maxTop, Math.max(minTop, modalRect.top)),
      };
      planningChatOverlay.style.right = "auto";
      planningChatOverlay.style.bottom = "auto";
      planningChatHeader.setPointerCapture?.(event.pointerId);
      event.preventDefault();
    });
    planningChatHeader.addEventListener("pointermove", (event) => {
      if (!dragState || event.pointerId !== dragState.pointerId) return;
      const left = Math.min(dragState.maxLeft, Math.max(0, event.clientX - dragState.offsetX));
      const top = Math.min(dragState.maxTop, Math.max(0, event.clientY - dragState.offsetY));
      dragState.left = Math.round(left);
      dragState.top = Math.round(top);
      planningChatOverlay.style.left = `${dragState.left}px`;
      planningChatOverlay.style.top = `${dragState.top}px`;
    });
    planningChatHeader.addEventListener("pointerup", endChatDrag);
    planningChatHeader.addEventListener("pointercancel", endChatDrag);
  }
  if (planningChatResizeHandle && planningChatOverlay){
    let resizeState = null;
    const endChatResize = () => {
      if (!resizeState) return;
      persistChatViewPrefs();
      resizeState = null;
    };
    planningChatResizeHandle.addEventListener("pointerdown", (event) => {
      if (event.pointerType === "mouse" && event.button !== 0) return;
      const modalRect = planningChatOverlay.getBoundingClientRect();
      resizeState = {
        pointerId: event.pointerId,
        startX: event.clientX,
        startY: event.clientY,
        width: modalRect.width,
        height: modalRect.height,
      };
      planningChatResizeHandle.setPointerCapture?.(event.pointerId);
      event.preventDefault();
    });
    planningChatResizeHandle.addEventListener("pointermove", (event) => {
      if (!resizeState || event.pointerId !== resizeState.pointerId) return;
      const width = Math.max(280, resizeState.width + (event.clientX - resizeState.startX));
      const height = Math.max(220, resizeState.height + (event.clientY - resizeState.startY));
      planningChatOverlay.style.width = `${Math.round(width)}px`;
      planningChatOverlay.style.height = `${Math.round(height)}px`;
      chatViewPrefs.width = Math.round(width);
      chatViewPrefs.height = Math.round(height);
    });
    planningChatResizeHandle.addEventListener("pointerup", endChatResize);
    planningChatResizeHandle.addEventListener("pointercancel", endChatResize);
  }
  if (configBtn){
    configBtn.addEventListener("click", () => {
      if (!configModal) return;
      if (configModal.classList.contains("show")){
        hideConfigModal();
        return;
      }
      showConfigModal();
    });
  }
  if (initiativeToggleBtn){
    initiativeToggleBtn.addEventListener("click", () => {
      toggleInitiativeBar();
    });
  }
  if (planningBtn){
    planningBtn.classList.toggle("hidden", isPlanning);
    planningBtn.disabled = isPlanning;
    planningBtn.setAttribute("aria-disabled", isPlanning ? "true" : "false");
    if (!isPlanning){
      planningBtn.addEventListener("click", () => {
        const baseUrl = window.LAN_BASE_URL || window.location.origin;
        const planningUrl = new URL(`${baseUrl.replace(/\/$/, "")}/planning`);
        if (clientId){
          planningUrl.searchParams.set("client_id", clientId);
        }
        if (claimedCid !== null && claimedCid !== undefined){
          planningUrl.searchParams.set("player_cid", String(claimedCid));
        }
        window.open(planningUrl.toString(), "_blank", "noopener,noreferrer");
      });
    }
  }
  if (inventoryBtn){
    inventoryBtn.addEventListener("click", () => setInventoryPanelOpen(!inventoryPanelOpen));
  }
  if (planningAoeBtn){
    planningAoeBtn.classList.toggle("hidden", !isPlanning);
    planningAoeBtn.disabled = !isPlanning;
    planningAoeBtn.setAttribute("aria-disabled", !isPlanning ? "true" : "false");
    if (isPlanning){
      planningAoeBtn.addEventListener("click", () => {
        spellLibrarySearchTerm = "";
        openSpellLibraryOverlay(true, {mode: "planning_aoe"});
      });
    }
  }
  if (planningChatBtn){
    planningChatBtn.addEventListener("click", () => setPlanningChatOpen(!planningChatOpen));
  }
  if (planningChatCloseBtn){
    planningChatCloseBtn.addEventListener("click", () => setPlanningChatOpen(false));
  }
  if (planningChatForm){
    planningChatForm.addEventListener("submit", (ev) => {
      ev.preventDefault();
      const text = String(planningChatInput?.value || "").trim();
      if (!text) return;
      send({type:"planning_chat", text});
      if (planningChatInput) planningChatInput.value = "";
    });
  }
  if (configCloseBtn){
    configCloseBtn.addEventListener("click", () => {
      hideConfigModal();
    });
  }
  if (configModal){
    configModal.addEventListener("click", (event) => {
      if (event.target === configModal){
        hideConfigModal();
      }
    });
  }
  const mapViewSettingInputs = [
    mapViewTextSizeInput,
    mapViewBarHeightInput,
    mapViewChipPaddingInput,
    mapViewChipGapInput,
    mapViewCornerRadiusInput,
    mapViewRotateHandleScaleInput,
    mapViewShowTitleInput,
    mapViewShowStatusInput,
    mapViewShowIndexInput,
  ].filter(Boolean);
  mapViewSettingInputs.forEach((inputEl) => {
    inputEl.addEventListener("input", () => {
      if (!mapViewSettings){
        mapViewSettings = readMapViewSettings();
      }
      mapViewSettings = {
        ...mapViewSettings,
        textSize: Number(mapViewTextSizeInput?.value || mapViewSettings.textSize),
        barHeight: Number(mapViewBarHeightInput?.value || mapViewSettings.barHeight),
        chipPadding: Number(mapViewChipPaddingInput?.value || mapViewSettings.chipPadding),
        chipGap: Number(mapViewChipGapInput?.value || mapViewSettings.chipGap),
        cornerRadius: Number(mapViewCornerRadiusInput?.value || mapViewSettings.cornerRadius),
        rotateHandleScale: Number(mapViewRotateHandleScaleInput?.value || mapViewSettings.rotateHandleScale),
        showTitle: !!mapViewShowTitleInput?.checked,
        showStatus: !!mapViewShowStatusInput?.checked,
        showIndex: !!mapViewShowIndexInput?.checked,
      };
      applyMapViewSettings(mapViewSettings);
      persistMapViewSettings();
    });
  });
  if (sheetHeightInput){
    sheetHeightInput.addEventListener("input", () => {
      applySheetHeight(Number(sheetHeightInput.value));
      persistSheetHeight();
    });
  }
  if (battleLogFontFamilyInput){
    battleLogFontFamilyInput.addEventListener("change", () => {
      battleLogViewPrefs.fontFamily = battleLogFontFamilyInput.value || battleLogViewPrefs.fontFamily;
      applyBattleLogViewPrefs();
      persistBattleLogViewPrefs();
    });
  }
  if (battleLogFontSizeInput){
    battleLogFontSizeInput.addEventListener("input", () => {
      battleLogViewPrefs.fontSize = Math.max(11, Math.min(28, Number(battleLogFontSizeInput.value) || 14));
      applyBattleLogViewPrefs();
      persistBattleLogViewPrefs();
    });
  }
  if (logModal && window.ResizeObserver){
    const logResizeObserver = new ResizeObserver((entries) => {
      const box = entries?.[0]?.contentRect;
      if (!box || !battleLogViewPrefs?.visible) return;
      battleLogViewPrefs.width = Math.round(box.width);
      battleLogViewPrefs.height = Math.round(box.height);
      persistBattleLogViewPrefs();
    });
    logResizeObserver.observe(logModal);
  }
  if (planningChatOverlay && window.ResizeObserver){
    const chatResizeObserver = new ResizeObserver((entries) => {
      const box = entries?.[0]?.contentRect;
      if (!box || !chatViewPrefs?.visible) return;
      chatViewPrefs.width = Math.round(box.width);
      chatViewPrefs.height = Math.round(box.height);
      persistChatViewPrefs();
    });
    chatResizeObserver.observe(planningChatOverlay);
  }
  if (presetSaveBtn){
    presetSaveBtn.addEventListener("click", () => {
      const preset = buildGuiPreset();
      persistLocalPreset(preset);
      send({type: "save_preset", preset});
    });
  }
  if (presetLoadBtn){
    presetLoadBtn.addEventListener("click", () => {
      send({type: "load_preset"});
    });
  }
  if (focusTabOnTurnInput){
    focusTabOnTurnInput.checked = focusTabOnTurn;
    focusTabOnTurnInput.addEventListener("change", (event) => {
      focusTabOnTurn = event.target.checked;
      localStorage.setItem(focusTabOnTurnStorageKey, focusTabOnTurn ? "1" : "0");
    });
  }
  if (unlockAudioBtn){
    unlockAudioBtn.addEventListener("click", () => {
      unlockTurnAudio();
    });
  }
  async function enableTurnAlertsFromUi(){
    const identity = getTurnAlertIdentity();
    if (!identity?.playerId){
      const message = "Claim a character first.";
      setNotificationStatus(message);
      setTurnAlertStatus(message);
      throw new Error(message);
    }
    let alreadySubscribed = false;
    if ("serviceWorker" in navigator){
      swRegistration = swRegistration || await navigator.serviceWorker.ready;
      const existing = await swRegistration.pushManager.getSubscription();
      if (existing){
        alreadySubscribed = true;
        await syncTurnAlertSubscription(existing, identity);
      }
    }
    await ensurePushSubscribed({
      vapidPublicKey: pushPublicKey,
      playerId: identity.playerId,
    });
    return {alreadySubscribed};
  }

  if (enableNotificationsBtn){
    enableNotificationsBtn.addEventListener("click", async () => {
      try {
        const {alreadySubscribed} = await enableTurnAlertsFromUi();
        setNotificationStatus(alreadySubscribed ? "Notifications already enabled." : "Notifications enabled.");
      } catch (err){
        const message = err?.message ? String(err.message) : "Failed to enable notifications.";
        console.warn("Push subscription failed.", err);
        setNotificationStatus(message);
      }
    });
  }
  if (enableTurnAlertsBtn){
    enableTurnAlertsBtn.addEventListener("click", async () => {
      try {
        const {alreadySubscribed} = await enableTurnAlertsFromUi();
        localToast(alreadySubscribed ? "Turn alerts already enabled." : "Turn alerts enabled.");
      } catch (err){
        const message = err?.message ? String(err.message) : "Failed to enable alerts.";
        setTurnAlertStatus(message);
        localToast(message);
      }
    });
  }
  if (hideTurnAlertsBtn && turnAlertsPanel){
    hideTurnAlertsBtn.addEventListener("click", () => {
      localStorage.setItem(turnAlertHideKey, "1");
      turnAlertsPanel.classList.add("hidden");
    });
  }
  if (castOverlayOpenBtn){
    castOverlayOpenBtn.addEventListener("click", () => {
      setCastOverlayOpen(true);
    });
  }
  if (castOverlayBackBtn){
    castOverlayBackBtn.addEventListener("click", () => {
      setCastOverlayOpen(false);
    });
  }
  if (spellLibraryBtn){
    spellLibraryBtn.addEventListener("click", () => {
      openSpellLibraryOverlay(true, {mode: "browse"});
    });
  }
  if (spellLibraryCloseBtn){
    spellLibraryCloseBtn.addEventListener("click", () => {
      openSpellLibraryOverlay(false);
    });
  }
  if (spellLibraryManageSpellsBtn){
    spellLibraryManageSpellsBtn.addEventListener("click", () => {
      openSpellLibraryOverlay(false);
      openSpellbookOverlay(true);
    });
  }
  if (spellLibrarySearchInput){
    spellLibrarySearchInput.addEventListener("input", (event) => {
      spellLibrarySearchTerm = String(event.target.value || "");
      renderSpellLibrary();
    });
  }
  if (spellLibrarySortSelect){
    spellLibrarySortSelect.addEventListener("change", (event) => {
      spellLibrarySortMode = String(event.target.value || "alpha");
      renderSpellLibrary();
    });
  }
  if (spellLibraryAoeOnlyInput){
    spellLibraryAoeOnlyInput.addEventListener("change", (event) => {
      spellLibraryAoeOnly = !!event.target.checked;
      renderSpellLibrary();
    });
  }
  if (spellbookOpenBtn){
    spellbookOpenBtn.addEventListener("click", () => {
      openSpellbookOverlay(true);
    });
  }
  if (wildShapeManageOpenBtn){
    wildShapeManageOpenBtn.addEventListener("click", () => {
      if (!isClaimedUnitDruid()){
        localToast("Only Druids level 2+ can manage Wild Shapes.");
        return;
      }
      setWildShapeOverlayOpen(true);
    });
  }
  if (wildShapeMenuCloseBtn){
    wildShapeMenuCloseBtn.addEventListener("click", () => setWildShapeMenuOpen(false));
  }
  if (wildShapeMenuManageFormsBtn){
    wildShapeMenuManageFormsBtn.addEventListener("click", () => {
      setWildShapeMenuOpen(false);
      setWildShapeOverlayOpen(true);
    });
  }
  if (wildShapeMenuApplyBtn){
    wildShapeMenuApplyBtn.addEventListener("click", () => setWildShapePickOverlayOpen(true));
  }
  if (wildShapeMenuRevertBtn){
    wildShapeMenuRevertBtn.addEventListener("click", () => {
      if (!claimedCid) return;
      send({type:"wild_shape_revert", cid: claimedCid});
      setWildShapeMenuOpen(false);
    });
  }
  if (wildShapeMenuRegainUseBtn){
    wildShapeMenuRegainUseBtn.addEventListener("click", () => {
      if (!claimedCid) return;
      send({type:"wild_shape_regain_use", cid: claimedCid});
      setWildShapeMenuOpen(false);
    });
  }
  if (wildShapeMenuRegainSpellBtn){
    wildShapeMenuRegainSpellBtn.addEventListener("click", () => {
      if (!claimedCid) return;
      send({type:"wild_shape_regain_spell", cid: claimedCid});
      setWildShapeMenuOpen(false);
    });
  }
  if (wildShapeMenuManagePoolBtn){
    wildShapeMenuManagePoolBtn.addEventListener("click", () => setWildShapePoolOverlayOpen(true));
  }
  if (wildShapePoolBackBtn){
    wildShapePoolBackBtn.addEventListener("click", () => setWildShapePoolOverlayOpen(false));
  }
  if (wildShapePoolDecBtn){
    wildShapePoolDecBtn.addEventListener("click", () => {
      if (!wildShapePoolCurrentInput) return;
      const value = Math.max(Number(wildShapePoolCurrentInput.min || 0), Number(wildShapePoolCurrentInput.value || 0) - 1);
      wildShapePoolCurrentInput.value = String(value);
    });
  }
  if (wildShapePoolIncBtn){
    wildShapePoolIncBtn.addEventListener("click", () => {
      if (!wildShapePoolCurrentInput) return;
      const max = Number(wildShapePoolCurrentInput.max || 0);
      const value = Math.min(max, Number(wildShapePoolCurrentInput.value || 0) + 1);
      wildShapePoolCurrentInput.value = String(value);
    });
  }
  if (wildShapePoolApplyBtn){
    wildShapePoolApplyBtn.addEventListener("click", () => {
      if (!claimedCid || !wildShapePoolCurrentInput) return;
      send({type:"wild_shape_pool_set_current", cid: claimedCid, current: Number(wildShapePoolCurrentInput.value || 0)});
      setWildShapePoolOverlayOpen(false);
      setWildShapeMenuOpen(false);
    });
  }
  if (wildShapePickBackBtn){
    wildShapePickBackBtn.addEventListener("click", () => setWildShapePickOverlayOpen(false));
  }
  if (secondWindCancelBtn){
    secondWindCancelBtn.addEventListener("click", () => setSecondWindOverlayOpen(false));
  }
  if (secondWindUseBtn){
    secondWindUseBtn.addEventListener("click", () => {
      if (!claimedCid) return;
      const rolled = Number(secondWindRollInput?.value ?? "");
      if (!Number.isFinite(rolled) || rolled < 1 || rolled > 10){
        localToast("Enter your Second Wind d10 roll (1-10). Add fighter level automatically.");
        return;
      }
      const msg = {type:"second_wind_use", cid: claimedCid, healing_roll: Math.floor(rolled)};
      if (isPlanning){
        planningMutate(msg);
        draw();
        updateHud();
      }
      send(msg);
      setSecondWindOverlayOpen(false);
    });
  }
  if (monkFocusCloseBtn){
    monkFocusCloseBtn.addEventListener("click", () => setMonkFocusOverlayOpen(false));
  }
  if (resourcePoolDetailCloseBtn){
    resourcePoolDetailCloseBtn.addEventListener("click", () => setResourcePoolDetailOverlayOpen(false));
  }
  if (poolSpellConfirmCancelBtn){
    poolSpellConfirmCancelBtn.addEventListener("click", () => setPoolSpellConfirmModalOpen(false));
  }
  if (poolSpellConfirmCastBtn){
    poolSpellConfirmCastBtn.addEventListener("click", () => {
      if (!pendingPoolSpellConfirm){
        setPoolSpellConfirmModalOpen(false);
        return;
      }
      const pending = {...pendingPoolSpellConfirm};
      setPoolSpellConfirmModalOpen(false);
      castResourcePoolSpell(pending.entry, pending.pool, true);
    });
  }
  if (beguilingMagicCancelBtn){
    beguilingMagicCancelBtn.addEventListener("click", () => {
      setBeguilingMagicModalOpen(false);
      pendingBeguilingMagic = null;
    });
  }
  if (beguilingMagicConfirmBtn){
    beguilingMagicConfirmBtn.addEventListener("click", () => {
      if (!pendingBeguilingMagic){
        pendingBeguilingMagic = {fromPool: false, condition: "charmed"};
      }
      pendingBeguilingMagic.condition = normalizeLowerValue(beguilingMagicConditionInput?.value || "charmed") || "charmed";
      setBeguilingMagicModalOpen(false);
      setAttackOverlayMode(true);
      localToast("Beguiling Magic ready. Select a target within 60 ft.");
    });
  }
  if (commandOptionCancelBtn){
    commandOptionCancelBtn.addEventListener("click", () => {
      clearSpellTargetingSession("Command selection cancelled.");
    });
  }
  if (commandOptionConfirmBtn){
    commandOptionConfirmBtn.addEventListener("click", () => {
      if (!pendingCommandResolution || !pendingSpellTargeting){
        setCommandOptionModalOpen(false);
        return;
      }
      const option = normalizeLowerValue(commandOptionSelect?.value || "approach") || "approach";
      const allowed = ["approach", "drop", "flee", "grovel", "halt"];
      if (!allowed.includes(option)){
        localToast("Pick a valid command option.");
        return;
      }
      if (pendingCommandResolution.castMsg){
        send(pendingCommandResolution.castMsg);
      }
      send({
        type: "command_resolve",
        cid: activeControlledUnitCid(),
        target_cids: pendingCommandResolution.targetCids.slice(),
        command_option: option,
        slot_level: Number(pendingCommandResolution.slotLevel || 1),
        spell_slug: pendingCommandResolution.spellSlug || "command",
        spell_id: pendingCommandResolution.spellId || "command",
      });
      setCommandOptionModalOpen(false);
      clearSpellTargetingSession("Command sent.");
    });
  }
  if (bardicDiceConfirmCancelBtn){
    bardicDiceConfirmCancelBtn.addEventListener("click", () => setBardicDiceConfirmModalOpen(false, null));
  }
  if (bardicDiceConfirmYesBtn){
    bardicDiceConfirmYesBtn.addEventListener("click", () => {
      send({type: "bardic_inspiration_use", cid: activeControlledUnitCid()});
      setBardicDiceConfirmModalOpen(false, null);
    });
  }
  const sendMonkFocusAction = (type, mode) => {
    if (isMapView) return;
    const cid = activeControlledUnitCid();
    if (cid === null){
      localToast("Claim a character first, matey.");
      return;
    }
    const msg = {type, cid, mode};
    if (isPlanning){
      planningMutate(msg);
      draw();
      updateHud();
    }
    send(msg);
    setMonkFocusOverlayOpen(false);
  };
  if (monkPatientDefenseFreeBtn){
    monkPatientDefenseFreeBtn.addEventListener("click", () => sendMonkFocusAction("monk_patient_defense", "free"));
  }
  if (monkPatientDefenseFocusBtn){
    monkPatientDefenseFocusBtn.addEventListener("click", () => sendMonkFocusAction("monk_patient_defense", "focus"));
  }
  if (monkStepOfWindFreeBtn){
    monkStepOfWindFreeBtn.addEventListener("click", () => sendMonkFocusAction("monk_step_of_wind", "free"));
  }
  if (monkStepOfWindFocusBtn){
    monkStepOfWindFocusBtn.addEventListener("click", () => sendMonkFocusAction("monk_step_of_wind", "focus"));
  }
  if (monkElementalAttunementToggleBtn){
    monkElementalAttunementToggleBtn.addEventListener("click", () => {
      const me = getClaimedUnit();
      if (!me){
        localToast("Claim a character first, matey.");
        return;
      }
      const mode = unitHasElementalAttunement(me) ? "deactivate" : "activate";
      sendMonkFocusAction("monk_elemental_attunement", mode);
    });
  }
  if (monkElementalBurstBtn){
    monkElementalBurstBtn.addEventListener("click", () => {
      if (isMapView) return;
      const caster = getClaimedUnit();
      if (!caster){
        localToast("Claim a character first, matey.");
        return;
      }
      setElementalBurstConfigOverlayOpen(true);
    });
  }
  if (elementalBurstConfigCancelBtn){
    elementalBurstConfigCancelBtn.addEventListener("click", () => setElementalBurstConfigOverlayOpen(false));
  }
  if (elementalBurstConfigContinueBtn){
    elementalBurstConfigContinueBtn.addEventListener("click", () => {
      if (isMapView) return;
      const caster = getClaimedUnit();
      if (!caster){
        localToast("Claim a character first, matey.");
        setElementalBurstConfigOverlayOpen(false);
        return;
      }
      const damageType = normalizeLowerValue(elementalBurstDamageTypeInput?.value);
      if (!["acid", "cold", "fire", "lightning", "thunder"].includes(damageType)){
        localToast("Pick a valid Elemental Burst damage type.");
        return;
      }
      const movementModeRaw = normalizeLowerValue(elementalBurstMovementModeInput?.value);
      const movementMode = movementModeRaw === "push" || movementModeRaw === "pull" ? movementModeRaw : null;
      const msg = {
        type: "monk_elemental_burst",
        cid: Number(caster.cid),
        damage_type: damageType,
        movement_mode: movementMode,
        payload: {
          shape: "sphere",
          name: "Elemental Burst",
          radius_ft: 20,
          cx: Number(caster.pos?.col ?? 0),
          cy: Number(caster.pos?.row ?? 0),
          damage_type: damageType,
        },
      };
      setElementalBurstConfigOverlayOpen(false);
      setMonkFocusOverlayOpen(false);
      pendingAoePlacement = {
        msg,
        payload: {...(msg.payload || {})},
        cursor: {col: Number(msg.payload.cx), row: Number(msg.payload.cy)},
        casterPos: toGridPoint(caster.pos),
        casterCid: Number(caster.cid),
        rangeFt: 120,
        castConfirmMessage: "Cast Elemental Burst (2 Focus + 1 Action)?",
        concentrationConfirmMessage: null,
      };
      refreshAoePlacementAimGuide();
      localToast("Elemental Burst placement: move cursor, click to place, then confirm.");
      draw();
    });
  }
  if (monkUncannyMetabolismBtn){
    monkUncannyMetabolismBtn.addEventListener("click", () => sendMonkFocusAction("monk_uncanny_metabolism", ""));
  }
  const startMonkBonusAttackSequence = (sequenceId, totalStrikes, focusCost) => {
    if (isMapView) return;
    const cid = activeControlledUnitCid();
    if (cid === null){
      localToast("Not yer turn yet, matey.");
      return;
    }
    const weapon = getUnarmedStrikeWeapon();
    if (!weapon){
      localToast("No configured unarmed strike found, matey.");
      return;
    }
    const total = Math.max(1, Math.min(10, Number(totalStrikes) || 1));
    pendingMonkBonusAttackSequence = {
      id: String(sequenceId || "martial_arts"),
      totalStrikes: total,
      remainingStrikes: total,
      weapon: {...weapon, resolve_prompt: `${sequenceId === "flurry" ? "Flurry of Blows" : "Martial Arts"}: strike 1/${total}  pick damage or leave blank to auto-roll.`},
      focusCost: Math.max(0, Number(focusCost) || 0),
      started: false,
    };
    pendingActionAttackWeapon = pendingMonkBonusAttackSequence.weapon;
    setMonkFocusOverlayOpen(false);
    setAttackOverlayMode(true);
    localToast("Pick a target for your bonus attack.");
    draw();
  };
  if (monkMartialArtsBonusBtn){
    monkMartialArtsBonusBtn.addEventListener("click", () => {
      startMonkBonusAttackSequence("martial_arts", 1, 0);
    });
  }
  if (monkFlurryOfBlowsBtn){
    monkFlurryOfBlowsBtn.addEventListener("click", () => {
      const profile = getPlayerProfile(getClaimedPlayerName());
      const monkLevel = getMonkLevelFromProfile(profile);
      startMonkBonusAttackSequence("flurry", monkLevel >= 10 ? 3 : 2, 1);
    });
  }
  if (mantleResolveCancelBtn){
    mantleResolveCancelBtn.addEventListener("click", () => {
      setMantleResolveModalOpen(false);
    });
  }
  if (mantleResolveUseBtn){
    mantleResolveUseBtn.addEventListener("click", () => {
      if (!pendingMantleOfInspiration){
        localToast("Pick Mantle targets first.");
        return;
      }
      const targetCids = Array.isArray(pendingMantleOfInspiration.targetCids)
        ? pendingMantleOfInspiration.targetCids.slice()
        : [];
      if (!targetCids.length){
        localToast("Pick at least one target first.");
        return;
      }
      const parsed = Number(mantleResolveDieInput?.value ?? "");
      const dieOverride = Number.isFinite(parsed) && parsed > 0 ? Math.floor(parsed) : null;
      send({
        type: "mantle_of_inspiration",
        cid: activeControlledUnitCid(),
        target_cids: targetCids,
        die_override: dieOverride,
      });
      setMantleResolveModalOpen(false);
      pendingMantleOfInspiration = null;
      renderSpellTargetSelectionUi();
      if (attackOverlayMode){
        setAttackOverlayMode(false);
      }
    });
  }

  if (layOnHandsCancelBtn){
    layOnHandsCancelBtn.addEventListener("click", () => {
      setLayOnHandsOverlayOpen(false);
      pendingLayOnHandsResolve = null;
      pendingLayOnHandsTargeting = null;
      if (attackOverlayMode){
        setAttackOverlayMode(false);
      }
    });
  }
  if (layOnHandsCurePoisonToggle){
    layOnHandsCurePoisonToggle.addEventListener("change", () => {
      const curePoison = !!layOnHandsCurePoisonToggle.checked;
      if (layOnHandsAmountInput){
        layOnHandsAmountInput.disabled = curePoison;
        if (curePoison){
          layOnHandsAmountInput.value = "0";
        } else if (Number(layOnHandsAmountInput.value || 0) <= 0){
          layOnHandsAmountInput.value = "1";
        }
      }
      if (layOnHandsUseBtn){
        layOnHandsUseBtn.textContent = curePoison ? "Cure Poisoned" : "Heal";
      }
    });
  }
  if (layOnHandsUseBtn){
    layOnHandsUseBtn.addEventListener("click", () => {
      if (!claimedCid) return;
      if (!pendingLayOnHandsResolve){
        localToast("Pick a Lay on Hands target first.");
        return;
      }
      const pools = getPlayerResourcePools(getClaimedPlayerName());
      const pool = pools.find((entry) => entry.id === "lay_on_hands");
      const available = Math.max(0, Number(pool?.current || 0));
      const curePoison = !!layOnHandsCurePoisonToggle?.checked;
      const amount = curePoison ? 5 : Math.floor(Number(layOnHandsAmountInput?.value ?? ""));
      if (curePoison){
        if (available < 5){
          localToast("Need at least 5 Lay on Hands points to remove Poisoned.");
          return;
        }
      } else if (!Number.isFinite(amount) || amount <= 0){
        localToast("Enter a valid Lay on Hands healing amount.");
        return;
      }
      if (amount > available){
        localToast("Not enough Lay on Hands points remaining.");
        return;
      }
      const msg = {type:"lay_on_hands_use", cid: claimedCid, target_cid: pendingLayOnHandsResolve.targetCid, amount, cure_poisoned: curePoison};
      if (isPlanning){
        planningMutate(msg);
        draw();
        updateHud();
      }
      send(msg);
      setLayOnHandsOverlayOpen(false);
      pendingLayOnHandsResolve = null;
      pendingLayOnHandsTargeting = null;
      if (attackOverlayMode){
        setAttackOverlayMode(false);
      }
    });
  }
  if (wildShapeBackBtn){
    wildShapeBackBtn.addEventListener("click", () => setWildShapeOverlayOpen(false));
  }
  if (wildShapeSearchInput){
    wildShapeSearchInput.addEventListener("input", () => renderWildShapeOverlay());
  }
  if (wildShapeShowLockedInput){
    wildShapeShowLockedInput.addEventListener("change", () => renderWildShapeOverlay());
  }
  if (wildShapeLeftList){
    wildShapeLeftList.addEventListener("click", (event) => {
      const item = event.target?.closest?.("[data-wildshape-id]");
      if (!item) return;
      const id = String(item.dataset.wildshapeId || "").trim().toLowerCase();
      if (!id) return;
      wildShapeSelectedAvailable = id;
      const entry = wildShapeAllowedMap.get(id);
      if (entry?.allowed === false){
        const reason = wildShapeLockReason(entry);
        if (wildShapeStatusEl) wildShapeStatusEl.textContent = `Locked: ${reason}.`;
      }
      renderWildShapeOverlay();
    });
  }
  if (wildShapeRightList){
    wildShapeRightList.addEventListener("click", (event) => {
      const item = event.target?.closest?.("[data-wildshape-known-id]");
      if (!item) return;
      const id = String(item.dataset.wildshapeKnownId || "").trim().toLowerCase();
      if (!id) return;
      wildShapeSelectedKnown = id;
      renderWildShapeOverlay();
    });
  }
  if (wildShapeAddBtn){
    wildShapeAddBtn.addEventListener("click", () => {
      const {limit} = getWildShapeProfileData();
      if (!wildShapeSelectedAvailable) return;
      const entry = wildShapeAllowedMap.get(wildShapeSelectedAvailable);
      if (entry?.allowed === false){
        localToast(`That form is locked: ${wildShapeLockReason(entry) || "not available"}.`);
        return;
      }
      if (wildShapeKnownDraft.includes(wildShapeSelectedAvailable)) return;
      if (wildShapeKnownDraft.length >= limit){
        localToast("No known form slots remaining.");
        return;
      }
      wildShapeKnownDraft.push(wildShapeSelectedAvailable);
      renderWildShapeOverlay();
    });
  }
  if (wildShapeRemoveBtn){
    wildShapeRemoveBtn.addEventListener("click", () => {
      if (!wildShapeSelectedKnown) return;
      wildShapeKnownDraft = wildShapeKnownDraft.filter((id) => id !== wildShapeSelectedKnown);
      renderWildShapeOverlay();
    });
  }
  if (wildShapeSaveBtn){
    wildShapeSaveBtn.addEventListener("click", () => {
      if (claimedCid == null) return;
      send({type:"wild_shape_set_known", cid: claimedCid, known: wildShapeKnownDraft});
      setWildShapeOverlayOpen(false);
    });
  }
  if (spellbookBackBtn){
    spellbookBackBtn.addEventListener("click", () => {
      openSpellbookOverlay(false);
    });
  }
  if (spellbookBackFloatingBtn){
    spellbookBackFloatingBtn.addEventListener("click", () => {
      openSpellbookOverlay(false);
    });
  }
  if (spellDetailBackBtn){
    spellDetailBackBtn.addEventListener("click", () => {
      closeSpellDetailOverlay();
    });
  }
  if (spellDetailColorInput){
    spellDetailColorInput.addEventListener("input", (event) => {
      const value = String(event.target.value || "");
      updateSpellDetailColorInputs(normalizeHexColor(value) || value);
    });
    spellDetailColorInput.addEventListener("change", (event) => {
      commitSpellDetailColor(event.target.value || "");
    });
  }
  if (spellDetailColorValue){
    spellDetailColorValue.addEventListener("change", (event) => {
      commitSpellDetailColor(event.target.value || "");
    });
  }
  if (spellbookTabKnown){
    spellbookTabKnown.addEventListener("click", () => {
      spellbookMode = "known";
      resetSpellbookSelections();
      renderSpellbook();
    });
  }
  if (spellbookTabPrepared){
    spellbookTabPrepared.addEventListener("click", () => {
      spellbookMode = "prepared";
      resetSpellbookSelections();
      renderSpellbook();
    });
  }
  if (spellbookKnownEnabledToggle){
    spellbookKnownEnabledToggle.addEventListener("change", (event) => {
      spellbookKnownEnabled = !!event.target.checked;
      if (!spellbookKnownEnabled){
        spellbookMode = "prepared";
      }
      resetSpellbookSelections();
      renderSpellbook();
    });
  }
  if (spellbookSearchInput){
    spellbookSearchInput.addEventListener("input", (event) => {
      spellbookSearchTerm = String(event.target.value || "");
      renderSpellbook();
    });
  }
  if (spellbookSortSelect){
    spellbookSortSelect.addEventListener("change", (event) => {
      spellbookSortMode = String(event.target.value || "alpha");
      renderSpellbook();
    });
  }
  if (spellbookAddBtn){
    spellbookAddBtn.addEventListener("click", () => {
      applySpellbookAdd();
    });
  }
  if (spellbookRemoveBtn){
    spellbookRemoveBtn.addEventListener("click", () => {
      applySpellbookRemove();
    });
  }
  if (spellbookSaveBtn){
    spellbookSaveBtn.addEventListener("click", () => {
      showSpellbookConfirm();
    });
  }
  if (spellbookConfirmCancel){
    spellbookConfirmCancel.addEventListener("click", () => {
      hideSpellbookConfirm();
    });
  }
  if (spellbookConfirmYes){
    spellbookConfirmYes.addEventListener("click", () => {
      saveSpellbookChanges();
    });
  }
  if (spellbookConfirmModal){
    spellbookConfirmModal.addEventListener("click", (event) => {
      if (event.target === spellbookConfirmModal){
        hideSpellbookConfirm();
      }
    });
  }
  if (mapViewTurnOrderEl){
    mapViewTurnOrderEl.addEventListener("click", (event) => {
      const chip = event.target.closest(".turn-chip");
      const chipCid = normalizeCid(chip?.dataset?.cid, "turnOrder.click.cid");
      if (chipCid !== null && canSelectControlledUnitCid(chipCid)){
        selectedTurnCid = chipCid;
        const unit = getUnitByCid(chipCid);
        if (unit?.name && unitControllableThisTurn(chipCid)){
          localToast(`Controlling ${unit.name}.`);
        }
        updateTurnOrder();
        updateHud();
        draw();
        return;
      }
    });
  }

  if (connEl && connPopoverEl){
    connEl.addEventListener("click", (event) => {
      event.stopPropagation();
      const isOpen = connPopoverEl.classList.contains("show");
      setConnPopover(!isOpen);
    });
  }
  if (connReconnectBtn){
    connReconnectBtn.addEventListener("click", () => {
      softReconnect();
    });
  }
  document.addEventListener("click", (event) => {
    if (!connPopoverEl || !connEl) return;
    if (connPopoverEl.contains(event.target) || connEl.contains(event.target)) return;
    closeConnPopover();
  });

  function cancelEscapeInteractionState(){
    if (pendingAoePlacement){
      clearPendingAoePlacement();
      localToast("AoE placement cancelled.");
      return true;
    }
    if (pendingSummonPlacement){
      clearSummonPlacementState();
      draw();
      localToast("Summon placement cancelled.");
      return true;
    }
    if (pendingSpellTargeting || pendingSpellTargetSelection || pendingPolymorphSelection || pendingMantleOfInspiration || pendingCommandResolution){
      clearSpellTargetingSession("Spell targeting cancelled.");
      return true;
    }
    if (pendingAttackResolve){
      setAttackResolveModalOpen(false);
      localToast("Attack cancelled.");
      return true;
    }
    const hasAttackTargetingContext = attackOverlayMode
      || pendingLayOnHandsTargeting
      || pendingLayOnHandsResolve
      || pendingBardicInspirationTargeting
      || pendingBeguilingMagic
      || pendingActionAttackWeapon
      || pendingUnleashIncarnation
      || pendingMonkBonusAttackSequence
      || pendingOpportunityAttack
      || pendingReactionRequestId;
    if (hasAttackTargetingContext){
      pendingLayOnHandsTargeting = null;
      pendingLayOnHandsResolve = null;
      pendingBardicInspirationTargeting = null;
      setLayOnHandsOverlayOpen(false);
      setAttackOverlayMode(false);
      localToast("Targeting cancelled.");
      return true;
    }
    return false;
  }

  document.addEventListener("keydown", (event) => {
    if (event.key === "Escape"){
      if (cancelEscapeInteractionState()){
        return;
      }
      if (spellbookConfirmModal?.classList.contains("show")){
        hideSpellbookConfirm();
        return;
      }
      if (castSpellModal?.classList.contains("show")){
        hideCastSpellModal();
        return;
      }
      if (helpModal?.classList.contains("show")){
        hideHelpModal();
        return;
      }
      if (spellLibraryOverlay?.classList.contains("show")){
        openSpellLibraryOverlay(false);
        return;
      }
      if (spellDetailOverlay?.classList.contains("show")){
        closeSpellDetailOverlay();
        return;
      }
      if (spellbookOverlay?.classList.contains("show")){
        openSpellbookOverlay(false);
        return;
      }
      if (castOverlay?.classList.contains("show")){
        setCastOverlayOpen(false);
        return;
      }
      closeConnPopover();
    }
  });
  document.addEventListener("keydown", (event) => {
    if (isShiftKey(event)){
      shiftMoveMode = true;
      draw();
    }
  });
  document.addEventListener("keyup", (event) => {
    if (isShiftKey(event)){
      shiftMoveMode = false;
      draw();
    }
  });
  if (toggleTopbarTitle){
    toggleTopbarTitle.addEventListener("change", (event) => {
      showTopbarTitle = !!event.target.checked;
      persistToggle(uiToggleKeys.topbarTitle, showTopbarTitle);
      applyUiConfig();
    });
  }
  if (toggleConnIndicator){
    toggleConnIndicator.addEventListener("change", (event) => {
      showConnIndicator = !!event.target.checked;
      persistToggle(uiToggleKeys.connIndicator, showConnIndicator);
      applyUiConfig();
    });
  }
  if (connStyleButtons.length){
    connStyleButtons.forEach((button) => {
      button.addEventListener("click", () => {
        const nextStyle = button.dataset.connStyle === "compact" ? "compact" : "full";
        if (connStyle === nextStyle) return;
        connStyle = nextStyle;
        persistChoice(uiSelectKeys.connStyle, connStyle);
        applyUiConfig();
      });
    });
  }
  if (toggleLockMap){
    toggleLockMap.addEventListener("change", (event) => {
      showLockMap = !!event.target.checked;
      persistToggle(uiToggleKeys.lockMap, showLockMap);
      applyUiConfig();
    });
  }
  if (toggleCenterMap){
    toggleCenterMap.addEventListener("change", (event) => {
      showCenterMap = !!event.target.checked;
      persistToggle(uiToggleKeys.centerMap, showCenterMap);
      applyUiConfig();
    });
  }
  if (toggleMeasure){
    toggleMeasure.addEventListener("change", (event) => {
      showMeasure = !!event.target.checked;
      persistToggle(uiToggleKeys.measure, showMeasure);
      applyUiConfig();
    });
  }
  if (toggleMeasureClear){
    toggleMeasureClear.addEventListener("change", (event) => {
      showMeasureClear = !!event.target.checked;
      persistToggle(uiToggleKeys.measureClear, showMeasureClear);
      applyUiConfig();
    });
  }
  if (toggleZoomIn){
    toggleZoomIn.addEventListener("change", (event) => {
      showZoomIn = !!event.target.checked;
      persistToggle(uiToggleKeys.zoomIn, showZoomIn);
      applyUiConfig();
    });
  }
  if (toggleZoomOut){
    toggleZoomOut.addEventListener("change", (event) => {
      showZoomOut = !!event.target.checked;
      persistToggle(uiToggleKeys.zoomOut, showZoomOut);
      applyUiConfig();
    });
  }
  if (toggleBattleLog){
    toggleBattleLog.addEventListener("change", (event) => {
      showBattleLog = !!event.target.checked;
      persistToggle(uiToggleKeys.battleLog, showBattleLog);
      applyUiConfig();
    });
  }
  if (initiativeStyleSelect){
    initiativeStyleSelect.addEventListener("change", (event) => {
      const value = event.target.value;
      initiativeStyle = ["full", "compact", "hidden"].includes(value) ? value : "full";
      persistChoice(uiSelectKeys.initiativeStyle, initiativeStyle);
      applyUiConfig();
    });
  }
  if (toggleUseAction){
    toggleUseAction.addEventListener("change", (event) => {
      showUseAction = !!event.target.checked;
      persistToggle(uiToggleKeys.useAction, showUseAction);
      applyUiConfig();
    });
  }
  if (toggleUseBonusAction){
    toggleUseBonusAction.addEventListener("change", (event) => {
      showUseBonusAction = !!event.target.checked;
      persistToggle(uiToggleKeys.useBonusAction, showUseBonusAction);
      applyUiConfig();
    });
  }
  if (toggleDash){
    toggleDash.addEventListener("change", (event) => {
      showDash = !!event.target.checked;
      persistToggle(uiToggleKeys.dash, showDash);
      applyUiConfig();
    });
  }
  if (toggleStandUp){
    toggleStandUp.addEventListener("change", (event) => {
      showStandUp = !!event.target.checked;
      persistToggle(uiToggleKeys.standUp, showStandUp);
      applyUiConfig();
    });
  }
  if (toggleResetTurn){
    toggleResetTurn.addEventListener("change", (event) => {
      showResetTurn = !!event.target.checked;
      persistToggle(uiToggleKeys.resetTurn, showResetTurn);
      applyUiConfig();
    });
  }
  if (toggleSpellMenu){
    toggleSpellMenu.addEventListener("change", (event) => {
      hideSpellMenu = !!event.target.checked;
      persistToggle(uiToggleKeys.hideSpellMenu, hideSpellMenu);
      applyUiConfig();
    });
  }
  if (toggleLockMenus){
    toggleLockMenus.addEventListener("change", (event) => {
      menusLocked = !!event.target.checked;
      persistToggle(uiToggleKeys.lockMenus, menusLocked);
      applyUiConfig();
    });
  }
  Object.entries(hotkeyConfig).forEach(([action, config]) => {
    if (!config || !config.input) return;
    config.input.addEventListener("keydown", (event) => {
      event.preventDefault();
      if (event.key === "Escape"){
        config.input.blur();
        return;
      }
      if (event.key === "Backspace" || event.key === "Delete"){
        setHotkey(action, "");
        return;
      }
      const combo = normalizeHotkeyEvent(event);
      if (!combo) return;
      setHotkey(action, combo);
    });
    config.input.addEventListener("focus", () => {
      config.input.select();
    });
  });
  if (attackOverlayToggleBtn){
    attackOverlayToggleBtn.addEventListener("click", () => {
      if (pendingSpellTargeting && attackOverlayMode){
        pendingMantleOfInspiration = null;
      setMantleResolveModalOpen(false);
      clearSpellTargetingSession("Targeting cancelled.");
        return;
      }
      if (attackOverlayMode){
        setAttackOverlayMode(false);
        return;
      }
      const controlledCid = activeControlledUnitCid();
      const controlled = controlledCid === null ? null : getUnitByCid(controlledCid);
      const claimed = getClaimedUnit();
      const isOwnedSummon = !!controlled && !!claimed
        && !cidMatches(controlled.cid, claimed.cid, "attack.summon.notClaimed")
        && cidMatches(controlled.summoned_by_cid, claimed.cid, "attack.summon.owner");
      const isMounted = normalizeCid(controlled?.mounted_by_cid, "attack.summon.mountedBy") !== null;
      if (isOwnedSummon && !isMounted){
        const options = summonAttackOptionsForUnit(controlled);
        if (!options.length){
          localToast("This summon has no attack actions.");
          return;
        }
        const selected = chooseSummonAttackOption(options);
        if (!selected){
          localToast("No summon attack selected.");
          return;
        }
        pendingActionAttackWeapon = {
          ...selected.weapon,
          resolve_prompt: String(selected.entry?.resolve_prompt || `Attack target with ${selected.weapon.name}.`).trim(),
          attack_count: Number.isFinite(Number(selected.entry?.attack_count))
            ? Math.max(1, Math.floor(Number(selected.entry.attack_count)))
            : Number(selected.weapon.attack_count || 1),
        };
        setAttackOverlayMode(true);
        localToast(pendingActionAttackWeapon.resolve_prompt || `Pick a target for ${selected.weapon.name}.`);
        return;
      }
      setAttackOverlayMode(true);
    });
  }
  if (polymorphFormSearchInput){
    polymorphFormSearchInput.addEventListener("input", () => {
      renderPolymorphFormList();
    });
  }
  if (polymorphFormCancelBtn){
    polymorphFormCancelBtn.addEventListener("click", () => {
      pendingPolymorphSelection = null;
      clearSpellTargetingSession("Polymorph cancelled.");
    });
  }
  if (spellTargetSelectionRemoveLastBtn){
    spellTargetSelectionRemoveLastBtn.addEventListener("click", () => {
      if (pendingSpellTargetSelection){
        pendingSpellTargetSelection.selectedTargets.pop();
      } else if (pendingMantleOfInspiration){
        pendingMantleOfInspiration.targetCids.pop();
      } else {
        return;
      }
      renderSpellTargetSelectionUi();
    });
  }
  if (spellTargetSelectionCancelBtn){
    spellTargetSelectionCancelBtn.addEventListener("click", () => {
      clearSpellTargetingSession("Spell targeting cancelled.");
    });
  }
  if (spellTargetSelectionConfirmBtn){
    spellTargetSelectionConfirmBtn.addEventListener("click", () => {
      if (pendingMantleOfInspiration){
        const selectedMantle = Array.isArray(pendingMantleOfInspiration.targetCids) ? pendingMantleOfInspiration.targetCids : [];
        if (!selectedMantle.length){
          localToast("Pick at least one target first.");
          return;
        }
        setMantleResolveModalOpen(true);
        return;
      }
      if (!pendingSpellTargetSelection || !pendingSpellTargeting){
        return;
      }
      const selected = pendingSpellTargetSelection.selectedTargets || [];
      if (!selected.length){
        localToast("Pick at least one target first.");
        return;
      }
      const castMsg = pendingSpellTargetSelection.castMsg;
      const castConfirmMessage = castMsg ? `Cast ${pendingSpellTargeting.spellName}?` : null;
      if (castConfirmMessage && !window.confirm(castConfirmMessage)){
        return;
      }
      const unit = getClaimedUnit();
      const concentrationSpell = normalizeTextValue(unit?.concentration_spell || unit?.concentrationSpell || "");
      if (castMsg && unit?.concentrating && concentrationSpell){
        if (!window.confirm(`You're concentrating on ${concentrationSpell}. Casting ${pendingSpellTargeting.spellName} will end it. Continue?`)){
          return;
        }
      }
      if (isCommandSpellTargeting()){
        pendingSpellTargetSelection = null;
        renderSpellTargetSelectionUi();
        queueCommandResolution(selected.slice(), castMsg || null);
        return;
      }
      if (castMsg){
        send(castMsg);
      }
      pendingSpellTargeting.queue = selected.slice();
      pendingSpellTargeting.remainingShots = selected.length;
      pendingSpellTargetSelection = null;
      renderSpellTargetSelectionUi();
      processNextSpellTarget();
    });
  }
  if (mainhandWeaponSelectEl){
    mainhandWeaponSelectEl.addEventListener("change", (event) => {
      selectedMainhandWeaponValue = String(event.target.value || "").trim();
      refreshWeaponSelectors();
      draw();
    });
  }
  if (offhandWeaponSelectEl){
    offhandWeaponSelectEl.addEventListener("change", (event) => {
      selectedOffhandWeaponValue = String(event.target.value || "").trim();
      cachedOffhandWeaponValue = selectedOffhandWeaponValue;
      saveCurrentWeaponSelections();
      draw();
    });
  }
  if (useActionBtn){
    useActionBtn.addEventListener("click", () => {
      if (isMapView) return;
      if (!claimedCid) return;
      openActionPicker("action");
    });
  }
  useBonusActionBtn.addEventListener("click", () => {
    if (isMapView) return;
    if (!claimedCid) return;
    openActionPicker("bonus");
  });
  if (useReactionBtn){
    useReactionBtn.addEventListener("click", () => {
      if (isMapView) return;
      if (!claimedCid) return;
      sendReactionPrefsUpdate();
      openActionPicker("reaction");
    });
  }
  if (reactionOfferDecline){
    reactionOfferDecline.addEventListener("click", () => {
      send({type:"reaction_response", cid: claimedCid, request_id: pendingReactionRequestId, choice:"decline"});
      pendingReactionRequestId = "";
      if (reactionOfferModal){ reactionOfferModal.classList.remove("show"); reactionOfferModal.setAttribute("aria-hidden", "true"); }
    });
  }
  if (warCasterCancelBtn){
    warCasterCancelBtn.addEventListener("click", () => {
      pendingReactionRequestId = "";
      setWarCasterModalOpen(false);
    });
  }
  if (warCasterCastBtn){
    warCasterCastBtn.addEventListener("click", () => {
      const spellSlug = normalizeTextValue(warCasterSpellSelect?.value);
      const targetCid = normalizeCid(warCasterTargetSelect?.value, "warCaster.target");
      if (!spellSlug || targetCid === null){
        localToast("Pick a spell and target first.");
        return;
      }
      const preset = spellPresetBySlug.get(getSpellKey(spellSlug))
        || cachedSpellPresets.find((entry) => getSpellKey(getPresetSlug(entry)) === getSpellKey(spellSlug));
      if (!preset){
        localToast("Could not find that spell preset, matey.");
        return;
      }
      const unit = getClaimedUnit();
      const actionCheck = canSpendSpellAction(unit, "reaction");
      if (!actionCheck.ok){
        localToast(actionCheck.reason || "Cannot cast that reaction right now.");
        return;
      }
      applySpellPreset(preset);
      const slotCheck = validateCastSlotSelection(preset, true);
      if (!slotCheck.ok){
        return;
      }
      const slotLevel = Number.isFinite(slotCheck.slotLevel) ? Math.floor(Number(slotCheck.slotLevel)) : null;
      const payload = {action_type: "reaction", name: normalizeTextValue(preset.name) || "Spell"};
      if (slotCheck.consumesPool){
        payload.consumes_pool = {id: slotCheck.consumesPool.id, cost: slotCheck.consumesPool.cost};
      }
      const msg = {
        type: "cast_spell",
        reaction_request_id: pendingReactionRequestId || undefined,
        payload,
        action_type: "reaction",
        spell_slug: normalizeTextValue(getPresetSlug(preset)) || null,
        spell_id: normalizeTextValue(preset.id) || null,
      };
      if (Number.isFinite(slotLevel)){
        msg.slot_level = slotLevel;
      }
      if (slotCheck.consumesPool){
        msg.consumes_pool_id = slotCheck.consumesPool.id;
        msg.consumes_pool_cost = slotCheck.consumesPool.cost;
      }
      send(msg);
      const config = getSpellTargetingConfig(preset, slotLevel);
      if (config){
        startSpellTargetingSession(config, preset, slotLevel);
        const target = getUnitByCid(targetCid);
        runSpellTargetingAgainstTarget(target);
      }
      setWarCasterModalOpen(false);
    });
  }
  if (standUpBtn){
    standUpBtn.addEventListener("click", () => {
      if (isMapView) return;
      if (!claimedCid) return;
      const msg = {type:"stand_up", cid: claimedCid};
      if (isPlanning){
        planningMutate(msg);
        draw();
        updateHud();
      }
      send(msg);
    });
  }
  if (resetTurnBtn){
    resetTurnBtn.addEventListener("click", () => {
      if (isMapView) return;
      if (!claimedCid) return;
      const msg = {type:"reset_turn", cid: claimedCid};
      if (isPlanning){
        planningMutate(msg);
        draw();
        updateHud();
      }
      send(msg);
    });
  }

  if (mountBtn){
    mountBtn.addEventListener("click", () => {
      const pair = pendingMountPair || mountCandidatePair();
      if (!pair) return;
      send({type:"mount_request", rider_cid:Number(pair.rider.cid), mount_cid:Number(pair.mount.cid)});
    });
  }
  if (dismountBtn){
    dismountBtn.addEventListener("click", () => send({type:"dismount"}));
  }
  if (mountPromptYes){
    mountPromptYes.addEventListener("click", () => {
      send({type:"mount_response", request_id: pendingMountRequestId, accept:true});
      if (mountPromptModal){ mountPromptModal.classList.remove("show"); mountPromptModal.setAttribute("aria-hidden", "true"); }
    });
  }
  if (mountPromptNo){
    mountPromptNo.addEventListener("click", () => {
      send({type:"mount_response", request_id: pendingMountRequestId, accept:false});
      if (mountPromptModal){ mountPromptModal.classList.remove("show"); mountPromptModal.setAttribute("aria-hidden", "true"); }
    });
  }
  if (echoTetherPromptYes){
    echoTetherPromptYes.addEventListener("click", () => {
      send({type:"echo_tether_response", request_id: pendingEchoTetherRequestId, accept:true});
      if (echoTetherPromptModal){ echoTetherPromptModal.classList.remove("show"); echoTetherPromptModal.setAttribute("aria-hidden", "true"); }
    });
  }
  if (echoTetherPromptNo){
    echoTetherPromptNo.addEventListener("click", () => {
      send({type:"echo_tether_response", request_id: pendingEchoTetherRequestId, accept:false});
      if (echoTetherPromptModal){ echoTetherPromptModal.classList.remove("show"); echoTetherPromptModal.setAttribute("aria-hidden", "true"); }
    });
  }

  function submitInitiativePrompt(){
    const raw = initiativePromptInput ? String(initiativePromptInput.value || "").trim() : "";
    const total = Number(raw);
    if (!raw || !Number.isFinite(total)){
      localToast("Enter a valid initiative total.");
      return;
    }
    const cid = Number.isFinite(Number(pendingInitiativeCid)) ? Number(pendingInitiativeCid) : Number(claimedCid);
    if (!Number.isFinite(cid)){
      localToast("No claimed character to update.");
      return;
    }
    send({type:"initiative_roll", cid, initiative: Math.trunc(total)});
    if (initiativePromptModal){
      initiativePromptModal.classList.remove("show");
      initiativePromptModal.setAttribute("aria-hidden", "true");
    }
    pendingInitiativeCid = null;
  }

  if (initiativePromptSubmit){
    initiativePromptSubmit.addEventListener("click", () => submitInitiativePrompt());
  }
  if (initiativePromptCancel){
    initiativePromptCancel.addEventListener("click", () => {
      if (initiativePromptModal){
        initiativePromptModal.classList.remove("show");
        initiativePromptModal.setAttribute("aria-hidden", "true");
      }
      pendingInitiativeCid = null;
    });
  }
  if (initiativePromptInput){
    initiativePromptInput.addEventListener("keydown", (event) => {
      if (event.key === "Enter"){
        event.preventDefault();
        submitInitiativePrompt();
      }
    });
  }
  if (attackResolveMiss){
    attackResolveMiss.addEventListener("change", () => {
      syncAttackResolveDamageVisibility();
    });
  }
  if (attackResolveHit){
    attackResolveHit.addEventListener("change", () => {
      syncAttackResolveDamageVisibility();
    });
  }
  if (attackDamageAdd){
    attackDamageAdd.addEventListener("click", () => addAttackDamageRow());
  }
  if (attackResolveCancel){
    attackResolveCancel.addEventListener("click", () => setAttackResolveModalOpen(false));
  }
  if (spellResolveAddDamage){
    spellResolveAddDamage.addEventListener("click", () => addDamageRow(spellResolveDamageRows));
  }
  if (spellResolveCancel){
    spellResolveCancel.addEventListener("click", () => setSpellResolveModalOpen(false));
  }
  if (spellResolveSubmit){
    spellResolveSubmit.addEventListener("click", () => {
      const pending = pendingSpellResolve;
      const {entries: damageEntries, invalidCount} = collectDamageEntriesFromRows(spellResolveDamageRows);
      if (invalidCount > 0){
        localToast("Invalid manual damage ignored; auto-roll used.");
      }
      setSpellResolveModalOpen(false);
      if (pending && typeof pending.onConfirm === "function"){
        pending.onConfirm(damageEntries);
      }
    });
  }
  if (sculptSelectCancel){
    sculptSelectCancel.addEventListener("click", () => setSculptSelectModalOpen(false));
  }
  if (sculptSelectConfirm){
    sculptSelectConfirm.addEventListener("click", () => {
      if (!pendingSculptSelect){
        setSculptSelectModalOpen(false);
        return;
      }
      const selected = Array.from(pendingSculptSelect.selected.values())
        .map((value) => Number(value))
        .filter((value) => Number.isFinite(value));
      if (selected.length > Number(pendingSculptSelect.maxSelections || 1)){
        localToast("Too many allies selected for Sculpt Spells.");
        return;
      }
      const onConfirm = pendingSculptSelect.onConfirm;
      setSculptSelectModalOpen(false);
      if (typeof onConfirm === "function"){
        onConfirm(selected);
      }
    });
  }
  if (cleavePromptCancel){
    cleavePromptCancel.addEventListener("click", () => setCleavePromptOpen(false));
  }
  if (attackResolveSubmit){
    attackResolveSubmit.addEventListener("click", () => {
      if (!pendingAttackResolve){
        setAttackResolveModalOpen(false);
        return;
      }
      const hit = !(attackResolveMiss && attackResolveMiss.checked);
      const critical = hit && !!(attackResolveCrit && attackResolveCrit.checked);
      const damageParseResult = hit ? collectDamageEntriesFromRows(attackDamageRows) : {entries: [], invalidCount: 0};
      const damageEntries = damageParseResult.entries;
      if (hit && damageParseResult.invalidCount > 0){
        localToast("Invalid manual damage ignored; auto-roll used.");
      }
      const actionCid = pendingAttackResolve.opportunityAttack ? normalizeCid(claimedCid, "attackResolve.opportunityCid") : activeControlledUnitCid();
      if (actionCid === null){
        localToast("Not yer turn yet, matey.");
        setAttackResolveModalOpen(false);
        return;
      }
      if (pendingAttackResolve.mode === "spell"){
        send({
          type: "spell_target_request",
          cid: actionCid,
          target_cid: Number(pendingAttackResolve.targetCid),
          spell_name: String(pendingAttackResolve.spellName || "").trim(),
          spell_slug: pendingAttackResolve.spellSlug || null,
          spell_id: pendingAttackResolve.spellId || null,
          spell_mode: String(pendingAttackResolve.spellMode || "attack"),
          save_type: pendingAttackResolve.saveType || null,
          save_dc: Number.isFinite(Number(pendingAttackResolve.saveDc)) ? Number(pendingAttackResolve.saveDc) : null,
          roll_save: !!pendingAttackResolve.rollSave,
          hit: pendingAttackResolve.forceHit ? true : hit,
          critical,
          damage_entries: damageEntries,
          damage_dice: String(pendingAttackResolve.damageDice || "").trim() || null,
          damage_type: String(pendingAttackResolve.damageType || "").trim().toLowerCase() || null,
        });
      } else {
        const monkSeq = pendingMonkBonusAttackSequence && typeof pendingMonkBonusAttackSequence === "object"
          ? pendingMonkBonusAttackSequence
          : null;
        const isSeqStart = !!(monkSeq && !monkSeq.started);
        const attackMsg = {
          type: "attack_request",
          cid: actionCid,
          target_cid: Number(pendingAttackResolve.targetCid),
          weapon_id: String(pendingAttackResolve.weaponId || "").trim(),
          weapon_name: String(pendingAttackResolve.weaponName || "").trim(),
          weapon: pendingAttackResolve.weapon && typeof pendingAttackResolve.weapon === "object" ? {...pendingAttackResolve.weapon} : null,
          attack_count: Number.isFinite(Number(pendingAttackResolve.attackCount)) ? Math.max(1, Math.floor(Number(pendingAttackResolve.attackCount))) : null,
          mastery_free_attack: pendingAttackResolve.masteryFreeAttack || null,
          opportunity_attack: !!pendingAttackResolve.opportunityAttack,
          consumes_pool: pendingAttackResolve.consumesPool && typeof pendingAttackResolve.consumesPool === "object"
            ? {
              id: pendingAttackResolve.consumesPool.poolId,
              label: pendingAttackResolve.consumesPool.poolLabel,
              cost: Number.isFinite(Number(pendingAttackResolve.consumesPool.cost)) ? Math.max(1, Math.floor(Number(pendingAttackResolve.consumesPool.cost))) : 1,
            }
            : null,
          hit: hit,
          critical,
          attack_origin_cid: pendingUnleashIncarnation ? Number(pendingUnleashIncarnation.echoCid) : Number(actionCid),
          damage_entries: damageEntries,
          damage_type_override: (pendingAttackResolve.elementalOverrideAllowed && attackDamageTypeOverrideSelect)
            ? String(attackDamageTypeOverrideSelect.value || "").trim().toLowerCase() || null
            : null,
          stunning_strike: !!(hit && pendingAttackResolve.stunningStrikeAllowed && attackStunningStrike?.checked),
          tactical_master_property: (pendingAttackResolve.tacticalMasterAllowed && attackTacticalMasterSelect)
            ? String(attackTacticalMasterSelect.value || "").trim().toLowerCase() || null
            : null,
        };
        if (monkSeq){
          attackMsg.attack_spend = "bonus";
          attackMsg.bonus_sequence_id = monkSeq.id;
          attackMsg.bonus_sequence_total = monkSeq.totalStrikes;
          attackMsg.bonus_sequence_start = isSeqStart;
          if (isSeqStart && monkSeq.focusCost > 0){
            attackMsg.consumes_pool = {id: "focus_points", label: "Focus Points", cost: monkSeq.focusCost};
            attackMsg.consumes_pool_always = true;
          }
        }
        send(attackMsg);
        if (monkSeq){
          monkSeq.started = true;
          monkSeq.remainingStrikes = Math.max(0, Number(monkSeq.remainingStrikes || 0) - 1);
          if (monkSeq.remainingStrikes > 0){
            const nextStrike = monkSeq.totalStrikes - monkSeq.remainingStrikes + 1;
            const label = monkSeq.id === "flurry" ? "Flurry of Blows" : "Martial Arts";
            const nextPrompt = `${label}: strike ${nextStrike}/${monkSeq.totalStrikes}  pick damage or leave blank to auto-roll.`;
            monkSeq.weapon = {...(monkSeq.weapon || {}), resolve_prompt: nextPrompt};
            pendingActionAttackWeapon = monkSeq.weapon;
            localToast(`${monkSeq.remainingStrikes} strike${monkSeq.remainingStrikes === 1 ? "" : "s"} remaining.`);
          } else {
            pendingMonkBonusAttackSequence = null;
            setAttackOverlayMode(false);
          }
        } else {
          setAttackOverlayMode(false);
        }
      }
      setAttackResolveModalOpen(false);
    });
  }

  const handleEndTurn = () => {
    if (isMapView) return;
    if (!claimedCid){
      localToast("Claim a character first, matey.");
      return;
    }
    const endTurnCid = activeControlledUnitCid();
    if (endTurnCid === null){
      localToast("Not yer turn yet, matey.");
      updateEndTurnState();
      return;
    }
    send({type:"end_turn", cid: endTurnCid});
  };
  if (endTurnBtn){
    endTurnBtn.addEventListener("click", handleEndTurn);
  }
  if (endTurnSheetBtn){
    endTurnSheetBtn.addEventListener("click", handleEndTurn);
  }
  if (dismissSummonsBtn){
    dismissSummonsBtn.addEventListener("click", () => {
      if (isMapView) return;
      if (!isPlanning && !claimedCid){
        localToast("Claim a character first, matey.");
        return;
      }
      const summonedUnits = Array.isArray(state?.units)
        ? state.units.filter(u => cidMatches(u?.summoned_by_cid, claimedCid, "dismissSummons.owner"))
        : [];
      if (!summonedUnits.length){
        localToast("Ye have no summons to dismiss.");
        return;
      }
      const summonList = summonedUnits.map(u => `- ${u?.name || `#${u?.cid ?? "?"}`}`).join("\n");
      const confirmed = window.confirm(
        `Are ye sure ye want to dismiss these summons?\n${summonList}`
      );
      if (!confirmed) return;
      send({type:"dismiss_summons", target_caster_cid: claimedCid, cid: claimedCid});
    });
  }
  if (moveEl){
    moveEl.addEventListener("click", () => {
      if (isMapView) return;
      if (!isPlanning && !claimedCid){
        localToast("Claim a character first, matey.");
        return;
      }
      send({type:"cycle_movement_mode", cid: claimedCid});
    });
  }
  if (toggleSheetPanelBtn){
    toggleSheetPanelBtn.addEventListener("click", () => {
      setSheetPanelHidden(!sheetPanelHidden);
    });
  }
  if (turnModalOk){
    turnModalOk.addEventListener("click", () => {
      handleUserGesture();
      hideTurnModal();
    });
  }

  document.addEventListener("keydown", (event) => {
    const direction = panDirectionFromKeyboardEvent(event);
    if (!direction || !canKeyboardPan(event)) return;
    const normalizedCode = normalizedPanCodeFromKeyboardEvent(event);
    if (!normalizedCode) return;
    const wasHeld = panHeldKeys.has(normalizedCode);
    panHeldKeys.add(normalizedCode);
    event.preventDefault();
    if (!event.repeat && !wasHeld){
      nudgeKeyboardPan(direction);
    }
    ensureKeyboardPanLoop();
  });

  document.addEventListener("keyup", (event) => {
    const direction = panDirectionFromKeyboardEvent(event);
    if (!direction) return;
    const normalizedCode = normalizedPanCodeFromKeyboardEvent(event);
    if (!normalizedCode) return;
    panHeldKeys.delete(normalizedCode);
    event.preventDefault();
    if (!panHeldKeys.size){
      ensureKeyboardPanLoop();
    }
  });

  window.addEventListener("blur", () => {
    clearKeyboardPanState();
  });

  document.addEventListener("keydown", (event) => {
    if (event.defaultPrevented) return;
    if (isTypingTarget(event.target)) return;
    const combo = normalizeHotkeyEvent(event);
    if (!combo) return;
    const action = hotkeyBindings.get(combo);
    if (!action) return;
    event.preventDefault();
    const config = hotkeyConfig[action];
    if (config && typeof config.action === "function"){
      config.action();
    }
  });
  document.addEventListener("pointerdown", handleUserGesture, {passive: true});
  document.addEventListener("keydown", handleUserGesture);

  clearReservedHotkeysFromStorage();
  updateHotkeyInputs();

  const mapWrap = document.querySelector(".mapWrap");
  if (mapWrap && window.ResizeObserver){
    const ro = new ResizeObserver(() => resize());
    ro.observe(mapWrap);
  }
  resize();
  updateMeasurementControls();
  updateWaitingOverlay();
  setAttackOverlayMode(false);

  if (toggleDmLogPanelInput){
    toggleDmLogPanelInput.checked = dmUiPrefs.showLogPanel === true;
    toggleDmLogPanelInput.addEventListener('change', ()=>{ dmUiPrefs.showLogPanel = toggleDmLogPanelInput.checked; saveDmUiPrefs(); renderDmLogPanel(); });
  }
  if (toggleDmMapPreviewInput){
    toggleDmMapPreviewInput.checked = dmUiPrefs.showMapPreview === true;
    toggleDmMapPreviewInput.addEventListener('change', ()=>{ dmUiPrefs.showMapPreview = toggleDmMapPreviewInput.checked; saveDmUiPrefs(); renderDmLogPanel(); renderDmPreview(); });
  }

  setInterval(() => {
    if (!state || !claimedCid) return;
    renderResourcePools();
  }, 1000);

  connect();
})();
</script>
</body>
</html>
"""
