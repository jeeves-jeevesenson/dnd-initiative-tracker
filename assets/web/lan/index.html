<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <meta name="apple-mobile-web-app-title" content="InitTracker LAN" />
  <link rel="apple-touch-icon" href="/assets/graphic.png" />
  <link rel="icon" href="/assets/icon.ico" sizes="any" />
  <link rel="manifest" href="/assets/manifest.webmanifest" />
  <title>InitTracker LAN</title>
  <script>window.PUSH_PUBLIC_KEY=__PUSH_PUBLIC_KEY__;</script>
  <script>window.LAN_BASE_URL=__LAN_BASE_URL__;</script>
  <style>
    :root{
      --bg:#0b0d10;
      --panel:#141923;
      --panel2:#0f1320;
      --text:#e8eef7;
      --muted:#93a2b8;
      --accent:#6aa9ff;
      --danger:#ff5b5b;
      --safeInsetTop: env(safe-area-inset-top, 0px);
      --safeInsetBottom: env(safe-area-inset-bottom, 0px);
      --modalTopOffset: 0px;
      --modalBottomOffset: 0px;
      --topbar-height: 0px;
      --bottombar-height: 0px;
      --battle-log-font-size: 14px;
      --battle-log-font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;
    }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--text); font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif; overflow:hidden;}
    .app{height:100dvh; display:flex; flex-direction:column; min-height:0;}
    .topbar{
      padding: calc(10px + var(--safeInsetTop)) 12px 10px 12px;
      background: linear-gradient(180deg, rgba(22,24,30,0.96), rgba(12,14,20,0.88));
      border-bottom: 1px solid rgba(214,186,126,0.28);
      display:flex;
      flex-direction:column;
      align-items:stretch;
      gap:10px;
      position:sticky;
      top:0;
      z-index:24;
      backdrop-filter: blur(12px);
      box-shadow: 0 8px 20px rgba(0,0,0,0.38);
    }
    .map-view{
      --map-view-bar-height: 68px;
      --map-view-order-font-size: 14px;
      --map-view-order-gap: 8px;
      --map-view-order-chip-pad-y: 6px;
      --map-view-order-chip-pad-x: 10px;
      --map-view-order-radius: 999px;
      --map-view-bar-bg: rgba(14,18,26,0.92);
      --map-view-bar-border: rgba(255,255,255,0.1);
    }
    .map-view .sheet-wrap,
    .map-view .cast-overlay,
    .map-view .menu-popover,
    .map-view .spell-library-overlay,
    .map-view .spell-detail-overlay,
    .map-view .spellbook-overlay,
    .map-view .turn-modal,
    .map-view .modal,
    .map-view-only .sheet-wrap,
    .map-view-only .cast-overlay,
    .map-view-only .menu-popover,
    .map-view-only .conn-popover,
    .map-view-only .spell-library-overlay,
    .map-view-only .spell-detail-overlay,
    .map-view-only .spellbook-overlay,
    .map-view-only .turn-modal,
    .map-view-only .modal{
      display:none !important;
    }
    .map-view .topbar{
      gap:8px;
      padding-bottom:8px;
    }
    .map-view .topbar-main-row{
      min-height:0;
      gap:8px;
    }
    .map-view .topbar-main-row #planningBtn,
    .map-view .topbar-main-row #spellLibraryBtn,
    .map-view .topbar-main-row #helpBtn,
    .map-view .topbar-main-row #configBtn,
    .map-view .topbar-main-row #initiativeToggleBtn,
    .map-view .topbar-main-row .topbar-controls,
    .map-view .topbar-main-row .spacer{
      display:none !important;
    }
    .map-view .topbar-main-row #topbarTitle{
      display:none;
    }
    .map-view-only .topbar-main-row #topbarTitle{
      display:none;
    }
    .map-view .conn-wrap{
      margin-left:0;
    }
    .map-view .conn-pill{
      min-width:0;
      padding:4px 8px;
      font-size:12px;
    }
    .map-view .conn-pill .conn-full-text{
      display:none;
    }
    .map-view .conn-pill .conn-compact-label,
    .map-view .conn-pill .conn-compact-dot{
      display:inline-flex;
    }
    .map-view-only .conn-popover{
      display:none !important;
    }
    .map-view .mapWrap{
      flex:1 1 auto;
    }
    .topbar-main-row,
    .topbar-initiative-row{
      display:flex;
      align-items:center;
      gap:12px;
      flex-wrap:wrap;
      position:relative;
    }
    .topbar-main-row{
      width:100%;
    }
    .topbar-initiative{
      display:flex;
      flex-direction:column;
      gap:8px;
      min-height: var(--map-view-bar-height);
      transition: max-height 0.22s ease, opacity 0.22s ease, margin 0.22s ease;
      max-height: 300px;
      opacity: 1;
      overflow: hidden;
    }
    .initiative-hidden .topbar-initiative{
      max-height: 0;
      opacity: 0;
      margin-top: -4px;
      pointer-events:none;
    }
    .map-view-title{
      font-size: 14px;
      font-weight: 700;
      color: var(--text);
      letter-spacing: 0.2px;
    }
    .map-view-readonly{
      font-size: 12px;
      color: var(--muted);
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px dashed rgba(255,255,255,0.18);
      background: rgba(15,19,32,0.6);
      letter-spacing: 0.2px;
      display:none;
    }
    .map-view .map-view-readonly{
      display:inline-flex;
    }
    .map-view-turn-order{
      display:flex;
      gap: var(--map-view-order-gap);
      overflow-x:auto;
      overflow-y:hidden;
      align-items:center;
      padding-bottom: 2px;
      flex-wrap: nowrap;
      max-width: 100%;
      flex: 1 1 100%;
      scrollbar-width: thin;
    }
    .map-view-turn-order::-webkit-scrollbar{
      height: 6px;
    }
    .map-view-turn-order::-webkit-scrollbar-thumb{
      border-radius: 999px;
      background: rgba(255,255,255,0.22);
    }
    .map-view .turn-chip{
      font-size: var(--map-view-order-font-size);
      padding: var(--map-view-order-chip-pad-y) var(--map-view-order-chip-pad-x);
      border-radius: var(--map-view-order-radius);
    }
    .map-view .turn-chip.friendly{
      background: rgba(106,255,176,0.18);
      border-color: rgba(106,255,176,0.45);
    }
    .map-view .turn-chip.enemy{
      background: rgba(255,91,91,0.16);
      border-color: rgba(255,91,91,0.4);
    }
    .map-view .turn-chip.friendly.active{
      border-color: rgba(106,255,176,0.75);
      box-shadow: 0 0 0 1px rgba(106,255,176,0.45);
    }
    .map-view .turn-chip.enemy.active{
      border-color: rgba(255,91,91,0.75);
      box-shadow: 0 0 0 1px rgba(255,91,91,0.45);
    }
    .map-view .turn-chip-index{
      font-size: calc(var(--map-view-order-font-size) * 0.7);
    }
    .map-view .turn-order-status{
      font-size: 13px;
      color: #f5e3b2;
      font-weight: 700;
    }
    .map-view-hide-index .turn-chip-index{
      display:none;
    }
    .map-view-hide-status #mapViewTurnOrderStatus{
      display:none;
    }
    .map-view-hide-title .map-view-title{
      display:none;
    }
    .topbar h1{font-size:14px; margin:0; font-weight:650;}
    .pill{font-size:12px; color:var(--muted); padding:6px 10px; border:1px solid rgba(255,255,255,0.10); border-radius:999px;}
    .conn-wrap{
      position:relative;
      display:inline-flex;
      align-items:center;
    }
    .conn-pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      cursor:pointer;
      background: transparent;
      font: inherit;
    }
    .conn-full-text{display:inline;}
    .conn-compact-label,
    .conn-compact-dot{display:none;}
    .conn-compact .conn-full-text{display:none;}
    .conn-compact .conn-compact-label,
    .conn-compact .conn-compact-dot{display:inline-flex;}
    .conn-compact-label{font-weight:700; letter-spacing:0.5px;}
    .conn-compact-dot{
      width:8px;
      height:8px;
      border-radius:50%;
      background: var(--accent);
    }
    .conn-popover{
      position:absolute;
      top: calc(100% + 10px);
      left: 0;
      min-width: 160px;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(15,19,32,0.98);
      box-shadow: 0 12px 30px rgba(0,0,0,0.45);
      display:flex;
      flex-direction:column;
      gap:10px;
      opacity:0;
      transform: translateY(-4px);
      pointer-events:none;
      transition: opacity 0.15s ease, transform 0.15s ease;
      z-index: 30;
    }
    .conn-popover::before{
      content:"";
      position:absolute;
      top: -6px;
      left: 16px;
      width: 12px;
      height: 12px;
      background: rgba(15,19,32,0.98);
      border-left: 1px solid rgba(255,255,255,0.12);
      border-top: 1px solid rgba(255,255,255,0.12);
      transform: rotate(45deg);
    }
    .conn-popover.show{
      opacity:1;
      transform: translateY(0);
      pointer-events:auto;
    }
    .conn-popover-status{
      font-size:12px;
      color: var(--muted);
    }
    .conn-style-toggle{
      display:inline-flex;
      gap:6px;
      flex-wrap:wrap;
    }
    .conn-style-btn{
      padding:6px 10px;
      font-size:12px;
    }
    .conn-style-btn.active{
      border-color: rgba(106,169,255,0.65);
      background: rgba(106,169,255,0.2);
      color: var(--text);
    }
    .menu-wrap{
      position:relative;
      display:inline-flex;
      align-items:center;
    }
    .menu-btn{
      display:inline-flex;
      align-items:center;
      gap:6px;
    }
    .menu-popover{
      position:absolute;
      top: calc(100% + 10px);
      left: 0;
      min-width: 190px;
      padding: 6px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(15,19,32,0.98);
      box-shadow: 0 12px 30px rgba(0,0,0,0.45);
      display:flex;
      flex-direction:column;
      gap:6px;
      opacity:0;
      transform: translateY(-4px);
      pointer-events:none;
      transition: opacity 0.15s ease, transform 0.15s ease;
      z-index: 30;
    }
    .menu-popover.show{
      opacity:1;
      transform: translateY(0);
      pointer-events:auto;
    }
    .menu-item{
      border:none;
      background: transparent;
      color: var(--text);
      font-size: 13px;
      font-weight: 600;
      text-align: left;
      padding: 8px 10px;
      border-radius: 10px;
      cursor:pointer;
    }
    .menu-item:hover,
    .menu-item:focus{
      background: rgba(255,255,255,0.08);
      outline:none;
    }
    .hidden{display:none !important;}

    .close-btn{
      position: fixed;
      top: 18px;
      right: 18px;
      z-index: 111;
      width: 42px;
      height: 42px;
      border-radius: 50%;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(11,15,24,0.95);
      color: #fff;
      font-size: 28px;
      line-height: 1;
      cursor: pointer;
    }
    @media (max-width: 760px){
      .close-btn{top: 10px; right: 10px;}
    }
    .spacer{flex:1;}
    .btn{
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 13px;
      font-weight: 650;
      touch-action: manipulation;
    }
    .btn:active{transform: translateY(1px);}
    .btn.danger{background: rgba(255,91,91,0.14); border-color: rgba(255,91,91,0.35);}
    .btn.accent{background: rgba(106,169,255,0.14); border-color: rgba(106,169,255,0.35);}
    .btn.success{background: rgba(78,204,128,0.22); border-color: rgba(78,204,128,0.55); color:#dcffe8;}
    .btn.end-turn-top{
      border-color: rgba(255,88,88,0.8);
      background: linear-gradient(180deg, rgba(255,102,102,0.95) 0%, rgba(209,48,48,0.95) 100%);
      color: #fff3f3;
      font-size: 14px;
      font-weight: 800;
      letter-spacing: 0.02em;
      padding: 10px 16px;
      box-shadow: 0 8px 18px rgba(112,16,16,0.45), inset 0 0 0 1px rgba(255,255,255,0.22);
      text-shadow: 0 1px 0 rgba(20,0,0,0.35);
    }
    .btn.end-turn-top.end-turn-ready{
      border-color: rgba(255,213,138,0.95);
      box-shadow: 0 0 0 2px rgba(255,186,106,0.35), 0 0 20px rgba(255,116,106,0.7), 0 8px 20px rgba(112,16,16,0.55), inset 0 0 0 1px rgba(255,255,255,0.28);
    }
    .btn.end-turn-top.end-turn-pop{
      animation: endTurnPop 260ms ease-out;
    }
    .btn.end-turn-top:disabled,
    .btn.end-turn-top[aria-disabled="true"]{
      box-shadow: none;
    }
    @keyframes endTurnPop{
      0%{transform: scale(1);}
      45%{transform: scale(1.12);}
      100%{transform: scale(1);}
    }
    .topbar-controls{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
    }

    .mapWrap{flex:1 1 auto; min-height:0; position:relative; overflow:hidden; background:#0a0c12;}
    canvas{position:absolute; inset:0; width:100%; height:100%; touch-action:none;}
    .map-tooltip{
      position:absolute;
      z-index:4;
      pointer-events:none;
      max-width:240px;
      padding:4px 8px;
      border-radius:6px;
      background:rgba(16,18,24,0.92);
      color:#eef2f7;
      font-size:12px;
      font-weight:600;
      box-shadow:0 2px 8px rgba(0,0,0,0.35);
      opacity:0;
      transition:opacity 0.08s ease;
      white-space:nowrap;
    }
    .map-tooltip.show{opacity:1;}
    .effects-overlay{
      position:absolute;
      right:10px;
      top:10px;
      z-index:7;
      display:flex;
      flex-direction:column;
      align-items:flex-end;
      gap:6px;
      pointer-events:none;
    }
    .effects-overlay.hidden{display:none;}
    .effects-list{display:flex; gap:6px; flex-wrap:wrap; justify-content:flex-end; pointer-events:auto;}
    .effect-icon{
      width:28px; height:28px; border-radius:8px;
      display:inline-flex; align-items:center; justify-content:center;
      font-size:16px; line-height:1;
      border:1px solid rgba(255,255,255,0.32);
      background:rgba(16,18,24,0.86);
      box-shadow:0 2px 8px rgba(0,0,0,0.35);
      cursor:help;
    }
    .waiting{
      position:absolute; inset:0; display:none; align-items:center; justify-content:center;
      background: rgba(10,12,18,0.82); color: var(--muted); font-size: 16px; letter-spacing: 0.4px;
      text-transform: lowercase;
    }
    .waiting.show{display:flex;}
    .summon-placement-banner{
      position:absolute;
      top:12px;
      left:50%;
      transform:translateX(-50%);
      z-index:6;
      padding:8px 12px;
      border-radius:10px;
      background:rgba(15,19,32,0.92);
      border:1px solid rgba(106,169,255,0.55);
      color:#e8eef7;
      font-size:12px;
      font-weight:600;
      box-shadow:0 6px 18px rgba(0,0,0,0.35);
      pointer-events:none;
    }

    .sheet-wrap{
      position:sticky; bottom:0; z-index:20;
      display:flex; flex-direction:column;
      background: rgba(20,25,35,0.92);
      border-top: 1px solid rgba(255,255,255,0.08);
      backdrop-filter: blur(10px);
      min-height: 180px;
      max-height: 75vh;
    }
    .sheet-handle{
      height: 18px;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor: ns-resize;
      touch-action: none;
      flex:0 0 auto;
    }
    .menus-locked .sheet-handle{
      cursor: not-allowed;
      opacity: 0.45;
      pointer-events: none;
    }
    .sheet-handle::before{
      content:"";
      width: 44px;
      height: 4px;
      border-radius: 999px;
      background: rgba(255,255,255,0.25);
    }
    .sheet{
      padding: 10px 12px calc(12px + var(--safeInsetBottom)) 12px;
      display:flex;
      flex-direction:column;
      flex:1 1 auto;
      min-height:0;
    }
    .sheet-content{
      display:flex;
      flex-direction:column;
      flex:1 1 auto;
      min-height:0;
    }
    .cast-panel{
      margin-top: 10px;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.1);
      background: rgba(10,14,22,0.55);
    }
    .turn-alerts-panel{
      margin-top: 10px;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.1);
      background: rgba(10,14,22,0.55);
    }
    .turn-alerts-panel legend{
      padding: 0 6px;
      font-weight: 700;
    }
    .turn-alerts-row{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .turn-alerts-status{
      font-size: 12px;
      color: var(--muted);
    }
    .turn-alerts-note{
      margin-top: 6px;
      font-size: 11px;
      color: var(--muted);
    }
    .btn.mount.glow{
      box-shadow: 0 0 0.8rem rgba(106,169,255,0.95);
      border-color: rgba(106,169,255,0.95);
    }
    .cast-panel summary{
      cursor:pointer;
      font-weight:700;
      list-style:none;
    }
    .cast-panel summary::-webkit-details-marker{display:none;}
    .cast-panel[open] summary{margin-bottom:8px;}
    .cast-menu-trigger{
      margin-top: 10px;
      display:flex;
    }
    .cast-menu-trigger .btn{
      flex:1;
    }
    .cast-overlay{
      background: var(--bg);
      display:none;
      flex-direction:column;
      padding: 10px 12px calc(12px + var(--safeInsetBottom)) 12px;
      z-index:40;
      height:100%;
      overflow:auto;
      flex:1 1 auto;
      min-height: 0;
    }
    .cast-overlay.show{
      display:flex;
    }
    .cast-overlay-header{
      display:flex;
      align-items:center;
      gap:12px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
    }
    .cast-overlay-header .btn{
      white-space: nowrap;
    }
    .cast-overlay-title{
      font-size: 14px;
      font-weight: 700;
    }
    .cast-overlay-spacer{
      flex:1;
    }
    .cast-overlay-body{
      margin-top: 10px;
      overflow:auto;
      flex:1 1 auto;
      min-height:0;
    }
    .cast-overlay .cast-panel{
      margin-top: 0;
      padding: 0;
      border: none;
      background: transparent;
    }
    .spell-select-overlay{
      position:fixed;
      inset: 0;
      top: var(--topbar-height);
      bottom: var(--bottombar-height);
      background: var(--bg);
      display:none;
      flex-direction:column;
      padding: 10px 12px calc(12px + var(--safeInsetBottom)) 12px;
      z-index:45;
      min-height:0;
    }
    .spell-select-overlay.show{
      display:flex;
    }
    .spell-select-header{
      display:flex;
      align-items:center;
      gap:12px;
      padding-bottom:8px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      flex-wrap:wrap;
    }
    .spell-select-title{
      font-size: 14px;
      font-weight: 700;
    }
    .spell-select-spacer{
      flex:1;
    }
    .spell-select-body{
      margin-top: 10px;
      display:flex;
      flex-direction:column;
      gap:10px;
      flex:1 1 auto;
      min-height:0;
    }
    .spell-select-summary{
      font-size: 12px;
      color: var(--muted);
    }
    .spell-select-table-wrap{
      overflow:auto;
      max-height: calc(100dvh - var(--topbar-height) - var(--bottombar-height) - 170px);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(8,12,20,0.6);
    }
    .spell-select-table{
      width:100%;
      border-collapse: collapse;
      font-size: 12px;
    }
    .spell-select-table th,
    .spell-select-table td{
      padding: 8px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.06);
      text-align:left;
      vertical-align:top;
    }
    .spell-select-check-col,
    .spell-select-check-cell{
      width: 38px;
      text-align:center;
    }
    .spell-select-overlay:not(.selecting) .spell-select-check-col,
    .spell-select-overlay:not(.selecting) .spell-select-check-cell{
      display:none;
    }
    .spell-select-table th{
      position: sticky;
      top: 0;
      background: rgba(12,16,26,0.98);
      z-index: 2;
      font-size: 11px;
      letter-spacing: 0.3px;
      text-transform: uppercase;
      color: var(--muted);
    }
    .spell-select-table tr:last-child td{
      border-bottom:none;
    }
    .spell-select-name-btn{
      background: none;
      border: none;
      padding: 0;
      color: var(--accent);
      cursor:pointer;
      font-weight: 600;
      text-align:left;
    }
    .spell-select-link{
      color: var(--accent);
      text-decoration: none;
      font-weight: 600;
    }
    .spell-select-link:hover{
      text-decoration: underline;
    }
    .spell-select-details-row td{
      padding-top: 0;
      background: rgba(10,14,22,0.45);
    }
    .spell-select-details-row details{
      padding: 6px 0 10px 0;
    }
    .spell-select-details-row summary{
      cursor:pointer;
      list-style:none;
      font-weight: 700;
      color: var(--text);
    }
    .spell-select-details-row summary::-webkit-details-marker{display:none;}
    .spell-select-details-grid{
      margin-top: 8px;
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 6px;
      font-size: 11px;
      color: var(--muted);
    }
    .spell-select-actions{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .spell-select-overlay:not(.selecting) .spell-select-save-btn{
      display:none;
    }
    .spell-select-details-item strong{
      color: var(--text);
      font-weight: 600;
      display:block;
      margin-bottom: 2px;
    }
    .spell-select-controls{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .spell-select-controls select{
      flex:1;
    }
    .form-grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap:8px;
    }
    .spell-filter-toolbar{
      margin-bottom: 10px;
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .spell-filter-toolbar .form-field{
      flex:1 1 220px;
      min-width: 160px;
    }
    .spell-filter-summary{
      font-size: 12px;
      color: var(--muted);
      flex: 1 1 100%;
    }
    .spell-filter-modal{
      position: fixed;
      inset: 0;
      display:none;
      background: rgba(8,10,14,0.8);
      backdrop-filter: blur(4px);
      z-index: 70;
      padding: 12px;
      align-items:flex-end;
    }
    .spell-filter-modal.show{display:flex;}
    .spell-filter-drawer{
      width: min(620px, 100%);
      max-height: calc(100dvh - 24px);
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(13,18,28,0.98);
      display:flex;
      flex-direction:column;
      overflow:hidden;
      margin: 0 auto;
    }
    .spell-filter-drawer-header{
      display:flex;
      align-items:center;
      gap:10px;
      padding: 12px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
    }
    .spell-filter-drawer-body{
      padding: 12px;
      overflow:auto;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .spell-filter-drawer-actions{
      padding: 12px;
      border-top: 1px solid rgba(255,255,255,0.08);
      display:flex;
      justify-content:flex-end;
      gap:8px;
    }
    .multi-select{
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 10px;
      background: rgba(8,12,20,0.6);
      padding: 8px;
    }
    .multi-select summary{
      cursor:pointer;
      list-style:none;
      font-size: 12px;
      color: var(--text);
    }
    .multi-select summary::-webkit-details-marker{display:none;}
    .multi-select-options{
      margin-top: 8px;
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap:6px;
    }
    .multi-select-options label{
      display:flex;
      align-items:center;
      gap:6px;
      font-size: 12px;
      color: var(--muted);
    }
    .advanced-filter-toggle{
      margin:0;
      padding: 8px;
      border: 1px dashed rgba(255,255,255,0.2);
      border-radius: 10px;
      background: rgba(8,12,20,0.35);
    }
    .advanced-filter-toggle summary{
      cursor:pointer;
      font-size: 12px;
      font-weight: 600;
      color: var(--text);
    }
    .spell-details{
      margin-top: 10px;
      padding: 8px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.1);
      background: rgba(8,12,20,0.6);
      font-size: 12px;
      color: var(--muted);
    }
    .spell-details-grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 6px;
    }
    .spell-details-row{
      display:flex;
      gap:6px;
      align-items:baseline;
    }
    .spell-details-label{
      font-size: 11px;
      color: var(--muted);
      min-width: 64px;
    }
    .spell-details-value{
      font-size: 12px;
      color: var(--text);
      font-weight: 600;
    }
    .spellbook-overlay{
      position: fixed;
      inset: 0;
      height: calc(var(--spellbook-vh, 1vh) * 100);
      max-height: 100dvh;
      background: rgba(10, 12, 16, 0.9);
      backdrop-filter: blur(8px);
      display: none;
      flex-direction: column;
      z-index: 60;
    }
    .spellbook-overlay.show{display:flex;}
    .spell-detail-overlay{
      position: fixed;
      inset: 0;
      height: calc(var(--spellbook-vh, 1vh) * 100);
      max-height: 100dvh;
      background: rgba(10, 12, 16, 0.95);
      backdrop-filter: blur(10px);
      display: none;
      flex-direction: column;
      z-index: 95;
    }
    .spell-detail-overlay.show{display:flex;}
    .spell-detail-header{
      padding: calc(12px + var(--safeInsetTop)) 14px 12px 14px;
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border-bottom: 1px solid rgba(255,255,255,0.08);
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .spell-detail-title{
      font-size: 15px;
      font-weight: 700;
    }
    .spell-detail-spacer{flex:1;}
    .spell-detail-body{
      padding: 14px;
      padding-bottom: calc(14px + var(--safeInsetBottom));
      overflow:auto;
      flex: 1 1 auto;
      min-height: 0;
      display:flex;
      flex-direction:column;
      gap: 14px;
    }
    .spell-detail-card{
      background: rgba(20,25,35,0.92);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      padding: 12px 14px;
      display:flex;
      flex-direction:column;
      gap: 12px;
    }
    .spell-detail-heading{
      font-size: 14px;
      font-weight: 700;
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .spell-detail-meta{
      font-size: 12px;
      color: var(--muted);
    }
    .spell-detail-color-row{
      display:flex;
      align-items:center;
      gap:12px;
      flex-wrap:wrap;
    }
    .spell-detail-color-value{
      width: 96px;
      text-transform: uppercase;
    }
    .spell-color-swatch{
      width: 18px;
      height: 18px;
      border-radius: 50%;
      border: 1px solid rgba(255,255,255,0.4);
      background: rgba(255,255,255,0.2);
      display:inline-block;
      flex: 0 0 auto;
    }
    .spellbook-color-dot{
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: 1px solid rgba(255,255,255,0.4);
      background: rgba(255,255,255,0.2);
      flex: 0 0 auto;
      margin-right: 6px;
    }
    .spell-library-overlay{
      position: fixed;
      inset: 0;
      background: rgba(10, 12, 16, 0.95);
      backdrop-filter: blur(6px);
      display: none;
      flex-direction: column;
      z-index: 80;
    }
    .spell-library-overlay.show{display:flex;}
    .spell-library-header{
      padding: calc(12px + var(--safeInsetTop)) 14px 12px 14px;
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border-bottom: 1px solid rgba(255,255,255,0.08);
      display:flex;
      align-items:center;
      gap:12px;
      flex-wrap:wrap;
    }
    .spell-library-title{
      font-size: 15px;
      font-weight: 700;
    }
    .spell-library-spacer{flex:1;}
    .spell-library-controls{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .spell-library-controls input,
    .spell-library-controls select{
      background: rgba(15,19,32,0.75);
      border: 1px solid rgba(255,255,255,0.15);
      color: var(--text);
      padding: 6px 10px;
      border-radius: 8px;
      font-size: 12px;
    }
    .spell-library-body{
      padding: 12px 14px calc(14px + var(--safeInsetBottom)) 14px;
      overflow:auto;
      flex: 1 1 auto;
      min-height: 0;
    }
    .spell-library-status{
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 10px;
    }
    .spell-library-list{
      display:flex;
      flex-direction: column;
      gap: 12px;
    }
    .spell-library-card{
      background: rgba(20,25,35,0.92);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      display:flex;
      flex-direction: column;
    }
    .spell-library-card summary{
      list-style: none;
      cursor: pointer;
      padding: 12px 14px;
    }
    .spell-library-card summary::-webkit-details-marker{display:none;}
    .spell-library-summary{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }
    .spell-library-summary-title{
      font-size: 14px;
      font-weight: 700;
    }
    .spell-library-summary-meta{
      font-size: 12px;
      color: var(--muted);
    }
    .spell-library-detail-body{
      border-top: 1px solid rgba(255,255,255,0.08);
      padding: 10px 14px 12px 14px;
      display:flex;
      flex-direction: column;
      gap: 10px;
    }
    .spell-library-detail-grid{
      display:grid;
      grid-template-columns: minmax(120px, 180px) minmax(0, 1fr);
      gap: 6px 12px;
    }
    .spell-library-detail-label{
      font-size: 12px;
      color: var(--muted);
      font-weight: 600;
    }
    .spell-library-detail-value{
      font-size: 12px;
      color: var(--text);
      white-space: pre-wrap;
      word-break: break-word;
    }
    .spell-library-detail-description{
      font-size: 12px;
      color: var(--text);
      white-space: pre-wrap;
      line-height: 1.4;
    }
    .spell-library-action-row{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
    }
    .spell-library-color-row{
      display:flex;
      align-items:center;
      gap: 8px;
    }
    .spell-library-color-row .spell-color-swatch{
      width: 16px;
      height: 16px;
    }
    .spellbook-header{
      padding: calc(12px + var(--safeInsetTop)) 14px 12px 14px;
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border-bottom: 1px solid rgba(255,255,255,0.08);
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .spellbook-title{font-size:14px; font-weight:650;}
    .spellbook-spacer{flex:1;}
    .spellbook-body{
      display:flex;
      flex-direction:column;
      gap:12px;
      padding:12px;
      padding-bottom: calc(12px + var(--safeInsetBottom) + 56px);
      overflow:hidden;
      flex:1;
      min-height: 0;
    }
    .spellbook-tabs{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-items:center;
    }
    .spellbook-controls{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-items:center;
    }
    .spellbook-controls input,
    .spellbook-controls select{
      background: rgba(15,19,32,0.75);
      border: 1px solid rgba(255,255,255,0.15);
      color: var(--text);
      padding: 6px 10px;
      border-radius: 8px;
      font-size: 12px;
    }
    .spellbook-columns{
      display:grid;
      grid-template-columns: 1fr auto 1fr;
      gap:12px;
      flex:1;
      min-height:0;
    }
    .spellbook-column{
      background: var(--panel);
      border:1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      padding:10px;
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    .spellbook-column-title{
      font-size:12px;
      color: var(--muted);
      margin-bottom:8px;
      text-transform: uppercase;
      letter-spacing:0.8px;
    }
    .spellbook-list{
      display:flex;
      flex-direction:column;
      gap:6px;
      overflow:auto;
      flex:1;
      padding-right:4px;
    }
    .spellbook-item{
      touch-action: manipulation;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:8px;
      background: rgba(255,255,255,0.05);
      border:1px solid transparent;
      border-radius:8px;
      padding:8px 10px;
      color: var(--text);
      cursor:pointer;
      font-size:13px;
    }
    .spellbook-item-name{
      display:flex;
      align-items:center;
      gap:6px;
      flex:1;
      min-width:0;
    }
    .spellbook-item-name span{
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .spellbook-item.selected{
      border-color: var(--accent);
      background: rgba(106,169,255,0.18);
    }
    .spellbook-item small{
      color: var(--muted);
      font-size:11px;
    }
    .spellbook-item.locked{
      border-color: rgba(255,180,90,0.3);
      background: rgba(255,180,90,0.12);
    }
    .wildshape-menu-actions{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-top:8px;
    }
    .wildshape-pool-row{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }
    .wildshape-pool-row input{max-width:120px;}

    .spellbook-actions{
      display:flex;
      flex-direction:column;
      gap:8px;
      justify-content:center;
    }
    .spellbook-status{
      font-size:12px;
      color: var(--muted);
      min-height:16px;
    }
    .spellbook-confirm-text{
      font-size:14px;
      margin:0 0 10px 0;
    }
    .spellbook-back-fab{
      position: fixed;
      left: 16px;
      bottom: calc(16px + var(--safeInsetBottom));
      z-index: 1;
      box-shadow: 0 10px 24px rgba(0,0,0,0.35);
    }
    .manual-entry-badge{
      display: none;
      align-items: center;
      gap: 4px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(255,180,90,0.6);
      background: rgba(255,140,60,0.2);
      color: #ffcc9b;
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.4px;
    }
    .manual-entry-badge.show{
      display: inline-flex;
    }
    .form-field{display:flex; flex-direction:column; gap:4px;}
    .form-field label{font-size:11px; color:var(--muted);}
    .form-field input,
    .form-field select{
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      border-radius: 8px;
      padding: 6px 8px;
      font-size: 12px;
    }
    .form-field select{
      background: var(--panel2);
      color: var(--text);
    }
    .form-field select option{
      background: var(--panel2);
      color: var(--text);
    }
    .form-field input[type="color"]{
      padding:0;
      height:36px;
      width:100%;
      border:none;
      background:none;
    }
    .damage-type-controls{
      display:flex;
      gap:6px;
      align-items:center;
    }
    .damage-type-controls select{flex:1;}
    .damage-type-list{
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      min-height:24px;
    }
    .damage-type-chip{
      display:inline-flex;
      align-items:center;
      gap:6px;
    }
    .chip button{
      border:none;
      background:none;
      color: var(--text);
      font-size: 14px;
      cursor:pointer;
      padding:0;
      line-height:1;
    }
    .form-actions{margin-top:10px; display:flex; gap:8px; flex-wrap:wrap;}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .row + .row{margin-top:10px;}
    .sheet-actions{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .initiative-compact .turn-order{max-height: 60px; overflow:auto;}
    .initiative-compact .turn-order-status{display:none;}
    .label{font-size:12px; color:var(--muted);}
    .value{font-size:14px; font-weight:700;}
    .chip{font-size:12px; padding:6px 10px; border-radius:999px; border:1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.05);}
    .chip input{margin-right:6px;}
    .hp-bar-wrap{
      display:none;
      align-items:center;
      gap:8px;
      width:min(360px, 100%);
    }
    .hp-bar-wrap.show{display:flex;}
    .hp-bar-track{
      flex:1;
      min-width:120px;
      height:10px;
      border-radius:999px;
      background:rgba(255,255,255,0.12);
      overflow:hidden;
    }
    .hp-bar-fill{
      height:100%;
      width:0%;
      background:#38c172;
      transition:width 120ms ease-out, background 120ms ease-out;
    }
    .hp-bar-fill.mid{background:#f2c94c;}
    .hp-bar-fill.low{background:#ff5b5b;}
    .hp-bar-label{font-size:12px; color:var(--muted);}
    .turn-order{display:flex; flex-wrap:wrap; gap:6px; align-items:center;}
    .turn-chip{
      min-width: 26px;
      font-size:12px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.04);
      color: var(--text);
      display:inline-flex;
      align-items:center;
      gap:6px;
    }
    .turn-chip-index{font-weight:700;}
    .turn-chip-name{
      max-width: 140px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .turn-chip-marker{
      display:none;
      width:8px;
      height:8px;
      border-radius:50%;
      background: rgba(255,255,255,0.3);
      flex:0 0 auto;
    }
    .turn-chip-marker.active-marker{
      background: var(--accent);
      box-shadow: 0 0 6px rgba(106,169,255,0.6);
    }
    .turn-chip-marker.claimed-marker{
      background: rgba(106,169,255,0.55);
      border: 1px solid rgba(106,169,255,0.85);
    }
    .initiative-compact .turn-chip-name{display:none;}
    .initiative-compact .turn-chip-marker{display:inline-block;}
    .initiative-compact .turn-chip.active{
      background: rgba(106,169,255,0.2);
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(106,169,255,0.5);
    }
    .auto-compact .compact-optional{display:none;}
    .turn-chip.claimed{
      border-color: rgba(106,169,255,0.45);
      box-shadow: inset 0 0 0 1px rgba(106,169,255,0.18);
    }
    .turn-chip.active{
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(106,169,255,0.35);
    }
    .modal{
      position:fixed; inset:0; background: rgba(0,0,0,0.55);
      display:none; align-items:center; justify-content:center;
      padding: calc(var(--modalTopOffset) + 12px) 14px calc(var(--modalBottomOffset) + 12px);
      z-index: 80;
    }
    .modal.show{display:flex;}
    #helpModal{z-index:110;}
    .card{
      width:min(520px, 100%);
      background: var(--panel);
      border:1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 12px 40px rgba(0,0,0,0.5);
      display:flex;
      flex-direction:column;
      overflow:auto;
      max-height: calc(100dvh - var(--safeInsetTop) - var(--safeInsetBottom) - var(--modalTopOffset) - var(--modalBottomOffset) - 24px);
    }
    .config-card{overflow:hidden;}
    .card-scroll{
      max-height: calc(100dvh - var(--safeInsetTop) - var(--safeInsetBottom) - var(--modalTopOffset) - var(--modalBottomOffset) - 24px);
      overflow:auto;
    }
    .modal-body{
      flex: 1 1 auto;
      min-height: 0;
      overflow: auto;
    }
    .card h2{margin:0 0 8px 0; font-size:16px;}
    .list{max-height: 50vh; overflow:auto; border:1px solid rgba(255,255,255,0.10); border-radius:12px;}
    .item{
      padding: 12px;
      border-bottom:1px solid rgba(255,255,255,0.08);
      display:flex; align-items:center; gap:10px;
      touch-action: manipulation;
    }
    .item:last-child{border-bottom:none;}
    .item .name{font-weight:750;}
    .item .meta{font-size:12px; color:var(--muted);}
    .item:active{background: rgba(255,255,255,0.04);}
    .claim-item{
      width:100%;
      text-align:left;
      background: transparent;
      color: var(--text);
      border: none;
      cursor:pointer;
    }
    .claim-item.selected{
      background: rgba(106,169,255,0.12);
      box-shadow: inset 0 0 0 1px rgba(106,169,255,0.35);
    }
    .claim-item input{
      pointer-events:none;
    }
    .hint{font-size:12px; color:var(--muted); margin-top:10px; line-height:1.4;}
    .mastery-advantage-text{color:#34d399;font-weight:700;}
    .hint.hidden{display:none;}
    .modal-actions{display:flex; gap:10px; flex-wrap:wrap; margin-top:12px;}

    .rules-help-layout{display:grid; grid-template-columns:minmax(220px, 32%) 1fr; gap:10px; min-height:68vh; max-height:calc(100dvh - 170px);}
    .rules-help-left{display:flex; flex-direction:column; gap:8px; min-height:0;}
    .rules-help-search{width:100%;}
    .rules-help-tree{overflow:auto; border:1px solid rgba(255,255,255,.12); border-radius:10px; padding:8px; background:rgba(8,10,14,.5); min-height:200px;}
    .rules-help-node{margin:4px 0;}
    .rules-help-node button{width:100%; text-align:left; background:transparent; border:0; color:var(--text); padding:4px 6px; border-radius:6px;}
    .rules-help-node button:hover{background:rgba(255,255,255,.1);}
    .rules-help-pinned{margin:0 0 8px 0; padding-bottom:8px; border-bottom:1px solid rgba(255,255,255,.12);}
    .rules-help-pinned button{width:100%; text-align:left;}
    .rules-help-children{margin-left:12px; border-left:1px solid rgba(255,255,255,.08); padding-left:8px;}
    .rules-help-right{display:flex; flex-direction:column; gap:8px; min-height:0; height:100%;}
    .rules-help-frame{flex:1 1 auto; min-height:460px; height:100%; border:1px solid rgba(255,255,255,.15); border-radius:10px; background:#0b0d10; width:100%;}
    .rules-help-message{font-size:12px; color:var(--muted); min-height:16px;}
    @media (max-width: 1600px){ .rules-help-layout{min-height:64vh; max-height:calc(100dvh - 150px);} }
    @media (max-width: 1200px){ .rules-help-layout{min-height:60vh; max-height:calc(100dvh - 130px);} }
    @media (max-width: 900px){ .rules-help-layout{grid-template-columns:1fr; min-height:56vh; max-height:none;} .rules-help-frame{min-height:360px;} }
    .modal-actions .btn{flex:1; min-width:120px;}
    .action-picker-list{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-top:4px;
    }
    .action-picker-item{
      border:1px solid rgba(255,255,255,0.12);
      border-radius:12px;
      padding:10px;
      background: rgba(15,20,30,0.6);
      text-align:left;
      color: var(--text);
      cursor:pointer;
    }
    .action-picker-item .action-picker-name{
      font-weight:650;
      margin-bottom:4px;
    }
    .action-picker-item .action-picker-meta{
      font-size:12px;
      color: var(--muted);
      line-height:1.4;
    }
    .config-section{margin-top:8px;}
    .config-section summary{
      cursor:pointer;
      list-style:none;
      font-weight:700;
      font-size:14px;
      padding: 6px 4px;
    }
    .config-section summary::-webkit-details-marker{display:none;}
    .config-list{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-top:8px;
    }
    .config-item{
      display:flex;
      flex-direction:column;
      gap:8px;
      padding: 10px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,0.1);
      background: rgba(10,14,22,0.55);
    }
    .config-item-title{font-size:13px; font-weight:650;}
    .config-controls{display:flex; align-items:center; gap:8px; flex-wrap:wrap;}
    .preset-actions{display:flex; align-items:center; gap:8px; flex-wrap:wrap;}
    .preset-status{font-size:12px; color:var(--accent); min-height:16px;}
    .config-toggle{
      display:flex;
      align-items:center;
      gap:6px;
      font-size:12px;
      color: var(--muted);
    }
    .config-toggle input{transform: scale(1.05);}
    .hotkey-input{
      width:120px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      padding:6px 8px;
      font-size:12px;
    }
    .hotkey-input.conflict{
      border-color: rgba(255,91,91,0.55);
      box-shadow: 0 0 0 1px rgba(255,91,91,0.3);
    }
    .hotkey-conflict{
      min-height:14px;
      font-size:11px;
      color: var(--danger);
    }
    .hotkey-hint{font-size:11px; color: var(--muted);}
    .color-section-title{font-size:12px; color:var(--muted); letter-spacing:0.04em; text-transform:uppercase; font-weight:700; margin:2px 0 6px 0; text-align:left;}
    .color-row{display:flex; align-items:center; gap:12px; flex-wrap:wrap;}
    .rgb-values{display:flex; align-items:center; gap:6px; flex-wrap:wrap;}
    .rgb-box{min-width:44px; padding:6px 8px; border-radius:8px; border:1px solid rgba(255,255,255,0.14); background:rgba(255,255,255,0.05); font-size:12px; color:var(--text); text-align:center; font-variant-numeric:tabular-nums;}
    .color-divider{height:1px; width:100%; margin: 4px 0 2px 0; background:rgba(255,255,255,0.12);}
    .color-swatch{width:36px; height:36px; border-radius:50%; border:2px solid rgba(255,255,255,0.2); background:#6aa9ff;}
    .color-input{width:64px; height:44px; border:none; background:none; padding:0;}
    .turn-modal{
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 20px 14px;
      background: rgba(0,0,0,0.6);
      opacity:0;
      pointer-events:none;
      transition: opacity 0.2s ease;
    }
    .turn-modal.show{
      opacity:1;
      pointer-events:auto;
    }
    .turn-card{
      width:min(380px, 100%);
      background: var(--panel);
      border:1px solid rgba(255,255,255,0.16);
      border-radius: 16px;
      padding: 18px 16px;
      text-align:center;
      box-shadow: 0 16px 40px rgba(0,0,0,0.5);
      display:flex;
      flex-direction:column;
      max-height: calc(100vh - var(--safeInsetTop) - var(--safeInsetBottom) - 40px);
    }
    .turn-card h2{margin:0 0 12px 0; font-size:18px;}
    .dm-side-layout{
      position:absolute;
      top:10px;
      bottom:10px;
      left:10px;
      right:10px;
      pointer-events:none;
      display:flex;
      justify-content:space-between;
      gap:10px;
      z-index:5;
    }
    .dm-log-panel,.dm-map-preview{
      pointer-events:auto;
      background: rgba(11,14,21,0.72);
      border:1px solid rgba(255,255,255,0.16);
      border-radius:12px;
      backdrop-filter: blur(6px);
    }
    .dm-log-panel{
      width:min(430px,42vw);
      display:none;
      flex-direction:column;
      overflow:hidden;
    }
    .dm-log-panel.show{display:flex;}
    .dm-log-header{display:flex;justify-content:space-between;gap:8px;padding:8px;border-bottom:1px solid rgba(255,255,255,0.1);}
    .dm-log-list{overflow:auto; padding:6px 8px; font-size:12px; display:flex; flex-direction:column; gap:4px;}
    .dm-log-entry{display:grid; grid-template-columns: 72px 1fr; gap:8px; padding:4px 6px; border-radius:6px; cursor:pointer;}
    .dm-log-entry:hover{background:rgba(255,255,255,0.08);}
    .dm-log-time{color:var(--muted); font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;}
    .dm-log-entry.attack .dm-log-msg{color:#ffdbb0;}
    .dm-log-entry.damage .dm-log-msg{color:#ffbcbc;}
    .dm-log-entry.heal .dm-log-msg{color:#bcffd9;}
    .dm-log-entry.save .dm-log-msg{color:#b8d3ff;}
    .dm-map-preview{width:min(300px,28vw); display:none; flex-direction:column; padding:8px; opacity:0.55;}
    .dm-map-preview.show{display:flex;}
    .dm-map-preview canvas{width:100%; aspect-ratio:1/1; background:rgba(5,8,14,0.78); border-radius:8px;}
    .map-view-log-panel{
      position:fixed;
      right:12px;
      bottom:12px;
      width:min(540px,52vw);
      max-height:min(42vh, 360px);
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.2);
      background: rgba(8,10,16,0.82);
      box-shadow: 0 12px 28px rgba(0,0,0,0.45);
      backdrop-filter: blur(8px);
      z-index: 16;
      overflow: hidden;
      pointer-events:auto;
      display:none;
      flex-direction:column;
    }
    .map-view .map-view-log-panel{display:flex;}
    .map-view-log-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      padding:8px 10px;
      border-bottom:1px solid rgba(255,255,255,0.12);
      font-size:12px;
      letter-spacing:0.3px;
    }
    .map-view-log-title{font-weight:700;}
    .map-view-log-subtitle{color:var(--muted); font-size:11px;}
    .map-view-log-list{
      overflow:auto;
      padding:8px;
      display:flex;
      flex-direction:column;
      gap:6px;
      font-size:15px;
      line-height:1.35;
    }
    .map-view-log-entry{
      display:grid;
      grid-template-columns: 74px 1fr;
      gap:8px;
      align-items:start;
      padding:5px 8px;
      border-radius:8px;
      background: rgba(255,255,255,0.03);
      border:1px solid rgba(255,255,255,0.06);
    }
    .map-view-log-time{
      color:var(--muted);
      font-size:11px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      margin-top:2px;
    }
    .map-view-log-msg{color:#f2f6ff; text-shadow: 0 1px 0 rgba(0,0,0,0.45);}
    .map-view-log-msg.is-crit{font-weight:800; font-style:italic; letter-spacing:0.2px; color:#7a1016; text-shadow:0 0 10px rgba(122,16,22,0.45);}
    .map-view-log-msg .damage-type{font-weight:700; text-shadow:0 0 8px currentColor;}
    @media (max-width: 900px){
      .map-view-log-panel{left:8px; right:8px; bottom:8px; width:auto; max-height:34vh;}
      .map-view-log-list{font-size:13px;}
      .map-view-log-entry{grid-template-columns: 64px 1fr;}
    }

    .log-overlay{
      position:fixed;
      right:12px;
      bottom: calc(var(--bottombar-height) + 12px);
      width:min(760px, 82vw);
      height:min(58vh, 560px);
      min-width:260px;
      min-height:180px;
      border:1px solid rgba(255,255,255,0.2);
      border-radius:12px;
      background: rgba(0,0,0,0.72);
      box-shadow: 0 12px 30px rgba(0,0,0,0.45);
      backdrop-filter: blur(8px);
      z-index: 22;
      display:none;
      flex-direction:column;
      overflow:hidden;
      resize: both;
    }
    .log-overlay.show{display:flex;}
    .log-overlay .map-view-log-header{
      cursor:move;
      user-select:none;
      touch-action:none;
    }
    .log-content{
      overflow:auto;
      flex:1;
      min-height:0;
      padding: 10px;
      font-size: var(--battle-log-font-size);
      font-family: var(--battle-log-font-family);
      line-height: 1.45;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .log-content .map-view-log-entry{
      background: rgba(255,255,255,0.04);
    }
    .log-content .map-view-log-time{
      font-size: max(10px, calc(var(--battle-log-font-size) * 0.72));
    }
    .log-resize-handle{
      position:absolute;
      right:4px;
      bottom:4px;
      width:18px;
      height:18px;
      cursor:nwse-resize;
      touch-action:none;
      opacity:0.75;
      background:
        linear-gradient(135deg, transparent 47%, rgba(255,255,255,0.62) 48%, rgba(255,255,255,0.62) 52%, transparent 53%),
        linear-gradient(135deg, transparent 61%, rgba(255,255,255,0.42) 62%, rgba(255,255,255,0.42) 66%, transparent 67%);
      border-radius:4px;
    }
    .spell-slot-monitor-row{
      align-items:center;
    }
    .spell-slot-monitor{
      display:flex;
      flex-wrap:wrap;
      gap:10px 14px;
      align-items:center;
      min-height: 18px;
      padding: 4px 2px;
    }
    .spell-slot-monitor.is-empty{
      display:none;
    }
    .spell-slot-level{
      display:inline-flex;
      align-items:center;
      gap:6px;
      font-size: 11px;
      letter-spacing: 0.5px;
      color: var(--muted);
      text-transform: uppercase;
    }
    .spell-slot-squares{
      display:inline-flex;
      gap:4px;
    }
    .spell-slot-square{
      width:10px;
      height:10px;
      border-radius:3px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.14);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.35);
    }
    .spell-slot-square.is-active{
      background: linear-gradient(135deg, rgba(106,169,255,0.9), rgba(106,255,176,0.55));
      border-color: rgba(106,169,255,0.9);
      box-shadow: 0 0 6px rgba(106,169,255,0.55), inset 0 0 0 1px rgba(255,255,255,0.25);
    }
    .spell-slot-square.is-spent{
      background: rgba(255,255,255,0.05);
      border-color: rgba(255,255,255,0.08);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.4);
    }
    .resource-pools-panel{
      width: 100%;
      border: 1px solid #2c3f54;
      border-radius: 10px;
      background: #121b26;
      padding: 6px 8px;
    }
    .resource-pools-panel summary{
      cursor: pointer;
      font-weight: 700;
      color: #d6e6ff;
    }
    .resource-pool-list{
      margin-top: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .resource-pool-chip{
      background: #19293b;
      border: 1px solid #335172;
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 12px;
      color: #d6e6ff;
    }
    .resource-pool-chip.is-empty{
      opacity: .45;
    }
    .turn-order-status{
      margin-top: 6px;
      font-size: 12px;
      color: var(--muted);
    }
    .turn-order-bubble{
      position:absolute;
      left:0;
      top:0;
      transform: translate(-50%, 0);
      background: rgba(16,20,28,0.95);
      border: 1px solid rgba(255,255,255,0.16);
      border-radius: 999px;
      padding: 6px 12px;
      font-size: 12px;
      color: var(--text);
      box-shadow: 0 10px 24px rgba(0,0,0,0.4);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s ease;
      z-index: 2;
      max-width: calc(100% - 16px);
      box-sizing: border-box;
      text-align: center;
    }
    .turn-order-bubble.show{
      opacity: 1;
    }
    .turn-chip.selected{
      border-color: rgba(255,255,255,0.5);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.18);
    }
    .topbar-initiative .turn-chip{
      min-width: 44px;
      border-radius: 999px;
      border-color: rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.07);
      box-shadow: 0 4px 10px rgba(0,0,0,0.32);
      padding: 7px 12px;
      flex: 0 0 auto;
    }
    .topbar-initiative .turn-chip.active{
      border-color: rgba(214,186,126,0.95);
      box-shadow: 0 0 0 1px rgba(214,186,126,0.7), 0 0 12px rgba(214,186,126,0.35);
    }
    .topbar-initiative .turn-chip.friendly{
      background: rgba(106,255,176,0.16);
      border-color: rgba(106,255,176,0.42);
    }
    .topbar-initiative .turn-chip.enemy{
      background: rgba(255,91,91,0.15);
      border-color: rgba(255,91,91,0.35);
    }
    .topbar-initiative .turn-chip-name{
      max-width: 120px;
    }
    @media (max-width: 720px), (max-height: 720px){
      .btn{padding: 6px 8px; font-size: 12px;}
      .btn.end-turn-top{padding: 9px 12px; font-size: 13px;}
      .topbar{gap:8px; padding: calc(8px + var(--safeInsetTop)) 10px 8px 10px;}
      .sheet{padding: 8px 10px calc(10px + var(--safeInsetBottom)) 10px;}
    }
  </style>
</head>
<body>
<div class="app">
  <div class="topbar">
    <div class="topbar-main-row">
      <h1 class="map-view-title" id="topbarTitle">Initiative Tracker</h1>
      <div class="conn-wrap">
        <button class="pill conn-pill" id="conn" type="button" title="Connecting" aria-haspopup="dialog" aria-expanded="false">
          <span class="conn-full-text" id="connFullText">Connecting</span>
          <span class="conn-compact-label" id="connCompactLabel" aria-hidden="true">C</span>
          <span class="conn-compact-dot" id="connDot" aria-hidden="true"></span>
        </button>
        <div class="conn-popover" id="connPopover" role="dialog" aria-hidden="true">
          <div class="conn-popover-status" id="connPopoverStatus">Connecting</div>
          <button class="btn" id="connReconnectBtn" type="button">Reconnect</button>
        </div>
      </div>
      <button class="btn end-turn-top" id="endTurn">End Turn</button>
      <div class="spacer"></div>
      <button class="btn" id="planningBtn" type="button">Planning Mode</button>
      <button class="btn" id="spellLibraryBtn" type="button">Spellbook</button>
      <button class="btn" id="helpBtn" type="button" aria-controls="helpModal" aria-expanded="false">Help</button>
      <button class="btn" id="configBtn" aria-controls="configModal" aria-expanded="false">Config</button>
      <div class="topbar-controls">
        <button class="btn" id="lockMap">Lock Map</button>
        <button class="btn compact-optional" id="lockAoeToggle" type="button" aria-pressed="true">Unlock my AOEs</button>
        <button class="btn compact-optional" id="auraToggle" type="button" aria-pressed="true">Auras: On</button>
        <button class="btn" id="centerMap">Center on Me</button>
        <button class="btn compact-optional" id="tokenColorModeBtn">Token Color</button>
        <button class="btn" id="measureToggle" aria-pressed="false">Measure</button>
        <button class="btn" id="attackOverlayToggle" type="button" aria-pressed="false">Attack Overlay</button>
        <button class="btn compact-optional" id="measureClear">Clear Measure</button>
        <button class="btn accent" id="zoomIn">Zoom +</button>
        <button class="btn accent" id="zoomOut">Zoom </button>
        <button class="btn compact-optional" id="battleLog">Battle Log</button>
        <button class="btn" id="toggleSheetPanel" aria-pressed="false">Hide Panel</button>
      </div>
    </div>
    <div class="topbar-initiative" id="initiativeBarWrap" aria-label="Initiative bar">
      <div class="topbar-initiative-row">
        <div class="map-view-readonly" id="mapViewReadOnly" role="note">View-only: actions and movement are disabled.</div>
      </div>
      <div class="topbar-initiative-row">
        <div class="turn-order map-view-turn-order" id="mapViewTurnOrder" aria-label="Initiative order"></div>
        <div class="turn-order-bubble" id="mapViewTurnOrderBubble" role="status" aria-live="polite"></div>
      </div>
      <div class="topbar-initiative-row">
        <div class="turn-order-status" id="mapViewTurnOrderStatus"></div>
      </div>
    </div>
  </div>

  <div class="mapWrap">
    <canvas id="c"></canvas>
    <div class="waiting" id="waitingOverlay">(waiting for combat...)</div>
    <div class="summon-placement-banner hidden" id="summonPlacementBanner" role="status" aria-live="polite"></div>
    <div class="map-tooltip" id="tokenTooltip" role="tooltip" aria-hidden="true"></div>
    <div class="effects-overlay hidden" id="effectsOverlay" aria-live="polite">
      <div class="effects-list" id="effectsList"></div>
    </div>
    <div class="dm-side-layout" id="dmSideLayout">
      <aside class="dm-log-panel" id="dmLogPanel">
        <div class="dm-log-header">
          <strong>Battle Log</strong>
          <label><input type="checkbox" id="dmLogAutoScroll" checked /> Auto-scroll</label>
        </div>
        <div class="dm-log-header">
          <label><input type="checkbox" data-log-filter="attack" checked /></label>
          <label><input type="checkbox" data-log-filter="damage" checked /></label>
          <label><input type="checkbox" data-log-filter="save" checked /></label>
          <label><input type="checkbox" data-log-filter="heal" checked /></label>
          <label><input type="checkbox" data-log-filter="spell" checked /></label>
        </div>
        <div class="dm-log-list" id="dmLogList"></div>
      </aside>
      <aside class="dm-map-preview" id="dmMapPreview">
        <strong>Map Preview</strong>
        <canvas id="dmPreviewCanvas" width="240" height="240"></canvas>
      </aside>
    </div>
    <aside class="map-view-log-panel" id="mapViewLogPanel" aria-live="polite">
      <div class="map-view-log-header">
        <div class="map-view-log-title">Battle Feed</div>
        <div class="map-view-log-subtitle">Spectator view</div>
      </div>
      <div class="map-view-log-list" id="mapViewLogList"></div>
    </aside>

    <div class="modal" id="claimModal" aria-hidden="true">
      <div class="card">
        <h2>Claim yer character</h2>
        <div class="modal-body">
          <div class="list" id="claimList"></div>
          <div class="hint hidden" id="claimEmptyHint">No claimable PCs yet. Ask the DM to add one.</div>
          <div class="hint" id="claimHint">Pick a character to control. The DM can reassign ye later.</div>
        </div>
        <div class="modal-actions">
          <button class="btn accent" id="claimConfirm" type="button">Confirm</button>
          <button class="btn" id="claimSpectator" type="button">Spectator / View only</button>
          <button class="btn" id="claimContinue" type="button">Continue unclaimed</button>
        </div>
      </div>
    </div>

    <div class="modal" id="initiativePromptModal" aria-hidden="true">
      <div class="card">
        <h2>Roll Initiative</h2>
        <div class="hint" id="initiativePromptBody">Roll initiative and enter your total.</div>
        <div class="modal-body">
          <input id="initiativePromptInput" type="number" step="1" placeholder="Initiative total" />
        </div>
        <div class="modal-actions">
          <button class="btn accent" id="initiativePromptSubmit" type="button">Submit</button>
          <button class="btn" id="initiativePromptCancel" type="button">Cancel</button>
        </div>
      </div>
    </div>

    <div class="modal" id="attackResolveModal" aria-hidden="true">
      <div class="card">
        <h2>Resolve Attack</h2>
        <div class="hint" id="attackResolveBody">Choose hit or miss, then add damage on a hit.</div>
        <div class="modal-body">
          <div class="row">
            <label class="chip"><input type="radio" name="attackResolveOutcome" id="attackResolveHit" value="hit" checked>Hit</label>
            <label class="chip"><input type="radio" name="attackResolveOutcome" id="attackResolveMiss" value="miss">Miss</label>
          </div>
          <div class="row">
            <label class="chip"><input type="checkbox" id="attackResolveCrit">Critical hit (for log)</label>
          </div>
          <div class="damage-type-list" id="attackDamageRows" aria-live="polite"></div>
          <div class="modal-actions" style="justify-content:flex-start;padding:0;">
            <button class="btn" id="attackDamageAdd" type="button">Add damage box</button>
          </div>
        </div>
        <div class="modal-actions">
          <button class="btn accent" id="attackResolveSubmit" type="button">Confirm</button>
          <button class="btn" id="attackResolveCancel" type="button">Cancel</button>
        </div>
      </div>
    </div>

    <div class="modal" id="cleavePromptModal" aria-hidden="true">
      <div class="card card-scroll">
        <h2>Cleave Attack</h2>
        <div class="hint" id="cleavePromptBody">Choose one nearby enemy to cleave.</div>
        <div class="action-picker-list" id="cleavePromptList"></div>
        <div class="modal-actions">
          <button class="btn" id="cleavePromptCancel" type="button">Cancel</button>
        </div>
      </div>
    </div>

    <div class="modal" id="colorModal" aria-hidden="true">
      <div class="card">
        <h2>Pick yer token colors</h2>
        <div class="color-section-title">Token</div>
        <div class="row color-row">
          <div class="color-swatch" id="tokenColorSwatch"></div>
          <input class="color-input" type="color" id="tokenColorInput" value="#6aa9ff" />
          <div class="rgb-values" id="tokenColorRgbValues" aria-label="Token RGB value">
            <div class="rgb-box" id="tokenColorR">R: 106</div>
            <div class="rgb-box" id="tokenColorG">G: 169</div>
            <div class="rgb-box" id="tokenColorB">B: 255</div>
          </div>
        </div>
        <div class="color-divider" role="presentation"></div>
        <div class="color-section-title">Border</div>
        <div class="row color-row">
          <div class="color-swatch" id="tokenBorderColorSwatch"></div>
          <input class="color-input" type="color" id="tokenBorderColorInput" value="#ffffff" />
          <div class="rgb-values" id="tokenBorderColorRgbValues" aria-label="Border RGB value">
            <div class="rgb-box" id="tokenBorderColorR">R: 255</div>
            <div class="rgb-box" id="tokenBorderColorG">G: 255</div>
            <div class="rgb-box" id="tokenBorderColorB">B: 255</div>
          </div>
        </div>
        <div class="modal-actions">
          <button class="btn accent" id="tokenColorConfirm">Confirm</button>
          <button class="btn" id="tokenColorCancel">Cancel</button>
        </div>
      </div>
    </div>
    <div class="modal" id="actionPickerModal" aria-hidden="true">
      <div class="card card-scroll">
        <h2 id="actionPickerTitle">Choose an Action</h2>
        <div class="action-picker-list" id="actionPickerList"></div>
        <div class="modal-actions">
          <button class="btn" id="actionPickerCancel">Cancel</button>
        </div>
      </div>
    </div>
    <div class="modal" id="warCasterModal" aria-hidden="true">
      <div class="card">
        <h2>War Caster Reaction</h2>
        <div class="form-field">
          <label for="warCasterSpellSelect">Spell</label>
          <select id="warCasterSpellSelect"></select>
        </div>
        <div class="form-field">
          <label for="warCasterTargetSelect">Target</label>
          <select id="warCasterTargetSelect"></select>
        </div>
        <div class="modal-actions">
          <button class="btn accent" id="warCasterCast" type="button">Cast</button>
          <button class="btn" id="warCasterCancel" type="button">Cancel</button>
        </div>
      </div>
    </div>
    <div class="modal" id="dashModal" aria-hidden="true">
      <div class="card">
        <h2>Use Action or Bonus Action?</h2>
        <div class="modal-actions">
          <button class="btn accent" id="dashAction">Use Action</button>
          <button class="btn accent" id="dashBonusAction">Use Bonus Action</button>
          <button class="btn" id="dashCancel">Cancel</button>
        </div>
      </div>
    </div>
    <aside class="log-overlay" id="logModal" aria-hidden="true">
      <div class="map-view-log-header" id="logHeader">
        <div class="map-view-log-title">Battle Log</div>
        <div class="config-controls">
          <button class="btn" id="logClose" type="button">Hide</button>
        </div>
      </div>
      <div class="log-content" id="logContent"></div>
      <div class="log-resize-handle" id="logResizeHandle" aria-hidden="true"></div>
    </aside>

    <div class="modal" id="helpModal" aria-hidden="true">
      <div class="panel" role="dialog" aria-modal="true" aria-labelledby="helpModalTitle" style="width:min(1200px,96vw)">
        <h2 id="helpModalTitle">Rules Help</h2>
        <div class="modal-actions" style="margin-top:0;">
          <button class="btn" id="helpOpenBook" type="button">Open book</button>
          <button class="btn" id="helpOpenClass" type="button">Open my class</button>
          <button class="btn" id="helpOpenTab" type="button">Open in new tab</button>
          <button class="btn" id="helpClose" type="button">Close</button>
        </div>
        <div class="rules-help-layout">
          <div class="rules-help-left">
            <input class="input rules-help-search" id="helpSearch" type="text" placeholder="Search sections" />
            <div class="rules-help-tree" id="helpTocTree"></div>
          </div>
          <div class="rules-help-right">
            <div class="rules-help-message" id="helpMessage"></div>
            <iframe class="rules-help-frame" id="helpViewer" title="Rules PDF viewer" loading="lazy"></iframe>
          </div>
        </div>
      </div>
    </div>

    <div class="modal" id="configModal" aria-hidden="true">
      <div class="card config-card">
        <h2>Config</h2>
        <div class="modal-body">
          <details class="config-section">
            <summary>Top Bar</summary>
            <div class="config-list">
              <div class="config-item">
                <div class="config-item-title">InitTracker LAN title</div>
                <div class="config-controls">
                  <label class="config-toggle"><input type="checkbox" id="toggleTopbarTitle" />Show</label>
                  <input class="hotkey-input" id="hotkeyTopbarTitle" data-hotkey-action="toggleTopbarTitle" placeholder="Hotkey" readonly />
                </div>
                <div class="hotkey-conflict" id="hotkeyConflictTopbarTitle"></div>
              </div>
              <div class="config-item">
                <div class="config-item-title">Connection indicator</div>
                <div class="config-controls">
                  <label class="config-toggle"><input type="checkbox" id="toggleConnIndicator" />Show</label>
                  <div class="conn-style-toggle" role="group" aria-label="Connection indicator style">
                    <button class="btn conn-style-btn" type="button" data-conn-style="full">Full</button>
                    <button class="btn conn-style-btn" type="button" data-conn-style="compact">Compact</button>
                  </div>
                  <input class="hotkey-input" id="hotkeyConnStyle" data-hotkey-action="toggleConnStyle" placeholder="Hotkey" readonly />
                </div>
                <div class="hotkey-conflict" id="hotkeyConflictConnStyle"></div>
              </div>
              <div class="config-item">
                <div class="config-item-title">Lock Map</div>
                <div class="config-controls">
                  <label class="config-toggle"><input type="checkbox" id="toggleLockMap" />Show</label>
                  <input class="hotkey-input" id="hotkeyLockMap" data-hotkey-action="lockMap" placeholder="Hotkey" readonly />
                </div>
                <div class="hotkey-conflict" id="hotkeyConflictLockMap"></div>
              </div>
              <div class="config-item">
                <div class="config-item-title">Center on Me</div>
                <div class="config-controls">
                  <label class="config-toggle"><input type="checkbox" id="toggleCenterMap" />Show</label>
                  <input class="hotkey-input" id="hotkeyCenterMap" data-hotkey-action="centerMap" placeholder="Hotkey" readonly />
                </div>
                <div class="hotkey-conflict" id="hotkeyConflictCenterMap"></div>
              </div>
              <div class="config-item">
                <div class="config-item-title">Measure</div>
                <div class="config-controls">
                  <label class="config-toggle"><input type="checkbox" id="toggleMeasure" />Show</label>
                  <input class="hotkey-input" id="hotkeyMeasure" data-hotkey-action="measure" placeholder="Hotkey" readonly />
                </div>
                <div class="hotkey-conflict" id="hotkeyConflictMeasure"></div>
              </div>
              <div class="config-item">
                <div class="config-item-title">Clear Measure</div>
                <div class="config-controls">
                  <label class="config-toggle"><input type="checkbox" id="toggleMeasureClear" />Show</label>
                  <input class="hotkey-input" id="hotkeyMeasureClear" data-hotkey-action="measureClear" placeholder="Hotkey" readonly />
                </div>
                <div class="hotkey-conflict" id="hotkeyConflictMeasureClear"></div>
              </div>
              <div class="config-item">
                <div class="config-item-title">Zoom +</div>
                <div class="config-controls">
                  <label class="config-toggle"><input type="checkbox" id="toggleZoomIn" />Show</label>
                  <input class="hotkey-input" id="hotkeyZoomIn" data-hotkey-action="zoomIn" placeholder="Hotkey" readonly />
                </div>
                <div class="hotkey-conflict" id="hotkeyConflictZoomIn"></div>
              </div>
              <div class="config-item">
                <div class="config-item-title">Zoom -</div>
                <div class="config-controls">
                  <label class="config-toggle"><input type="checkbox" id="toggleZoomOut" />Show</label>
                  <input class="hotkey-input" id="hotkeyZoomOut" data-hotkey-action="zoomOut" placeholder="Hotkey" readonly />
                </div>
                <div class="hotkey-conflict" id="hotkeyConflictZoomOut"></div>
              </div>
              <div class="config-item">
              <div class="config-item-title">Battle Log</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="toggleBattleLog" />Show</label>
                <input class="hotkey-input" id="hotkeyBattleLog" data-hotkey-action="battleLog" placeholder="Hotkey" readonly />
              </div>
              <div class="hotkey-conflict" id="hotkeyConflictBattleLog"></div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Battle log font family</div>
              <div class="config-controls">
                <select id="battleLogFontFamily">
                  <option value="system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif">System</option>
                  <option value="ui-sans-serif,Arial,Helvetica,sans-serif">Sans-serif</option>
                  <option value="Georgia,Times New Roman,serif">Serif</option>
                  <option value="ui-monospace,SFMono-Regular,Menlo,Consolas,monospace">Monospace</option>
                </select>
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Battle log text size</div>
              <div class="config-controls">
                <input id="battleLogFontSize" type="range" min="11" max="28" step="1" />
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">DM side log panel</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="toggleDmLogPanel" />Show</label>
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">DM map preview</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="toggleDmMapPreview" />Show</label>
              </div>
            </div>
          </div>
        </details>
        <details class="config-section">
          <summary>Bottom Bar</summary>
          <div class="config-list">
            <div class="config-item">
              <div class="config-item-title">Action</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="toggleUseAction" />Show</label>
                <input class="hotkey-input" id="hotkeyUseAction" data-hotkey-action="useAction" placeholder="Hotkey" readonly />
              </div>
              <div class="hotkey-conflict" id="hotkeyConflictUseAction"></div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Bonus Action</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="toggleUseBonusAction" />Show</label>
                <input class="hotkey-input" id="hotkeyUseBonusAction" data-hotkey-action="useBonusAction" placeholder="Hotkey" readonly />
              </div>
              <div class="hotkey-conflict" id="hotkeyConflictUseBonusAction"></div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Dash</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="toggleDash" />Show</label>
                <input class="hotkey-input" id="hotkeyDash" data-hotkey-action="dash" placeholder="Hotkey" readonly />
              </div>
              <div class="hotkey-conflict" id="hotkeyConflictDash"></div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Stand</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="toggleStandUp" />Show</label>
                <input class="hotkey-input" id="hotkeyStandUp" data-hotkey-action="standUp" placeholder="Hotkey" readonly />
              </div>
              <div class="hotkey-conflict" id="hotkeyConflictStandUp"></div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Reset</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="toggleResetTurn" />Show</label>
                <input class="hotkey-input" id="hotkeyResetTurn" data-hotkey-action="resetTurn" placeholder="Hotkey" readonly />
              </div>
              <div class="hotkey-conflict" id="hotkeyConflictResetTurn"></div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Toggle bottom panel</div>
              <div class="config-controls">
                <input class="hotkey-input" id="hotkeyToggleSheetPanel" data-hotkey-action="toggleSheetPanel" placeholder="Hotkey" readonly />
              </div>
              <div class="hotkey-conflict" id="hotkeyConflictToggleSheetPanel"></div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Attack overlay</div>
              <div class="config-controls">
                <input class="hotkey-input" id="hotkeyAttackOverlay" data-hotkey-action="toggleAttackOverlay" placeholder="Hotkey" readonly />
              </div>
              <div class="hotkey-conflict" id="hotkeyConflictAttackOverlay"></div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Hide spell menu for non spell casters</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="toggleSpellMenu" />Hide</label>
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Bottom panel height</div>
              <div class="config-controls">
                <input id="sheetHeight" type="range" min="180" max="720" step="2" />
              </div>
            </div>
          </div>
        </details>
        <details class="config-section">
          <summary>Initiative Display</summary>
          <div class="config-list">
            <div class="config-item">
              <div class="config-item-title">Text size</div>
              <div class="config-controls">
                <input id="mapViewTextSize" type="range" min="10" max="28" step="1" />
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Bar height</div>
              <div class="config-controls">
                <input id="mapViewBarHeight" type="range" min="56" max="140" step="2" />
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Chip padding</div>
              <div class="config-controls">
                <input id="mapViewChipPadding" type="range" min="4" max="18" step="1" />
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Chip gap</div>
              <div class="config-controls">
                <input id="mapViewChipGap" type="range" min="2" max="20" step="1" />
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Chip radius</div>
              <div class="config-controls">
                <input id="mapViewCornerRadius" type="range" min="6" max="40" step="2" />
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Rotate handle scale</div>
              <div class="config-controls">
                <input id="mapViewRotateHandleScale" type="range" min="0.8" max="2.4" step="0.1" />
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Show tracker title</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="mapViewShowTitle" />Show</label>
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Show status</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="mapViewShowStatus" />Show</label>
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Show turn index</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="mapViewShowIndex" />Show</label>
              </div>
            </div>
          </div>
        </details>
        <details class="config-section">
          <summary>Notifications</summary>
          <div class="config-list">
            <div class="config-item">
              <div class="config-item-title">Push notifications</div>
              <div class="config-controls">
                <button class="btn" id="enableNotifications" type="button">Enable</button>
                <div class="preset-status" id="notificationStatus" aria-live="polite"></div>
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Focus tab on my turn</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="focusTabOnTurn" />Focus</label>
              </div>
            </div>
          </div>
        </details>
        <div class="hint hidden" id="iosInstallHint">
          Open Safari  Share  Add to Home Screen.
          <a href="https://support.apple.com/en-us/HT201366" target="_blank" rel="noopener">Learn more</a>
        </div>
        </div>
        <div class="modal-actions">
          <button class="btn" id="configClose">Close</button>
        </div>
      </div>
    </div>
  </div>
    </div>
  </div>

  <div class="sheet-wrap" id="sheetWrap">
    <div class="sheet-handle" id="sheetHandle" role="separator" aria-orientation="horizontal" aria-label="Resize sheet"></div>
    <div class="sheet" id="sheet">
      <div class="sheet-content">
      <div class="row">
        <div class="label">Ye be:</div>
        <div class="value" id="me">(unclaimed)</div>
        <button class="btn" id="switchCharacter" type="button">Switch character</button>
        <div class="spacer"></div>
        <div class="sheet-actions">
          <button class="btn" id="useAction">Use Action</button>
          <button class="btn" id="useBonusAction">Use Bonus Action</button>
          <button class="btn" id="useReaction">Reaction</button>
          <button class="btn" id="dash">Dash</button>
          <button class="btn" id="standUp">Stand Up</button>
          <button class="btn" id="resetTurn">Reset Turn</button>
          <button class="btn" id="dismissSummons">Dismiss Summons</button>
          <button class="btn mount hidden" id="mountBtn">Mount</button>
          <button class="btn hidden" id="dismountBtn">Dismount</button>
        </div>
      </div>
      <div class="row">
        <div class="form-field">
          <label for="actionSelect">Action</label>
          <select id="actionSelect">
            <option value="">None/Custom</option>
          </select>
        </div>
        <div class="form-field">
          <label for="bonusActionSelect">Bonus Action</label>
          <select id="bonusActionSelect">
            <option value="">None/Custom</option>
          </select>
        </div>
        <div class="form-field">
          <label for="attackWeaponSelect">Attack Weapon</label>
          <select id="attackWeaponSelect">
            <option value="">Auto (first configured)</option>
          </select>
        </div>
      </div>
      <div class="row">
        <div class="chip" id="move">Move: </div>
        <div class="chip" id="action">Action: </div>
        <div class="chip" id="attackResource">Attacks: </div>
        <div class="chip" id="bonusAction">Bonus Action: </div>
        <div class="chip" id="reaction">Reaction: </div>
        <div class="chip" id="turn">Turn: </div>
        <div class="chip" id="note">Tip: drag yer token  hold Shift to drag AoE (touch-hold ok)</div>
        <label class="chip"><input type="checkbox" id="showAllNames">Show All Names</label>
      </div>
      <div class="row hp-bar-wrap" id="playerHpBarWrap" aria-live="polite">
        <div class="hp-bar-track"><div class="hp-bar-fill" id="playerHpBarFill"></div></div>
        <div class="hp-bar-label" id="playerHpBarLabel">HP </div>
      </div>
      <fieldset class="turn-alerts-panel" id="turnAlertsPanel">
        <legend>Turn Alerts</legend>
        <div class="turn-alerts-row">
          <div class="turn-alerts-status" id="turnAlertStatus" aria-live="polite">Not installed.</div>
          <button class="btn" id="unlockAudio" type="button">Enable sounds</button>
          <button class="btn" id="enableTurnAlerts" type="button">Enable Turn Alerts</button>
          <button class="btn" id="hideTurnAlerts" type="button">Hide</button>
        </div>
        <div class="turn-alerts-note">Only works when installed as an app.</div>
      </fieldset>
      <div class="row spell-slot-monitor-row">
        <div class="spell-slot-monitor" id="spellSlotMonitor" aria-label="Spell slot monitor"></div>
      </div>
      <div class="row">
        <details class="resource-pools-panel" id="resourcePoolsPanel">
          <summary>Resource Pools</summary>
          <div class="resource-pool-list" id="resourcePoolsList"></div>
        </details>
      </div>
      <div class="cast-menu-trigger" id="castMenuTrigger">
        <button class="btn" id="castOverlayOpen" type="button">Cast Spell</button>
      </div>
      </div>
    </div>
    <div class="cast-overlay hidden" id="sheetCastView" aria-hidden="true">
      <div class="cast-overlay-header">
        <button class="btn" id="castOverlayBack" type="button">Back</button>
        <div class="cast-overlay-title" id="castOverlayTitle">Cast Spell</div>
        <div class="cast-overlay-spacer"></div>
        <button class="btn" id="spellbookOpen" type="button">Manage Spells</button>
        <button class="btn" id="wildShapeManageOpen" type="button">Manage Wild Shapes</button>
      </div>
      <div class="cast-overlay-body" role="dialog" aria-modal="true" aria-labelledby="castOverlayTitle">
        <div class="cast-panel" id="castPanel">
          <form id="castForm">
            <div class="spell-filter-toolbar">
              <div class="form-field">
                <label for="castSearch">Search</label>
                <input id="castSearch" type="search" placeholder="Search name, tags, description" />
              </div>
              <button class="btn" id="openSpellFilters" type="button">Filters</button>
              <div class="spell-filter-summary" id="spellFilterSummary">No filters active.</div>
            </div>
            <div class="spell-filter-modal" id="spellFilterModal" aria-hidden="true">
              <div class="spell-filter-drawer" role="dialog" aria-modal="true" aria-labelledby="spellFilterModalTitle">
                <div class="spell-filter-drawer-header">
                  <strong id="spellFilterModalTitle">Spell Filters</strong>
                  <div class="spell-select-spacer"></div>
                  <button class="btn" id="closeSpellFilters" type="button">Close</button>
                </div>
                <div class="spell-filter-drawer-body">
                  <div class="form-grid">
                    <div class="form-field">
                      <label for="castFilterLevelMin">Level Min</label>
                      <select id="castFilterLevelMin">
                        <option value="" selected>Any</option>
                        <option value="0">Cantrip</option>
                        <option value="1">1st</option>
                        <option value="2">2nd</option>
                        <option value="3">3rd</option>
                        <option value="4">4th</option>
                        <option value="5">5th</option>
                        <option value="6">6th</option>
                        <option value="7">7th</option>
                        <option value="8">8th</option>
                        <option value="9">9th</option>
                      </select>
                    </div>
                    <div class="form-field">
                      <label for="castFilterLevelMax">Level Max</label>
                      <select id="castFilterLevelMax">
                        <option value="" selected>Any</option>
                        <option value="0">Cantrip</option>
                        <option value="1">1st</option>
                        <option value="2">2nd</option>
                        <option value="3">3rd</option>
                        <option value="4">4th</option>
                        <option value="5">5th</option>
                        <option value="6">6th</option>
                        <option value="7">7th</option>
                        <option value="8">8th</option>
                        <option value="9">9th</option>
                      </select>
                    </div>
                    <div class="form-field">
                      <label for="castFilterCastingTime">Casting Time</label>
                      <select id="castFilterCastingTime"><option value="" selected>Any</option></select>
                    </div>
                    <div class="form-field">
                      <label for="castFilterRange">Range</label>
                      <select id="castFilterRange"><option value="" selected>Any</option></select>
                    </div>
                  </div>
                  <details class="multi-select" id="castFilterSchoolMulti">
                    <summary>Schools: Any</summary>
                    <div class="multi-select-options" id="castFilterSchoolOptions"></div>
                  </details>
                  <details class="multi-select" id="castFilterTagMulti">
                    <summary>Tags: Any</summary>
                    <div class="multi-select-options" id="castFilterTagOptions"></div>
                  </details>
                  <details class="multi-select" id="castFilterListMulti">
                    <summary>Lists: Any</summary>
                    <div class="multi-select-options" id="castFilterListOptions"></div>
                  </details>
                  <details class="advanced-filter-toggle" id="advancedSpellFilters">
                    <summary>Advanced Filters</summary>
                    <div class="form-grid" style="margin-top:8px;">
                      <label class="chip"><input type="checkbox" id="castFilterRitual"> Ritual only</label>
                      <label class="chip"><input type="checkbox" id="castFilterConcentration"> Concentration only</label>
                    </div>
                  </details>
                </div>
                <div class="spell-filter-drawer-actions">
                  <button class="btn" id="clearSpellFilters" type="button">Clear</button>
                  <button class="btn" id="applySpellFilters" type="button">Apply</button>
                </div>
              </div>
            </div>
          <div class="form-grid">
            <div class="form-field">
              <label for="castPreset">Preset <span class="manual-entry-badge" id="castManualEntryBadge" title="Manual entry required.">Manual entry required</span></label>
              <div class="spell-select-controls">
                <select id="castPreset">
                  <option value="" selected>Custom</option>
                </select>
              </div>
            </div>
            <div class="form-field">
              <label for="castName">Name</label>
              <input id="castName" type="text" placeholder="Fireball" />
            </div>
            <div class="form-field">
              <label for="castSlotLevel">Slot Level</label>
              <input id="castSlotLevel" type="number" min="0" step="1" placeholder="1" disabled />
            </div>
          </div>
          <div class="form-grid" id="aoeOptions">
            <div class="form-field">
              <label for="castShape">Shape</label>
              <select id="castShape">
                <option value="" selected>Choose shape</option>
                <option value="circle">Circle</option>
                <option value="square">Square</option>
                <option value="line">Line</option>
                <option value="sphere">Sphere</option>
                <option value="cube">Cube</option>
                <option value="cone">Cone</option>
                <option value="cylinder">Cylinder</option>
                <option value="wall">Wall</option>
              </select>
            </div>
            <div class="form-field cast-size-field" id="castRadiusField">
              <label for="castRadius">Radius (ft)</label>
              <input id="castRadius" type="number" min="5" step="5" value="10" readonly disabled />
            </div>
            <div class="form-field cast-size-field" id="castSideField">
              <label for="castSide">Side (ft)</label>
              <input id="castSide" type="number" min="5" step="5" value="10" readonly disabled />
            </div>
            <div class="form-field cast-size-field" id="castLengthField">
              <label for="castLength">Length (ft)</label>
              <input id="castLength" type="number" min="5" step="5" value="30" readonly disabled />
            </div>
            <div class="form-field cast-size-field" id="castWidthField">
              <label for="castWidth">Width (ft)</label>
              <input id="castWidth" type="number" min="5" step="5" value="5" readonly disabled />
            </div>
            <div class="form-field cast-size-field" id="castAngleField">
              <label for="castAngle">Angle (deg)</label>
              <input id="castAngle" type="number" min="0" step="5" value="90" readonly disabled />
            </div>
            <div class="form-field cast-size-field" id="castOrientField">
              <label for="castOrient">Orientation</label>
              <select id="castOrient" disabled>
                <option value="vertical" selected>Vertical</option>
                <option value="horizontal">Horizontal</option>
              </select>
            </div>
            <div class="form-field cast-size-field" id="castThicknessField">
              <label for="castThickness">Thickness (ft)</label>
              <input id="castThickness" type="number" min="1" step="1" value="5" readonly disabled />
            </div>
            <div class="form-field cast-size-field" id="castHeightField">
              <label for="castHeight">Height (ft)</label>
              <input id="castHeight" type="number" min="1" step="1" value="10" readonly disabled />
            </div>
            <div class="form-field">
              <label for="castDcType">DC Type</label>
              <select id="castDcType">
                <option value="">None</option>
                <option value="str">STR</option>
                <option value="dex">DEX</option>
                <option value="con">CON</option>
                <option value="int">INT</option>
                <option value="wis">WIS</option>
                <option value="cha">CHA</option>
              </select>
            </div>
            <div class="form-field">
              <label for="castDcValue">Save DC</label>
              <input id="castDcValue" type="number" min="0" step="1" placeholder="15" />
            </div>
            <div class="form-field">
              <label for="castDefaultDamage">Default Damage</label>
              <input id="castDefaultDamage" type="text" placeholder="28" />
            </div>
            <div class="form-field">
              <label for="castDice">Damage Dice</label>
              <input id="castDice" type="text" placeholder="8d6" />
            </div>
            <div class="form-field">
              <label for="castDamageType">Damage Types</label>
              <div class="damage-type-controls">
                <select id="castDamageType">
                  <option value="" selected>Select a type</option>
__DAMAGE_TYPE_OPTIONS__
                </select>
                <button class="btn" type="button" id="castAddDamageType">Add</button>
              </div>
              <div class="damage-type-list" id="castDamageTypeList" aria-live="polite"></div>
            </div>
            <div class="form-field">
              <label for="castColor">Color</label>
              <input id="castColor" type="color" value="#6aa9ff" />
            </div>
          </div>
          <div id="summonOptions" class="hidden">
            <div class="form-grid">
              <div class="form-field" id="castSummonChoiceField">
                <label for="castSummonChoice">Summon</label>
                <select id="castSummonChoice"></select>
              </div>
              <div class="form-field" id="castSummonVariantField">
                <label for="castSummonVariant">Variant</label>
                <select id="castSummonVariant"></select>
              </div>
              <div class="form-field" id="castSummonQuantityField">
                <label for="castSummonQuantity">Quantity</label>
                <input id="castSummonQuantity" type="number" min="1" step="1" value="1" />
              </div>
              <div class="form-field hidden" id="castCustomSummonNameField">
                <label for="castCustomSummonName">Summon Name</label>
                <input id="castCustomSummonName" type="text" placeholder="Custom summon" />
              </div>
              <div class="form-field hidden" id="castCustomSummonMonsterSearchField">
                <label for="castCustomSummonMonsterSearch">Search Monster YAMLs</label>
                <input id="castCustomSummonMonsterSearch" type="search" placeholder="Search monsters..." />
              </div>
              <div class="form-field hidden" id="castCustomSummonMonsterField">
                <label for="castCustomSummonMonster">Monster YAML</label>
                <select id="castCustomSummonMonster"></select>
              </div>
              <div class="form-field hidden" id="castCustomSummonTypeField">
                <label for="castCustomSummonType">Type</label>
                <input id="castCustomSummonType" type="text" placeholder="construct" />
              </div>
              <div class="form-field hidden" id="castCustomSummonHpField">
                <label for="castCustomSummonHp">HP</label>
                <input id="castCustomSummonHp" type="number" min="1" step="1" value="30" />
              </div>
              <div class="form-field hidden" id="castCustomSummonAcField">
                <label for="castCustomSummonAc">AC</label>
                <input id="castCustomSummonAc" type="number" min="1" step="1" value="10" />
              </div>
              <div class="form-field hidden" id="castCustomSummonWalkField">
                <label for="castCustomSummonWalk">Walk (ft)</label>
                <input id="castCustomSummonWalk" type="number" min="0" step="5" value="30" />
              </div>
              <div class="form-field hidden" id="castCustomSummonSwimField">
                <label for="castCustomSummonSwim">Swim (ft)</label>
                <input id="castCustomSummonSwim" type="number" min="0" step="5" value="0" />
              </div>
              <div class="form-field hidden" id="castCustomSummonFlyField">
                <label for="castCustomSummonFly">Fly (ft)</label>
                <input id="castCustomSummonFly" type="number" min="0" step="5" value="0" />
              </div>
              <div class="form-field hidden" id="castCustomSummonBurrowField">
                <label for="castCustomSummonBurrow">Burrow (ft)</label>
                <input id="castCustomSummonBurrow" type="number" min="0" step="5" value="0" />
              </div>
              <div class="form-field hidden" id="castCustomSummonClimbField">
                <label for="castCustomSummonClimb">Climb (ft)</label>
                <input id="castCustomSummonClimb" type="number" min="0" step="5" value="0" />
              </div>
              <div class="form-field hidden" id="castCustomSummonStrField">
                <label for="castCustomSummonStr">STR</label>
                <input id="castCustomSummonStr" type="number" min="1" max="30" step="1" value="10" />
              </div>
              <div class="form-field hidden" id="castCustomSummonDexField">
                <label for="castCustomSummonDex">DEX</label>
                <input id="castCustomSummonDex" type="number" min="1" max="30" step="1" value="10" />
              </div>
              <div class="form-field hidden" id="castCustomSummonConField">
                <label for="castCustomSummonCon">CON</label>
                <input id="castCustomSummonCon" type="number" min="1" max="30" step="1" value="10" />
              </div>
              <div class="form-field hidden" id="castCustomSummonIntField">
                <label for="castCustomSummonInt">INT</label>
                <input id="castCustomSummonInt" type="number" min="1" max="30" step="1" value="10" />
              </div>
              <div class="form-field hidden" id="castCustomSummonWisField">
                <label for="castCustomSummonWis">WIS</label>
                <input id="castCustomSummonWis" type="number" min="1" max="30" step="1" value="10" />
              </div>
              <div class="form-field hidden" id="castCustomSummonChaField">
                <label for="castCustomSummonCha">CHA</label>
                <input id="castCustomSummonCha" type="number" min="1" max="30" step="1" value="10" />
              </div>
              <div class="form-field hidden" id="castCustomSummonRangeField">
                <label for="castCustomSummonRange">Range (ft)</label>
                <input id="castCustomSummonRange" type="number" min="0" step="5" value="30" />
              </div>
            </div>
            <div class="spell-details" id="castSummonMeta" aria-live="polite"></div>
          </div>
          <div class="spell-details" id="spellPresetDetails" aria-live="polite">
            Select a preset to see spell details.
          </div>
          <div class="form-actions">
            <button class="btn accent" id="castSubmit" type="submit">Cast</button>
          </div>
        </form>
      </div>
    </div>

  </div>
  </div>
</div>
<div class="modal" id="mountPromptModal" aria-hidden="true">
  <div class="card">
    <h2>Mount Request</h2>
    <div class="hint" id="mountPromptBody">Someone wants to mount you. OK?</div>
    <div class="modal-actions">
      <button class="btn accent" id="mountPromptYes">Yes</button>
      <button class="btn" id="mountPromptNo">No</button>
    </div>
  </div>
</div>
<div class="spellbook-overlay" id="spellbookOverlay" aria-hidden="true">
  <div class="spellbook-header">
    <button class="btn" id="spellbookBack" type="button">Back</button>
    <div class="spellbook-title" id="spellbookTitle">Manage Spells</div>
    <div class="spellbook-spacer"></div>
    <button class="btn accent" id="spellbookSave" type="button">Save</button>
  </div>
  <div class="spellbook-body">
    <div class="spellbook-tabs">
      <button class="btn" id="spellbookTabKnown" type="button">Known Spells</button>
      <button class="btn" id="spellbookTabPrepared" type="button">Prepared Spells</button>
      <label class="chip spellbook-toggle"><input type="checkbox" id="spellbookKnownEnabled" />Known spells enabled</label>
    </div>
    <div class="spellbook-controls">
      <input id="spellbookSearch" type="search" placeholder="Search spells..." />
      <select id="spellbookSort">
        <option value="alpha" selected>Name</option>
        <option value="level">Level</option>
      </select>
    </div>
    <div class="spellbook-columns">
      <div class="spellbook-column">
        <div class="spellbook-column-title" id="spellbookLeftTitle">All Spells</div>
        <div class="spellbook-list" id="spellbookLeftList"></div>
      </div>
      <div class="spellbook-column spellbook-actions">
        <button class="btn" id="spellbookAdd" type="button">Add </button>
        <button class="btn" id="spellbookRemove" type="button"> Remove</button>
      </div>
      <div class="spellbook-column">
        <div class="spellbook-column-title" id="spellbookRightTitle">Known Spells</div>
        <div class="spellbook-list" id="spellbookRightList"></div>
      </div>
    </div>
    <div class="spellbook-status" id="spellbookStatus"></div>
  </div>
  <button class="btn spellbook-back-fab" id="spellbookBackFloating" type="button" aria-label="Close spellbook">Close</button>
</div>
<div class="spell-detail-overlay" id="spellDetailOverlay" aria-hidden="true">
  <div class="spell-detail-header">
    <button class="btn" id="spellDetailBack" type="button">Back</button>
    <div class="spell-detail-title" id="spellDetailTitle">Spell Details</div>
    <div class="spell-detail-spacer"></div>
  </div>
  <div class="spell-detail-body">
    <div class="spell-detail-card">
      <div class="spell-detail-heading">
        <span id="spellDetailName">Spell</span>
        <span class="spell-detail-meta" id="spellDetailMeta"></span>
      </div>
      <div class="form-field">
        <label for="spellDetailColorInput">Spell Color</label>
        <div class="spell-detail-color-row">
          <span class="spell-color-swatch" id="spellDetailColorSwatch"></span>
          <input class="color-input" type="color" id="spellDetailColorInput" value="#6aa9ff" />
          <input class="spell-detail-color-value" id="spellDetailColorValue" type="text" inputmode="text" autocomplete="off" />
        </div>
      </div>
      <div class="spell-detail-meta" id="spellDetailStatus"></div>
    </div>
    <div class="spell-detail-card">
      <div class="spell-detail-heading">Spell Details</div>
      <div class="spell-details-grid" id="spellDetailGrid"></div>
    </div>
  </div>
</div>
<div class="modal" id="spellbookConfirmModal" aria-hidden="true">
  <div class="card">
    <h2>Confirm Spellbook</h2>
    <p class="spellbook-confirm-text" id="spellbookConfirmText">Overwrite player file?</p>
    <div class="modal-actions">
      <button class="btn" id="spellbookConfirmCancel" type="button">Cancel</button>
      <button class="btn accent" id="spellbookConfirmYes" type="button">Overwrite</button>
    </div>
  </div>
</div>
<div class="spell-library-overlay" id="spellLibraryOverlay" aria-hidden="true">
  <div class="spell-library-header">
    <button class="btn" id="spellLibraryClose" type="button">Back</button>
    <div class="spell-library-title">Spellbook</div>
    <div class="spell-library-spacer"></div>
    <div class="spell-library-controls">
      <input id="spellLibrarySearch" type="search" placeholder="Search spells..." />
      <select id="spellLibrarySort">
        <option value="alpha" selected>Name</option>
        <option value="level">Level</option>
      </select>
    </div>
  </div>
  <div class="spell-library-body">
    <div class="spell-library-status" id="spellLibraryStatus">Loading spells</div>
    <div class="spell-library-list" id="spellLibraryList"></div>
  </div>
</div>

<div class="modal" id="wildShapeMenuOverlay" aria-hidden="true">
  <div class="card">
    <h2>Wild Shape</h2>
    <div class="wildshape-menu-actions">
      <button class="btn" id="wildShapeMenuManagePool" type="button">Manage Resource Pool</button>
      <button class="btn" id="wildShapeMenuManageForms" type="button">Manage Wildshapes</button>
      <button class="btn success" id="wildShapeMenuApply" type="button">Wildshape</button>
      <button class="btn" id="wildShapeMenuRevert" type="button" style="display:none;">Revert</button>
      <button class="btn" id="wildShapeMenuRegainUse" type="button">Wild Resurgence: Regain Use</button>
      <button class="btn" id="wildShapeMenuRegainSpell" type="button">Wild Resurgence: Regain Spell Slot</button>
      <button class="btn" id="wildShapeMenuClose" type="button">Close</button>
    </div>
  </div>
</div>
<div class="modal" id="wildShapePoolOverlay" aria-hidden="true">
  <div class="card">
    <h2>Manage Wild Shape Resource Pool</h2>
    <div class="spellbook-status" id="wildShapePoolSummary"></div>
    <div class="wildshape-pool-row">
      <button class="btn" id="wildShapePoolDec" type="button"></button>
      <input id="wildShapePoolCurrentInput" type="number" min="0" step="1" />
      <button class="btn" id="wildShapePoolInc" type="button">+</button>
    </div>
    <div class="modal-actions" style="margin-top:10px;">
      <button class="btn" id="wildShapePoolBack" type="button">Back</button>
      <button class="btn accent" id="wildShapePoolApply" type="button">Apply</button>
    </div>
  </div>
</div>
<div class="modal" id="wildShapePickOverlay" aria-hidden="true">
  <div class="card">
    <h2>Choose Wild Shape Form</h2>
    <div class="spellbook-list" id="wildShapePickList" style="max-height:50vh;"></div>
    <div class="modal-actions" style="margin-top:10px;">
      <button class="btn" id="wildShapePickBack" type="button">Back</button>
    </div>
  </div>
</div>
<div class="modal" id="secondWindOverlay" aria-hidden="true">
  <div class="card">
    <h2>Second Wind</h2>
    <div class="spellbook-status" id="secondWindSummary"></div>
    <div class="spellbook-status" id="secondWindRules">
      Roll 1d10, enter the die result below, and this will add your fighter level automatically.
      Core Mechanics: Bonus Action to regain 1d10 + fighter level HP. Uses: 2 at level 1, 3 at level 4, 4 at level 10. Recharging: regain 1 use on Short Rest, all uses on Long Rest.
      Tactical Mind (Level 2): When you fail an ability check, expend a use to add 1d10; if the check still fails, the use is not expended.
      Tactical Shift (Level 5): When you activate Second Wind, move up to half your Speed without provoking Opportunity Attacks.
    </div>
    <div class="wildshape-pool-row" style="margin-top:8px;">
      <label for="secondWindRollInput">d10 roll</label>
      <input id="secondWindRollInput" type="number" min="1" max="10" step="1" placeholder="1-10" />
    </div>
    <div class="modal-actions" style="margin-top:10px;">
      <button class="btn" id="secondWindCancel" type="button">Cancel</button>
      <button class="btn accent" id="secondWindUse" type="button">Use 1 Charge</button>
    </div>
  </div>
</div>
<div class="modal" id="layOnHandsOverlay" aria-hidden="true">
  <div class="card">
    <h2>Lay on Hands</h2>
    <div class="spellbook-status" id="layOnHandsSummary"></div>
    <div class="spellbook-status" id="layOnHandsTarget"></div>
    <div class="wildshape-pool-row" style="margin-top:8px;">
      <label for="layOnHandsAmountInput">HP to heal</label>
      <input id="layOnHandsAmountInput" type="number" min="1" step="1" placeholder="1+" />
    </div>
    <div class="modal-actions" style="margin-top:10px;">
      <button class="btn" id="layOnHandsCancel" type="button">Cancel</button>
      <button class="btn accent" id="layOnHandsUse" type="button">Heal</button>
    </div>
  </div>
</div>
<div class="spellbook-overlay" id="wildShapeOverlay" aria-hidden="true">
  <div class="spellbook-header">
    <button class="btn" id="wildShapeBack" type="button">Back</button>
    <div class="spellbook-title" id="wildShapeTitle">Manage Wild Shapes</div>
    <div class="spellbook-spacer"></div>
    <button class="btn accent" id="wildShapeSave" type="button">Save</button>
  </div>
  <div class="spellbook-body">
    <div class="spellbook-controls">
      <input id="wildShapeSearch" type="search" placeholder="Search beast forms..." />
      <label class="chip spellbook-toggle"><input type="checkbox" id="wildShapeShowLocked" />Show locked forms</label>
    </div>
    <div class="spellbook-columns">
      <div class="spellbook-column">
        <div class="spellbook-column-title">Available Beast Forms</div>
        <div class="spellbook-list" id="wildShapeLeftList"></div>
      </div>
      <div class="spellbook-column spellbook-actions">
        <button class="btn" id="wildShapeAdd" type="button">Add </button>
        <button class="btn" id="wildShapeRemove" type="button"> Remove</button>
      </div>
      <div class="spellbook-column">
        <div class="spellbook-column-title">Known Forms</div>
        <div class="spellbook-list" id="wildShapeRightList"></div>
      </div>
    </div>
    <div class="spellbook-status" id="wildShapeStatus"></div>
  </div>
</div>
<div class="turn-modal" id="turnModal" aria-hidden="true">
  <div class="turn-card" role="dialog" aria-live="assertive">
    <h2>Its your turn!</h2>
    <button class="btn accent" id="turnModalOk">OK</button>
  </div>
</div>

<script>
(() => {
  const logClientError = (payload) => {
    try {
      console.error("Client error:", payload);
      fetch("/api/client-log", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify(payload),
      }).catch(() => {});
    } catch (err) {
      console.error("Failed to report client error:", err);
    }
  };

  window.onerror = (message, source, line, column, error) => {
    const stack = error?.stack ? String(error.stack) : "";
    logClientError({
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      url: location.href,
      stack: stack || `${message} at ${source}:${line}:${column}`,
    });
  };

  window.onunhandledrejection = (event) => {
    const reason = event?.reason;
    const stack = reason?.stack ? String(reason.stack) : "";
    const message = reason?.message ? String(reason.message) : String(reason || "");
    logClientError({
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      url: location.href,
      stack: stack || message || "Unhandled promise rejection",
    });
  };
})();

(() => {
  document.addEventListener("contextmenu", (e) => e.preventDefault());
  const canVibrate = "vibrate" in navigator;
  function vibrate(pattern){
    if (!canVibrate) return false;
    return navigator.vibrate(pattern);
  }

  const qs = new URLSearchParams(location.search);
  const normalizedPath = location.pathname.replace(/\/+$/, "") || "/";
  const isMapView = false;
  const isMapViewOnly = false;
  const isPlanning = normalizedPath === "/planning";
  const wsPath = "/ws";
  const wsUrl = (() => {
    const lanBase = (window.LAN_BASE_URL || "").trim();
    const fallbackOrigin = (location.origin && location.origin !== "null") ? location.origin : "";
    const baseCandidate = lanBase || fallbackOrigin;
    if (!baseCandidate){
      const host = location.host || location.hostname;
      if (!host) return "";
      const proto = location.protocol === "https:" ? "wss" : "ws";
      return `${proto}://${host}${wsPath}`;
    }
    try {
      const baseUrl = new URL(baseCandidate, location.href);
      const wsUrlObj = new URL(wsPath, baseUrl);
      wsUrlObj.protocol = wsUrlObj.protocol === "https:" ? "wss:" : "ws:";
      return wsUrlObj.toString();
    } catch (err){
      console.warn("Failed to resolve websocket base URL.", {baseCandidate, err});
      return "";
    }
  })();
  const pushPublicKey = (window.PUSH_PUBLIC_KEY || "").trim();
  const turnAlertStorageKey = "inittracker_turnAlertSubscription";
  const turnAlertHideKey = "inittracker_hideTurnAlerts";
  const spellFilterStorageKey = "inittracker_spellFilters_v2";
  const focusTabOnTurnStorageKey = "inittracker_focus_tab_on_turn";
  const clientIdStorageKey = "inittracker_client_id";
  let swRegistration = null;
  const cidWarningCache = new Set();
  const warnCid = (context, value, reason) => {
    const key = `${context}:${reason}`;
    if (cidWarningCache.has(key)) return;
    cidWarningCache.add(key);
    console.warn(`[CID normalize] ${context}: ${reason}`, {value});
  };
  const normalizeCid = (value, context = "cid") => {
    if (value === null || value === undefined || value === "") return null;
    if (typeof value === "number"){
      if (!Number.isFinite(value)){
        warnCid(context, value, "non-finite number");
        return null;
      }
      if (!Number.isInteger(value)){
        warnCid(context, value, "non-integer number");
        return null;
      }
      return value;
    }
    if (typeof value === "string"){
      const trimmed = value.trim();
      if (!trimmed) return null;
      const parsed = Number(trimmed);
      if (!Number.isFinite(parsed) || !Number.isInteger(parsed)){
        warnCid(context, value, "unusable string");
        return null;
      }
      warnCid(context, value, "coerced string to number");
      return parsed;
    }
    warnCid(context, value, `unsupported ${typeof value}`);
    return null;
  };
  const cidMatches = (left, right, context = "cidMatch") => {
    const leftCid = normalizeCid(left, `${context}.left`);
    const rightCid = normalizeCid(right, `${context}.right`);
    return leftCid !== null && rightCid !== null && leftCid === rightCid;
  };

  function setNotificationStatus(message){
    if (!notificationStatus) return;
    notificationStatus.textContent = message;
  }

  function setTurnAlertStatus(message){
    if (!turnAlertStatus) return;
    turnAlertStatus.textContent = message;
  }

  function isStandaloneDisplay(){
    return window.matchMedia("(display-mode: standalone)").matches || window.navigator.standalone;
  }

  function getTurnAlertIdentity(){
    const playerId = normalizeCid(claimedCid, "turnAlert.playerId");
    const claimedUnit = getClaimedUnit();
    const playerName = claimedUnit?.name ? String(claimedUnit.name) : "";
    return {
      playerId,
      username: null,
      playerName: playerName || null,
    };
  }

  function formatTurnAlertLabel(identity){
    if (identity?.playerName) return identity.playerName;
    if (identity?.username) return identity.username;
    if (identity?.playerId !== null && identity?.playerId !== undefined){
      return `#${identity.playerId}`;
    }
    return "";
  }

  function persistTurnAlertSubscription(subscription, identity){
    if (!subscription) return;
    const payload = {
      subscription: subscription.toJSON ? subscription.toJSON() : subscription,
      playerId: identity?.playerId ?? null,
      username: identity?.username ?? null,
      label: formatTurnAlertLabel(identity),
      createdAt: new Date().toISOString(),
    };
    try {
      localStorage.setItem(turnAlertStorageKey, JSON.stringify(payload));
    } catch (err){
      console.warn("Unable to store turn alert subscription.", err);
    }
  }

  function loadTurnAlertSubscription(){
    try {
      const raw = localStorage.getItem(turnAlertStorageKey);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (parsed && typeof parsed === "object") return parsed;
    } catch (err){
      console.warn("Unable to read turn alert subscription.", err);
    }
    return null;
  }

  function formatTurnAlertStatus(identity){
    const label = formatTurnAlertLabel(identity);
    return label ? `Subscribed (${label})` : "Subscribed";
  }

  async function syncTurnAlertSubscription(subscription, identity){
    if (!subscription || !identity?.playerId) return;
    const payload = {
      subscription: subscription.toJSON ? subscription.toJSON() : subscription,
      playerId: identity.playerId,
    };
    try {
      await fetch("/api/push/subscribe", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify(payload),
      });
    } catch (err){
      console.warn("Unable to sync turn alert subscription.", err);
    }
  }

  async function refreshTurnAlertStatus(){
    if (!turnAlertStatus) return;
    if (!isStandaloneDisplay()){
      setTurnAlertStatus("Not installed.");
      return;
    }
    if (!("Notification" in window)){
      setTurnAlertStatus("Notifications not supported.");
      return;
    }
    if (Notification.permission === "denied"){
      setTurnAlertStatus("Permission denied.");
      return;
    }
    if (!("serviceWorker" in navigator)){
      setTurnAlertStatus("Service worker unsupported.");
      return;
    }
    if (!("PushManager" in window)){
      setTurnAlertStatus("Push not supported.");
      return;
    }
    setTurnAlertStatus("Not subscribed.");
    try {
      swRegistration = swRegistration || await navigator.serviceWorker.ready;
      const existing = await swRegistration.pushManager.getSubscription();
      if (existing){
        const stored = loadTurnAlertSubscription();
        setTurnAlertStatus(formatTurnAlertStatus(stored || getTurnAlertIdentity()));
      }
    } catch (err){
      console.warn("Unable to check push subscription.", err);
    }
  }

  async function ensurePushSubscribed({vapidPublicKey, playerId}){
    if (!isStandaloneDisplay()){
      throw new Error("Not installed.");
    }
    if (!vapidPublicKey){
      throw new Error("Missing push public key.");
    }
    if (!playerId){
      throw new Error("Claim a character first.");
    }
    if (!("Notification" in window)){
      throw new Error("Notifications are not supported.");
    }
    if (!("serviceWorker" in navigator)){
      throw new Error("Service worker unsupported.");
    }
    if (!("PushManager" in window)){
      throw new Error("Push is not supported.");
    }
    try {
      swRegistration = swRegistration || await navigator.serviceWorker.ready;
    } catch (err){
      throw new Error("Service worker not ready.");
    }
    const permission = await Notification.requestPermission();
    if (permission !== "granted"){
      throw new Error(permission === "denied" ? "Permission denied." : "Permission required.");
    }
    const existing = await swRegistration.pushManager.getSubscription();
    if (existing){
      const identity = getTurnAlertIdentity();
      setTurnAlertStatus(formatTurnAlertStatus(identity));
      await syncTurnAlertSubscription(existing, identity);
      return existing;
    }
    const subscription = await swRegistration.pushManager.subscribe({
      userVisibleOnly: true,
      applicationServerKey: urlBase64ToUint8Array(vapidPublicKey),
    });
    const identity = getTurnAlertIdentity();
    persistTurnAlertSubscription(subscription, identity);
    setTurnAlertStatus(formatTurnAlertStatus(identity));
    await syncTurnAlertSubscription(subscription, identity);
    return subscription;
  }

  function routeDeepLink(url){
    if (!url) return;
    try {
      const target = new URL(url, location.origin);
      if (target.origin === location.origin){
        location.href = target.href;
      } else {
        location.href = url;
      }
    } catch (err){
      location.href = url;
    }
  }

  function urlBase64ToUint8Array(base64String){
    const padding = "=".repeat((4 - (base64String.length % 4)) % 4);
    const base64 = (base64String + padding).replace(/-/g, "+").replace(/_/g, "/");
    const rawData = atob(base64);
    const outputArray = new Uint8Array(rawData.length);
    for (let i = 0; i < rawData.length; ++i){
      outputArray[i] = rawData.charCodeAt(i);
    }
    return outputArray;
  }

  function generateClientId(){
    try {
      if (window.crypto && typeof window.crypto.randomUUID === "function"){
        return window.crypto.randomUUID();
      }
    } catch (err){
      console.warn("Unable to use crypto.randomUUID.", err);
    }
    try {
      if (window.crypto && typeof window.crypto.getRandomValues === "function"){
        const data = new Uint8Array(16);
        window.crypto.getRandomValues(data);
        return Array.from(data).map((byte) => byte.toString(16).padStart(2, "0")).join("");
      }
    } catch (err){
      console.warn("Unable to use crypto.getRandomValues.", err);
    }
    return `client_${Date.now().toString(36)}_${Math.random().toString(36).slice(2)}`;
  }

  function getClientId(){
    let existing = "";
    try {
      existing = String(localStorage.getItem(clientIdStorageKey) || "").trim();
    } catch (err){
      console.warn("Unable to read client id storage.", err);
    }
    if (existing){
      return existing;
    }
    const fresh = generateClientId();
    try {
      localStorage.setItem(clientIdStorageKey, fresh);
    } catch (err){
      console.warn("Unable to persist client id storage.", err);
    }
    return fresh;
  }

  const clientId = getClientId();

  if ("serviceWorker" in navigator){
    navigator.serviceWorker.register("/sw.js")
      .then(() => navigator.serviceWorker.ready)
      .then((registration) => {
        swRegistration = registration;
        navigator.serviceWorker.addEventListener("message", (event) => {
          const data = event.data || {};
          if (data && data.type === "deep-link" && typeof data.url === "string"){
            routeDeepLink(data.url);
          }
        });
      })
      .catch((err) => {
        console.warn("Service worker registration failed.", err);
      });
  }

  const connEl = document.getElementById("conn");
  const connFullTextEl = document.getElementById("connFullText");
  const connCompactLabelEl = document.getElementById("connCompactLabel");
  const connDotEl = document.getElementById("connDot");
  const topbarTitleEl = document.getElementById("topbarTitle");
  const mapViewTurnOrderEl = document.getElementById("mapViewTurnOrder");
  const mapViewTurnOrderStatusEl = document.getElementById("mapViewTurnOrderStatus");
  const mapViewTurnOrderBubbleEl = document.getElementById("mapViewTurnOrderBubble");
  const mapViewTextSizeInput = document.getElementById("mapViewTextSize");
  const mapViewBarHeightInput = document.getElementById("mapViewBarHeight");
  const mapViewChipPaddingInput = document.getElementById("mapViewChipPadding");
  const mapViewChipGapInput = document.getElementById("mapViewChipGap");
  const mapViewCornerRadiusInput = document.getElementById("mapViewCornerRadius");
  const mapViewRotateHandleScaleInput = document.getElementById("mapViewRotateHandleScale");
  const mapViewShowTitleInput = document.getElementById("mapViewShowTitle");
  const mapViewShowStatusInput = document.getElementById("mapViewShowStatus");
  const mapViewShowIndexInput = document.getElementById("mapViewShowIndex");
  const sheetHeightInput = document.getElementById("sheetHeight");
  const battleLogFontFamilyInput = document.getElementById("battleLogFontFamily");
  const battleLogFontSizeInput = document.getElementById("battleLogFontSize");
  const connPopoverEl = document.getElementById("connPopover");
  const connPopoverStatusEl = document.getElementById("connPopoverStatus");
  const connReconnectBtn = document.getElementById("connReconnectBtn");
  const connStyleButtons = Array.from(document.querySelectorAll(".conn-style-btn"));
  const meEl = document.getElementById("me");
  const moveEl = document.getElementById("move");
  const actionEl = document.getElementById("action");
  const attackResourceEl = document.getElementById("attackResource");
  const bonusActionEl = document.getElementById("bonusAction");
  const reactionEl = document.getElementById("reaction");
  const turnEl = document.getElementById("turn");
  const playerHpBarWrap = document.getElementById("playerHpBarWrap");
  const playerHpBarFill = document.getElementById("playerHpBarFill");
  const playerHpBarLabel = document.getElementById("playerHpBarLabel");
  const spellSlotMonitorEl = document.getElementById("spellSlotMonitor");
  const resourcePoolsPanelEl = document.getElementById("resourcePoolsPanel");
  const resourcePoolsListEl = document.getElementById("resourcePoolsList");
  const activeTurnOrderEl = mapViewTurnOrderEl;
  const activeTurnOrderStatusEl = mapViewTurnOrderStatusEl;
  const activeTurnOrderBubbleEl = mapViewTurnOrderBubbleEl;
  if (activeTurnOrderEl){
    activeTurnOrderEl.addEventListener("mouseleave", () => {
      hoveredTurnCid = null;
      hideTurnOrderBubble();
    });
  }
  const noteEl = document.getElementById("note");
  const colorModal = document.getElementById("colorModal");
  const tokenColorInput = document.getElementById("tokenColorInput");
  const tokenColorSwatch = document.getElementById("tokenColorSwatch");
  const tokenColorR = document.getElementById("tokenColorR");
  const tokenColorG = document.getElementById("tokenColorG");
  const tokenColorB = document.getElementById("tokenColorB");
  const tokenBorderColorInput = document.getElementById("tokenBorderColorInput");
  const tokenBorderColorSwatch = document.getElementById("tokenBorderColorSwatch");
  const tokenBorderColorR = document.getElementById("tokenBorderColorR");
  const tokenBorderColorG = document.getElementById("tokenBorderColorG");
  const tokenBorderColorB = document.getElementById("tokenBorderColorB");
  const tokenColorConfirm = document.getElementById("tokenColorConfirm");
  const tokenColorCancel = document.getElementById("tokenColorCancel");
  const tokenColorModeBtn = document.getElementById("tokenColorModeBtn");
  const dashModal = document.getElementById("dashModal");
  const dashActionBtn = document.getElementById("dashAction");
  const dashBonusActionBtn = document.getElementById("dashBonusAction");
  const dashCancelBtn = document.getElementById("dashCancel");
  const actionPickerModal = document.getElementById("actionPickerModal");
  const actionPickerTitle = document.getElementById("actionPickerTitle");
  const actionPickerList = document.getElementById("actionPickerList");
  const actionPickerCancelBtn = document.getElementById("actionPickerCancel");
  const warCasterModal = document.getElementById("warCasterModal");
  const warCasterSpellSelect = document.getElementById("warCasterSpellSelect");
  const warCasterTargetSelect = document.getElementById("warCasterTargetSelect");
  const warCasterCastBtn = document.getElementById("warCasterCast");
  const warCasterCancelBtn = document.getElementById("warCasterCancel");
  const battleLogBtn = document.getElementById("battleLog");
  const toggleSheetPanelBtn = document.getElementById("toggleSheetPanel");
  const lockMapBtn = document.getElementById("lockMap");
  const lockAoeBtn = document.getElementById("lockAoeToggle");
  const auraToggleBtn = document.getElementById("auraToggle");
  const effectsOverlay = document.getElementById("effectsOverlay");
  const effectsList = document.getElementById("effectsList");
  const centerMapBtn = document.getElementById("centerMap");
  const zoomInBtn = document.getElementById("zoomIn");
  const zoomOutBtn = document.getElementById("zoomOut");
  const dashBtn = document.getElementById("dash");
  const configBtn = document.getElementById("configBtn");
  const helpBtn = document.getElementById("helpBtn");
  const helpModal = document.getElementById("helpModal");
  const helpCloseBtn = document.getElementById("helpClose");
  const helpOpenBookBtn = document.getElementById("helpOpenBook");
  const helpOpenClassBtn = document.getElementById("helpOpenClass");
  const helpOpenTabBtn = document.getElementById("helpOpenTab");
  const helpSearchInput = document.getElementById("helpSearch");
  const helpTocTree = document.getElementById("helpTocTree");
  const helpViewer = document.getElementById("helpViewer");
  const helpMessage = document.getElementById("helpMessage");
  const rulesLastPageStorageKey = "inittracker_rules_last_page_v1";
  const initiativeToggleBtn = document.getElementById("initiativeToggleBtn");
  const configModal = document.getElementById("configModal");
  const configCloseBtn = document.getElementById("configClose");
  const toggleTopbarTitle = document.getElementById("toggleTopbarTitle");
  const toggleConnIndicator = document.getElementById("toggleConnIndicator");
  const toggleLockMap = document.getElementById("toggleLockMap");
  const toggleCenterMap = document.getElementById("toggleCenterMap");
  const toggleMeasure = document.getElementById("toggleMeasure");
  const toggleMeasureClear = document.getElementById("toggleMeasureClear");
  const toggleZoomIn = document.getElementById("toggleZoomIn");
  const toggleZoomOut = document.getElementById("toggleZoomOut");
  const toggleBattleLog = document.getElementById("toggleBattleLog");
  const initiativeStyleSelect = document.getElementById("initiativeStyleSelect");
  const toggleUseAction = document.getElementById("toggleUseAction");
  const toggleUseBonusAction = document.getElementById("toggleUseBonusAction");
  const toggleDash = document.getElementById("toggleDash");
  const toggleStandUp = document.getElementById("toggleStandUp");
  const toggleResetTurn = document.getElementById("toggleResetTurn");
  const toggleSpellMenu = document.getElementById("toggleSpellMenu");
  const toggleLockMenus = document.getElementById("toggleLockMenus");
  const presetSaveBtn = document.getElementById("savePreset");
  const presetLoadBtn = document.getElementById("loadPreset");
  const presetStatus = document.getElementById("presetStatus");
  const enableNotificationsBtn = document.getElementById("enableNotifications");
  const notificationStatus = document.getElementById("notificationStatus");
  const focusTabOnTurnInput = document.getElementById("focusTabOnTurn");
  const unlockAudioBtn = document.getElementById("unlockAudio");
  const enableTurnAlertsBtn = document.getElementById("enableTurnAlerts");
  const hideTurnAlertsBtn = document.getElementById("hideTurnAlerts");
  const turnAlertsPanel = document.getElementById("turnAlertsPanel");
  const turnAlertStatus = document.getElementById("turnAlertStatus");
  const hotkeyTopbarTitleInput = document.getElementById("hotkeyTopbarTitle");
  const hotkeyConnStyleInput = document.getElementById("hotkeyConnStyle");
  const hotkeyLockMapInput = document.getElementById("hotkeyLockMap");
  const hotkeyCenterMapInput = document.getElementById("hotkeyCenterMap");
  const hotkeyMeasureInput = document.getElementById("hotkeyMeasure");
  const hotkeyMeasureClearInput = document.getElementById("hotkeyMeasureClear");
  const hotkeyZoomInInput = document.getElementById("hotkeyZoomIn");
  const hotkeyZoomOutInput = document.getElementById("hotkeyZoomOut");
  const hotkeyBattleLogInput = document.getElementById("hotkeyBattleLog");
  const hotkeyUseActionInput = document.getElementById("hotkeyUseAction");
  const toggleDmLogPanelInput = document.getElementById("toggleDmLogPanel");
  const toggleDmMapPreviewInput = document.getElementById("toggleDmMapPreview");
  const hotkeyUseBonusActionInput = document.getElementById("hotkeyUseBonusAction");
  const hotkeyDashInput = document.getElementById("hotkeyDash");
  const hotkeyStandUpInput = document.getElementById("hotkeyStandUp");
  const hotkeyResetTurnInput = document.getElementById("hotkeyResetTurn");
  const hotkeyToggleSheetPanelInput = document.getElementById("hotkeyToggleSheetPanel");
  const hotkeyAttackOverlayInput = document.getElementById("hotkeyAttackOverlay");
  const iosInstallHint = document.getElementById("iosInstallHint");
  const measureToggle = document.getElementById("measureToggle");
  const attackOverlayToggleBtn = document.getElementById("attackOverlayToggle");
  const measureClear = document.getElementById("measureClear");
  const logModal = document.getElementById("logModal");
  const logHeader = document.getElementById("logHeader");
  const logContent = document.getElementById("logContent");
  const logResizeHandle = document.getElementById("logResizeHandle");
  const logCloseBtn = document.getElementById("logClose");
  const dmSideLayout = document.getElementById("dmSideLayout");
  const dmLogPanel = document.getElementById("dmLogPanel");
  const dmLogList = document.getElementById("dmLogList");
  const mapViewLogPanel = document.getElementById("mapViewLogPanel");
  const mapViewLogList = document.getElementById("mapViewLogList");
  const dmMapPreview = document.getElementById("dmMapPreview");
  const dmPreviewCanvas = document.getElementById("dmPreviewCanvas");
  const dmLogAutoScrollInput = document.getElementById("dmLogAutoScroll");
  const dmLogFilterInputs = Array.from(document.querySelectorAll("input[data-log-filter]"));
  const waitingOverlay = document.getElementById("waitingOverlay");
  const claimModal = document.getElementById("claimModal");
  const claimListEl = document.getElementById("claimList");
  const claimEmptyHint = document.getElementById("claimEmptyHint");
  const claimConfirmBtn = document.getElementById("claimConfirm");
  const claimSpectatorBtn = document.getElementById("claimSpectator");
  const claimContinueBtn = document.getElementById("claimContinue");
  const turnModal = document.getElementById("turnModal");
  const turnModalOk = document.getElementById("turnModalOk");
  const switchCharacterBtn = document.getElementById("switchCharacter");
  const useActionBtn = document.getElementById("useAction");
  const useBonusActionBtn = document.getElementById("useBonusAction");
  const useReactionBtn = document.getElementById("useReaction");
  const actionSelectEl = document.getElementById("actionSelect");
  const bonusActionSelectEl = document.getElementById("bonusActionSelect");
  const attackWeaponSelectEl = document.getElementById("attackWeaponSelect");
  const resetTurnBtn = document.getElementById("resetTurn");
  const standUpBtn = document.getElementById("standUp");
  const dismissSummonsBtn = document.getElementById("dismissSummons");
  const endTurnBtn = document.getElementById("endTurn");
  const mountBtn = document.getElementById("mountBtn");
  const dismountBtn = document.getElementById("dismountBtn");
  const mountPromptModal = document.getElementById("mountPromptModal");
  const mountPromptBody = document.getElementById("mountPromptBody");
  const mountPromptYes = document.getElementById("mountPromptYes");
  const mountPromptNo = document.getElementById("mountPromptNo");
  const initiativePromptModal = document.getElementById("initiativePromptModal");
  const initiativePromptBody = document.getElementById("initiativePromptBody");
  const initiativePromptInput = document.getElementById("initiativePromptInput");
  const initiativePromptSubmit = document.getElementById("initiativePromptSubmit");
  const initiativePromptCancel = document.getElementById("initiativePromptCancel");
  const attackResolveModal = document.getElementById("attackResolveModal");
  const attackResolveBody = document.getElementById("attackResolveBody");
  const attackResolveHit = document.getElementById("attackResolveHit");
  const attackResolveMiss = document.getElementById("attackResolveMiss");
  const attackResolveCrit = document.getElementById("attackResolveCrit");
  const attackDamageRows = document.getElementById("attackDamageRows");
  const attackDamageAdd = document.getElementById("attackDamageAdd");
  const attackResolveSubmit = document.getElementById("attackResolveSubmit");
  const attackResolveCancel = document.getElementById("attackResolveCancel");
  const cleavePromptModal = document.getElementById("cleavePromptModal");
  const cleavePromptBody = document.getElementById("cleavePromptBody");
  const cleavePromptList = document.getElementById("cleavePromptList");
  const cleavePromptCancel = document.getElementById("cleavePromptCancel");
  const showAllNamesEl = document.getElementById("showAllNames");
  const castOverlay = document.getElementById("sheetCastView");
  const castOverlayOpenBtn = document.getElementById("castOverlayOpen");
  const castOverlayBackBtn = document.getElementById("castOverlayBack");
  const castMenuTrigger = document.getElementById("castMenuTrigger");
  const castPanel = document.getElementById("castPanel");
  const castForm = document.getElementById("castForm");
  const castSearchInput = document.getElementById("castSearch");
  const openSpellFiltersBtn = document.getElementById("openSpellFilters");
  const closeSpellFiltersBtn = document.getElementById("closeSpellFilters");
  const applySpellFiltersBtn = document.getElementById("applySpellFilters");
  const clearSpellFiltersBtn = document.getElementById("clearSpellFilters");
  const spellFilterModal = document.getElementById("spellFilterModal");
  const spellFilterSummary = document.getElementById("spellFilterSummary");
  const castFilterLevelMinInput = document.getElementById("castFilterLevelMin");
  const castFilterLevelMaxInput = document.getElementById("castFilterLevelMax");
  const castFilterSchoolOptions = document.getElementById("castFilterSchoolOptions");
  const castFilterTagOptions = document.getElementById("castFilterTagOptions");
  const castFilterListOptions = document.getElementById("castFilterListOptions");
  const castFilterSchoolMulti = document.getElementById("castFilterSchoolMulti");
  const castFilterTagMulti = document.getElementById("castFilterTagMulti");
  const castFilterListMulti = document.getElementById("castFilterListMulti");
  const castFilterCastingTimeInput = document.getElementById("castFilterCastingTime");
  const castFilterRangeInput = document.getElementById("castFilterRange");
  const castFilterRitualInput = document.getElementById("castFilterRitual");
  const castFilterConcentrationInput = document.getElementById("castFilterConcentration");
  const castPresetInput = document.getElementById("castPreset");
  const castManualEntryBadge = document.getElementById("castManualEntryBadge");
  const planningBtn = document.getElementById("planningBtn");
  const spellLibraryBtn = document.getElementById("spellLibraryBtn");
  const spellLibraryOverlay = document.getElementById("spellLibraryOverlay");
  const spellLibraryCloseBtn = document.getElementById("spellLibraryClose");
  const spellLibrarySearchInput = document.getElementById("spellLibrarySearch");
  const spellLibrarySortSelect = document.getElementById("spellLibrarySort");
  const spellLibraryStatus = document.getElementById("spellLibraryStatus");
  const spellLibraryList = document.getElementById("spellLibraryList");
  const spellbookOpenBtn = document.getElementById("spellbookOpen");
  const wildShapeManageOpenBtn = document.getElementById("wildShapeManageOpen");
  const wildShapeMenuOverlay = document.getElementById("wildShapeMenuOverlay");
  const wildShapeMenuManagePoolBtn = document.getElementById("wildShapeMenuManagePool");
  const wildShapeMenuManageFormsBtn = document.getElementById("wildShapeMenuManageForms");
  const wildShapeMenuApplyBtn = document.getElementById("wildShapeMenuApply");
  const wildShapeMenuRevertBtn = document.getElementById("wildShapeMenuRevert");
  const wildShapeMenuRegainUseBtn = document.getElementById("wildShapeMenuRegainUse");
  const wildShapeMenuRegainSpellBtn = document.getElementById("wildShapeMenuRegainSpell");
  const wildShapeMenuCloseBtn = document.getElementById("wildShapeMenuClose");
  const wildShapePoolOverlay = document.getElementById("wildShapePoolOverlay");
  const wildShapePoolSummary = document.getElementById("wildShapePoolSummary");
  const wildShapePoolCurrentInput = document.getElementById("wildShapePoolCurrentInput");
  const wildShapePoolDecBtn = document.getElementById("wildShapePoolDec");
  const wildShapePoolIncBtn = document.getElementById("wildShapePoolInc");
  const wildShapePoolBackBtn = document.getElementById("wildShapePoolBack");
  const wildShapePoolApplyBtn = document.getElementById("wildShapePoolApply");
  const wildShapePickOverlay = document.getElementById("wildShapePickOverlay");
  const wildShapePickList = document.getElementById("wildShapePickList");
  const wildShapePickBackBtn = document.getElementById("wildShapePickBack");
  const secondWindOverlay = document.getElementById("secondWindOverlay");
  const secondWindSummary = document.getElementById("secondWindSummary");
  const secondWindRollInput = document.getElementById("secondWindRollInput");
  const secondWindCancelBtn = document.getElementById("secondWindCancel");
  const secondWindUseBtn = document.getElementById("secondWindUse");
  const layOnHandsOverlay = document.getElementById("layOnHandsOverlay");
  const layOnHandsSummary = document.getElementById("layOnHandsSummary");
  const layOnHandsTarget = document.getElementById("layOnHandsTarget");
  const layOnHandsAmountInput = document.getElementById("layOnHandsAmountInput");
  const layOnHandsCancelBtn = document.getElementById("layOnHandsCancel");
  const layOnHandsUseBtn = document.getElementById("layOnHandsUse");
  const wildShapeOverlay = document.getElementById("wildShapeOverlay");
  const wildShapeBackBtn = document.getElementById("wildShapeBack");
  const wildShapeSaveBtn = document.getElementById("wildShapeSave");
  const wildShapeSearchInput = document.getElementById("wildShapeSearch");
  const wildShapeShowLockedInput = document.getElementById("wildShapeShowLocked");
  const wildShapeLeftList = document.getElementById("wildShapeLeftList");
  const wildShapeRightList = document.getElementById("wildShapeRightList");
  const wildShapeAddBtn = document.getElementById("wildShapeAdd");
  const wildShapeRemoveBtn = document.getElementById("wildShapeRemove");
  const wildShapeStatusEl = document.getElementById("wildShapeStatus");
  const spellbookOverlay = document.getElementById("spellbookOverlay");
  const spellbookBackBtn = document.getElementById("spellbookBack");
  const spellbookBackFloatingBtn = document.getElementById("spellbookBackFloating");
  const spellbookSaveBtn = document.getElementById("spellbookSave");
  const spellbookTabKnown = document.getElementById("spellbookTabKnown");
  const spellbookTabPrepared = document.getElementById("spellbookTabPrepared");
  const spellbookKnownEnabledToggle = document.getElementById("spellbookKnownEnabled");
  const spellbookSearchInput = document.getElementById("spellbookSearch");
  const spellbookSortSelect = document.getElementById("spellbookSort");
  const spellbookLeftTitle = document.getElementById("spellbookLeftTitle");
  const spellbookRightTitle = document.getElementById("spellbookRightTitle");
  const spellbookLeftList = document.getElementById("spellbookLeftList");
  const spellbookRightList = document.getElementById("spellbookRightList");
  const spellbookAddBtn = document.getElementById("spellbookAdd");
  const spellbookRemoveBtn = document.getElementById("spellbookRemove");
  const spellbookStatus = document.getElementById("spellbookStatus");
  const spellbookConfirmModal = document.getElementById("spellbookConfirmModal");
  const spellbookConfirmText = document.getElementById("spellbookConfirmText");
  const spellbookConfirmCancel = document.getElementById("spellbookConfirmCancel");
  const spellbookConfirmYes = document.getElementById("spellbookConfirmYes");
  const spellDetailOverlay = document.getElementById("spellDetailOverlay");
  const spellDetailBackBtn = document.getElementById("spellDetailBack");
  const spellDetailTitle = document.getElementById("spellDetailTitle");
  const spellDetailName = document.getElementById("spellDetailName");
  const spellDetailMeta = document.getElementById("spellDetailMeta");
  const spellDetailGrid = document.getElementById("spellDetailGrid");
  const spellDetailColorInput = document.getElementById("spellDetailColorInput");
  const spellDetailColorSwatch = document.getElementById("spellDetailColorSwatch");
  const spellDetailColorValue = document.getElementById("spellDetailColorValue");
  const spellDetailStatus = document.getElementById("spellDetailStatus");
  const castNameInput = document.getElementById("castName");
  const castSubmitBtn = document.getElementById("castSubmit");
  const aoeOptions = document.getElementById("aoeOptions");
  const summonOptions = document.getElementById("summonOptions");
  const castSummonChoiceInput = document.getElementById("castSummonChoice");
  const castSummonVariantInput = document.getElementById("castSummonVariant");
  const castSummonQuantityInput = document.getElementById("castSummonQuantity");
  const castSummonMeta = document.getElementById("castSummonMeta");
  const castSummonChoiceField = document.getElementById("castSummonChoiceField");
  const castSummonVariantField = document.getElementById("castSummonVariantField");
  const castSummonVariantLabel = castSummonVariantField?.querySelector("label");
  const castSummonQuantityField = document.getElementById("castSummonQuantityField");
  const castCustomSummonNameField = document.getElementById("castCustomSummonNameField");
  const castCustomSummonMonsterSearchField = document.getElementById("castCustomSummonMonsterSearchField");
  const castCustomSummonMonsterField = document.getElementById("castCustomSummonMonsterField");
  const castCustomSummonTypeField = document.getElementById("castCustomSummonTypeField");
  const castCustomSummonHpField = document.getElementById("castCustomSummonHpField");
  const castCustomSummonAcField = document.getElementById("castCustomSummonAcField");
  const castCustomSummonWalkField = document.getElementById("castCustomSummonWalkField");
  const castCustomSummonSwimField = document.getElementById("castCustomSummonSwimField");
  const castCustomSummonFlyField = document.getElementById("castCustomSummonFlyField");
  const castCustomSummonBurrowField = document.getElementById("castCustomSummonBurrowField");
  const castCustomSummonClimbField = document.getElementById("castCustomSummonClimbField");
  const castCustomSummonStrField = document.getElementById("castCustomSummonStrField");
  const castCustomSummonDexField = document.getElementById("castCustomSummonDexField");
  const castCustomSummonConField = document.getElementById("castCustomSummonConField");
  const castCustomSummonIntField = document.getElementById("castCustomSummonIntField");
  const castCustomSummonWisField = document.getElementById("castCustomSummonWisField");
  const castCustomSummonChaField = document.getElementById("castCustomSummonChaField");
  const castCustomSummonRangeField = document.getElementById("castCustomSummonRangeField");
  const castCustomSummonNameInput = document.getElementById("castCustomSummonName");
  const castCustomSummonMonsterSearchInput = document.getElementById("castCustomSummonMonsterSearch");
  const castCustomSummonMonsterInput = document.getElementById("castCustomSummonMonster");
  const castCustomSummonTypeInput = document.getElementById("castCustomSummonType");
  const castCustomSummonHpInput = document.getElementById("castCustomSummonHp");
  const castCustomSummonAcInput = document.getElementById("castCustomSummonAc");
  const castCustomSummonWalkInput = document.getElementById("castCustomSummonWalk");
  const castCustomSummonSwimInput = document.getElementById("castCustomSummonSwim");
  const castCustomSummonFlyInput = document.getElementById("castCustomSummonFly");
  const castCustomSummonBurrowInput = document.getElementById("castCustomSummonBurrow");
  const castCustomSummonClimbInput = document.getElementById("castCustomSummonClimb");
  const castCustomSummonStrInput = document.getElementById("castCustomSummonStr");
  const castCustomSummonDexInput = document.getElementById("castCustomSummonDex");
  const castCustomSummonConInput = document.getElementById("castCustomSummonCon");
  const castCustomSummonIntInput = document.getElementById("castCustomSummonInt");
  const castCustomSummonWisInput = document.getElementById("castCustomSummonWis");
  const castCustomSummonChaInput = document.getElementById("castCustomSummonCha");
  const castCustomSummonRangeInput = document.getElementById("castCustomSummonRange");
  const castShapeInput = document.getElementById("castShape");
  const castRadiusField = document.getElementById("castRadiusField");
  const castSideField = document.getElementById("castSideField");
  const castLengthField = document.getElementById("castLengthField");
  const castWidthField = document.getElementById("castWidthField");
  const castAngleField = document.getElementById("castAngleField");
  const castOrientField = document.getElementById("castOrientField");
  const castThicknessField = document.getElementById("castThicknessField");
  const castHeightField = document.getElementById("castHeightField");
  const castRadiusInput = document.getElementById("castRadius");
  const castSideInput = document.getElementById("castSide");
  const castLengthInput = document.getElementById("castLength");
  const castWidthInput = document.getElementById("castWidth");
  const castAngleInput = document.getElementById("castAngle");
  const castOrientInput = document.getElementById("castOrient");
  const castThicknessInput = document.getElementById("castThickness");
  const castHeightInput = document.getElementById("castHeight");
  const castDcTypeInput = document.getElementById("castDcType");
  const castDcValueInput = document.getElementById("castDcValue");
  const castDefaultDamageInput = document.getElementById("castDefaultDamage");
  const castDiceInput = document.getElementById("castDice");
  const castSlotLevelInput = document.getElementById("castSlotLevel");
  const castDamageTypeInput = document.getElementById("castDamageType");
  const castDamageTypeList = document.getElementById("castDamageTypeList");
  const castAddDamageTypeBtn = document.getElementById("castAddDamageType");
  const castColorInput = document.getElementById("castColor");
  const castShapeField = castShapeInput?.closest(".form-field");
  const castDcTypeField = castDcTypeInput?.closest(".form-field");
  const castDcValueField = castDcValueInput?.closest(".form-field");
  const castDefaultDamageField = castDefaultDamageInput?.closest(".form-field");
  const castDiceField = castDiceInput?.closest(".form-field");
  const spellPresetDetails = document.getElementById("spellPresetDetails");
  const sheetWrap = document.getElementById("sheetWrap");
  const sheet = document.getElementById("sheet");
  const sheetHandle = document.getElementById("sheetHandle");
  const tokenTooltip = document.getElementById("tokenTooltip");
  const summonPlacementBanner = document.getElementById("summonPlacementBanner");
  const clientInitPayload = {
    timestamp: new Date().toISOString(),
    userAgent: navigator.userAgent,
    url: location.href,
    message: "LAN client initialized",
    stack: "",
  };
  console.info("LAN client initialized");
  document.documentElement.dataset.lanBoot = "true";
  try {
    fetch("/api/client-log", {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify(clientInitPayload),
    }).catch(() => {});
  } catch (err) {
    console.warn("Failed to report LAN client init:", err);
  }
  const turnAlertAudio = new Audio("/assets/alert.wav");
  turnAlertAudio.preload = "auto";
  const koAlertAudio = new Audio("/assets/ko.wav");
  koAlertAudio.preload = "auto";
  let audioUnlocked = false;
  let focusTabOnTurn = localStorage.getItem(focusTabOnTurnStorageKey) === "1";
  let pendingTurnAlert = false;
  let pendingVibrate = false;
  const notificationPermissionAskedKey = "inittracker_notification_permission_asked_v1";
  let notificationPermissionAsked = localStorage.getItem(notificationPermissionAskedKey) === "1";
  let lastVibrateSupported = canVibrate;
  let userHasInteracted = navigator.userActivation?.hasBeenActive ?? false;
  let castOverlayPreviousFocus = null;
  let pendingSpellActionType = null;
  let pendingSummonPlacement = null;
  let summonValidCells = new Set();
  const preparedSpellDefaults = {
    prepared: [],
    preparedFree: [],
    max: null,
    maxFormula: "",
    known: [],
    knownFree: [],
    knownLimit: null,
    knownEnabled: true,
    cantrips: [],
    cantripsMax: null,
  };

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  let ws = null;
  let state = null;
  let planningSnapshotLocked = false;
  let reconnectTimer = null;
  let reconnecting = false;
  let claimedCid = null;
  claimedCid = normalizeCid(claimedCid, "init.claimedCid");
  let shownNoOwnedToast = false;
  let pendingClaim = null;
  let lastPcList = [];
  let claimStaticDataSeen = false;
  let claimStateSeen = false;
  let claimDataReady = false;
  let claimRenderRetryTimer = null;
  const claimRenderRetryDelayMs = 500;
  let allowUnclaimed = false;
  let selectedClaimCid = null;
  const lanSelectedCidKey = "lan_selected_cid";
  const lanSelectedNameKey = "lan_selected_name";
  const autoClaimTimeoutMs = 1500;
  let autoClaimPending = null;
  let autoClaimChecked = false;
  let claimInFlight = false;
  let claimInFlightCid = null;
  let claimInFlightTimeoutId = null;
  const claimInFlightTimeoutMs = 8000;
  let claimStatus = "unclaimed";
  let claimRev = 0;
  let stateUpdateCounter = 0;
  let lastActiveCid = null;
  let lastTurnRound = null;
  let turnAlertPrimed = false;
  let endTurnReadyVisualActive = false;
  let selectedTurnCid = null;
  let pendingMountRequestId = null;
  let pendingInitiativeCid = null;
  let pendingMountPair = null;
  let hoveredTurnCid = null;
  const claimDebugLoggingEnabled = window.location.hostname === "localhost"
    || window.location.hostname === "127.0.0.1";

  // view transform
  let zoom = 32; // px per square
  let panX = 0, panY = 0;
  let dragging = null; // {cid, startX, startY, origCol, origRow}
  let rotatingToken = null; // {cid}
  let rotatePreviewDeg = null;
  let aoeDragging = null; // {aid, offsetCol, offsetRow, isRotating}
  let aoeDragPreview = null; // {aid, cx, cy, angle_deg, ax, ay, spread_deg}
  let aoeDragPending = null; // {pointerId, aid, offsetCol, offsetRow, centerCol, centerRow, startX, startY, timerId}
  let panning = null;  // {x,y, panX, panY}
  let shiftMoveMode = false;
  const isShiftKey = (event) => (
    event?.key === "Shift"
    || event?.code === "ShiftLeft"
    || event?.code === "ShiftRight"
  );
  let centeredCid = null;
  let initialCenterDone = false;
  let initialCenterFallback = false;
  let lockMap = false;
  let lastGrid = {cols: null, rows: null};
  let lastGridVersion = null;
  let fittedToGrid = false;
  let showAllNames = localStorage.getItem("inittracker_showAllNames") === "1";
  let measurementMode = false;
  let measurement = {start: null, end: null};
  let attackOverlayMode = false;
  let selectedAttackWeaponId = "";
  let pendingAttackResolve = null;
  let pendingActionAttackWeapon = null;
  let pendingOpportunityAttack = false;
  let pendingCleavePrompt = null;
  let pendingSpellTargeting = null;
  let pendingLayOnHandsTargeting = null;
  let pendingLayOnHandsResolve = null;
  let losPreview = null; // {start:{col,row}, end:{col,row}, blocked, expiresAt}
  const LOS_PREVIEW_MS = 900;
  const sheetHeightKey = "inittracker_sheetHeight";
  const lockMyAoesKey = "inittracker_lock_my_aoes";
  const uiToggleKeys = {
    topbarTitle: "inittracker_ui_topbarTitle",
    connIndicator: "inittracker_ui_connIndicator",
    lockMap: "inittracker_ui_lockMap",
    centerMap: "inittracker_ui_centerMap",
    measure: "inittracker_ui_measure",
    measureClear: "inittracker_ui_measureClear",
    zoomIn: "inittracker_ui_zoomIn",
    zoomOut: "inittracker_ui_zoomOut",
    battleLog: "inittracker_ui_battleLog",
    useAction: "inittracker_ui_useAction",
    useBonusAction: "inittracker_ui_useBonusAction",
    dash: "inittracker_ui_dash",
    standUp: "inittracker_ui_standUp",
    resetTurn: "inittracker_ui_resetTurn",
    hideSpellMenu: "inittracker_ui_hideSpellMenu",
    lockMenus: "inittracker_lockMenus",
  };
  const uiSelectKeys = {
    connStyle: "inittracker_ui_connStyle",
    initiativeStyle: "inittracker_ui_initiativeStyle",
  };
  const mapViewSettingsKey = "inittracker_map_view_settings";
  const dmUiPrefsKey = "inittracker_dm_ui_prefs";
  const battleLogViewPrefsKey = "inittracker_battle_log_view_prefs";
  const sheetPanelHiddenKey = "inittracker_ui_sheetPanelHidden";
  let dmLogLines = [];
  let mapViewLogPollTimer = null;
  let dmHighlightUntil = new Map();
  let dmUiPrefs = {showMapPreview:false, showLogPanel:false, autoScroll:true, filters:{attack:true,damage:true,save:true,heal:true,spell:true}};
  try { dmUiPrefs = {...dmUiPrefs, ...(JSON.parse(localStorage.getItem(dmUiPrefsKey)||"{}")||{})}; } catch(_) {}

  let showTopbarTitle = readToggle(uiToggleKeys.topbarTitle, true);
  let showConnIndicator = readToggle(uiToggleKeys.connIndicator, true);
  let showLockMap = readToggle(uiToggleKeys.lockMap, true);
  let showCenterMap = readToggle(uiToggleKeys.centerMap, true);
  let showMeasure = readToggle(uiToggleKeys.measure, true);
  let showMeasureClear = readToggle(uiToggleKeys.measureClear, true);
  let showZoomIn = readToggle(uiToggleKeys.zoomIn, true);
  let showZoomOut = readToggle(uiToggleKeys.zoomOut, true);
  let showBattleLog = readToggle(uiToggleKeys.battleLog, true);
  let showUseAction = readToggle(uiToggleKeys.useAction, true);
  let showUseBonusAction = readToggle(uiToggleKeys.useBonusAction, true);
  let showDash = readToggle(uiToggleKeys.dash, true);
  let showStandUp = readToggle(uiToggleKeys.standUp, true);
  let showResetTurn = readToggle(uiToggleKeys.resetTurn, true);
  let hideSpellMenu = readToggle(uiToggleKeys.hideSpellMenu, false);
  let menusLocked = readToggle(uiToggleKeys.lockMenus, false);
  let sheetPanelHidden = readToggle(sheetPanelHiddenKey, false);
  let lockMyAoes = readToggle(lockMyAoesKey, true);
  let mapViewSettings = null;
  let battleLogViewPrefs = null;
  let connStyle = "full";
  let initiativeStyle = "full";
  let sheetHeight = null;
  if (turnAlertStatus){
    refreshTurnAlertStatus();
  }
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
  const isSafariEngine = /AppleWebKit/.test(navigator.userAgent);
  const isAltBrowser = /CriOS|FxiOS|EdgiOS|OPiOS/.test(navigator.userAgent);
  const isStandalone = window.navigator.standalone === true;
  if (document.body){
    document.body.classList.toggle("map-view", isMapView);
    document.body.classList.toggle("map-view-only", isMapViewOnly);
    document.body.classList.toggle("planning-view", isPlanning);
  }
  if (iosInstallHint){
    const showHint = isIOS && isSafariEngine && !isAltBrowser && !isStandalone;
    iosInstallHint.classList.toggle("hidden", !showHint);
  }
  if (turnAlertsPanel){
    const hideTurnAlerts = localStorage.getItem(turnAlertHideKey) === "1";
    const shouldHideAlerts = !isIOS || hideTurnAlerts;
    turnAlertsPanel.classList.toggle("hidden", shouldHideAlerts);
  }
  applyMapViewSettings(readMapViewSettings());
  battleLogViewPrefs = readBattleLogViewPrefs();
  applyBattleLogViewPrefs();
  if (isMapView){ dmUiPrefs.showLogPanel = dmUiPrefs.showLogPanel === true; dmUiPrefs.showMapPreview = dmUiPrefs.showMapPreview === true; renderDmLogPanel(); refreshMapViewLogPolling(); }
  function applyMapViewReadOnlyControls(){
    if (!isMapView) return;
    const controls = [
      useActionBtn,
      useBonusActionBtn,
      useReactionBtn,
      dashBtn,
      standUpBtn,
      resetTurnBtn,
      endTurnBtn,
      actionSelectEl,
      bonusActionSelectEl,
    ];
    controls.forEach((control) => {
      if (!control) return;
      control.disabled = true;
      control.setAttribute("aria-disabled", "true");
    });
  }
  function updateEndTurnState(){
    if (!endTurnBtn) return;
    const needsClaim = claimedCid === null || claimedCid === undefined;
    const myTurn = !needsClaim && activeControlledUnitCid() !== null;
    const shouldDisable = isMapView || needsClaim || !myTurn;
    endTurnBtn.disabled = shouldDisable;
    endTurnBtn.setAttribute("aria-disabled", shouldDisable ? "true" : "false");
    if (shouldDisable){
      endTurnBtn.classList.remove("end-turn-ready", "end-turn-pop");
      endTurnReadyVisualActive = false;
    }
    let titleText = "";
    if (needsClaim){
      titleText = "Claim a character first, matey.";
    } else if (isMapView){
      titleText = "Map view is read-only.";
    } else if (!myTurn){
      titleText = "Wait for your turn, matey.";
    }
    if (titleText){
      endTurnBtn.setAttribute("title", titleText);
    } else {
      endTurnBtn.removeAttribute("title");
    }
  }
  function updateEndTurnReadyVisual(me, myTurn){
    if (!endTurnBtn || !me || endTurnBtn.disabled){
      if (endTurnBtn){
        endTurnBtn.classList.remove("end-turn-ready", "end-turn-pop");
      }
      endTurnReadyVisualActive = false;
      return;
    }
    const noMovement = Number(me.move_remaining || 0) <= 0;
    const noAction = Number(me.action_remaining || 0) <= 0;
    const noBonusAction = Number(me.bonus_action_remaining || 0) <= 0;
    const shouldEmphasize = myTurn && noMovement && noAction && noBonusAction;
    if (shouldEmphasize){
      endTurnBtn.classList.add("end-turn-ready");
      if (!endTurnReadyVisualActive){
        endTurnBtn.classList.remove("end-turn-pop");
        void endTurnBtn.offsetWidth;
        endTurnBtn.classList.add("end-turn-pop");
      }
    } else {
      endTurnBtn.classList.remove("end-turn-ready", "end-turn-pop");
    }
    endTurnReadyVisualActive = shouldEmphasize;
  }
  applyMapViewReadOnlyControls();
  updateEndTurnState();
  if (showAllNamesEl){
    showAllNamesEl.checked = showAllNames;
    showAllNamesEl.addEventListener("change", (ev) => {
      showAllNames = !!ev.target.checked;
      localStorage.setItem("inittracker_showAllNames", showAllNames ? "1" : "0");
      draw();
    });
  }

  window.addEventListener("resize", () => {
    if (sheetWrap){
      applySheetHeight(sheetHeight);
    }
    applyUiConfig();
  });
  updateSpellbookViewportHeight();
  window.addEventListener("resize", updateSpellbookViewportHeight);
  if (window.visualViewport){
    window.visualViewport.addEventListener("resize", updateSpellbookViewportHeight);
    window.visualViewport.addEventListener("scroll", updateSpellbookViewportHeight);
  }

  function updateConnDisplay(){
    if (connFullTextEl) connFullTextEl.textContent = connStatusText;
    if (connEl) connEl.setAttribute("title", connStatusText);
    if (connCompactLabelEl) connCompactLabelEl.textContent = "C";
    if (connDotEl){
      connDotEl.style.background = connStatusOk ? "var(--accent)" : "var(--danger)";
    }
    if (connPopoverStatusEl){
      connPopoverStatusEl.textContent = connStatusText;
    }
  }

  function setConn(ok, txt){
    connStatusOk = !!ok;
    connStatusText = String(txt || "");
    if (connEl){
      connEl.style.borderColor = connStatusOk ? "rgba(106,169,255,0.35)" : "rgba(255,91,91,0.35)";
      connEl.style.background = connStatusOk ? "rgba(106,169,255,0.14)" : "rgba(255,91,91,0.14)";
    }
    updateConnDisplay();
  }

  function setConnPopover(open){
    if (!connPopoverEl || !connEl) return;
    connPopoverEl.classList.toggle("show", open);
    connPopoverEl.setAttribute("aria-hidden", open ? "false" : "true");
    connEl.setAttribute("aria-expanded", open ? "true" : "false");
  }

  function closeConnPopover(){
    setConnPopover(false);
  }

  function scheduleReconnect(delayMs){
    if (reconnectTimer){
      clearTimeout(reconnectTimer);
    }
    reconnectTimer = setTimeout(() => {
      reconnectTimer = null;
      connect();
    }, delayMs);
  }

  function softReconnect(){
    reconnecting = true;
    setConn(false, "Reconnecting");
    closeConnPopover();
    if (ws && ws.readyState === 1){
      ws.close(4001, "reconnect");
    } else {
      scheduleReconnect(200);
    }
  }

  function resize(){
    const r = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.max(1, Math.floor(r.width * dpr));
    canvas.height = Math.max(1, Math.floor(r.height * dpr));
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }
  window.addEventListener("resize", resize);

  function getSheetConstraints(){
    const viewportHeight = window.innerHeight || 0;
    const min = Math.max(180, Math.round(viewportHeight * 0.2));
    const max = Math.max(min + 80, Math.round(viewportHeight * 0.7));
    return {min, max};
  }

  function updateModalOffsets(){
    const topbarHeight = document.querySelector(".topbar")?.getBoundingClientRect().height || 0;
    const sheetHeight = document.getElementById("sheetWrap")?.getBoundingClientRect().height || 0;
    const rootStyle = document.documentElement.style;
    rootStyle.setProperty("--modalTopOffset", `${topbarHeight}px`);
    rootStyle.setProperty("--modalBottomOffset", `${sheetHeight}px`);
    rootStyle.setProperty("--topbar-height", `${topbarHeight}px`);
    rootStyle.setProperty("--bottombar-height", `${sheetHeight}px`);
  }

  function updateSpellbookViewportHeight(){
    const viewportHeight = window.visualViewport?.height || window.innerHeight || 0;
    const vh = Math.max(1, viewportHeight) * 0.01;
    document.documentElement.style.setProperty("--spellbook-vh", `${vh}px`);
  }

  function readMapViewSettings(){
    const defaults = {
      textSize: 14,
      barHeight: 68,
      chipPadding: 6,
      chipGap: 8,
      cornerRadius: 40,
      rotateHandleScale: 1.2,
      showTitle: true,
      showStatus: true,
      showIndex: true,
    };
    try {
      const raw = localStorage.getItem(mapViewSettingsKey);
      if (!raw){
        return defaults;
      }
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== "object"){
        return defaults;
      }
      return {
        ...defaults,
        ...parsed,
      };
    } catch (err){
      return defaults;
    }
  }

  function applyMapViewSettings(settings){
    if (!settings){
      return;
    }
    mapViewSettings = settings;
    const rootStyle = document.documentElement.style;
    rootStyle.setProperty("--map-view-order-font-size", `${settings.textSize}px`);
    rootStyle.setProperty("--map-view-bar-height", `${settings.barHeight}px`);
    rootStyle.setProperty("--map-view-order-chip-pad-y", `${settings.chipPadding}px`);
    rootStyle.setProperty("--map-view-order-chip-pad-x", `${Math.max(6, settings.chipPadding + 4)}px`);
    rootStyle.setProperty("--map-view-order-gap", `${settings.chipGap}px`);
    rootStyle.setProperty("--map-view-order-radius", `${settings.cornerRadius}px`);
    if (document.body){
      document.body.classList.toggle("map-view-hide-title", !settings.showTitle);
      document.body.classList.toggle("map-view-hide-status", !settings.showStatus);
      document.body.classList.toggle("map-view-hide-index", !settings.showIndex);
    }
    if (mapViewTextSizeInput){
      mapViewTextSizeInput.value = String(settings.textSize);
    }
    if (mapViewBarHeightInput){
      mapViewBarHeightInput.value = String(settings.barHeight);
    }
    if (mapViewChipPaddingInput){
      mapViewChipPaddingInput.value = String(settings.chipPadding);
    }
    if (mapViewChipGapInput){
      mapViewChipGapInput.value = String(settings.chipGap);
    }
    if (mapViewCornerRadiusInput){
      mapViewCornerRadiusInput.value = String(settings.cornerRadius);
    }
    if (mapViewRotateHandleScaleInput){
      mapViewRotateHandleScaleInput.value = String(settings.rotateHandleScale);
    }
    if (mapViewShowTitleInput){
      mapViewShowTitleInput.checked = !!settings.showTitle;
    }
    if (mapViewShowStatusInput){
      mapViewShowStatusInput.checked = !!settings.showStatus;
    }
    if (mapViewShowIndexInput){
      mapViewShowIndexInput.checked = !!settings.showIndex;
    }
  }

  function persistMapViewSettings(){
    if (!mapViewSettings){
      return;
    }
    try {
      localStorage.setItem(mapViewSettingsKey, JSON.stringify(mapViewSettings));
    } catch (err){
      console.warn("Failed to persist map view settings.", err);
    }
  }

  function readBattleLogViewPrefs(){
    const defaults = {
      visible: false,
      fontFamily: "system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif",
      fontSize: 14,
      width: null,
      height: null,
      left: null,
      top: null,
    };
    try {
      const raw = localStorage.getItem(battleLogViewPrefsKey);
      if (!raw){
        return defaults;
      }
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== "object"){
        return defaults;
      }
      const merged = {
        ...defaults,
        ...parsed,
      };
      if (Number.isFinite(Number(merged.left)) && Number.isFinite(Number(merged.top))){
        if (Number(merged.left) <= 4 && Number(merged.top) <= 4){
          merged.left = null;
          merged.top = null;
        }
      }
      return merged;
    } catch (_err){
      return defaults;
    }
  }

  function persistBattleLogViewPrefs(){
    if (!battleLogViewPrefs){
      return;
    }
    try {
      localStorage.setItem(battleLogViewPrefsKey, JSON.stringify(battleLogViewPrefs));
    } catch (_err) {}
  }

  function applyBattleLogViewPrefs(){
    if (!battleLogViewPrefs){
      battleLogViewPrefs = readBattleLogViewPrefs();
    }
    const rootStyle = document.documentElement.style;
    rootStyle.setProperty("--battle-log-font-family", battleLogViewPrefs.fontFamily || "system-ui,sans-serif");
    rootStyle.setProperty("--battle-log-font-size", `${Number(battleLogViewPrefs.fontSize) || 14}px`);
    if (battleLogFontFamilyInput){
      battleLogFontFamilyInput.value = battleLogViewPrefs.fontFamily || "";
    }
    if (battleLogFontSizeInput){
      battleLogFontSizeInput.value = String(Number(battleLogViewPrefs.fontSize) || 14);
    }
    if (logModal){
      if (Number.isFinite(Number(battleLogViewPrefs.width))){
        logModal.style.width = `${Math.max(260, Number(battleLogViewPrefs.width))}px`;
      }
      if (Number.isFinite(Number(battleLogViewPrefs.height))){
        logModal.style.height = `${Math.max(180, Number(battleLogViewPrefs.height))}px`;
      }
      if (Number.isFinite(Number(battleLogViewPrefs.left)) && Number.isFinite(Number(battleLogViewPrefs.top))){
        const modalRect = logModal.getBoundingClientRect();
        const topbarHeight = document.querySelector(".topbar")?.getBoundingClientRect().height || 0;
        const sheetHeight = sheetWrap && !sheetWrap.classList.contains("hidden")
          ? sheetWrap.getBoundingClientRect().height
          : 0;
        const minTop = Math.max(0, topbarHeight + 8);
        const maxLeft = Math.max(0, window.innerWidth - modalRect.width);
        const maxTop = Math.max(minTop, window.innerHeight - sheetHeight - modalRect.height - 8);
        const left = Math.min(maxLeft, Math.max(0, Number(battleLogViewPrefs.left)));
        const top = Math.min(maxTop, Math.max(minTop, Number(battleLogViewPrefs.top)));
        logModal.style.left = `${left}px`;
        logModal.style.top = `${top}px`;
        logModal.style.right = "auto";
        logModal.style.bottom = "auto";
      } else {
        const modalRect = logModal.getBoundingClientRect();
        const topbarHeight = document.querySelector(".topbar")?.getBoundingClientRect().height || 0;
        const sheetHeight = sheetWrap && !sheetWrap.classList.contains("hidden")
          ? sheetWrap.getBoundingClientRect().height
          : 0;
        const minTop = Math.max(0, topbarHeight + 8);
        const maxTop = Math.max(minTop, window.innerHeight - sheetHeight - modalRect.height - 8);
        const defaultTop = Math.round(minTop + ((maxTop - minTop) / 2));
        logModal.style.left = "auto";
        logModal.style.top = `${defaultTop}px`;
        logModal.style.right = "12px";
        logModal.style.bottom = "auto";
      }
      logModal.classList.toggle("show", battleLogViewPrefs.visible === true);
      logModal.setAttribute("aria-hidden", battleLogViewPrefs.visible === true ? "false" : "true");
    }
    if (battleLogBtn){
      battleLogBtn.setAttribute("aria-pressed", battleLogViewPrefs.visible === true ? "true" : "false");
    }
  }

  function mapRotateHandleScale(){
    const raw = Number(mapViewSettings?.rotateHandleScale);
    if (!Number.isFinite(raw)) return 1.2;
    return Math.min(2.4, Math.max(0.8, raw));
  }

  function applySheetHeight(value){
    if (!sheetWrap) return;
    const {min, max} = getSheetConstraints();
    let target = Number(value);
    if (!Number.isFinite(target)){
      target = Math.round((min + max) / 2);
    }
    target = Math.min(max, Math.max(min, target));
    sheetWrap.style.height = `${target}px`;
    sheetWrap.style.minHeight = `${min}px`;
    sheetWrap.style.maxHeight = `${max}px`;
    sheetHeight = target;
    if (sheetHeightInput){
      sheetHeightInput.min = String(min);
      sheetHeightInput.max = String(max);
      sheetHeightInput.value = String(Math.round(target));
    }
    resize();
    updateModalOffsets();
  }

  function setSheetPanelHidden(hidden){
    sheetPanelHidden = !!hidden;
    persistToggle(sheetPanelHiddenKey, sheetPanelHidden);
    if (sheetWrap){
      sheetWrap.classList.toggle("hidden", sheetPanelHidden);
    }
    if (toggleSheetPanelBtn){
      toggleSheetPanelBtn.textContent = sheetPanelHidden ? "Show Panel" : "Hide Panel";
      toggleSheetPanelBtn.setAttribute("aria-pressed", sheetPanelHidden ? "true" : "false");
    }
    resize();
    updateModalOffsets();
  }

  function setCastOverlayOpen(open){
    if (!castOverlay) return;
    castOverlay.classList.toggle("show", open);
    castOverlay.classList.toggle("hidden", !open);
    castOverlay.setAttribute("aria-hidden", open ? "false" : "true");
    if (sheet){
      sheet.classList.toggle("hidden", open);
    }
    if (!open){
      pendingSpellActionType = null;
    }
    if (open){
      castOverlayPreviousFocus = document.activeElement instanceof HTMLElement
        ? document.activeElement
        : null;
      requestAnimationFrame(() => {
        castOverlayBackBtn?.focus();
      });
      applyDefaultSpellSaveDc();
    } else if (castOverlayPreviousFocus){
      castOverlayPreviousFocus.focus();
      castOverlayPreviousFocus = null;
    }
    updateModalOffsets();
    resize();
  }

  function getClaimedPlayerName(){
    const claimedUnit = getClaimedUnit();
    if (!claimedUnit?.name) return null;
    return String(claimedUnit.name);
  }

  function normalizeCharacterLookupKey(value){
    return String(value || "").trim().toLowerCase();
  }

  function characterSlugify(value){
    return normalizeCharacterLookupKey(value)
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/^-+|-+$/g, "");
  }

  function stripCombatNameSuffix(value){
    const text = String(value || "").trim();
    if (!text) return "";
    const withoutForm = text.replace(/\s*\([^)]*\)\s*$/, "").trim();
    const withoutDupe = withoutForm.replace(/\s+\d+$/, "").trim();
    return withoutDupe || text;
  }

  function getPlayerProfile(name){
    if (!name) return null;
    const profiles = state?.player_profiles;
    if (!profiles || typeof profiles !== "object") return null;
    const direct = profiles[name];
    if (direct && typeof direct === "object") return direct;
    const lookup = normalizeCharacterLookupKey(name);
    const lookupSlug = characterSlugify(name);
    const stripped = stripCombatNameSuffix(name);
    const strippedLookup = normalizeCharacterLookupKey(stripped);
    const strippedSlug = characterSlugify(stripped);
    for (const [profileName, profile] of Object.entries(profiles)){
      if (!profile || typeof profile !== "object") continue;
      const knownLookup = normalizeCharacterLookupKey(profileName);
      const knownSlug = characterSlugify(profileName);
      if (
        knownLookup === lookup
        || (lookupSlug && knownSlug === lookupSlug)
        || (strippedLookup && knownLookup === strippedLookup)
        || (strippedSlug && knownSlug === strippedSlug)
      ){
        return profile;
      }
    }
    return null;
  }

  function getClaimedWeapons(){
    const profile = getPlayerProfile(getClaimedPlayerName());
    const attacks = profile?.attacks;
    if (!attacks || typeof attacks !== "object" || !Array.isArray(attacks.weapons)){
      return [];
    }
    return attacks.weapons.filter((entry) => entry && typeof entry === "object");
  }

  function isWeaponEquipped(weapon){
    const value = weapon?.equipped;
    if (typeof value === "boolean") return value;
    if (typeof value === "number") return value !== 0;
    if (typeof value === "string"){
      const normalized = value.trim().toLowerCase();
      return normalized === "1" || normalized === "true" || normalized === "yes" || normalized === "on";
    }
    return false;
  }

  function getDefaultAttackWeapon(weapons){
    if (!Array.isArray(weapons) || !weapons.length){
      return null;
    }
    const equipped = weapons.find((entry) => isWeaponEquipped(entry));
    return equipped || weapons[0] || null;
  }

  function isMeleeWeapon(weapon){
    const category = normalizeLowerValue(weapon?.category || weapon?.weapon_group);
    if (category.includes("melee")) return true;
    const rangeText = normalizeLowerValue(weapon?.range);
    if (!rangeText) return true;
    if (rangeText.includes("/")) return false;
    return parseWeaponRangeFeet(weapon) <= 10;
  }

  function getPrimaryMeleeAttackWeapon(){
    const weapons = getClaimedWeapons();
    if (!weapons.length){
      return null;
    }
    const meleeWeapons = weapons.filter((entry) => isMeleeWeapon(entry));
    return getDefaultAttackWeapon(meleeWeapons);
  }

  function parseWeaponRangeFeet(weapon){
    const raw = weapon?.range ?? weapon?.normal_range ?? weapon?.reach ?? "";
    const text = String(raw || "").trim().toLowerCase();
    if (!text){
      return 5;
    }
    const firstPart = text.split("/")[0];
    const match = firstPart.match(/(\d+(?:\.\d+)?)/);
    if (!match){
      return 5;
    }
    const value = Number(match[1]);
    return Number.isFinite(value) && value > 0 ? value : 5;
  }

  function getSelectedAttackWeapon(){
    const weapons = getClaimedWeapons();
    if (!weapons.length){
      return null;
    }
    const selectedId = String(selectedAttackWeaponId || "").trim().toLowerCase();
    if (selectedId){
      const match = weapons.find((entry) => String(entry?.id || "").trim().toLowerCase() === selectedId);
      if (match){
        return match;
      }
    }
    return getDefaultAttackWeapon(weapons);
  }

  function getPlayerResourcePools(name){
    if (!name) return [];
    const poolsByPlayer = state?.resource_pools;
    if (!poolsByPlayer || typeof poolsByPlayer !== "object") return [];
    const pools = poolsByPlayer[name];
    if (!Array.isArray(pools)) return [];
    return pools.filter((entry) => entry && typeof entry === "object").map((entry) => {
      const currentRaw = Number(entry.current ?? 0);
      const maxRaw = Number(entry.max ?? 0);
      const max = Number.isFinite(maxRaw) ? Math.max(0, Math.floor(maxRaw)) : 0;
      const current = Number.isFinite(currentRaw) ? Math.max(0, Math.min(Math.floor(currentRaw), max)) : 0;
      return {
        id: String(entry.id || "").trim(),
        label: String(entry.label || entry.id || "").trim(),
        current,
        max,
      };
    }).filter((entry) => entry.id);
  }

  function getPoolGrantedSpellEntries(name){
    const cfg = state?.player_spells?.[name];
    const block = cfg?.spellcasting?.pool_granted_spells ?? cfg?.pool_granted_spells;
    if (!Array.isArray(block)) return [];
    return block.filter((entry) => entry && typeof entry === "object");
  }

  function renderResourcePools(){
    if (!resourcePoolsListEl) return;
    const playerName = getClaimedPlayerName();
    const pools = getPlayerResourcePools(playerName);
    resourcePoolsListEl.textContent = "";
    if (!pools.length){
      if (resourcePoolsPanelEl){
        resourcePoolsPanelEl.style.display = "none";
      }
      return;
    }
    if (resourcePoolsPanelEl){
      resourcePoolsPanelEl.style.display = "block";
    }
    pools.forEach((pool) => {
      const chip = document.createElement("span");
      chip.className = `resource-pool-chip ${pool.current <= 0 ? "is-empty" : ""}`;
      chip.textContent = `${pool.label || pool.id} ${pool.current}/${pool.max}`;
      if (pool.id === "wild_shape"){
        chip.style.cursor = "pointer";
        chip.title = "Wild Shape actions";
        chip.addEventListener("click", () => {
          if (!isClaimedUnitDruid()){
            localToast("Only Druids level 2+ can use Wild Shape.");
            return;
          }
          setWildShapeMenuOpen(true);
        });
      }
      if (pool.id === "second_wind"){
        chip.style.cursor = "pointer";
        chip.title = "Second Wind";
        chip.addEventListener("click", () => setSecondWindOverlayOpen(true));
      }
      if (pool.id === "action_surge"){
        chip.style.cursor = "pointer";
        chip.title = "Use Action Surge";
        chip.addEventListener("click", () => {
          const cid = activeControlledUnitCid();
          if (cid === null){
            localToast("Claim a character first, matey.");
            return;
          }
          if (!window.confirm("Action Surge?")){
            return;
          }
          const msg = {type: "action_surge_use", cid};
          if (isPlanning){
            planningMutate(msg);
            draw();
            updateHud();
          }
          send(msg);
        });
      }
      if (pool.id === "lay_on_hands"){
        chip.style.cursor = "pointer";
        chip.title = "Lay on Hands";
        chip.addEventListener("click", () => {
          const me = getClaimedUnit();
          if (!me || !me.pos){
            localToast("Claim a character first, matey.");
            return;
          }
          pendingLayOnHandsTargeting = {
            poolCurrent: Number(pool.current || 0),
            poolMax: Number(pool.max || 0),
            rangeFt: 5,
          };
          pendingLayOnHandsResolve = null;
          setLayOnHandsOverlayOpen(false);
          setAttackOverlayMode(true);
          localToast("Select a creature within 5 ft for Lay on Hands.");
          draw();
        });
      }
      resourcePoolsListEl.appendChild(chip);
    });
  }

  const spellSlotNumerals = ["I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
  let wildShapeSelectedAvailable = null;
  let wildShapeSelectedKnown = null;
  let wildShapeKnownDraft = [];
  let wildShapeAllowedMap = new Map();

  function setModalOpen(el, open){
    if (!el) return;
    el.classList.toggle("show", !!open);
    el.setAttribute("aria-hidden", open ? "false" : "true");
  }

  function setWildShapeMenuOpen(open){
    setModalOpen(wildShapeMenuOverlay, open);
    const me = getClaimedUnit();
    if (wildShapeMenuRevertBtn){
      wildShapeMenuRevertBtn.style.display = me?.is_wild_shaped ? "" : "none";
    }
  }

  function setWildShapePoolOverlayOpen(open){
    setModalOpen(wildShapePoolOverlay, open);
    if (!open) return;
    const pools = getPlayerResourcePools(getClaimedPlayerName());
    const wildPool = pools.find((entry) => entry.id === "wild_shape");
    if (!wildPool){
      if (wildShapePoolSummary) wildShapePoolSummary.textContent = "No Wild Shape pool found.";
      return;
    }
    if (wildShapePoolSummary) wildShapePoolSummary.textContent = `Current uses: ${wildPool.current}/${wildPool.max}`;
    if (wildShapePoolCurrentInput){
      wildShapePoolCurrentInput.min = "0";
      wildShapePoolCurrentInput.max = String(wildPool.max);
      wildShapePoolCurrentInput.value = String(wildPool.current);
    }
  }

  function setWildShapePickOverlayOpen(open){
    setModalOpen(wildShapePickOverlay, open);
    if (!open || !wildShapePickList) return;
    const {forms, known} = getWildShapeProfileData();
    const knownSet = new Set(known);
    const picks = forms.filter((entry) => knownSet.has(String(entry?.id || "").trim().toLowerCase()));
    wildShapePickList.textContent = "";
    if (!picks.length){
      const empty = document.createElement("div");
      empty.className = "spellbook-item";
      empty.textContent = "No prepared forms. Use Manage Wildshapes first.";
      wildShapePickList.appendChild(empty);
      return;
    }
    picks.forEach((entry) => {
      const id = String(entry?.id || "").trim().toLowerCase();
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "spellbook-item";
      btn.textContent = `${entry?.name || id}  CR ${entry?.challenge_rating ?? 0}`;
      btn.addEventListener("click", () => {
        if (claimedCid == null) return;
        send({type:"wild_shape_apply", cid: claimedCid, beast_id: id});
        setWildShapePickOverlayOpen(false);
        setWildShapeMenuOpen(false);
      });
      wildShapePickList.appendChild(btn);
    });
  }

  function setSecondWindOverlayOpen(open){
    setModalOpen(secondWindOverlay, open);
    if (!open) return;
    const pools = getPlayerResourcePools(getClaimedPlayerName());
    const secondWind = pools.find((entry) => entry.id === "second_wind");
    if (!secondWind){
      if (secondWindSummary) secondWindSummary.textContent = "No Second Wind pool found.";
      return;
    }
    if (secondWindSummary) secondWindSummary.textContent = `Current uses: ${secondWind.current}/${secondWind.max}`;
  }

  function setLayOnHandsOverlayOpen(open){
    setModalOpen(layOnHandsOverlay, open);
    if (!open) return;
    const pools = getPlayerResourcePools(getClaimedPlayerName());
    const pool = pools.find((entry) => entry.id === "lay_on_hands");
    const current = Math.max(0, Number(pool?.current || 0));
    const max = Math.max(0, Number(pool?.max || 0));
    if (layOnHandsSummary) layOnHandsSummary.textContent = pool ? `Pool: ${current}/${max}` : "No Lay on Hands pool found.";
    if (layOnHandsTarget){
      layOnHandsTarget.textContent = pendingLayOnHandsResolve
        ? `Target: ${pendingLayOnHandsResolve.targetName}`
        : "Target: none selected";
    }
    if (layOnHandsAmountInput){
      layOnHandsAmountInput.min = "1";
      layOnHandsAmountInput.max = String(current);
      layOnHandsAmountInput.value = current > 0 ? "1" : "0";
    }
  }

  function isClaimedUnitDruid(){
    const name = getClaimedPlayerName();
    const profile = getPlayerProfile(name);
    const classes = profile?.leveling?.classes;
    if (Array.isArray(classes)){
      const level = classes
        .filter((entry) => String(entry?.name || "").trim().toLowerCase() === "druid")
        .reduce((sum, entry) => sum + Math.max(0, Number(entry?.level || 0)), 0);
      return level >= 2;
    }
    return String(profile?.leveling?.class || "").trim().toLowerCase() === "druid" && Number(profile?.leveling?.level || 0) >= 2;
  }

  function getWildShapeProfileData(){
    const playerName = getClaimedPlayerName();
    const profile = getPlayerProfile(playerName) || {};
    const forms = Array.isArray(profile.wild_shape_available_forms) ? profile.wild_shape_available_forms : [];
    const known = Array.isArray(profile.learned_wild_shapes) ? profile.learned_wild_shapes.map((v) => String(v || "").trim().toLowerCase()).filter(Boolean) : [];
    const limit = Number(profile.wild_shape_known_limit || 0);
    return {forms, known, limit};
  }

  function wildShapeLockReason(entry){
    const reasons = [];
    if (entry?.allowed === false){
      const speed = entry?.speed || {};
      if (Number(speed.fly || 0) > 0) reasons.push("flight locked at current level");
      if (Number(speed.swim || 0) > 0) reasons.push("swim locked at current level");
      if (String(entry?.size || "").toLowerCase() === "tiny") reasons.push("tiny forms unlock at level 11");
      if (!reasons.length) reasons.push("CR too high for current level");
    }
    return reasons.join(", ");
  }

  function renderWildShapeOverlay(){
    if (!wildShapeOverlay) return;
    const {forms, limit} = getWildShapeProfileData();
    const query = String(wildShapeSearchInput?.value || "").trim().toLowerCase();
    const showLocked = !!wildShapeShowLockedInput?.checked;
    if (!Array.isArray(wildShapeKnownDraft) || !wildShapeKnownDraft.length){
      wildShapeKnownDraft = getWildShapeProfileData().known.slice(0, Math.max(0, limit));
    }
    const available = forms.filter((entry) => {
      const id = String(entry?.id || "").trim().toLowerCase();
      const name = String(entry?.name || "").toLowerCase();
      const cr = String(entry?.challenge_rating ?? "");
      if (!showLocked && entry?.allowed === false) return false;
      if (!query) return true;
      return id.includes(query) || name.includes(query) || cr.includes(query);
    });
    if (wildShapeLeftList) wildShapeLeftList.textContent = "";
    if (wildShapeRightList) wildShapeRightList.textContent = "";
    wildShapeAllowedMap = new Map();
    available.forEach((entry) => {
      const id = String(entry?.id || "").trim().toLowerCase();
      if (!id) return;
      wildShapeAllowedMap.set(id, entry);
      const item = document.createElement("button");
      item.type = "button";
      item.dataset.wildshapeId = id;
      item.className = `spellbook-item ${entry?.allowed === false ? "locked" : ""} ${wildShapeSelectedAvailable === id ? "selected" : ""}`;
      item.textContent = `${entry?.name || id}  CR ${entry?.challenge_rating ?? 0}  ${entry?.size || ""}`;
      wildShapeLeftList?.appendChild(item);
    });
    const knownSet = new Set(wildShapeKnownDraft);
    forms.filter((entry) => knownSet.has(String(entry?.id || "").trim().toLowerCase())).forEach((entry) => {
      const id = String(entry?.id || "").trim().toLowerCase();
      const item = document.createElement("button");
      item.type = "button";
      item.dataset.wildshapeKnownId = id;
      item.className = `spellbook-item ${wildShapeSelectedKnown === id ? "selected" : ""}`;
      item.textContent = `${entry?.name || id}  CR ${entry?.challenge_rating ?? 0}`;
      wildShapeRightList?.appendChild(item);
    });
    if (wildShapeStatusEl){
      const remaining = Math.max(0, limit - wildShapeKnownDraft.length);
      wildShapeStatusEl.textContent = `Known forms: ${wildShapeKnownDraft.length}/${limit}. Remaining choices: ${remaining}.`;
    }
  }

  function setWildShapeOverlayOpen(open){
    if (!wildShapeOverlay) return;
    wildShapeOverlay.classList.toggle("show", !!open);
    wildShapeOverlay.setAttribute("aria-hidden", open ? "false" : "true");
    if (open){
      wildShapeKnownDraft = getWildShapeProfileData().known.slice();
      wildShapeSelectedAvailable = null;
      wildShapeSelectedKnown = null;
      renderWildShapeOverlay();
    }
  }

  function getSpellSlotLevels(profile){
    const slots = profile?.spellcasting?.spell_slots;
    if (!slots || typeof slots !== "object") return [];
    const levels = [];
    for (let level = 1; level <= 9; level += 1){
      const entry = Array.isArray(slots)
        ? slots[level - 1]
        : (slots[String(level)] ?? slots[level]);
      let maxValue = 0;
      let currentValue = 0;
      if (entry && typeof entry === "object"){
        maxValue = Number(entry.max ?? entry.total ?? entry.slots ?? 0);
        currentValue = Number(entry.current ?? entry.remaining ?? entry.max ?? maxValue);
      } else {
        maxValue = Number(entry ?? 0);
        currentValue = maxValue;
      }
      if (!Number.isFinite(maxValue)) maxValue = 0;
      if (!Number.isFinite(currentValue)) currentValue = maxValue;
      maxValue = Math.max(0, Math.floor(maxValue));
      currentValue = Math.max(0, Math.min(Math.floor(currentValue), maxValue));
      levels.push({level, max: maxValue, current: currentValue});
    }
    return levels;
  }

  function getAvailableSlotCountAtOrAbove(profile, minLevel){
    const levelFloor = Number.isFinite(Number(minLevel)) ? Math.max(1, Math.floor(Number(minLevel))) : 1;
    return getSpellSlotLevels(profile)
      .filter((entry) => entry.level >= levelFloor)
      .reduce((sum, entry) => sum + Math.max(0, Number(entry.current) || 0), 0);
  }

  function renderSpellSlotMonitor(){
    if (!spellSlotMonitorEl) return;
    const playerName = getClaimedPlayerName();
    const profile = getPlayerProfile(playerName);
    const levels = getSpellSlotLevels(profile).filter((entry) => entry.max > 0);
    spellSlotMonitorEl.textContent = "";
    if (!levels.length){
      spellSlotMonitorEl.classList.add("is-empty");
      return;
    }
    spellSlotMonitorEl.classList.remove("is-empty");
    levels.forEach((entry) => {
      const levelWrap = document.createElement("div");
      levelWrap.className = "spell-slot-level";
      const label = document.createElement("span");
      label.textContent = spellSlotNumerals[entry.level - 1] || String(entry.level);
      levelWrap.appendChild(label);
      const squaresWrap = document.createElement("div");
      squaresWrap.className = "spell-slot-squares";
      for (let i = 0; i < entry.max; i += 1){
        const square = document.createElement("span");
        square.className = `spell-slot-square ${i < entry.current ? "is-active" : "is-spent"}`;
        squaresWrap.appendChild(square);
      }
      levelWrap.appendChild(squaresWrap);
      spellSlotMonitorEl.appendChild(levelWrap);
    });
  }

  function normalizePreparedSpellList(list){
    if (!Array.isArray(list)) return [];
    return list.map(normalizeTextValue).filter(Boolean);
  }

  function getPlayerCantripList(name){
    const profile = getPlayerProfile(name);
    const spellcasting = profile?.spellcasting;
    if (!spellcasting || typeof spellcasting !== "object") return [];
    if (Array.isArray(spellcasting.cantrips_list)){
      return normalizePreparedSpellList(spellcasting.cantrips_list);
    }
    const cantrips = spellcasting.cantrips;
    if (Array.isArray(cantrips)){
      return normalizePreparedSpellList(cantrips);
    }
    if (cantrips && typeof cantrips === "object"){
      return normalizePreparedSpellList(cantrips.known);
    }
    return [];
  }

  function evaluatePreparedFormula(formula, variables){
    if (typeof formula !== "string") return null;
    const trimmed = formula.trim();
    if (!trimmed) return null;
    if (!/^[0-9+\-*/(). _a-zA-Z]+$/.test(trimmed)) return null;
    let expr = trimmed;
    Object.entries(variables).forEach(([key, value]) => {
      const safeValue = Number.isFinite(value) ? String(value) : "0";
      const pattern = new RegExp(`\\b${key}\\b`, "g");
      expr = expr.replace(pattern, safeValue);
    });
    if (/[a-zA-Z]/.test(expr)) return null;
    try {
      const result = Function(`"use strict"; return (${expr});`)();
      if (!Number.isFinite(result)) return null;
      return Math.max(0, Math.floor(result));
    } catch (err){
      return null;
    }
  }

  function getAbilityModifier(profile, key){
    const normalizedKey = normalizeAbilityKey(key);
    const abilities = profile?.abilities;
    if (!abilities || typeof abilities !== "object") return 0;
    const modValue = Number(
      abilities[`${normalizedKey}_mod`]
      ?? abilities[`${normalizedKey}_modifier`]
    );
    if (Number.isFinite(modValue)){
      return Math.floor(modValue);
    }
    const scoreValue = Number(
      abilities[normalizedKey]
      ?? abilities[normalizedKey.toUpperCase()]
      ?? abilities[`${normalizedKey}_score`]
    );
    if (Number.isFinite(scoreValue)){
      return Math.floor((scoreValue - 10) / 2);
    }
    return 0;
  }

  function normalizeAbilityKey(key){
    const raw = normalizeLowerValue(key || "");
    if (!raw) return "";
    const abilityMap = {
      strength: "str",
      str: "str",
      dexterity: "dex",
      dex: "dex",
      constitution: "con",
      con: "con",
      intelligence: "int",
      int: "int",
      wisdom: "wis",
      wis: "wis",
      charisma: "cha",
      cha: "cha",
      chr: "cha",
      char: "cha",
    };
    return abilityMap[raw] || raw;
  }

  function getProficiencyBonus(profile){
    const level = getPlayerLevel(profile);
    if (level >= 1){
      if (level >= 17) return 6;
      if (level >= 13) return 5;
      if (level >= 9) return 4;
      if (level >= 5) return 3;
      return 2;
    }
    const prof = Number(profile?.proficiency?.bonus);
    return Number.isFinite(prof) ? Math.floor(prof) : 0;
  }

  function getPreparedSpellLimit(profile, preparedData){
    const maxFormula = preparedData?.maxFormula;
    const maxValue = preparedData?.maxValue;
    const levelRaw = profile?.leveling?.level ?? profile?.leveling?.total_level ?? profile?.leveling?.lvl;
    const level = Number.isFinite(Number(levelRaw)) ? Math.max(0, Math.floor(Number(levelRaw))) : 0;
    const variables = {
      level,
      total_level: level,
      str_mod: getAbilityModifier(profile, "str"),
      dex_mod: getAbilityModifier(profile, "dex"),
      con_mod: getAbilityModifier(profile, "con"),
      int_mod: getAbilityModifier(profile, "int"),
      wis_mod: getAbilityModifier(profile, "wis"),
      cha_mod: getAbilityModifier(profile, "cha"),
    };
    const evaluated = evaluatePreparedFormula(maxFormula, variables);
    if (Number.isFinite(evaluated)){
      return evaluated;
    }
    if (Number.isFinite(maxValue)){
      return Math.max(0, Math.floor(maxValue));
    }
    const fallbackKnown = Number(profile?.spellcasting?.known_spells);
    if (Number.isFinite(fallbackKnown)){
      return Math.max(0, Math.floor(fallbackKnown));
    }
    return null;
  }

  function getPlayerSpellSaveDc(name){
    const profile = getPlayerProfile(name);
    const spellcasting = profile?.spellcasting;
    if (!spellcasting || typeof spellcasting !== "object") return null;
    const rawValue = spellcasting.save_dc ?? spellcasting.saveDC;
    const dcValue = Number(rawValue);
    if (Number.isFinite(dcValue)){
      return Math.floor(dcValue);
    }
    const formula = normalizeTextValue(spellcasting.save_dc_formula);
    if (formula){
      const castingAbility = normalizeAbilityKey(spellcasting.casting_ability || "");
      const castingMod = castingAbility ? getAbilityModifier(profile, castingAbility) : 0;
      const prof = getProficiencyBonus(profile);
      const variables = {
        prof,
        casting_mod: castingMod,
        str_mod: getAbilityModifier(profile, "str"),
        dex_mod: getAbilityModifier(profile, "dex"),
        con_mod: getAbilityModifier(profile, "con"),
        int_mod: getAbilityModifier(profile, "int"),
        wis_mod: getAbilityModifier(profile, "wis"),
        cha_mod: getAbilityModifier(profile, "cha"),
      };
      const evaluated = evaluatePreparedFormula(formula, variables);
      if (Number.isFinite(evaluated)){
        return evaluated;
      }
    }
    return null;
  }

  function applyDefaultSpellSaveDc(){
    if (!castDcValueInput) return;
    if (String(castDcValueInput.value || "").trim()){
      return;
    }
    const playerName = getClaimedPlayerName();
    const dcValue = getPlayerSpellSaveDc(playerName);
    if (Number.isFinite(dcValue)){
      castDcValueInput.value = String(dcValue);
    }
  }

  function getSpellbookConfig(name){
    const defaults = {...preparedSpellDefaults};
    if (!name) return defaults;
    const profile = getPlayerProfile(name);
    const spellcasting = profile?.spellcasting && typeof profile.spellcasting === "object"
      ? profile.spellcasting
      : null;
    if (!spellcasting){
      return defaults;
    }
    const preparedBlock = spellcasting.prepared_spells && typeof spellcasting.prepared_spells === "object"
      ? spellcasting.prepared_spells
      : {};
    const knownBlock = spellcasting.known_spells && typeof spellcasting.known_spells === "object"
      ? spellcasting.known_spells
      : {};
    const cantripsBlock = spellcasting.cantrips && typeof spellcasting.cantrips === "object"
      ? spellcasting.cantrips
      : {};
    const maxFormula = normalizeTextValue(
      spellcasting.prepared_limit_formula
      ?? preparedBlock.max_formula
    );
    const maxValue = Number(preparedBlock.max ?? preparedBlock.max_spells ?? preparedBlock.max_prepared);
    const limit = getPreparedSpellLimit(profile, {maxFormula, maxValue});
    const knownLimitRaw = spellcasting.known_limit ?? knownBlock.max ?? spellcasting.known_spells;
    const knownLimit = Number.isFinite(Number(knownLimitRaw))
      ? Math.max(0, Math.floor(Number(knownLimitRaw)))
      : null;
    const cantripsMaxRaw = cantripsBlock.max;
    const cantripsMax = Number.isFinite(Number(cantripsMaxRaw))
      ? Math.max(0, Math.floor(Number(cantripsMaxRaw)))
      : null;
    return {
      prepared: normalizePreparedSpellList(
        spellcasting.prepared_list ?? preparedBlock.prepared
      ),
      preparedFree: normalizePreparedSpellList(
        spellcasting.prepared_free_list ?? preparedBlock.free
      ),
      max: limit,
      maxFormula,
      known: normalizePreparedSpellList(
        spellcasting.known_list ?? knownBlock.known ?? spellcasting.known_spell_names
      ),
      knownFree: normalizePreparedSpellList(
        spellcasting.known_free_list ?? knownBlock.free
      ),
      knownLimit,
      knownEnabled: spellcasting.known_enabled !== false,
      cantrips: normalizePreparedSpellList(
        spellcasting.cantrips_list ?? cantripsBlock.known ?? spellcasting.cantrips
      ),
      cantripsMax,
    };
  }

  function persistSheetHeight(){
    if (!Number.isFinite(sheetHeight)) return;
    const roundedHeight = Math.round(sheetHeight);
    localStorage.setItem(sheetHeightKey, String(roundedHeight));
    const localPreset = loadLocalPreset();
    if (localPreset && typeof localPreset === "object"){
      localPreset.sheetHeight = roundedHeight;
      persistLocalPreset(localPreset);
    }
  }

  function loadSheetHeight(){
    if (!sheetWrap) return;
    const stored = Number(localStorage.getItem(sheetHeightKey));
    if (Number.isFinite(stored)){
      applySheetHeight(stored);
      return;
    }
    const {min, max} = getSheetConstraints();
    applySheetHeight(Math.round(min + ((max - min) * 0.62)));
  }

  function readToggle(key, defaultValue){
    const stored = localStorage.getItem(key);
    if (stored === null || stored === undefined) return defaultValue;
    return stored === "1";
  }

  function readChoice(key, allowed, defaultValue){
    const stored = localStorage.getItem(key);
    if (stored && allowed.includes(stored)) return stored;
    return defaultValue;
  }

  function persistToggle(key, value){
    localStorage.setItem(key, value ? "1" : "0");
  }

  function persistChoice(key, value){
    if (!value){
      localStorage.removeItem(key);
      return;
    }
    localStorage.setItem(key, value);
  }

  connStyle = readChoice(uiSelectKeys.connStyle, ["full", "compact"], "full");
  initiativeStyle = readChoice(uiSelectKeys.initiativeStyle, ["full", "compact", "hidden"], "full");
  let connStatusText = "Connecting";
  let connStatusOk = false;

  const hotkeyConfig = {
    toggleTopbarTitle: {
      input: hotkeyTopbarTitleInput,
      conflictEl: document.getElementById("hotkeyConflictTopbarTitle"),
      storageKey: "inittracker_hotkey_toggleTopbarTitle",
      action: () => {
        showTopbarTitle = !showTopbarTitle;
        persistToggle(uiToggleKeys.topbarTitle, showTopbarTitle);
        applyUiConfig();
      },
    },
    toggleConnStyle: {
      input: hotkeyConnStyleInput,
      conflictEl: document.getElementById("hotkeyConflictConnStyle"),
      storageKey: "inittracker_hotkey_toggleConnStyle",
      action: () => {
        connStyle = connStyle === "compact" ? "full" : "compact";
        persistChoice(uiSelectKeys.connStyle, connStyle);
        applyUiConfig();
      },
    },
    lockMap: {
      input: hotkeyLockMapInput,
      conflictEl: document.getElementById("hotkeyConflictLockMap"),
      storageKey: "inittracker_hotkey_lockMap",
      action: () => lockMapBtn && lockMapBtn.click(),
    },
    centerMap: {
      input: hotkeyCenterMapInput,
      conflictEl: document.getElementById("hotkeyConflictCenterMap"),
      storageKey: "inittracker_hotkey_centerMap",
      action: () => centerMapBtn && centerMapBtn.click(),
    },
    measure: {
      input: hotkeyMeasureInput,
      conflictEl: document.getElementById("hotkeyConflictMeasure"),
      storageKey: "inittracker_hotkey_measure",
      action: () => measureToggle && measureToggle.click(),
    },
    measureClear: {
      input: hotkeyMeasureClearInput,
      conflictEl: document.getElementById("hotkeyConflictMeasureClear"),
      storageKey: "inittracker_hotkey_measureClear",
      action: () => measureClear && measureClear.click(),
    },
    zoomIn: {
      input: hotkeyZoomInInput,
      conflictEl: document.getElementById("hotkeyConflictZoomIn"),
      storageKey: "inittracker_hotkey_zoomIn",
      action: () => zoomInBtn && zoomInBtn.click(),
    },
    zoomOut: {
      input: hotkeyZoomOutInput,
      conflictEl: document.getElementById("hotkeyConflictZoomOut"),
      storageKey: "inittracker_hotkey_zoomOut",
      action: () => zoomOutBtn && zoomOutBtn.click(),
    },
    battleLog: {
      input: hotkeyBattleLogInput,
      conflictEl: document.getElementById("hotkeyConflictBattleLog"),
      storageKey: "inittracker_hotkey_battleLog",
      action: () => battleLogBtn && battleLogBtn.click(),
    },
    useAction: {
      input: hotkeyUseActionInput,
      conflictEl: document.getElementById("hotkeyConflictUseAction"),
      storageKey: "inittracker_hotkey_useAction",
      action: () => useActionBtn && useActionBtn.click(),
    },
    useBonusAction: {
      input: hotkeyUseBonusActionInput,
      conflictEl: document.getElementById("hotkeyConflictUseBonusAction"),
      storageKey: "inittracker_hotkey_useBonusAction",
      action: () => useBonusActionBtn && useBonusActionBtn.click(),
    },
    dash: {
      input: hotkeyDashInput,
      conflictEl: document.getElementById("hotkeyConflictDash"),
      storageKey: "inittracker_hotkey_dash",
      action: () => dashBtn && dashBtn.click(),
    },
    standUp: {
      input: hotkeyStandUpInput,
      conflictEl: document.getElementById("hotkeyConflictStandUp"),
      storageKey: "inittracker_hotkey_standUp",
      action: () => standUpBtn && standUpBtn.click(),
    },
    resetTurn: {
      input: hotkeyResetTurnInput,
      conflictEl: document.getElementById("hotkeyConflictResetTurn"),
      storageKey: "inittracker_hotkey_resetTurn",
      action: () => resetTurnBtn && resetTurnBtn.click(),
    },
    toggleSheetPanel: {
      input: hotkeyToggleSheetPanelInput,
      conflictEl: document.getElementById("hotkeyConflictToggleSheetPanel"),
      storageKey: "inittracker_hotkey_toggleSheetPanel",
      action: () => setSheetPanelHidden(!sheetPanelHidden),
    },
    toggleAttackOverlay: {
      input: hotkeyAttackOverlayInput,
      conflictEl: document.getElementById("hotkeyConflictAttackOverlay"),
      storageKey: "inittracker_hotkey_toggleAttackOverlay",
      action: () => attackOverlayToggleBtn && !attackOverlayToggleBtn.disabled && attackOverlayToggleBtn.click(),
    },
  };

  if (!localStorage.getItem("inittracker_hotkey_toggleSheetPanel")){
    localStorage.setItem("inittracker_hotkey_toggleSheetPanel", "Delete");
  }
  if (!localStorage.getItem("inittracker_hotkey_toggleAttackOverlay")){
    localStorage.setItem("inittracker_hotkey_toggleAttackOverlay", "A");
  }

  let hotkeyBindings = new Map();

  function normalizeHotkeyEvent(event){
    if (!event) return null;
    if (event.key === "Shift" || event.key === "Control" || event.key === "Alt" || event.key === "Meta"){
      return null;
    }
    const parts = [];
    if (event.ctrlKey) parts.push("Ctrl");
    if (event.altKey) parts.push("Alt");
    if (event.metaKey) parts.push("Meta");
    if (event.shiftKey) parts.push("Shift");
    let key = event.key;
    if (key === " ") key = "Space";
    if (key.length === 1) key = key.toUpperCase();
    parts.push(key);
    return parts.join("+");
  }

  function isTypingTarget(target){
    if (!target) return false;
    const tag = target.tagName ? target.tagName.toLowerCase() : "";
    if (tag === "input" || tag === "textarea" || tag === "select") return true;
    if (target.isContentEditable) return true;
    return false;
  }

  function setHotkey(action, value){
    const config = hotkeyConfig[action];
    if (!config) return;
    const stored = value ? String(value) : "";
    if (stored){
      localStorage.setItem(config.storageKey, stored);
    } else {
      localStorage.removeItem(config.storageKey);
    }
    updateHotkeyInputs();
  }

  function updateHotkeyInputs(){
    const usage = {};
    hotkeyBindings = new Map();
    Object.entries(hotkeyConfig).forEach(([action, config]) => {
      if (!config || !config.input) return;
      const stored = localStorage.getItem(config.storageKey) || "";
      const normalized = stored.trim();
      config.input.value = normalized;
      if (normalized){
        if (!usage[normalized]) usage[normalized] = [];
        usage[normalized].push(action);
      }
    });
    Object.entries(hotkeyConfig).forEach(([action, config]) => {
      if (!config || !config.input) return;
      const stored = (localStorage.getItem(config.storageKey) || "").trim();
      const conflicts = stored && usage[stored] && usage[stored].length > 1;
      config.input.classList.toggle("conflict", !!conflicts);
      if (config.conflictEl){
        config.conflictEl.textContent = conflicts ? "Conflict" : "";
      }
      if (stored && !conflicts){
        hotkeyBindings.set(stored, action);
      }
    });
  }

  let presetStatusTimer = null;
  const presetStorageKey = "inittracker_gui_preset";

  function setPresetStatus(text, durationMs=2000){
    if (!presetStatus) return;
    presetStatus.textContent = text || "";
    if (presetStatusTimer){
      clearTimeout(presetStatusTimer);
      presetStatusTimer = null;
    }
    if (text && durationMs > 0){
      presetStatusTimer = setTimeout(() => {
        if (presetStatus) presetStatus.textContent = "";
        presetStatusTimer = null;
      }, durationMs);
    }
  }

  function normalizePresetHotkey(value){
    if (value === null || value === undefined) return "";
    const normalized = String(value).trim();
    return normalized;
  }

  function buildGuiPreset(){
    const hotkeys = {};
    Object.entries(hotkeyConfig).forEach(([action, config]) => {
      if (!config || !config.storageKey) return;
      hotkeys[action] = normalizePresetHotkey(localStorage.getItem(config.storageKey) || "");
    });
    return {
      version: 1,
      toggles: {
        topbarTitle: showTopbarTitle,
        connIndicator: showConnIndicator,
        lockMap: showLockMap,
        centerMap: showCenterMap,
        measure: showMeasure,
        measureClear: showMeasureClear,
        zoomIn: showZoomIn,
        zoomOut: showZoomOut,
        battleLog: showBattleLog,
        useAction: showUseAction,
        useBonusAction: showUseBonusAction,
        dash: showDash,
        standUp: showStandUp,
        resetTurn: showResetTurn,
        hideSpellMenu: hideSpellMenu,
        lockMenus: menusLocked,
      },
      choices: {
        connStyle,
        initiativeStyle,
      },
      showAllNames: showAllNames,
      sheetHeight: Number.isFinite(sheetHeight) ? Math.round(sheetHeight) : null,
      hotkeys,
    };
  }

  function persistLocalPreset(preset){
    try {
      localStorage.setItem(presetStorageKey, JSON.stringify(preset));
    } catch (err){
      console.warn("Failed to persist GUI preset locally.", err);
    }
  }

  function loadLocalPreset(){
    try {
      const raw = localStorage.getItem(presetStorageKey);
      if (!raw) return null;
      const preset = JSON.parse(raw);
      if (preset && typeof preset === "object"){
        return preset;
      }
    } catch (err){
      console.warn("Failed to load GUI preset from storage.", err);
    }
    return null;
  }

  function applyGuiPreset(preset, options = {}){
    if (!preset || typeof preset !== "object") return;
    const persist = options.persist !== false;
    const toggles = preset.toggles && typeof preset.toggles === "object" ? preset.toggles : {};
    const choices = preset.choices && typeof preset.choices === "object" ? preset.choices : {};
    if (typeof toggles.topbarTitle === "boolean") showTopbarTitle = toggles.topbarTitle;
    if (typeof toggles.connIndicator === "boolean") showConnIndicator = toggles.connIndicator;
    if (typeof toggles.lockMap === "boolean") showLockMap = toggles.lockMap;
    if (typeof toggles.centerMap === "boolean") showCenterMap = toggles.centerMap;
    if (typeof toggles.measure === "boolean") showMeasure = toggles.measure;
    if (typeof toggles.measureClear === "boolean") showMeasureClear = toggles.measureClear;
    if (typeof toggles.zoomIn === "boolean") showZoomIn = toggles.zoomIn;
    if (typeof toggles.zoomOut === "boolean") showZoomOut = toggles.zoomOut;
    if (typeof toggles.battleLog === "boolean") showBattleLog = toggles.battleLog;
    if (typeof toggles.useAction === "boolean") showUseAction = toggles.useAction;
    if (typeof toggles.useBonusAction === "boolean") showUseBonusAction = toggles.useBonusAction;
    if (typeof toggles.dash === "boolean") showDash = toggles.dash;
    if (typeof toggles.standUp === "boolean") showStandUp = toggles.standUp;
    if (typeof toggles.resetTurn === "boolean") showResetTurn = toggles.resetTurn;
    if (typeof toggles.hideSpellMenu === "boolean") hideSpellMenu = toggles.hideSpellMenu;
    if (typeof toggles.lockMenus === "boolean") menusLocked = toggles.lockMenus;
    if (persist){
      persistToggle(uiToggleKeys.topbarTitle, showTopbarTitle);
      persistToggle(uiToggleKeys.connIndicator, showConnIndicator);
      persistToggle(uiToggleKeys.lockMap, showLockMap);
      persistToggle(uiToggleKeys.centerMap, showCenterMap);
      persistToggle(uiToggleKeys.measure, showMeasure);
      persistToggle(uiToggleKeys.measureClear, showMeasureClear);
      persistToggle(uiToggleKeys.zoomIn, showZoomIn);
      persistToggle(uiToggleKeys.zoomOut, showZoomOut);
      persistToggle(uiToggleKeys.battleLog, showBattleLog);
      persistToggle(uiToggleKeys.useAction, showUseAction);
      persistToggle(uiToggleKeys.useBonusAction, showUseBonusAction);
      persistToggle(uiToggleKeys.dash, showDash);
      persistToggle(uiToggleKeys.standUp, showStandUp);
      persistToggle(uiToggleKeys.resetTurn, showResetTurn);
      persistToggle(uiToggleKeys.hideSpellMenu, hideSpellMenu);
      persistToggle(uiToggleKeys.lockMenus, menusLocked);
    }
    if (choices.connStyle && ["full", "compact"].includes(choices.connStyle)){
      connStyle = choices.connStyle;
      if (persist){
        persistChoice(uiSelectKeys.connStyle, connStyle);
      }
    }
    if (choices.initiativeStyle && ["full", "compact", "hidden"].includes(choices.initiativeStyle)){
      initiativeStyle = choices.initiativeStyle;
      if (persist){
        persistChoice(uiSelectKeys.initiativeStyle, initiativeStyle);
      }
    }
    if (typeof preset.showAllNames === "boolean"){
      showAllNames = preset.showAllNames;
      if (showAllNamesEl){
        showAllNamesEl.checked = showAllNames;
      }
      if (persist){
        localStorage.setItem("inittracker_showAllNames", showAllNames ? "1" : "0");
      }
    }
    if (Number.isFinite(Number(preset.sheetHeight))){
      applySheetHeight(Number(preset.sheetHeight));
      if (persist){
        persistSheetHeight();
      }
    }
    if (preset.hotkeys && typeof preset.hotkeys === "object"){
      Object.entries(preset.hotkeys).forEach(([action, value]) => {
        const config = hotkeyConfig[action];
        if (!config || !config.storageKey) return;
        const normalized = normalizePresetHotkey(value);
        if (persist){
          if (normalized){
            localStorage.setItem(config.storageKey, normalized);
          } else {
            localStorage.removeItem(config.storageKey);
          }
        }
        if (config.input){
          config.input.value = normalized;
        }
      });
    }
    applyUiConfig();
    updateHotkeyInputs();
  }

  function applyConnStyle(){
    if (!connEl) return;
    connEl.classList.toggle("conn-compact", connStyle === "compact");
    updateConnDisplay();
  }

  function shouldAutoCompactLayout(){
    const width = window.innerWidth || document.documentElement?.clientWidth || 0;
    const height = window.innerHeight || document.documentElement?.clientHeight || 0;
    return width <= 900 || height <= 720;
  }

  function toggleInitiativeBar(forceVisible){
    const shouldShow = typeof forceVisible === "boolean"
      ? forceVisible
      : document.body.classList.contains("initiative-hidden");
    document.body.classList.toggle("initiative-hidden", !shouldShow);
    initiativeStyle = shouldShow ? "full" : "hidden";
    persistChoice(uiSelectKeys.initiativeStyle, initiativeStyle);
    if (initiativeStyleSelect){
      initiativeStyleSelect.value = initiativeStyle;
    }
    if (initiativeToggleBtn){
      initiativeToggleBtn.setAttribute("aria-pressed", shouldShow ? "true" : "false");
    }
    updateModalOffsets();
    updateTurnOrder();
    resize();
  }

  function applyUiConfig(){
    const autoCompact = initiativeStyle === "full" && shouldAutoCompactLayout();
    document.body.classList.toggle("menus-locked", menusLocked);
    document.body.classList.toggle("initiative-compact", initiativeStyle === "compact" || autoCompact);
    document.body.classList.toggle("initiative-hidden", initiativeStyle === "hidden");
    document.body.classList.toggle("auto-compact", autoCompact);
    if (initiativeToggleBtn) initiativeToggleBtn.setAttribute("aria-pressed", initiativeStyle === "hidden" ? "false" : "true");
    if (topbarTitleEl) topbarTitleEl.classList.toggle("hidden", !showTopbarTitle);
    if (connEl) connEl.classList.toggle("hidden", !showConnIndicator);
    if (!showConnIndicator){
      closeConnPopover();
    }
    if (lockMapBtn) lockMapBtn.classList.toggle("hidden", !showLockMap);
    if (centerMapBtn) centerMapBtn.classList.toggle("hidden", !showCenterMap);
    if (measureToggle) measureToggle.classList.toggle("hidden", !showMeasure);
    if (measureClear) measureClear.classList.toggle("hidden", !showMeasureClear);
    if (zoomInBtn) zoomInBtn.classList.toggle("hidden", !showZoomIn);
    if (zoomOutBtn) zoomOutBtn.classList.toggle("hidden", !showZoomOut);
    if (battleLogBtn) battleLogBtn.classList.toggle("hidden", !showBattleLog);
    if (useActionBtn) useActionBtn.classList.toggle("hidden", !showUseAction);
    if (useBonusActionBtn) useBonusActionBtn.classList.toggle("hidden", !showUseBonusAction);
    if (dashBtn) dashBtn.classList.toggle("hidden", !showDash);
    if (standUpBtn) standUpBtn.classList.toggle("hidden", !showStandUp);
    if (resetTurnBtn) resetTurnBtn.classList.toggle("hidden", !showResetTurn);
    if (toggleTopbarTitle) toggleTopbarTitle.checked = showTopbarTitle;
    if (toggleConnIndicator) toggleConnIndicator.checked = showConnIndicator;
    if (connStyleButtons.length){
      connStyleButtons.forEach((button) => {
        const isActive = button.dataset.connStyle === connStyle;
        button.classList.toggle("active", isActive);
        button.setAttribute("aria-pressed", isActive ? "true" : "false");
      });
    }
    if (toggleLockMap) toggleLockMap.checked = showLockMap;
    if (toggleCenterMap) toggleCenterMap.checked = showCenterMap;
    if (toggleMeasure) toggleMeasure.checked = showMeasure;
    if (toggleMeasureClear) toggleMeasureClear.checked = showMeasureClear;
    if (toggleZoomIn) toggleZoomIn.checked = showZoomIn;
    if (toggleZoomOut) toggleZoomOut.checked = showZoomOut;
    if (toggleBattleLog) toggleBattleLog.checked = showBattleLog;
    if (initiativeStyleSelect) initiativeStyleSelect.value = initiativeStyle;
    if (toggleUseAction) toggleUseAction.checked = showUseAction;
    if (toggleUseBonusAction) toggleUseBonusAction.checked = showUseBonusAction;
    if (toggleDash) toggleDash.checked = showDash;
    if (toggleStandUp) toggleStandUp.checked = showStandUp;
    if (toggleResetTurn) toggleResetTurn.checked = showResetTurn;
    if (toggleSpellMenu) toggleSpellMenu.checked = hideSpellMenu;
    if (toggleLockMenus) toggleLockMenus.checked = menusLocked;
    if (sheetWrap){
      sheetWrap.classList.toggle("hidden", sheetPanelHidden);
    }
    if (toggleSheetPanelBtn){
      toggleSheetPanelBtn.textContent = sheetPanelHidden ? "Show Panel" : "Hide Panel";
      toggleSheetPanelBtn.setAttribute("aria-pressed", sheetPanelHidden ? "true" : "false");
    }
    if (sheetHandle){
      sheetHandle.setAttribute("aria-disabled", menusLocked ? "true" : "false");
    }
    applyConnStyle();
    updateHotkeyInputs();
    updateSpellPanelVisibility();
    updateMountControls();
    updateAoeLockButton();
  }

  const localPreset = loadLocalPreset();
  if (localPreset){
    applyGuiPreset(localPreset, {persist: true});
    if (!Number.isFinite(Number(localPreset.sheetHeight))){
      loadSheetHeight();
    }
  } else {
    applyUiConfig();
    loadSheetHeight();
  }
  if (sheetHandle && sheetWrap){
    let dragState = null;
    sheetHandle.addEventListener("pointerdown", (event) => {
      if (menusLocked) return;
      sheetHandle.setPointerCapture(event.pointerId);
      dragState = {
        startY: event.clientY,
        startHeight: sheetWrap.getBoundingClientRect().height,
      };
      event.preventDefault();
    });
    sheetHandle.addEventListener("pointermove", (event) => {
      if (!dragState) return;
      const delta = dragState.startY - event.clientY;
      applySheetHeight(dragState.startHeight + delta);
    });
    sheetHandle.addEventListener("pointerup", () => {
      if (!dragState) return;
      dragState = null;
      persistSheetHeight();
    });
    sheetHandle.addEventListener("pointercancel", () => {
      if (!dragState) return;
      dragState = null;
      persistSheetHeight();
    });
  }

  function setHelpMessage(text){
    if (helpMessage){ helpMessage.textContent = text || ""; }
  }

  function flattenToc(nodes){
    const out = [];
    const walk = (items) => (items || []).forEach((node) => { out.push(node); walk(node.children || []); });
    walk(nodes || []);
    return out;
  }

  function renderRulesToc(){
    if (!helpTocTree) return;
    const q = String(helpSearchInput?.value || "").trim().toLowerCase();
    const matches = (title) => !q || String(title || "").toLowerCase().includes(q);
    const className = getClaimedPlayerClassName();
    const classNode = findClassNode(className);
    const build = (nodes) => {
      const frag = document.createDocumentFragment();
      (nodes || []).forEach((node) => {
        const childFrag = build(node.children || []);
        const include = matches(node.title) || childFrag.childNodes.length > 0;
        if (!include) return;
        const row = document.createElement("div");
        row.className = "rules-help-node";
        const btn = document.createElement("button");
        btn.type = "button";
        const page = node.page ? ` (p.${node.page})` : "";
        btn.textContent = `${node.title}${page}`;
        btn.addEventListener("click", () => jumpRulesPage(node.page || 1));
        row.appendChild(btn);
        if (childFrag.childNodes.length){
          const children = document.createElement("div");
          children.className = "rules-help-children";
          children.appendChild(childFrag);
          row.appendChild(children);
        }
        frag.appendChild(row);
      });
      return frag;
    };
    helpTocTree.innerHTML = "";
    if (rulesStatusCache?.available && classNode?.page){
      const pinned = document.createElement("div");
      pinned.className = "rules-help-pinned";
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "btn";
      btn.textContent = `My class: ${className || classNode.title || "Unknown"} (p.${classNode.page})`;
      btn.addEventListener("click", () => jumpRulesPage(classNode.page || 1));
      pinned.appendChild(btn);
      helpTocTree.appendChild(pinned);
    }
    helpTocTree.appendChild(build(rulesTocCache));
  }

  function loadRulesViewer(page=1){
    if (!helpViewer) return;
    rulesLastPage = Math.max(1, Number(page || 1));
    const base = "/assets/web/lan/pdfjs/web/viewer.html";
    const nonce = Date.now();
    const url = `${base}?page=${rulesLastPage}&_ts=${nonce}#page=${rulesLastPage}`;
    rulesViewerReady = false;
    helpViewer.src = url;
    rulesViewerLoaded = true;
  }

  function jumpRulesPage(page=1){
    const num = Math.max(1, Number(page || 1));
    rulesLastPage = num;
    try { localStorage.setItem(rulesLastPageStorageKey, String(num)); } catch (_err) {}
    if (!rulesViewerLoaded){
      loadRulesViewer(num);
      return;
    }
    try {
      const frameWin = helpViewer.contentWindow;
      if (rulesViewerReady && frameWin){
        frameWin.postMessage({ type: "rules:jump", page: num }, window.location.origin);
      }
      const current = new URL(helpViewer.src, window.location.origin);
      current.hash = `page=${num}`;
      const nextUrl = current.toString();
      if (helpViewer.src !== nextUrl){
        helpViewer.src = nextUrl;
      }
    } catch (_err){
      loadRulesViewer(num);
    }
  }

  function normalizeClassToken(value){
    const raw = String(value || "").trim().toLowerCase();
    if (!raw) return "";
    const first = raw.split(/[\/,;&+|]/)[0] || raw;
    return first.trim().replace(/[^a-z0-9\s-]/g, " ").split(/\s+/)[0] || "";
  }

  function getClaimedPlayerClassName(){
    const claimed = getClaimedUnit?.();
    const claimedName = String(claimed?.name || "").trim();
    if (!claimedName) return "";
    const profiles = state?.player_profiles && typeof state.player_profiles === "object"
      ? state.player_profiles
      : null;
    if (!profiles) return "";
    const player = profiles[claimedName] || null;
    if (!player || typeof player !== "object") return "";
    const leveling = player.leveling && typeof player.leveling === "object" ? player.leveling : null;
    if (!leveling) return "";
    if (typeof leveling.class === "string" && leveling.class.trim()) return leveling.class.trim();
    const classes = Array.isArray(leveling.classes) ? leveling.classes : [];
    const first = classes.find((entry) => entry && typeof entry === "object" && typeof entry.name === "string" && entry.name.trim());
    return first?.name?.trim() || "";
  }

  function findClassNode(className){
    const token = normalizeClassToken(className);
    if (!token) return null;
    const flat = flattenToc(rulesTocCache);
    const normalized = flat.map((n) => ({
      node: n,
      title: String(n?.title || "").trim().toLowerCase().replace(/[^a-z0-9\s-]/g, " ").replace(/\s+/g, " ").trim(),
    }));
    return normalized.find((n) => n.title === token)?.node
      || normalized.find((n) => n.title.startsWith(`${token} `))?.node
      || normalized.find((n) => n.title.includes(token))?.node
      || null;
  }

  async function ensureRulesData(){
    if (!rulesStatusCache){
      const statusResp = await fetch("/api/rules/status");
      rulesStatusCache = await statusResp.json();
    }
    if (rulesStatusCache?.available && (!Array.isArray(rulesTocCache) || !rulesTocCache.length)){
      const tocResp = await fetch("/api/rules/toc");
      const tocPayload = await tocResp.json();
      rulesTocCache = Array.isArray(tocPayload?.toc) ? tocPayload.toc : [];
    }
    if (!rulesSpellPagesCache){
      const spellPagesResp = await fetch("/api/rules/spell-pages");
      const spellPagesPayload = await spellPagesResp.json();
      rulesSpellPagesCache = spellPagesPayload?.pages && typeof spellPagesPayload.pages === "object"
        ? spellPagesPayload.pages
        : {};
    }
    renderRulesToc();
    const available = !!rulesStatusCache?.available;
    if (helpOpenBookBtn) helpOpenBookBtn.disabled = !available;
    if (helpOpenClassBtn) helpOpenClassBtn.disabled = !available;
    if (!available){
      const expected = rulesStatusCache?.expected_path || "~/Documents/Dnd-Init-Yamls/rules/PlayersHandbook2024.pdf";
      setHelpMessage(`Place your PDF at: ${expected} (or set INITTRACKER_RULES_PDF).`);
    } else if (rulesStatusCache?.error){
      setHelpMessage(String(rulesStatusCache.error));
    } else {
      setHelpMessage("");
    }
  }

  function showHelpModal(){
    if (!helpModal) return;
    helpModal.classList.add("show");
    helpModal.setAttribute("aria-hidden", "false");
    if (helpBtn) helpBtn.setAttribute("aria-expanded", "true");
    ensureRulesData().catch(() => setHelpMessage("Failed to load rules metadata."));
  }

  function hideHelpModal(){
    if (!helpModal) return;
    helpModal.classList.remove("show");
    helpModal.setAttribute("aria-hidden", "true");
    if (helpBtn) helpBtn.setAttribute("aria-expanded", "false");
  }

  function showConfigModal(){
    if (!configModal) return;
    configModal.classList.add("show");
    configModal.setAttribute("aria-hidden", "false");
    if (configBtn){
      configBtn.setAttribute("aria-expanded", "true");
    }
  }

  function hideConfigModal(){
    if (!configModal) return;
    configModal.classList.remove("show");
    configModal.setAttribute("aria-hidden", "true");
    if (configBtn){
      configBtn.setAttribute("aria-expanded", "false");
    }
  }

  if (helpBtn){
    helpBtn.addEventListener("click", () => {
      if (helpModal?.classList.contains("show")){
        hideHelpModal();
        return;
      }
      showHelpModal();
    });
  }
  if (helpCloseBtn){
    helpCloseBtn.addEventListener("click", hideHelpModal);
  }
  if (helpModal){
    helpModal.addEventListener("click", (event) => {
      if (event.target === helpModal){
        hideHelpModal();
      }
    });
  }
  if (helpSearchInput){
    helpSearchInput.addEventListener("input", () => renderRulesToc());
  }
  if (helpViewer){
    helpViewer.addEventListener("load", () => {
      rulesViewerReady = true;
      try {
        const frameWin = helpViewer.contentWindow;
        if (frameWin){
          frameWin.postMessage({ type: "rules:jump", page: rulesLastPage || 1 }, window.location.origin);
        }
      } catch (_err) {}
    });
  }
  if (helpOpenBookBtn){
    helpOpenBookBtn.addEventListener("click", () => jumpRulesPage(rulesLastPage || 1));
  }
  if (helpOpenTabBtn){
    helpOpenTabBtn.addEventListener("click", () => {
      window.open(`/assets/web/lan/pdfjs/web/viewer.html?page=${rulesLastPage || 1}#page=${rulesLastPage || 1}`, "_blank", "noopener,noreferrer");
    });
  }
  if (helpOpenClassBtn){
    helpOpenClassBtn.addEventListener("click", () => {
      const className = getClaimedPlayerClassName();
      const node = findClassNode(className);
      if (!className){
        setHelpMessage("Could not determine your class from the claimed character profile.");
        return;
      }
      if (!node || !node.page){
        setHelpMessage(`Could not find a bookmark for class: ${className}`);
        return;
      }
      setHelpMessage("");
      jumpRulesPage(node.page);
    });
  }

  const mapViewBlockedTypes = new Set([
    "move",
    "dash",
    "cycle_movement_mode",
    "perform_action",
    "end_turn",
    "use_action",
    "use_bonus_action",
    "set_color",
    "reset_turn",
    "cast_aoe",
    "cast_spell",
    "echo_summon",
    "echo_swap",
    "aoe_move",
    "aoe_remove",
    "save_preset",
    "lay_on_hands_use",
  ]);

  function send(msg){
    if (isPlanning) return;
    if (isMapView && msg && mapViewBlockedTypes.has(msg.type)){
      return;
    }
    if (!ws || ws.readyState !== 1) return;
    ws.send(JSON.stringify(msg));
  }

  function localToast(text){
    if (!noteEl) return;
    noteEl.textContent = text || "";
  }

  const DEFAULT_SPELL_COLOR = "#6aa9ff";

  function normalizeHexColor(raw){
    if (!raw) return null;
    const value = String(raw).trim().toLowerCase();
    if (!/^#[0-9a-f]{6}$/.test(value)) return null;
    return value;
  }

  function normalizeMovementMode(value){
    if (typeof value !== "string") return "normal";
    const lowered = value.trim().toLowerCase();
    if (["normal", "swim", "burrow", "fly"].includes(lowered)) return lowered;
    if (lowered === "land") return "normal";
    if (lowered === "water") return "swim";
    return "normal";
  }

  function normalizeMovementType(value, isSwim){
    if (typeof value === "string"){
      const lowered = value.trim().toLowerCase();
      if (["water", "ground"].includes(lowered)) return lowered;
      if (["swim", "waterborne"].includes(lowered)) return "water";
      if (["land", "normal", "burrow", "earth"].includes(lowered)) return "ground";
    }
    return isSwim ? "water" : "ground";
  }

  function cellMovementType(cell){
    return normalizeMovementType(cell?.movement_type, !!cell?.is_swim);
  }

  function movementModeLabel(mode){
    const key = normalizeMovementMode(mode);
    if (key === "swim") return "Swim";
    if (key === "burrow") return "Burrow";
    if (key === "fly") return "Fly";
    return "Normal";
  }

  function resolveSpellColor(raw){
    return normalizeHexColor(raw || "") || DEFAULT_SPELL_COLOR;
  }

  function hexToRgb(hex){
    const value = normalizeHexColor(hex);
    if (!value) return null;
    return {
      r: parseInt(value.slice(1, 3), 16),
      g: parseInt(value.slice(3, 5), 16),
      b: parseInt(value.slice(5, 7), 16),
    };
  }


  function applyServerClaim(claimedCidValue, claimedName, incomingRev){
    const revValue = Number.isFinite(Number(incomingRev)) ? Number(incomingRev) : claimRev;
    if (Number.isFinite(revValue) && revValue < claimRev){
      return false;
    }
    claimRev = Number.isFinite(revValue) ? revValue : claimRev;
    claimedCid = normalizeCid(claimedCidValue, "claim.server.claimedCid");
    claimStatus = (claimedCid !== null && claimedCid !== undefined) ? "claimed" : "unclaimed";
    clearClaimInFlight();
    if (meEl){
      if (claimedCid !== null && claimedCid !== undefined){
        const name = claimedName || getClaimablePcName(claimedCid, lastPcList || []) || `#${claimedCid}`;
        meEl.textContent = name;
      } else {
        meEl.textContent = "(unclaimed)";
      }
    }
    if (claimedCid !== null && claimedCid !== undefined){
      shownNoOwnedToast = false;
    }
    refreshSpellPresetOptions();
    updateClaimOverlay();
    updateMountControls();
    queueMicrotask(updateMountControls);
    return true;
  }

  function rgbaFromHex(hex, alpha){
    const rgb = hexToRgb(hex);
    if (!rgb) return null;
    return `rgba(${rgb.r},${rgb.g},${rgb.b},${alpha})`;
  }

  function updateColorRgbBoxes(color, rEl, gEl, bEl){
    const rgb = hexToRgb(color);
    if (!rgb) return;
    if (rEl) rEl.textContent = `R: ${rgb.r}`;
    if (gEl) gEl.textContent = `G: ${rgb.g}`;
    if (bEl) bEl.textContent = `B: ${rgb.b}`;
  }

  function updateTokenColorSwatch(color){
    const resolved = normalizeHexColor(color) || "#6aa9ff";
    if (tokenColorSwatch) tokenColorSwatch.style.background = resolved;
    updateColorRgbBoxes(resolved, tokenColorR, tokenColorG, tokenColorB);
  }

  function updateTokenBorderColorSwatch(color){
    const resolved = normalizeHexColor(color) || "#ffffff";
    if (tokenBorderColorSwatch) tokenBorderColorSwatch.style.background = resolved;
    updateColorRgbBoxes(resolved, tokenBorderColorR, tokenBorderColorG, tokenBorderColorB);
  }

  function openColorModal(unit){
    if (!colorModal || !tokenColorInput || !tokenBorderColorInput) return;
    const targetUnit = unit || getClaimedUnit();
    if (!targetUnit){
      localToast("Claim a character first, matey.");
      return;
    }
    pendingClaim = targetUnit;
    let preferred = normalizeHexColor(targetUnit?.token_color)
      || normalizeHexColor(localStorage.getItem("inittracker_tokenColor"))
      || "#6aa9ff";
    const preferredBorder = normalizeHexColor(targetUnit?.token_border_color)
      || normalizeHexColor(localStorage.getItem("inittracker_tokenBorderColor"))
      || "#ffffff";
    tokenColorInput.value = preferred;
    tokenBorderColorInput.value = preferredBorder;
    updateTokenColorSwatch(preferred);
    updateTokenBorderColorSwatch(preferredBorder);
    colorModal.classList.add("show");
    colorModal.setAttribute("aria-hidden", "false");
  }

  function closeColorModal(){
    if (!colorModal) return;
    colorModal.classList.remove("show");
    colorModal.setAttribute("aria-hidden", "true");
    pendingClaim = null;
  }

  function openClaimedColorModal(){
    openColorModal(getClaimedUnit());
  }

  function validateTokenColor(raw){
    const color = normalizeHexColor(raw);
    if (!color){
      localToast("Pick a valid hex color, matey.");
      return null;
    }
    return color;
  }

  function showNoOwnedPcToast(pcs){
    if (isMapView) return;
    if (shownNoOwnedToast) return;
    if (claimStatus !== "unclaimed") return;
    if (claimedCid) return;
    const list = Array.isArray(pcs) ? pcs : [];
    if (!list.length) return;
    localToast("No assigned PCs found. Ask the DM to assign yer character.");
    shownNoOwnedToast = true;
  }

  function getClaimablePcName(cid, pcs){
    const list = Array.isArray(pcs) ? pcs : [];
    const match = list.find((pc) => pc && cidMatches(pc.cid, cid, "claimList.nameMatch"));
    if (match?.name) return String(match.name);
    const unit = getUnitByCid(cid);
    if (unit?.name) return String(unit.name);
    return null;
  }

  function storeLanSelection(cid, pcs){
    const cidValue = normalizeCid(cid, "lan.storeCid");
    if (cidValue === null) return;
    localStorage.setItem(lanSelectedCidKey, String(cidValue));
    const name = getClaimablePcName(cidValue, pcs);
    if (name){
      localStorage.setItem(lanSelectedNameKey, name);
    } else {
      localStorage.removeItem(lanSelectedNameKey);
    }
  }

  function clearLanSelection(){
    localStorage.removeItem(lanSelectedCidKey);
    localStorage.removeItem(lanSelectedNameKey);
  }

  function loadLanSelection(){
    const storedCid = Number(localStorage.getItem(lanSelectedCidKey));
    const cidValue = normalizeCid(storedCid, "lan.loadCid");
    if (cidValue === null) return null;
    const nameValue = localStorage.getItem(lanSelectedNameKey);
    return {
      cid: cidValue,
      name: nameValue ? String(nameValue) : null,
    };
  }

  function clearAutoClaimPending(){
    if (autoClaimPending?.timeoutId){
      clearTimeout(autoClaimPending.timeoutId);
    }
    autoClaimPending = null;
  }

  function setClaimInFlight(cid){
    if (claimInFlightTimeoutId){
      clearTimeout(claimInFlightTimeoutId);
      claimInFlightTimeoutId = null;
    }
    claimInFlight = true;
    claimInFlightCid = normalizeCid(cid, "claim.inFlightCid");
    claimStatus = "claiming";
    claimInFlightTimeoutId = setTimeout(() => {
      claimInFlightTimeoutId = null;
      if (!claimInFlight) return;
      const pendingCid = claimInFlightCid;
      clearClaimInFlight();
      if (claimStatus !== "claimed"){
        claimStatus = "unclaimed";
      }
      if (pendingCid !== null && pendingCid !== undefined){
        const displayName = getClaimablePcName(pendingCid, lastPcList || []) || `#${pendingCid}`;
        localToast(`Claim for ${displayName} timed out. Please try again.`);
      } else {
        localToast("Claim request timed out. Please try again.");
      }
      updateClaimOverlay();
    }, claimInFlightTimeoutMs);
    if (claimConfirmBtn){
      claimConfirmBtn.disabled = true;
    }
  }

  function clearClaimInFlight(){
    if (claimInFlightTimeoutId){
      clearTimeout(claimInFlightTimeoutId);
      claimInFlightTimeoutId = null;
    }
    claimInFlight = false;
    claimInFlightCid = null;
    if (claimStatus === "claiming"){
      claimStatus = (claimedCid !== null && claimedCid !== undefined) ? "claimed" : "unclaimed";
    }
    updateClaimSelection();
  }

  function handleAutoClaimFailure(){
    if (!autoClaimPending) return;
    const cid = autoClaimPending.cid;
    const displayName = autoClaimPending.name || `#${cid}`;
    clearAutoClaimPending();
    clearClaimInFlight();
    clearLanSelection();
    allowUnclaimed = false;
    localToast(`Could not claim ${displayName}. Please choose again.`);
    updateClaimOverlay();
  }

  function checkAutoClaimResolved(){
    if (!autoClaimPending) return;
    if (claimedCid !== null && claimedCid !== undefined){
      if (cidMatches(claimedCid, autoClaimPending.cid, "lan.autoClaimMatch")){
        clearAutoClaimPending();
      } else {
        handleAutoClaimFailure();
      }
    }
  }

  function maybeAutoClaimFromState(msg, pcs){
    if (autoClaimChecked) return;
    const hasPcInfo = Object.prototype.hasOwnProperty.call(msg || {}, "pcs")
      || Object.prototype.hasOwnProperty.call(msg || {}, "claimable");
    if (!hasPcInfo) return;
    autoClaimChecked = true;
    if (claimedCid !== null && claimedCid !== undefined) return;
    const selection = loadLanSelection();
    if (!selection) return;
    const list = Array.isArray(pcs) ? pcs : [];
    if (list.length){
      const inList = list.some((pc) => pc && cidMatches(pc.cid, selection.cid, "lan.autoClaimList"));
      if (!inList){
        autoClaimPending = {cid: selection.cid, name: selection.name || `#${selection.cid}`};
        handleAutoClaimFailure();
        return;
      }
    }
    const pendingName = selection.name || getClaimablePcName(selection.cid, list) || `#${selection.cid}`;
    autoClaimPending = {
      cid: selection.cid,
      name: pendingName,
      timeoutId: setTimeout(() => {
        if (!autoClaimPending) return;
        if (!claimedCid || !cidMatches(claimedCid, selection.cid, "lan.autoClaimTimeout")){
          handleAutoClaimFailure();
        }
      }, autoClaimTimeoutMs),
      startedAt: stateUpdateCounter,
    };
    setClaimInFlight(selection.cid);
    send({type:"claim", cid: selection.cid, client_id: clientId});
  }

  function handleAutoClaimStateUpdate(){
    if (!autoClaimPending) return;
    if (autoClaimPending.startedAt === undefined) return;
    if (stateUpdateCounter > autoClaimPending.startedAt){
      if (!claimedCid || !cidMatches(claimedCid, autoClaimPending.cid, "lan.autoClaimStateCheck")){
        handleAutoClaimFailure();
      } else {
        clearAutoClaimPending();
      }
    }
  }

  function setSelectedClaimCid(cid){
    selectedClaimCid = normalizeCid(cid, "claimModal.selectedCid");
    updateClaimSelection();
    updateMountControls();
  }

  function updateClaimSelection(){
    if (!claimListEl) return;
    const items = Array.from(claimListEl.querySelectorAll("[data-claim-cid]"));
    items.forEach((item) => {
      const cidValue = normalizeCid(item.dataset.claimCid, "claimModal.itemCid");
      const isSelected = cidValue !== null && selectedClaimCid !== null
        && cidMatches(cidValue, selectedClaimCid, "claimModal.selectedMatch");
      item.classList.toggle("selected", isSelected);
      const radio = item.querySelector("input[type=\"radio\"]");
      if (radio){
        radio.checked = isSelected;
      }
    });
    if (claimConfirmBtn){
      claimConfirmBtn.disabled = claimInFlight || selectedClaimCid === null || selectedClaimCid === undefined;
    }
  }

  function logClaimMessage(type, pcs){
    if (!claimDebugLoggingEnabled) return;
    console.debug(`[claim] ${type} received`, {
      ready: claimDataReady,
      static_data_seen: claimStaticDataSeen,
      state_seen: claimStateSeen,
      claimable_count: Array.isArray(pcs) ? pcs.length : 0,
      claimable_pcs: Array.isArray(pcs) ? pcs : [],
    });
  }

  function markClaimMessageSeen(type){
    if (type === "static_data"){
      claimStaticDataSeen = true;
    } else if (type === "state"){
      claimStateSeen = true;
    }
    claimDataReady = claimStaticDataSeen && claimStateSeen;
  }

  function clearClaimRenderRetry(){
    if (claimRenderRetryTimer){
      clearTimeout(claimRenderRetryTimer);
      claimRenderRetryTimer = null;
    }
  }

  function scheduleClaimRenderRetry(){
    clearClaimRenderRetry();
    claimRenderRetryTimer = setTimeout(() => {
      claimRenderRetryTimer = null;
      if (!claimDataReady) return;
      if (claimedCid !== null && claimedCid !== undefined) return;
      renderClaimList(lastPcList || []);
      updateClaimOverlay();
    }, claimRenderRetryDelayMs);
  }

  function renderClaimList(pcs){
    if (!claimListEl) return;
    const list = Array.isArray(pcs) ? pcs : [];
    if (!claimDataReady){
      clearClaimRenderRetry();
      claimListEl.textContent = "";
      selectedClaimCid = null;
      if (claimEmptyHint){
        claimEmptyHint.textContent = "Loading characters";
        claimEmptyHint.classList.remove("hidden");
      }
      updateClaimSelection();
      return;
    }
    claimListEl.textContent = "";
    let fallbackCid = null;
    list.forEach((pc) => {
      if (!pc || typeof pc !== "object") return;
      const cidValue = normalizeCid(pc.cid, "claimModal.renderCid");
      if (cidValue === null) return;
      if (fallbackCid === null){
        fallbackCid = cidValue;
      }
      const item = document.createElement("button");
      item.type = "button";
      item.className = "item claim-item";
      item.dataset.claimCid = String(cidValue);
      const radio = document.createElement("input");
      radio.type = "radio";
      radio.name = "claimChoice";
      radio.tabIndex = -1;
      const nameEl = document.createElement("div");
      nameEl.className = "name";
      nameEl.textContent = pc.name ? String(pc.name) : `#${cidValue}`;
      const metaEl = document.createElement("div");
      metaEl.className = "meta";
      metaEl.textContent = `CID ${cidValue}`;
      item.appendChild(radio);
      item.appendChild(nameEl);
      item.appendChild(metaEl);
      item.addEventListener("click", () => {
        allowUnclaimed = false;
        setSelectedClaimCid(cidValue);
      });
      claimListEl.appendChild(item);
    });
    if (!list.length){
      selectedClaimCid = null;
    } else if (selectedClaimCid === null || selectedClaimCid === undefined){
      setSelectedClaimCid(fallbackCid);
    }
    if (claimEmptyHint){
      claimEmptyHint.textContent = "No claimable PCs yet. Ask the DM to add one.";
      claimEmptyHint.classList.toggle("hidden", list.length > 0);
    }
    if (!list.length){
      scheduleClaimRenderRetry();
    } else {
      clearClaimRenderRetry();
    }
    updateClaimSelection();
  }

  function updateClaimOverlay(){
    if (!claimModal) return;
    if (isMapView){
      claimModal.classList.remove("show");
      claimModal.setAttribute("aria-hidden", "true");
      return;
    }
    const needsClaim = claimedCid === null || claimedCid === undefined;
    const shouldShow = claimStatus === "unclaimed" && needsClaim && !allowUnclaimed;
    claimModal.classList.toggle("show", shouldShow);
    claimModal.setAttribute("aria-hidden", shouldShow ? "false" : "true");
    if (claimSpectatorBtn){
      claimSpectatorBtn.classList.remove("hidden");
    }
    if (claimContinueBtn){
      claimContinueBtn.classList.remove("hidden");
    }
    if (shouldShow){
      if (!claimDataReady && claimEmptyHint){
        claimEmptyHint.textContent = "Loading characters";
        claimEmptyHint.classList.remove("hidden");
      }
      renderClaimList(lastPcList || []);
    } else {
      clearClaimRenderRetry();
    }
  }

  function enterUnclaimedSpectatorMode(){
    allowUnclaimed = true;
    setSelectedClaimCid(null);
    clearAutoClaimPending();
    clearClaimInFlight();
    clearLanSelection();
    setSheetPanelHidden(true);
    updateClaimOverlay();
  }

  function requestCharacterSwitch(){
    allowUnclaimed = false;
    clearAutoClaimPending();
    clearClaimInFlight();
    clearLanSelection();
    if (claimedCid !== null && claimedCid !== undefined){
      claimStatus = "unclaiming";
      send({type:"unclaim", client_id: clientId});
    }
    claimedCid = null;
    selectedClaimCid = null;
    if (meEl){
      meEl.textContent = "(unclaimed)";
    }
    updateEndTurnState();
    updateClaimOverlay();
  }

  function showDashModal(){
    if (!dashModal) return;
    dashModal.classList.add("show");
    dashModal.setAttribute("aria-hidden", "false");
  }

  function hideDashModal(){
    if (!dashModal) return;
    dashModal.classList.remove("show");
    dashModal.setAttribute("aria-hidden", "true");
  }

  function showLogModal(){
    if (!logModal) return;
    battleLogViewPrefs.visible = true;
    applyBattleLogViewPrefs();
    persistBattleLogViewPrefs();
    refreshMapViewLogPolling();
  }

  function hideLogModal(){
    if (!logModal) return;
    battleLogViewPrefs.visible = false;
    applyBattleLogViewPrefs();
    persistBattleLogViewPrefs();
    refreshMapViewLogPolling();
  }

  function renderBattleLogOverlay(lines){
    if (!logContent) return;
    const entries = Array.isArray(lines) ? lines : [];
    logContent.textContent = "";
    if (!entries.length){
      logContent.textContent = "No log entries yet.";
      return;
    }
    const frag = document.createDocumentFragment();
    entries.forEach((line) => {
      const parsed = parseBattleLine(line);
      const row = document.createElement("div");
      row.className = "map-view-log-entry";
      const msgClass = isCriticalLine(parsed.msg) ? "map-view-log-msg is-crit" : "map-view-log-msg";
      row.innerHTML = `<div class="map-view-log-time">${parsed.time ? parsed.time.slice(11,19) : ''}</div><div class="${msgClass}">${decorateDamageTypes(parsed.msg)}</div>`;
      frag.appendChild(row);
    });
    logContent.appendChild(frag);
    logContent.scrollTop = logContent.scrollHeight;
  }

  function requestBattleLog(){
    if (logContent){
      logContent.textContent = "Loading";
    }
    send({type:"log_request"});
  }

  function applyTerrainPayload(terrain){
    if (!state){ state = {}; }
    if (!terrain || typeof terrain !== "object") return;
    if (Array.isArray(terrain.rough_terrain)){
      state.rough_terrain = terrain.rough_terrain;
    } else if (!state.rough_terrain){
      state.rough_terrain = [];
    }
    if (Array.isArray(terrain.obstacles)){
      state.obstacles = terrain.obstacles;
    } else if (!state.obstacles){
      state.obstacles = [];
    }
  }

  function applyTerrainPatch(patch){
    if (!state){ state = {}; }
    if (!patch || typeof patch !== "object") return;
    const roughUpdates = Array.isArray(patch.rough_updates) ? patch.rough_updates : [];
    const roughRemovals = Array.isArray(patch.rough_removals) ? patch.rough_removals : [];
    if (roughUpdates.length || roughRemovals.length){
      const roughMap = new Map();
      (state.rough_terrain || []).forEach((cell) => {
        if (!cell) return;
        const key = `${Number(cell.col)},${Number(cell.row)}`;
        roughMap.set(key, cell);
      });
      roughUpdates.forEach((cell) => {
        if (!cell) return;
        const key = `${Number(cell.col)},${Number(cell.row)}`;
        roughMap.set(key, cell);
      });
      roughRemovals.forEach((cell) => {
        if (!cell) return;
        const key = `${Number(cell.col)},${Number(cell.row)}`;
        roughMap.delete(key);
      });
      state.rough_terrain = Array.from(roughMap.values());
    }

    const obstacleUpdates = Array.isArray(patch.obstacle_updates) ? patch.obstacle_updates : [];
    const obstacleRemovals = Array.isArray(patch.obstacle_removals) ? patch.obstacle_removals : [];
    if (obstacleUpdates.length || obstacleRemovals.length){
      const obstacleSet = new Set((state.obstacles || []).map(o => `${Number(o.col)},${Number(o.row)}`));
      obstacleUpdates.forEach((cell) => {
        if (!cell) return;
        obstacleSet.add(`${Number(cell.col)},${Number(cell.row)}`);
      });
      obstacleRemovals.forEach((cell) => {
        if (!cell) return;
        obstacleSet.delete(`${Number(cell.col)},${Number(cell.row)}`);
      });
      state.obstacles = Array.from(obstacleSet).map((key) => {
        const [col, row] = key.split(",").map(Number);
        return {col, row};
      });
    }
  }

  function applyUnitUpdates(updates){
    if (!state || !Array.isArray(state.units)) return;
    updates.forEach((update) => {
      if (!update || update.cid === undefined || update.cid === null) return;
      const cid = Number(update.cid);
      const idx = state.units.findIndex((unit) => Number(unit.cid) === cid);
      if (idx < 0) return;
      const current = state.units[idx];
      const next = {...current};
      Object.keys(update).forEach((key) => {
        if (key === "cid") return;
        next[key] = update[key];
      });
      state.units[idx] = next;
    });
    updateMountControls();
  }

  function applyAoePatch(patch){
    if (!state){ state = {}; }
    if (!patch || typeof patch !== "object") return;
    const updates = Array.isArray(patch.updates) ? patch.updates : [];
    const removals = Array.isArray(patch.removals) ? patch.removals : [];
    if (!Array.isArray(state.aoes)){
      state.aoes = [];
    }
    const aoeMap = new Map();
    state.aoes.forEach((aoe) => {
      if (!aoe || aoe.aid === undefined || aoe.aid === null) return;
      aoeMap.set(Number(aoe.aid), aoe);
    });
    updates.forEach((aoe) => {
      if (!aoe || aoe.aid === undefined || aoe.aid === null) return;
      aoeMap.set(Number(aoe.aid), aoe);
    });
    removals.forEach((aid) => {
      aoeMap.delete(Number(aid));
    });
    state.aoes = Array.from(aoeMap.values()).sort((a, b) => Number(a.aid) - Number(b.aid));
  }

  function planningModeSpeed(unit){
    if (!unit) return 30;
    const mode = normalizeMovementMode(unit?.movement_mode);
    if (mode === "swim"){
      const swimSpeed = Number(unit?.swim_speed || 0);
      if (Number.isFinite(swimSpeed) && swimSpeed > 0) return swimSpeed;
    }
    if (mode === "fly"){
      const flySpeed = Number(unit?.fly_speed || 0);
      if (Number.isFinite(flySpeed) && flySpeed > 0) return flySpeed;
    }
    if (mode === "burrow"){
      const burrowSpeed = Number(unit?.burrow_speed || 0);
      if (Number.isFinite(burrowSpeed) && burrowSpeed > 0) return burrowSpeed;
    }
    const speed = Number(unit?.speed || 30);
    if (!Number.isFinite(speed) || speed <= 0) return 30;
    return speed;
  }

  function nextPlanningAoeId(){
    const list = Array.isArray(state?.aoes) ? state.aoes : [];
    let maxAid = 0;
    list.forEach((aoe) => {
      const aid = Number(aoe?.aid);
      if (Number.isFinite(aid) && aid > maxAid){
        maxAid = aid;
      }
    });
    return maxAid + 1;
  }

  function buildPlanningAoe(payload){
    if (!payload || typeof payload !== "object") return null;
    const shape = String(payload.shape || payload.kind || "").toLowerCase();
    if (!shape) return null;
    const feetPerSquare = Math.max(1, Number(state?.grid?.feet_per_square || 5));
    const aoe = {
      aid: nextPlanningAoeId(),
      kind: shape,
      cx: Number(payload.cx ?? 0),
      cy: Number(payload.cy ?? 0),
    };
    if (payload.name){
      aoe.name = payload.name;
    }
    if (payload.color){
      aoe.color = payload.color;
    }
    if (payload.damage_type){
      aoe.damage_type = payload.damage_type;
    }
    if (Array.isArray(payload.damage_types) && payload.damage_types.length){
      aoe.damage_types = payload.damage_types.slice();
    }
    if (payload.save_type){
      aoe.save_type = payload.save_type;
    }
    if (payload.dc !== undefined && payload.dc !== null){
      aoe.dc = Number(payload.dc);
    }
    if (payload.default_damage){
      aoe.default_damage = payload.default_damage;
    }
    if (payload.dice){
      aoe.dice = payload.dice;
    }
    if (payload.duration_turns !== undefined && payload.duration_turns !== null){
      const duration = Number(payload.duration_turns);
      if (Number.isFinite(duration)){
        aoe.duration_turns = duration;
        aoe.remaining_turns = duration > 0 ? duration : null;
      }
    }
    if (payload.over_time){
      aoe.over_time = true;
    }
    if (payload.persistent){
      aoe.persistent = true;
    }
    if (payload.trigger_on_start_or_enter){
      aoe.trigger_on_start_or_enter = payload.trigger_on_start_or_enter;
    }
    if (payload.move_per_turn_ft !== undefined && payload.move_per_turn_ft !== null){
      aoe.move_per_turn_ft = Number(payload.move_per_turn_ft);
      aoe.move_remaining_ft = Number(payload.move_per_turn_ft);
    }
    if (payload.pinned_default){
      aoe.pinned = true;
    }
    const radiusFt = Number(payload.radius_ft);
    const sideFt = Number(payload.side_ft);
    const lengthFt = Number(payload.length_ft);
    const widthFt = Number(payload.width_ft);
    const thicknessFt = Number(payload.thickness_ft);
    const heightFt = Number(payload.height_ft);
    const angleDeg = payload.angle_deg !== undefined && payload.angle_deg !== null
      ? Number(payload.angle_deg)
      : null;
    if (shape === "circle" || shape === "sphere" || shape === "cylinder"){
      if (Number.isFinite(radiusFt)){
        aoe.radius_sq = Math.max(0.5, radiusFt / feetPerSquare);
        aoe.radius_ft = radiusFt;
      }
      if ((shape === "sphere" || shape === "cylinder") && Number.isFinite(heightFt)){
        aoe.height_ft = heightFt;
      }
    } else if (shape === "square" || shape === "cube"){
      if (Number.isFinite(sideFt)){
        aoe.side_sq = Math.max(1.0, sideFt / feetPerSquare);
        aoe.side_ft = sideFt;
      }
    } else if (shape === "cone"){
      if (Number.isFinite(lengthFt)){
        aoe.length_sq = Math.max(1.0, lengthFt / feetPerSquare);
        aoe.length_ft = lengthFt;
      }
      if (Number.isFinite(angleDeg)){
        aoe.angle_deg = angleDeg;
      }
      aoe.orient = String(payload.orient || "vertical");
    } else if (shape === "wall"){
      if (Number.isFinite(lengthFt)){
        aoe.length_sq = Math.max(1.0, lengthFt / feetPerSquare);
        aoe.length_ft = lengthFt;
      }
      if (Number.isFinite(widthFt)){
        aoe.width_sq = Math.max(1.0, widthFt / feetPerSquare);
        aoe.width_ft = widthFt;
        if (Number.isFinite(heightFt)){
          aoe.height_ft = heightFt;
        }
      } else if (Number.isFinite(thicknessFt)){
        aoe.width_sq = Math.max(1.0, thicknessFt / feetPerSquare);
        aoe.thickness_ft = thicknessFt;
        if (Number.isFinite(heightFt)){
          aoe.height_ft = heightFt;
        }
      }
      if (Number.isFinite(angleDeg)){
        aoe.angle_deg = angleDeg;
      }
      aoe.orient = String(payload.orient || "vertical");
    } else if (shape === "line"){
      if (Number.isFinite(lengthFt)){
        aoe.length_sq = Math.max(1.0, lengthFt / feetPerSquare);
        aoe.length_ft = lengthFt;
      }
      if (Number.isFinite(widthFt)){
        aoe.width_sq = Math.max(1.0, widthFt / feetPerSquare);
        aoe.width_ft = widthFt;
      } else {
        aoe.width_sq = 1.0;
      }
      if (Number.isFinite(angleDeg)){
        aoe.angle_deg = angleDeg;
      }
      aoe.orient = String(payload.orient || "vertical");
    }
    return aoe;
  }

  function planningMutate(msg){
    if (!msg || typeof msg !== "object") return;
    const type = String(msg.type || "");
    const mutateSpellSlotCounter = (unit, rawLevel) => {
      const playerName = String(unit?.name || "").trim();
      const level = Number(rawLevel);
      if (!playerName || !Number.isFinite(level) || level <= 0) return;
      const profile = getPlayerProfile(playerName);
      const spellcasting = profile?.spellcasting;
      const slots = spellcasting?.spell_slots;
      if (!slots || typeof slots !== "object") return;
      const slotLevel = Math.floor(level);
      if (Array.isArray(slots)){
        const idx = slotLevel - 1;
        if (idx < 0 || idx >= slots.length) return;
        const entry = slots[idx];
        if (entry && typeof entry === "object"){
          const current = Number(entry.current ?? entry.remaining ?? entry.max ?? 0);
          entry.current = Math.max(0, Number.isFinite(current) ? Math.floor(current) - 1 : 0);
        } else if (Number.isFinite(Number(entry))){
          slots[idx] = Math.max(0, Math.floor(Number(entry)) - 1);
        }
        return;
      }
      const key = String(slotLevel);
      const entry = slots[key] ?? slots[slotLevel];
      if (entry && typeof entry === "object"){
        const current = Number(entry.current ?? entry.remaining ?? entry.max ?? 0);
        entry.current = Math.max(0, Number.isFinite(current) ? Math.floor(current) - 1 : 0);
      } else if (Number.isFinite(Number(entry))){
        slots[key] = Math.max(0, Math.floor(Number(entry)) - 1);
      }
    };
    const mutateResourcePoolCounter = (unit, consumesPoolRaw) => {
      const playerName = String(unit?.name || "").trim();
      const consumes = consumesPoolRaw && typeof consumesPoolRaw === "object" ? consumesPoolRaw : null;
      if (!playerName || !consumes) return;
      const poolsByPlayer = state?.resource_pools;
      if (!poolsByPlayer || typeof poolsByPlayer !== "object") return;
      const pools = poolsByPlayer[playerName];
      if (!Array.isArray(pools)) return;
      const id = String(consumes.id ?? consumes.pool ?? "").trim().toLowerCase();
      if (!id) return;
      const costRaw = Number(consumes.cost ?? 1);
      const cost = Number.isFinite(costRaw) ? Math.max(1, Math.floor(costRaw)) : 1;
      const pool = pools.find((entry) => String(entry?.id || "").trim().toLowerCase() === id);
      if (!pool || typeof pool !== "object") return;
      const current = Number(pool.current ?? 0);
      if (!Number.isFinite(current)) return;
      pool.current = Math.max(0, Math.floor(current) - cost);
    };
    if (type === "move"){
      const unit = getUnitByCid(msg.cid);
      const to = msg.to || {};
      if (!unit) return;
      const update = {
        cid: unit.cid,
        pos: {col: Number(to.col ?? unit.pos.col), row: Number(to.row ?? unit.pos.row)},
      };
      const updates = [update];
      const mountedByCid = normalizeCid(unit.mounted_by_cid, "move.mountedByCid");
      const mountedByUnit = mountedByCid !== null ? getUnitByCid(mountedByCid) : null;
      const riderControlsMount = unit.mount_shared_turn === true && String(unit.mount_controller_mode || "").toLowerCase() === "rider";
      let movementSourceUnit = unit;
      let movementSourceUpdate = update;
      if (mountedByUnit && riderControlsMount) {
        const mountedByUpdate = {cid: mountedByUnit.cid, pos: {...update.pos}};
        updates.push(mountedByUpdate);
        movementSourceUnit = mountedByUnit;
        movementSourceUpdate = mountedByUpdate;
      } else if (mountedByUnit) {
        updates.push({cid: mountedByUnit.cid, pos: {...update.pos}});
      } else {
        const riderCid = normalizeCid(unit.rider_cid, "move.riderCid");
        const riderMountUnit = riderCid !== null ? getUnitByCid(riderCid) : null;
        if (riderMountUnit) {
          updates.push({cid: riderMountUnit.cid, pos: {...update.pos}});
          // Movement costs remain on the rider; the mount just mirrors position.
        }
      }
      if (gridReady()){
        const moveRemaining = Number(movementSourceUnit.move_remaining ?? 0);
        if (Number.isFinite(moveRemaining) && moveRemaining > 0){
          const feetPerSquare = Math.max(1, Number(state?.grid?.feet_per_square || 5));
          const roughMap = buildRoughTerrainMap(state.rough_terrain);
          const obstacleSet = buildObstacleSet(state.obstacles);
          const costMap = movementCostMap(
            Number(unit.pos.col),
            Number(unit.pos.row),
            moveRemaining,
            unit,
            roughMap,
            obstacleSet,
            state.grid.cols,
            state.grid.rows,
            feetPerSquare,
          );
          const cost = costMap.get(cellKey(update.pos.col, update.pos.row));
          if (Number.isFinite(cost)){
            movementSourceUpdate.move_remaining = Math.max(0, moveRemaining - cost);
          }
        }
      }
      applyUnitUpdates(updates);
      updateMountControls();
      return;
    }
    if (type === "set_facing"){
      const unit = getUnitByCid(msg.cid);
      if (!unit) return;
      const facingDeg = normalizeFacingDeg(msg.facing_deg);
      unit.facing_deg = facingDeg;
      syncOwnedRotatableAoesWithFacing(unit.cid, facingDeg);
      return;
    }
    if (["dash", "perform_action", "use_action", "use_bonus_action"].includes(type)){
      const unit = getUnitByCid(msg.cid);
      if (!unit) return;
      const update = {cid: unit.cid};
      const spendRaw = String(msg.spend || "").toLowerCase();
      const spend = spendRaw.includes("bonus") ? "bonus" : (spendRaw === "reaction" ? "reaction" : "action");
      const useAction = () => {
        const current = Number(unit.action_remaining || 0);
        update.action_remaining = Math.max(0, current - 1);
      };
      const useBonus = () => {
        const current = Number(unit.bonus_action_remaining || 0);
        update.bonus_action_remaining = Math.max(0, current - 1);
      };
      const useReaction = () => {
        const current = Number(unit.reaction_remaining || 0);
        update.reaction_remaining = Math.max(0, current - 1);
      };
      if (type === "use_action"){
        useAction();
      } else if (type === "use_bonus_action"){
        useBonus();
      } else if (spend === "reaction"){
        useReaction();
      } else if (spend === "bonus"){
        useBonus();
      } else {
        useAction();
      }
      const actionName = String(msg.action || msg.name || "");
      const actionKey = normalizeLowerValue(actionName);
      if (type === "dash" || actionKey === "dash"){
        const baseSpeed = planningModeSpeed(unit);
        const total = Number(unit.move_total || 0);
        const remaining = Number(unit.move_remaining || 0);
        update.move_total = total + baseSpeed;
        update.move_remaining = remaining + baseSpeed;
      }
      applyUnitUpdates([update]);
      updateMountControls();
      return;
    }
    if (type === "set_auras_enabled"){
      if (!state || typeof state !== "object") state = {};
      state.auras_enabled = msg.enabled !== false;
      updateAurasButton();
      draw();
      return;
    }
    if (type === "second_wind_use"){
      const unit = getUnitByCid(msg.cid);
      if (!unit) return;
      mutateResourcePoolCounter(unit, {id: "second_wind", cost: 1});
      const update = {cid: unit.cid};
      const current = Number(unit.bonus_action_remaining || 0);
      update.bonus_action_remaining = Math.max(0, current - 1);
      applyUnitUpdates([update]);
      renderSecondWindSummary();
      renderResourcePools();
      return;
    }
    if (type === "action_surge_use"){
      const unit = getUnitByCid(msg.cid);
      if (!unit) return;
      mutateResourcePoolCounter(unit, {id: "action_surge", cost: 1});
      const update = {cid: unit.cid};
      const current = Number(unit.action_remaining || 0);
      update.action_remaining = Math.max(0, current + 1);
      applyUnitUpdates([update]);
      renderResourcePools();
      return;
    }
    if (type === "lay_on_hands_use"){
      const unit = getUnitByCid(msg.cid);
      const target = getUnitByCid(msg.target_cid);
      const amount = Math.max(0, Number(msg.amount || 0));
      if (!unit || !target || amount <= 0) return;
      mutateResourcePoolCounter(unit, {id: "lay_on_hands", cost: amount});
      const targetHp = Number(target.hp || 0);
      const targetMaxHp = Number(target.max_hp || targetHp);
      applyUnitUpdates([
        {cid: unit.cid, action_remaining: Math.max(0, Number(unit.action_remaining || 0) - 1)},
        {cid: target.cid, hp: Math.max(0, Math.min(targetMaxHp, targetHp + amount))},
      ]);
      renderResourcePools();
      return;
    }
    if (type === "cast_spell"){
      const unit = getUnitByCid(msg.cid);
      if (!unit) return;
      const payload = msg.payload && typeof msg.payload === "object" ? msg.payload : {};
      const spendRaw = String(msg.action_type || payload.action_type || "").toLowerCase();
      const spend = spendRaw.includes("bonus") ? "bonus" : (spendRaw === "reaction" ? "reaction" : "action");
      const update = {cid: unit.cid};
      const spellCastRemaining = Number(unit.spell_cast_remaining || 0);
      update.spell_cast_remaining = Math.max(0, spellCastRemaining - 1);
      update.action_remaining = 0;
      update.bonus_action_remaining = 0;
      if (spend === "reaction"){
        const currentReaction = Number(unit.reaction_remaining || 0);
        update.reaction_remaining = Math.max(0, currentReaction - 1);
      }
      applyUnitUpdates([update]);
      mutateSpellSlotCounter(unit, msg.slot_level ?? payload.slot_level ?? payload.level);
      mutateResourcePoolCounter(unit, payload.consumes_pool);
      renderResourcePools();
      updateMountControls();
      return;
    }
    if (type === "stand_up"){
      const unit = getUnitByCid(msg.cid);
      if (!unit) return;
      if (!unit.is_prone) return;
      const speed = planningModeSpeed(unit);
      const cost = Math.max(0, Math.floor(speed / 2));
      const moveRemaining = Number(unit.move_remaining || 0);
      if (!Number.isFinite(moveRemaining) || moveRemaining < cost) return;
      applyUnitUpdates([{
        cid: unit.cid,
        is_prone: false,
        move_remaining: Math.max(0, moveRemaining - cost),
      }]);
      updateMountControls();
      return;
    }
    if (type === "reset_turn"){
      const unit = getUnitByCid(msg.cid);
      if (!unit) return;
      applyUnitUpdates([{
        cid: unit.cid,
        action_remaining: Number(unit.action_total ?? 1),
        bonus_action_remaining: Number(unit.bonus_action_total ?? 1),
        reaction_remaining: Number(unit.reaction_total ?? 1),
        spell_cast_remaining: Number(unit.spell_cast_total ?? 1),
        move_remaining: Number(unit.move_total ?? planningModeSpeed(unit)),
      }]);
      updateMountControls();
      return;
    }
    if (type === "cast_aoe"){
      const aoe = buildPlanningAoe(msg.payload || {});
      if (!aoe) return;
      applyAoePatch({updates: [aoe], removals: []});
      return;
    }
    if (type === "aoe_move"){
      const aid = Number(msg.aid);
      if (!Number.isFinite(aid)) return;
      const target = msg.to || {};
      const current = Array.isArray(state?.aoes)
        ? state.aoes.find(a => Number(a?.aid) === aid)
        : null;
      if (!current) return;
      const update = {
        ...current,
        cx: Number(target.cx ?? current.cx),
        cy: Number(target.cy ?? current.cy),
      };
      if (target.angle_deg !== undefined){
        update.angle_deg = Number(target.angle_deg);
      }
      if (target.ax !== undefined){
        update.ax = Number(target.ax);
      }
      if (target.ay !== undefined){
        update.ay = Number(target.ay);
      }
      if (target.spread_deg !== undefined){
        update.spread_deg = Number(target.spread_deg);
      }
      if (target.angle_deg !== undefined){
        syncFacingFromRotatableAoe(update, target.angle_deg);
      }
      applyAoePatch({
        updates: [update],
        removals: [],
      });
      return;
    }
    if (type === "aoe_remove"){
      const aid = Number(msg.aid);
      if (!Number.isFinite(aid)) return;
      applyAoePatch({updates: [], removals: [aid]});
    }
  }

  function gridToScreen(col,row){
    return {x: panX + col*zoom + zoom/2, y: panY + row*zoom + zoom/2};
  }
  function screenToGrid(x,y){
    return {col: Math.floor((x - panX)/zoom), row: Math.floor((y - panY)/zoom)};
  }
  function screenToGridFloat(x,y){
    return {col: (x - panX - zoom / 2) / zoom, row: (y - panY - zoom / 2) / zoom};
  }

  function coneSpreadDeg(aoe){
    const spread = Number(aoe?.spread_deg);
    if (Number.isFinite(spread)) return spread;
    const angle = Number(aoe?.angle_deg);
    if (Number.isFinite(angle)) return angle;
    return 90;
  }

  function coneHeadingDeg(aoe){
    const hasSpread = Number.isFinite(Number(aoe?.spread_deg));
    const angle = Number(aoe?.angle_deg);
    if (hasSpread && Number.isFinite(angle)) return angle;
    return aoe?.orient === "horizontal" ? 0 : -90;
  }

  function normalizeAngleDeg(angle){
    let next = angle % 360;
    if (next > 180) next -= 360;
    if (next < -180) next += 360;
    return next;
  }

  function angularDiffDeg(a, b){
    return Math.abs(normalizeAngleDeg(a - b));
  }

  function renderAoeOverlay(aoe, options = {}){
    if (!aoe || !aoe.kind) return;
    const renderAoe = options.override ? {...aoe, ...options.override} : aoe;
    const remainingTurnsRaw = renderAoe.remaining_turns;
    const remainingTurnsValue = (remainingTurnsRaw === null || remainingTurnsRaw === undefined)
      ? null
      : Number(remainingTurnsRaw);
    const cx = Number(options.cx ?? renderAoe.cx ?? 0);
    const cy = Number(options.cy ?? renderAoe.cy ?? 0);
    const {x,y} = gridToScreen(cx, cy);
    const colorHex = normalizeHexColor(renderAoe.color || "");
    const isPreview = !!options.preview;
    const alphaScale = isPreview ? 0.65 : 1;
    const alwaysOnAura = !!renderAoe.light || !!renderAoe.is_aura;
    const fillBaseAlpha = alwaysOnAura ? 0.14 : 0.28;
    ctx.save();
    ctx.lineWidth = 2;
    ctx.setLineDash([6,4]);
    if (renderAoe.kind === "circle" || renderAoe.kind === "sphere" || renderAoe.kind === "cylinder"){
      const r = Math.max(0, Number(renderAoe.radius_sq || 0)) * zoom;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fillStyle = colorHex
        ? rgbaFromHex(colorHex, fillBaseAlpha * alphaScale)
        : `rgba(168,197,255,${0.32 * alphaScale})`;
      ctx.strokeStyle = colorHex || `rgba(45,79,138,${0.85 * alphaScale})`;
      ctx.fill();
      ctx.stroke();
    } else if (renderAoe.kind === "line" || renderAoe.kind === "wall"){
      const lengthPx = Math.max(0, Number(renderAoe.length_sq || 0)) * zoom;
      const widthPx = Math.max(0, Number(renderAoe.width_sq || 0)) * zoom;
      const angleDeg = Number.isFinite(Number(renderAoe.angle_deg)) ? Number(renderAoe.angle_deg) : null;
      const orient = renderAoe.orient === "horizontal" ? "horizontal" : "vertical";
      const halfW = orient === "horizontal" ? lengthPx / 2 : widthPx / 2;
      const halfH = orient === "horizontal" ? widthPx / 2 : lengthPx / 2;
      ctx.fillStyle = colorHex
        ? rgbaFromHex(colorHex, fillBaseAlpha * alphaScale)
        : (renderAoe.kind === "wall"
          ? `rgba(255,230,153,${0.32 * alphaScale})`
          : `rgba(183,255,224,${0.32 * alphaScale})`);
      ctx.strokeStyle = colorHex || (renderAoe.kind === "wall"
        ? `rgba(181,125,34,${0.85 * alphaScale})`
        : `rgba(45,138,87,${0.85 * alphaScale})`);
      if (angleDeg !== null){
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate((angleDeg * Math.PI) / 180);
        ctx.beginPath();
        ctx.rect(-lengthPx / 2, -widthPx / 2, lengthPx, widthPx);
        ctx.fill();
        ctx.stroke();
        ctx.restore();
      } else {
        ctx.beginPath();
        ctx.rect(x - halfW, y - halfH, halfW * 2, halfH * 2);
        ctx.fill();
        ctx.stroke();
      }
    } else if (renderAoe.kind === "square" || renderAoe.kind === "cube"){
      const sidePx = Math.max(0, Number(renderAoe.side_sq || 0)) * zoom;
      const half = sidePx / 2;
      const angleDeg = Number.isFinite(Number(renderAoe.angle_deg)) ? Number(renderAoe.angle_deg) : null;
      if (angleDeg !== null){
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate((angleDeg * Math.PI) / 180);
        ctx.beginPath();
        ctx.rect(-half, -half, sidePx, sidePx);
        ctx.fillStyle = colorHex
          ? rgbaFromHex(colorHex, 0.28 * alphaScale)
          : `rgba(226,182,255,${0.32 * alphaScale})`;
        ctx.strokeStyle = colorHex || `rgba(107,61,138,${0.85 * alphaScale})`;
        ctx.fill();
        ctx.stroke();
        ctx.restore();
      } else {
        ctx.beginPath();
        ctx.rect(x - half, y - half, sidePx, sidePx);
        ctx.fillStyle = colorHex
          ? rgbaFromHex(colorHex, 0.28 * alphaScale)
          : `rgba(226,182,255,${0.32 * alphaScale})`;
        ctx.strokeStyle = colorHex || `rgba(107,61,138,${0.85 * alphaScale})`;
        ctx.fill();
        ctx.stroke();
      }
    } else if (renderAoe.kind === "cone"){
      const lengthPx = Math.max(0, Number(renderAoe.length_sq || 0)) * zoom;
      const spreadDeg = coneSpreadDeg(renderAoe);
      const headingDeg = coneHeadingDeg(renderAoe);
      const halfSpread = (spreadDeg * Math.PI) / 360;
      const headingRad = (headingDeg * Math.PI) / 180;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.arc(x, y, lengthPx, headingRad - halfSpread, headingRad + halfSpread);
      ctx.closePath();
      ctx.fillStyle = colorHex
        ? rgbaFromHex(colorHex, fillBaseAlpha * alphaScale)
        : `rgba(255,189,110,${0.32 * alphaScale})`;
      ctx.strokeStyle = colorHex || `rgba(181,110,34,${0.85 * alphaScale})`;
      ctx.fill();
      ctx.stroke();
    }
    ctx.setLineDash([]);
    const label = aoe.name ? String(aoe.name) : "";
    const labelText = label
      ? (aoe.pinned && Number.isFinite(remainingTurnsValue) ? `${label} (${remainingTurnsValue}t)` : label)
      : "";
    if (labelText && !isPreview){
      ctx.font = `700 ${Math.max(10, Math.floor(zoom*0.32))}px system-ui`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = "rgba(20,25,35,0.9)";
      ctx.fillText(labelText, x + 1, y + 1);
      ctx.fillStyle = "rgba(232,238,247,0.95)";
      ctx.fillText(labelText, x, y);
    }
    ctx.restore();
  }

  function hitTestAoe(p){
    if (!state || !state.aoes || !state.aoes.length) return null;
    const gridPos = screenToGridFloat(p.x, p.y);
    for (let i = state.aoes.length - 1; i >= 0; i--){
      const aoe = state.aoes[i];
      if (!aoe || !aoe.kind) continue;
      if (!canInteractWithAoe(aoe)) continue;
      const cx = Number(aoe.cx ?? 0);
      const cy = Number(aoe.cy ?? 0);
      const dx = gridPos.col - cx;
      const dy = gridPos.row - cy;
      const kind = String(aoe.kind);
      if (kind === "circle" || kind === "sphere" || kind === "cylinder"){
        const radius = Math.max(0, Number(aoe.radius_sq || 0));
        if (dx * dx + dy * dy <= radius * radius) return aoe;
      } else if (kind === "square" || kind === "cube"){
        const side = Math.max(0, Number(aoe.side_sq || 0));
        const half = side / 2;
        const angleDeg = Number.isFinite(Number(aoe.angle_deg)) ? Number(aoe.angle_deg) : null;
        if (angleDeg !== null){
          const rad = (-angleDeg * Math.PI) / 180;
          const rx = dx * Math.cos(rad) - dy * Math.sin(rad);
          const ry = dx * Math.sin(rad) + dy * Math.cos(rad);
          if (Math.abs(rx) <= half && Math.abs(ry) <= half) return aoe;
        } else if (Math.abs(dx) <= half && Math.abs(dy) <= half) return aoe;
      } else if (kind === "line" || kind === "wall"){
        const length = Math.max(0, Number(aoe.length_sq || 0));
        const width = Math.max(0, Number(aoe.width_sq || 0));
        const angleDeg = Number.isFinite(Number(aoe.angle_deg)) ? Number(aoe.angle_deg) : null;
        const orient = aoe.orient === "horizontal" ? "horizontal" : "vertical";
        const halfW = orient === "horizontal" ? length / 2 : width / 2;
        const halfH = orient === "horizontal" ? width / 2 : length / 2;
        if (angleDeg !== null){
          const rad = (-angleDeg * Math.PI) / 180;
          const rx = dx * Math.cos(rad) - dy * Math.sin(rad);
          const ry = dx * Math.sin(rad) + dy * Math.cos(rad);
          if (Math.abs(rx) <= length / 2 && Math.abs(ry) <= width / 2) return aoe;
        } else {
          if (Math.abs(dx) <= halfW && Math.abs(dy) <= halfH) return aoe;
        }
      } else if (kind === "cone"){
        const length = Math.max(0, Number(aoe.length_sq || 0));
        const dist = Math.hypot(dx, dy);
        if (dist > length) continue;
        const angleToPoint = (Math.atan2(dy, dx) * 180) / Math.PI;
        const headingDeg = coneHeadingDeg(aoe);
        const spreadDeg = coneSpreadDeg(aoe);
        const diff = angularDiffDeg(angleToPoint, headingDeg);
        if (diff <= spreadDeg / 2) return aoe;
      }
    }
    return null;
  }


  function gridReady(){
    if (!state || !state.grid) return false;
    if (state.grid.ready === false) return false;
    return Number.isFinite(state.grid.cols) && Number.isFinite(state.grid.rows);
  }

  function updateWaitingOverlay(){
    if (!waitingOverlay) return;
    waitingOverlay.classList.toggle("show", !gridReady());
  }

  function formatFeet(feet){
    const rounded = Math.round(feet * 10) / 10;
    const label = Number.isInteger(rounded) ? String(rounded) : rounded.toFixed(1);
    return `${label} ft`;
  }

  function parseSpellRangeFeet(rangeValue){
    const text = String(rangeValue || "").toLowerCase();
    const match = text.match(/(\d+(?:\.\d+)?)\s*(?:ft|feet)/);
    if (!match) return null;
    const value = Number(match[1]);
    return Number.isFinite(value) && value >= 0 ? value : null;
  }

  function parseSpellTargetRangeFeet(preset){
    const mechanicsRange = Number(preset?.mechanics?.targeting?.range?.distance_ft);
    if (Number.isFinite(mechanicsRange) && mechanicsRange >= 0){
      return mechanicsRange;
    }
    return parseSpellRangeFeet(preset?.range);
  }

  function distanceFeetBetweenCells(a, b){
    const feetPerSquare = Math.max(1, Number(state?.grid?.feet_per_square || 5));
    const dx = Number(a?.col || 0) - Number(b?.col || 0);
    const dy = Number(a?.row || 0) - Number(b?.row || 0);
    return Math.hypot(dx, dy) * feetPerSquare;
  }

  function setAttackOverlayMode(enabled){
    attackOverlayMode = !!enabled;
    if (!attackOverlayMode){
      pendingOpportunityAttack = false;
      pendingActionAttackWeapon = null;
    }
    if (attackOverlayToggleBtn){
      attackOverlayToggleBtn.setAttribute("aria-pressed", attackOverlayMode ? "true" : "false");
      attackOverlayToggleBtn.classList.toggle("accent", attackOverlayMode);
      attackOverlayToggleBtn.textContent = attackOverlayMode ? "Attack Overlay: On" : "Attack Overlay";
    }
    draw();
  }

  function attackDamageTypeOptions(){
    const options = [];
    const select = castDamageTypeInput;
    if (select){
      Array.from(select.options || []).forEach((opt) => {
        const value = String(opt?.value || "").trim();
        if (!value) return;
        options.push(value);
      });
    }
    return options;
  }

  function addAttackDamageRow(initialAmount = "", initialType = ""){
    if (!attackDamageRows) return;
    const row = document.createElement("div");
    row.className = "damage-type-controls";
    const amountInput = document.createElement("input");
    amountInput.type = "number";
    amountInput.min = "0";
    amountInput.step = "1";
    amountInput.placeholder = "Damage";
    amountInput.value = String(initialAmount || "");
    const typeSelect = document.createElement("select");
    const placeholderOption = document.createElement("option");
    placeholderOption.value = "";
    placeholderOption.textContent = "Damage type";
    typeSelect.appendChild(placeholderOption);
    attackDamageTypeOptions().forEach((value) => {
      const option = document.createElement("option");
      option.value = value;
      option.textContent = value;
      typeSelect.appendChild(option);
    });
    if (initialType){
      const normalizedInitial = String(initialType).trim().toLowerCase();
      let matchedValue = "";
      Array.from(typeSelect.options || []).forEach((opt) => {
        if (matchedValue) return;
        if (String(opt?.value || "").trim().toLowerCase() === normalizedInitial){
          matchedValue = String(opt.value || "");
        }
      });
      if (!matchedValue && normalizedInitial){
        const customOption = document.createElement("option");
        customOption.value = normalizedInitial;
        customOption.textContent = normalizedInitial;
        typeSelect.appendChild(customOption);
        matchedValue = normalizedInitial;
      }
      if (matchedValue){
        typeSelect.value = matchedValue;
      }
    }
    const removeBtn = document.createElement("button");
    removeBtn.type = "button";
    removeBtn.className = "btn";
    removeBtn.textContent = "Remove";
    removeBtn.addEventListener("click", () => {
      row.remove();
    });
    row.appendChild(amountInput);
    row.appendChild(typeSelect);
    row.appendChild(removeBtn);
    attackDamageRows.appendChild(row);
  }

  function syncAttackResolveDamageVisibility(){
    const isMiss = !!(attackResolveMiss && attackResolveMiss.checked);
    if (attackDamageRows){
      attackDamageRows.classList.toggle("hidden", isMiss);
    }
    if (attackDamageAdd){
      attackDamageAdd.classList.toggle("hidden", isMiss);
    }
  }

  function setAttackResolveModalOpen(open){
    if (!attackResolveModal) return;
    attackResolveModal.classList.toggle("show", !!open);
    attackResolveModal.setAttribute("aria-hidden", open ? "false" : "true");
    if (!open){
      if (attackResolveHit) attackResolveHit.disabled = false;
      if (attackResolveMiss) attackResolveMiss.disabled = false;
      if (attackResolveCrit) attackResolveCrit.checked = false;
      pendingAttackResolve = null;
    }
  }

  function setCleavePromptOpen(open){
    if (!cleavePromptModal) return;
    cleavePromptModal.classList.toggle("show", !!open);
    cleavePromptModal.setAttribute("aria-hidden", open ? "false" : "true");
    if (!open){
      pendingCleavePrompt = null;
      if (cleavePromptList){
        cleavePromptList.textContent = "";
      }
    }
  }

  function openCleavePrompt(resultMsg){
    if (!cleavePromptBody || !cleavePromptList) return;
    const candidates = Array.isArray(resultMsg?.cleave_candidates) ? resultMsg.cleave_candidates : [];
    if (!candidates.length){
      return;
    }
    pendingCleavePrompt = {
      weaponId: String(resultMsg?.weapon_id || "").trim(),
      weaponName: String(resultMsg?.weapon_name || "Weapon").trim() || "Weapon",
      candidates,
    };
    cleavePromptBody.textContent = "Cleave triggers! Pick one nearby enemy for a free attack.";
    cleavePromptList.textContent = "";
    candidates.forEach((entry) => {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "btn";
      btn.textContent = String(entry?.name || `Enemy #${entry?.cid || "?"}`);
      btn.addEventListener("click", () => {
        const unit = getUnitByCid(entry?.cid) || {cid: entry?.cid, name: entry?.name || "Enemy"};
        const weapon = {id: pendingCleavePrompt.weaponId, name: pendingCleavePrompt.weaponName};
        setCleavePromptOpen(false);
        openAttackResolveModal(unit, weapon);
        if (pendingAttackResolve){
          pendingAttackResolve.masteryFreeAttack = "cleave";
        }
      });
      cleavePromptList.appendChild(btn);
    });
    setCleavePromptOpen(true);
  }

  function openAttackResolveModal(target, weapon){
    if (!attackResolveBody || !attackDamageRows) return;
    let mode = null;
    if (weapon?.one_handed && String(weapon.one_handed.damage_formula || "").trim()){
      mode = weapon.one_handed;
    } else if (weapon?.two_handed && String(weapon.two_handed.damage_formula || "").trim()){
      mode = weapon.two_handed;
    }
    const effect = weapon?.effect && typeof weapon.effect === "object" ? weapon.effect : null;
    const hintParts = [];
    if (mode){
      const baseFormula = String(mode.damage_formula || "").trim();
      const baseType = String(mode.damage_type || "").trim().toLowerCase();
      if (baseFormula){
        hintParts.push(`Auto-on-hit: ${baseFormula}${baseType ? ` ${baseType}` : ""} damage.`);
      }
    }
    const riderText = String(effect?.on_hit || "").trim();
    if (riderText){
      hintParts.push(`Rider: ${riderText}`);
    }
    const saveAbility = String(effect?.save_ability || "").trim().toUpperCase();
    const saveDc = Number(effect?.save_dc);
    if (saveAbility && Number.isFinite(saveDc) && saveDc > 0){
      hintParts.push(`Save rider: ${saveAbility} DC ${Math.floor(saveDc)}.`);
    }
    const me = getClaimedUnit();
    const hasVexAdvantage = Number.isFinite(Number(target?.vexed_by_cid))
      && Number.isFinite(Number(me?.cid))
      && Number(target.vexed_by_cid) === Number(me.cid);
    pendingAttackResolve = {
      targetCid: Number(target?.cid),
      targetName: String(target?.name || "target"),
      weaponId: String(weapon?.id || "").trim(),
      weaponName: String(weapon?.name || "Weapon").trim() || "Weapon",
      weapon: weapon && typeof weapon === "object" ? {...weapon} : null,
      attackCount: Number.isFinite(Number(weapon?.attack_count)) ? Math.max(1, Math.floor(Number(weapon.attack_count))) : null,
      masteryAdvantage: hasVexAdvantage,
      opportunityAttack: pendingOpportunityAttack,
    };
    pendingOpportunityAttack = false;
    const advantageText = hasVexAdvantage ? ' <span class="mastery-advantage-text">Vex Advantage: ye have advantage on this attack.</span>' : "";
    const resolvePrompt = String(weapon?.resolve_prompt || "").trim();
    attackResolveBody.innerHTML = `${resolvePrompt || `Attack ${pendingAttackResolve.targetName} with ${pendingAttackResolve.weaponName}.`}`
      + (hintParts.length ? ` ${hintParts.join(" ")}` : "")
      + advantageText;
    attackDamageRows.textContent = "";
    const suggestedTypes = [];
    const pushSuggestedType = (value) => {
      const normalized = String(value || "").trim().toLowerCase();
      if (!normalized || suggestedTypes.includes(normalized)) return;
      suggestedTypes.push(normalized);
    };
    if (mode){
      pushSuggestedType(mode.damage_type);
    }
    if (riderText){
      // Match rider snippets like "1d6 fire damage" (or "d6 fire damage") and collect the extracted damage type.
      const riderRegex = /(\d*d\d+(?:\s*[+\-]\s*\d+)?)\s+([a-zA-Z]+)\s+damage/gi;
      let riderMatch = null;
      while ((riderMatch = riderRegex.exec(riderText))){
        pushSuggestedType(riderMatch[2]);
      }
    }
    if (suggestedTypes.length){
      suggestedTypes.forEach((dtype) => addAttackDamageRow("", dtype));
    } else {
      addAttackDamageRow();
    }
    if (attackResolveHit) attackResolveHit.checked = true;
    if (attackResolveMiss) attackResolveMiss.checked = false;
    if (attackResolveCrit) attackResolveCrit.checked = false;
    syncAttackResolveDamageVisibility();
    setAttackResolveModalOpen(true);
  }

  function summonCellKey(col, row){
    return `${Number(col)},${Number(row)}`;
  }

  function isSummonPlacementCellValid(cell){
    if (!pendingSummonPlacement || !cell) return false;
    return summonValidCells.has(summonCellKey(cell.col, cell.row));
  }

  function clearSummonPlacementState(){
    pendingSummonPlacement = null;
    summonValidCells = new Set();
    if (summonPlacementBanner){
      summonPlacementBanner.classList.add("hidden");
      summonPlacementBanner.textContent = "";
    }
  }

  function updateSummonPlacementBanner(){
    if (!summonPlacementBanner) return;
    if (!pendingSummonPlacement){
      summonPlacementBanner.classList.add("hidden");
      summonPlacementBanner.textContent = "";
      return;
    }
    const total = Math.max(1, Number(pendingSummonPlacement.summonQuantity || 1));
    const placed = pendingSummonPlacement.positions.length;
    const remaining = Math.max(0, total - placed);
    const hasRange = Number.isFinite(Number(pendingSummonPlacement.maxRangeFt));
    const rangeLabel = hasRange ? `${Math.round(Number(pendingSummonPlacement.maxRangeFt))} ft` : "any range";
    const placementLabel = pendingSummonPlacement.mode === "echo_summon" ? "Johns Echo" : "a summon";
    summonPlacementBanner.textContent = `You're placing ${placementLabel}. Click up to ${remaining} square(s) within ${rangeLabel} of your caster to choose spawn locations.`;
    summonPlacementBanner.classList.remove("hidden");
  }

  function rebuildSummonValidCells(){
    summonValidCells = new Set();
    if (!pendingSummonPlacement || !gridReady()) return;
    const cols = Number(state?.grid?.cols || 0);
    const rows = Number(state?.grid?.rows || 0);
    const blocked = new Set((state?.obstacles || []).map((o) => summonCellKey(o.col, o.row)));
    const maxRangeFt = Number(pendingSummonPlacement.maxRangeFt);
    for (let col = 0; col < cols; col += 1){
      for (let row = 0; row < rows; row += 1){
        const key = summonCellKey(col, row);
        if (blocked.has(key)) continue;
        if (Number.isFinite(maxRangeFt)){
          const distFt = distanceFeetBetweenCells(pendingSummonPlacement.casterPos, {col, row});
          if (distFt > maxRangeFt + 1e-6) continue;
        }
        summonValidCells.add(key);
      }
    }
  }

  function updateMeasurementControls(){
    if (measureToggle){
      measureToggle.textContent = measurementMode ? "Measuring" : "Measure";
      measureToggle.classList.toggle("accent", measurementMode);
      measureToggle.setAttribute("aria-pressed", measurementMode ? "true" : "false");
    }
    if (measureClear){
      measureClear.disabled = !(measurement.start || measurement.end);
    }
  }

  function updateAoeLockButton(){
    if (!lockAoeBtn) return;
    lockAoeBtn.classList.toggle("accent", !lockMyAoes);
    lockAoeBtn.setAttribute("aria-pressed", lockMyAoes ? "true" : "false");
    lockAoeBtn.textContent = "Unlock my AOEs";
    lockAoeBtn.setAttribute(
      "title",
      lockMyAoes ? "AOEs locked (click to unlock)." : "AOEs unlocked (click to lock)."
    );
  }

  function areAurasEnabled(){
    return state?.auras_enabled !== false;
  }

  function updateAurasButton(){
    if (!auraToggleBtn) return;
    const enabled = areAurasEnabled();
    auraToggleBtn.textContent = enabled ? "Auras: On" : "Auras: Off";
    auraToggleBtn.setAttribute("aria-pressed", enabled ? "true" : "false");
    auraToggleBtn.classList.toggle("accent", enabled);
    auraToggleBtn.setAttribute("title", enabled ? "Click to disable always-on auras." : "Click to enable always-on auras.");
  }

  function renderEffectsOverlay(){
    if (!effectsOverlay || !effectsList) return;
    const claimed = getClaimedUnit();
    const effects = Array.isArray(claimed?.effects) ? claimed.effects : [];
    if (!claimed || !effects.length){
      effectsOverlay.classList.add("hidden");
      effectsList.innerHTML = "";
      return;
    }
    effectsList.innerHTML = "";
    effects.forEach((effect) => {
      const icon = document.createElement("div");
      icon.className = "effect-icon";
      icon.textContent = String(effect?.icon || "");
      const name = String(effect?.name || "Effect").trim() || "Effect";
      const desc = String(effect?.description || "").trim();
      icon.title = desc ? `${name}: ${desc}` : name;
      icon.setAttribute("aria-label", icon.title);
      effectsList.appendChild(icon);
    });
    effectsOverlay.classList.remove("hidden");
  }

  function isAdminClient(){
    return false;
  }

  function canInteractWithAoe(aoe){
    if (!aoe) return false;
    if (isMapView) return isAdminClient();
    if (isAdminClient()) return true;
    if (!claimedCid) return false;
    if (!cidMatches(aoe.owner_cid, claimedCid, "aoe.ownerCid")) return false;
    if (lockMyAoes) return false;
    return true;
  }

  function getClaimedUnit(){
    if (!state || !state.units || claimedCid === null) return null;
    return state.units.find(u => cidMatches(u.cid, claimedCid, "claimedUnit")) || null;
  }

  function getUnitByCid(cid){
    if (!state || !state.units) return null;
    const cidValue = normalizeCid(cid, "getUnitByCid.cid");
    if (cidValue === null) return null;
    return state.units.find(u => cidMatches(u.cid, cidValue, "getUnitByCid.unitCid")) || null;
  }

  function canControlSummonUnit(unit){
    if (!unit || claimedCid === null || claimedCid === undefined) return false;
    if (!cidMatches(unit.summoned_by_cid, claimedCid, "summonControl.owner")) return false;
    const mode = normalizeTextValue(unit.summon_controller_mode);
    return mode === "summoner" || !!unit.summon_shared_turn;
  }

  function canSelectControlledUnitCid(cid){
    const cidValue = normalizeCid(cid, "controlledSelect.cid");
    if (cidValue === null || claimedCid === null || claimedCid === undefined) return false;
    if (cidMatches(cidValue, claimedCid, "controlledSelect.claimedMatch")) return true;
    return canControlSummonUnit(getUnitByCid(cidValue));
  }

  function unitControllableThisTurn(cid){
    const cidValue = normalizeCid(cid, "controlledTurn.cid");
    const activeCid = normalizeCid(state?.active_cid, "controlledTurn.activeCid");
    if (cidValue === null || activeCid === null || claimedCid === null || claimedCid === undefined){
      return false;
    }
    if (cidMatches(activeCid, claimedCid, "controlledTurn.claimedActive")){
      if (cidMatches(cidValue, claimedCid, "controlledTurn.claimedSelection")){
        return true;
      }
      return canControlSummonUnit(getUnitByCid(cidValue));
    }
    return cidMatches(activeCid, cidValue, "controlledTurn.activeSelection");
  }

  function getMountMovementCid(){
    const rider = getClaimedUnit();
    if (!rider) return null;
    const mountCid = normalizeCid(rider.rider_cid, "mountMove.riderCid");
    if (mountCid === null) return null;
    const mount = getUnitByCid(mountCid);
    if (!mount) return null;
    if (!cidMatches(mount.mounted_by_cid, rider.cid, "mountMove.mountOwner")) return null;
    const mode = normalizeTextValue(mount.mount_controller_mode);
    if (mode !== "rider") return null;
    return mountCid;
  }

  function activeControlledUnitCid(){
    if (claimedCid === null || claimedCid === undefined){
      return null;
    }
    const selectedCid = normalizeCid(selectedTurnCid, "activeControlled.selectedCid");
    if (selectedCid !== null && canSelectControlledUnitCid(selectedCid) && unitControllableThisTurn(selectedCid)){
      return selectedCid;
    }
    if (unitControllableThisTurn(claimedCid)){
      return claimedCid;
    }
    const activeCid = normalizeCid(state?.active_cid, "activeControlled.activeCid");
    if (activeCid !== null && canControlSummonUnit(getUnitByCid(activeCid))){
      return activeCid;
    }
    return null;
  }

  function isUnitConcentrationLinked(unit){
    if (!unit) return false;
    if (unit.concentrating === true) return true;
    const ownerCid = normalizeCid(unit.summoned_by_cid, "concentration.ownerCid");
    if (ownerCid === null) return false;
    const owner = getUnitByCid(ownerCid);
    if (!owner || owner.concentrating !== true) return false;
    const ownerSpell = normalizeTextValue(owner.concentration_spell);
    const sourceSpell = normalizeTextValue(unit.summon_source_spell);
    return !!ownerSpell && !!sourceSpell && ownerSpell === sourceSpell;
  }

  function isUnitSpellcaster(unit){
    if (!unit) return false;
    if (unit.is_spellcaster !== undefined && unit.is_spellcaster !== null){
      return !!unit.is_spellcaster;
    }
    if (unit.spellcaster !== undefined && unit.spellcaster !== null){
      return !!unit.spellcaster;
    }
    return true;
  }

  function updateSpellPanelVisibility(){
    if (!castPanel) return;
    const claimedUnit = getClaimedUnit();
    const hideForNonCaster = hideSpellMenu && claimedUnit && !isUnitSpellcaster(claimedUnit);
    const wildShaped = !!claimedUnit?.is_wild_shaped;
    castPanel.classList.toggle("hidden", hideForNonCaster);
    if (castMenuTrigger){
      castMenuTrigger.classList.toggle("hidden", hideForNonCaster);
    }
    if (castOverlay){
      castOverlay.classList.toggle("hidden", hideForNonCaster);
    }
    if (hideForNonCaster && castOverlay?.classList.contains("show")){
      setCastOverlayOpen(false);
    }
    if (castOverlayOpenBtn){
      castOverlayOpenBtn.disabled = wildShaped;
      castOverlayOpenBtn.setAttribute("aria-disabled", wildShaped ? "true" : "false");
      castOverlayOpenBtn.title = wildShaped ? "Spellcasting is disabled while Wild Shaped." : "Cast Spell";
    }
  }

  function defaultAoeCenter(){
    const unit = getClaimedUnit();
    if (unit){
      return {cx: Number(unit.pos.col), cy: Number(unit.pos.row)};
    }
    const cols = state?.grid?.cols ?? 0;
    const rows = state?.grid?.rows ?? 0;
    return {cx: Math.max(0, (cols - 1) / 2), cy: Math.max(0, (rows - 1) / 2)};
  }

  function toGridPoint(point){
    if (!point) return {col: 0, row: 0};
    const colValue = point.col ?? point.cx ?? 0;
    const rowValue = point.row ?? point.cy ?? 0;
    return {col: Math.round(Number(colValue)), row: Math.round(Number(rowValue))};
  }

  function isLineOfSightBlocked(startPoint, endPoint){
    if (!state || !state.obstacles || !state.obstacles.length) return false;
    const start = toGridPoint(startPoint);
    const end = toGridPoint(endPoint);
    const obstacles = new Set(state.obstacles.map(o => `${Number(o.col)},${Number(o.row)}`));
    let x0 = start.col;
    let y0 = start.row;
    const x1 = end.col;
    const y1 = end.row;
    const dx = Math.abs(x1 - x0);
    const dy = Math.abs(y1 - y0);
    const sx = x0 < x1 ? 1 : -1;
    const sy = y0 < y1 ? 1 : -1;
    let err = dx - dy;
    let first = true;
    while (true){
      if (!first && obstacles.has(`${x0},${y0}`)){
        return true;
      }
      if (x0 === x1 && y0 === y1){
        break;
      }
      const e2 = 2 * err;
      if (e2 > -dy){
        err -= dy;
        x0 += sx;
      }
      if (e2 < dx){
        err += dx;
        y0 += sy;
      }
      first = false;
    }
    return false;
  }

  function setLosPreview(startPoint, endPoint, blocked){
    losPreview = {
      start: toGridPoint(startPoint),
      end: toGridPoint(endPoint),
      blocked: !!blocked,
      expiresAt: Date.now() + LOS_PREVIEW_MS,
    };
    setTimeout(() => {
      if (losPreview && Date.now() >= losPreview.expiresAt){
        losPreview = null;
        draw();
      }
    }, LOS_PREVIEW_MS + 25);
    draw();
  }

  function clearMeasurement(){
    measurement = {start: null, end: null};
    updateMeasurementControls();
    draw();
  }

  function setMeasurementPoint(p){
    if (!gridReady()) return;
    const g = screenToGrid(p.x, p.y);
    const point = {col: g.col, row: g.row};
    if (!measurement.start || measurement.end){
      measurement = {start: point, end: null};
    } else {
      measurement.end = point;
    }
    updateMeasurementControls();
    draw();
  }

  function cellKey(col, row){
    return `${col},${row}`;
  }

  function buildRoughTerrainMap(list){
    const map = new Map();
    if (Array.isArray(list)){
      list.forEach(cell => {
        map.set(cellKey(Number(cell.col), Number(cell.row)), cell || {});
      });
    }
    return map;
  }

  function buildObstacleSet(list){
    const set = new Set();
    if (Array.isArray(list)){
      list.forEach(cell => {
        set.add(cellKey(Number(cell.col), Number(cell.row)));
      });
    }
    return set;
  }

  function movementCostMap(startCol, startRow, maxFt, unit, roughMap, obstacles, cols, rows, feetPerSquare){
    const step = Number(feetPerSquare) || 5;
    const diag5 = step;
    const diag10 = step * 2;
    const mode = normalizeMovementMode(unit?.movement_mode);
    const landSpeed = Math.max(0, Number(unit?.speed || 0));
    let swimSpeed = Math.max(0, Number(unit?.swim_speed || 0));
    if (swimSpeed <= 0){
      swimSpeed = Math.max(1, Math.floor(landSpeed / 2));
    }
    let waterMultiplier = 1;
    if (mode === "normal" && landSpeed > 0 && swimSpeed > 0){
      waterMultiplier = landSpeed / swimSpeed;
    }

    function inBounds(col, row){
      return col >= 0 && row >= 0 && col < cols && row < rows;
    }

    const best = new Map();
    const bestSq = new Map();
    const heap = [];

    function heapPush(item){
      heap.push(item);
      let i = heap.length - 1;
      while (i > 0){
        const p = Math.floor((i - 1) / 2);
        if (heap[p].cost <= heap[i].cost) break;
        [heap[p], heap[i]] = [heap[i], heap[p]];
        i = p;
      }
    }

    function heapPop(){
      if (!heap.length) return null;
      const top = heap[0];
      const last = heap.pop();
      if (heap.length && last){
        heap[0] = last;
        let i = 0;
        while (true){
          const l = i * 2 + 1;
          const r = i * 2 + 2;
          let smallest = i;
          if (l < heap.length && heap[l].cost < heap[smallest].cost) smallest = l;
          if (r < heap.length && heap[r].cost < heap[smallest].cost) smallest = r;
          if (smallest === i) break;
          [heap[i], heap[smallest]] = [heap[smallest], heap[i]];
          i = smallest;
        }
      }
      return top;
    }

    const startKey = `${startCol},${startRow},0`;
    best.set(startKey, 0);
    heapPush({cost: 0, col: startCol, row: startRow, parity: 0});

    while (heap.length){
      const item = heapPop();
      if (!item) break;
      const {cost, col, row, parity} = item;
      const stateKey = `${col},${row},${parity}`;
      if (cost !== best.get(stateKey)) continue;
      if (cost > maxFt) continue;
      const sqKey = cellKey(col, row);
      const prev = bestSq.get(sqKey);
      if (prev === undefined || cost < prev){
        bestSq.set(sqKey, cost);
      }

      const neighbors = [
        [-1, 0, false], [1, 0, false], [0, -1, false], [0, 1, false],
        [-1, -1, true], [1, -1, true], [-1, 1, true], [1, 1, true],
      ];
      for (const [dc, dr, isDiag] of neighbors){
        const nc = col + dc;
        const nr = row + dr;
        if (!inBounds(nc, nr)) continue;
        if (obstacles.has(cellKey(nc, nr))) continue;
        if (isDiag){
          if (obstacles.has(cellKey(col + dc, row)) || obstacles.has(cellKey(col, row + dr))){
            continue;
          }
        }
        let stepCost;
        let npar;
        if (isDiag){
          stepCost = parity === 0 ? diag5 : diag10;
          npar = 1 - parity;
        } else {
          stepCost = step;
          npar = parity;
        }

        const currentCell = roughMap.get(cellKey(col, row)) || {};
        const targetCell = roughMap.get(cellKey(nc, nr)) || {};
        const currentType = cellMovementType(currentCell);
        const targetType = cellMovementType(targetCell);
        if (mode === "swim" && targetType !== "water") continue;
        if (mode === "burrow" && targetType === "water") continue;
        if (mode !== "fly"){
          if (currentType === "water" || targetType === "water"){
            stepCost = Math.ceil(stepCost * waterMultiplier);
          }
          if (targetCell.is_rough){
            stepCost *= 2;
          }
        }

        const newCost = cost + stepCost;
        if (newCost > maxFt) continue;
        const nextKey = `${nc},${nr},${npar}`;
        if (newCost < (best.get(nextKey) ?? 1e9)){
          best.set(nextKey, newCost);
          heapPush({cost: newCost, col: nc, row: nr, parity: npar});
        }
      }
    }

    return bestSq;
  }

  
  function saveDmUiPrefs(){ try { localStorage.setItem(dmUiPrefsKey, JSON.stringify(dmUiPrefs)); } catch(_) {} }
  function classifyLogLine(text){ const t=(text||"").toLowerCase(); if (t.includes("heal")) return "heal"; if (t.includes("save")||t.includes("concentration")) return "save"; if (t.includes("hits")||t.includes("miss")) return "attack"; if (t.includes("damage")||t.includes("takes")) return "damage"; if (t.includes("spell")||t.includes("")) return "spell"; return "spell"; }
  function parseBattleLine(line){ const m=String(line||"").match(/^\[([^\]]+)\]\s*	?\s*(.*)$/); return {time:m?m[1]:"", msg:m?m[2]:String(line||"")}; }
  function escapeHtml(text){
    return String(text ?? "").replace(/[&<>"']/g, (ch) => {
      if (ch === "&") return "&amp;";
      if (ch === "<") return "&lt;";
      if (ch === ">") return "&gt;";
      if (ch === "\"") return "&quot;";
      if (ch === "'") return "&#39;";
      return ch;
    });
  }
  function isCriticalLine(text){
    const msg = String(text || "").toLowerCase();
    return /\b(crit|critical|nat\s*20|natural\s*20)\b/.test(msg);
  }
  const damageTypeColorByName = {
    acid: "#7CAC00",
    cold: "#348CC4",
    fire: "#EC5400",
    force: "#C83434",
    healing: "#30B8B8",
    lightning: "#3058C0",
    necrotic: "#40AC50",
    poison: "#44B800",
    radiant: "#C8A800",
    thunder: "#8444B8",
    psychic: "#AC7094",
    physical: "#888888",
    piercing: "#888888",
    bludgeoning: "#888888",
    slashing: "#888888",
    hellfire: "#A00000",
  };
  function decorateDamageTypes(message){
    const html = escapeHtml(String(message || ""));
    const typeKeys = Object.keys(damageTypeColorByName).sort((a, b) => b.length - a.length);
    const typePattern = typeKeys.join("|");
    const rx = new RegExp(`\\b(\\d+(?:\\.\\d+)?)\\s+(${typePattern})(\\s+damage\\b)?|\\b(\\d+(?:\\.\\d+)?)\\s+(damage\\b)`, "gi");
    return html.replace(rx, (match, typedAmount, type, typedDamageWord, plainAmount, plainDamageWord) => {
      const amount = String(typedAmount || plainAmount || "").trim();
      const typeText = String(type || "").trim();
      const damageWord = String(typedDamageWord || plainDamageWord || "").trim();
      const key = String(typeText || "physical").toLowerCase();
      const color = damageTypeColorByName[key] || damageTypeColorByName.physical;
      if (typeText){
        return `<span class="damage-type" style="color:${color}"><strong>${amount}</strong> ${typeText}${damageWord ? ` ${damageWord}` : ""}</span>`;
      }
      return `<span class="damage-type" style="color:${color}"><strong>${amount}</strong> ${damageWord || "damage"}</span>`;
    });
  }
  function renderMapViewLogPanel(){
    if (!mapViewLogPanel || !mapViewLogList) return;
    if (!isMapView){
      mapViewLogPanel.style.display = "none";
      return;
    }
    mapViewLogPanel.style.display = "flex";
    const atBottom = mapViewLogList.scrollTop + mapViewLogList.clientHeight >= mapViewLogList.scrollHeight - 20;
    mapViewLogList.textContent = "";
    const visibleLines = dmLogLines.slice(-18);
    visibleLines.forEach((line)=>{
      const parsed = parseBattleLine(line);
      const row = document.createElement('div');
      row.className = "map-view-log-entry";
      const msgClass = isCriticalLine(parsed.msg) ? "map-view-log-msg is-crit" : "map-view-log-msg";
      row.innerHTML = `<div class="map-view-log-time">${parsed.time ? parsed.time.slice(11,19) : ''}</div><div class="${msgClass}">${decorateDamageTypes(parsed.msg)}</div>`;
      mapViewLogList.appendChild(row);
    });
    if (atBottom) mapViewLogList.scrollTop = mapViewLogList.scrollHeight;
  }
  function refreshMapViewLogPolling(){
    if (mapViewLogPollTimer){
      clearInterval(mapViewLogPollTimer);
      mapViewLogPollTimer = null;
    }
    const shouldPoll = isMapView || battleLogViewPrefs?.visible === true;
    if (!shouldPoll) return;
    requestBattleLog();
    mapViewLogPollTimer = setInterval(()=>{
      if (ws && ws.readyState === WebSocket.OPEN && (isMapView || battleLogViewPrefs?.visible === true)){
        send({type:"log_request"});
      }
    }, 2500);
  }
  function renderDmLogPanel(){
    const isAdmin = isAdminClient();
    if (!dmLogPanel || !dmLogList){
      renderMapViewLogPanel();
      return;
    }
    dmLogPanel.classList.toggle('show', !!(isAdmin && dmUiPrefs.showLogPanel));
    dmMapPreview?.classList.toggle('show', !!(isAdmin && dmUiPrefs.showMapPreview));
    if (!isAdmin){ renderMapViewLogPanel(); return; }
    dmLogList.textContent = "";
    const atBottom = dmLogList.scrollTop + dmLogList.clientHeight >= dmLogList.scrollHeight - 12;
    dmLogLines.forEach((line)=>{
      const parsed = parseBattleLine(line);
      const kind = classifyLogLine(parsed.msg);
      if (dmUiPrefs.filters && dmUiPrefs.filters[kind] === false) return;
      const row = document.createElement('div');
      row.className = `dm-log-entry ${kind}`;
      row.innerHTML = `<div class="dm-log-time">${parsed.time ? parsed.time.slice(11,19) : ''}</div><div class="dm-log-msg">${parsed.msg}</div>`;
      row.addEventListener('click', ()=>{
        const unit=(state?.units||[]).find(u => parsed.msg.includes(u.name));
        if (unit){ centerOn(unit.cid); dmHighlightUntil.set(String(unit.cid), Date.now()+2200); }
      });
      dmLogList.appendChild(row);
    });
    if (dmUiPrefs.autoScroll && (atBottom || dmLogAutoScrollInput?.checked)) dmLogList.scrollTop = dmLogList.scrollHeight;
    renderMapViewLogPanel();
  }
  function renderDmPreview(){
    if (!dmPreviewCanvas || !state?.grid || !dmUiPrefs.showMapPreview || !isAdminClient()) return;
    const pctx = dmPreviewCanvas.getContext('2d');
    const w = dmPreviewCanvas.width, h = dmPreviewCanvas.height;
    pctx.clearRect(0,0,w,h); pctx.fillStyle='#0a0c12'; pctx.fillRect(0,0,w,h);
    const cols=Number(state.grid.cols||1), rows=Number(state.grid.rows||1);
    const cell=Math.max(2, Math.min((w-8)/cols,(h-8)/rows));
    const ox=(w-cols*cell)/2, oy=(h-rows*cell)/2;
    pctx.strokeStyle='rgba(255,255,255,0.08)'; pctx.lineWidth=1;
    for(let c=0;c<=cols;c++){const x=ox+c*cell; pctx.beginPath(); pctx.moveTo(x,oy); pctx.lineTo(x,oy+rows*cell); pctx.stroke();}
    for(let r=0;r<=rows;r++){const y=oy+r*cell; pctx.beginPath(); pctx.moveTo(ox,y); pctx.lineTo(ox+cols*cell,y); pctx.stroke();}
    (state.aoes||[]).forEach(a=>{ pctx.fillStyle='rgba(120,160,255,0.18)'; const cx=ox+(Number(a.cx||0)+0.5)*cell; const cy=oy+(Number(a.cy||0)+0.5)*cell; const rr=Math.max(2, Number(a.radius_sq||1)*cell); pctx.beginPath(); pctx.arc(cx,cy,rr,0,Math.PI*2); pctx.fill(); });
    (state.units||[]).forEach(u=>{ const x=ox+(Number(u.pos.col)+0.5)*cell; const y=oy+(Number(u.pos.row)+0.5)*cell; pctx.fillStyle=(u.role==='enemy')?'rgba(255,91,91,0.9)':'rgba(106,255,176,0.9)'; pctx.beginPath(); pctx.arc(x,y,Math.max(2,cell*0.25),0,Math.PI*2); pctx.fill(); });
  }

  function draw(){
    if (!state) return;
    if (!gridReady()){
      updateWaitingOverlay();
      return;
    }
    updateWaitingOverlay();
    renderDmPreview();
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;

    ctx.clearRect(0,0,w,h);

    // background
    ctx.fillStyle = "#0a0c12";
    ctx.fillRect(0,0,w,h);

    const cols = state.grid.cols, rows = state.grid.rows;
    if (cols !== lastGrid.cols || rows !== lastGrid.rows){
      fittedToGrid = false;
      lastGrid = {cols, rows};
    }

    // auto-fit on first draw
    if (!fittedToGrid){
      const pad = 24;
      const sx = (w - pad*2) / (cols*zoom);
      const sy = (h - pad*2) / (rows*zoom);
      const s = Math.min(1.0, Math.max(0.35, Math.min(sx, sy)));
      zoom = Math.floor(zoom * s);
      panX = Math.floor((w - cols*zoom)/2);
      panY = Math.floor((h - rows*zoom)/2);
      fittedToGrid = true;
    }

    // grid
    ctx.strokeStyle = "rgba(255,255,255,0.07)";
    ctx.lineWidth = 1;
    for(let c=0;c<=cols;c++){
      const x = panX + c*zoom;
      ctx.beginPath(); ctx.moveTo(x, panY); ctx.lineTo(x, panY + rows*zoom); ctx.stroke();
    }
    for(let r=0;r<=rows;r++){
      const y = panY + r*zoom;
      ctx.beginPath(); ctx.moveTo(panX, y); ctx.lineTo(panX + cols*zoom, y); ctx.stroke();
    }

    // rough terrain
    if (state.rough_terrain && state.rough_terrain.length){
      state.rough_terrain.forEach(cell => {
        const x = panX + cell.col*zoom;
        const y = panY + cell.row*zoom;
        const colorHex = normalizeHexColor(cell.color || "");
        const movementType = cellMovementType(cell);
        const isSwim = movementType === "water";
        const isRough = !!cell.is_rough;
        let alpha = isSwim ? 0.35 : 0.25;
        if (isRough && !isSwim){
          alpha = 0.3;
        }
        const fallback = isSwim ? "rgba(74,163,223,0.32)" : "rgba(141,110,99,0.25)";
        ctx.fillStyle = colorHex ? rgbaFromHex(colorHex, alpha) : fallback;
        ctx.fillRect(x+1,y+1,zoom-2,zoom-2);
      });
    }

    // movement range (claimed token or controlled summon)
    const movableCid = activeControlledUnitCid();
    if (movableCid !== null && state.units){
      const me = state.units.find(u => cidMatches(u.cid, movableCid, "movementRange.unitCid"));
      if (me){
        const move = Math.max(0, Number(me.move_remaining || 0));
        const feet = Math.max(1, Number(state.grid.feet_per_square || 5));
        if (move > 0){
          const roughMap = buildRoughTerrainMap(state.rough_terrain);
          const obstacleSet = buildObstacleSet(state.obstacles);
          const costMap = movementCostMap(
            Number(me.pos.col),
            Number(me.pos.row),
            move,
            me,
            roughMap,
            obstacleSet,
            cols,
            rows,
            feet,
          );
          costMap.forEach((cost, key) => {
            if (!cost) return;
            const [col, row] = key.split(",").map(Number);
            const x = panX + col * zoom;
            const y = panY + row * zoom;
            ctx.fillStyle = "rgba(106,169,255,0.18)";
            ctx.fillRect(x + 1, y + 1, zoom - 2, zoom - 2);
          });
        }
      }
    }

    if (attackOverlayMode){
      const me = getClaimedUnit();
      const weapon = pendingSpellTargeting ? null : getSelectedAttackWeapon();
      const spellRangeFt = Number(pendingSpellTargeting?.rangeFt);
      const layOnHandsRangeFt = Number(pendingLayOnHandsTargeting?.rangeFt);
      if (me && me.pos && (weapon || Number.isFinite(spellRangeFt) || Number.isFinite(layOnHandsRangeFt))){
        const rangeFt = Number.isFinite(layOnHandsRangeFt)
          ? layOnHandsRangeFt
          : (Number.isFinite(spellRangeFt)
            ? spellRangeFt
            : parseWeaponRangeFeet(weapon) + (isMeleeWeapon(weapon) ? 3 : 0));
        const feetPerSquare = Math.max(1, Number(state.grid.feet_per_square || 5));
        const radiusCells = Math.max(0, Number(rangeFt) / feetPerSquare);
        const center = gridToScreen(me.pos.col, me.pos.row);
        const overlayColor = normalizeHexColor(pendingLayOnHandsTargeting ? "#4caf50" : (pendingSpellTargeting?.overlayColor || ""));
        ctx.save();
        ctx.fillStyle = overlayColor ? rgbaFromHex(overlayColor, 0.15) : "rgba(255,78,78,0.15)";
        ctx.strokeStyle = overlayColor ? rgbaFromHex(overlayColor, 0.72) : "rgba(255,78,78,0.72)";
        ctx.lineWidth = 2;
        ctx.setLineDash([6, 4]);
        ctx.beginPath();
        ctx.arc(center.x, center.y, Math.max(6, radiusCells * zoom), 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();
      }
    }

    if (pendingSummonPlacement){
      rebuildSummonValidCells();
      updateSummonPlacementBanner();
      summonValidCells.forEach((key) => {
        const [col, row] = key.split(",").map(Number);
        const x = panX + col * zoom;
        const y = panY + row * zoom;
        ctx.fillStyle = "rgba(106,169,255,0.22)";
        ctx.fillRect(x + 1, y + 1, zoom - 2, zoom - 2);
      });
      if (pendingSummonPlacement.casterPos && Number.isFinite(Number(pendingSummonPlacement.maxRangeFt))){
        const feetPerSquare = Math.max(1, Number(state.grid.feet_per_square || 5));
        const radiusCells = Number(pendingSummonPlacement.maxRangeFt) / feetPerSquare;
        const caster = gridToScreen(pendingSummonPlacement.casterPos.col, pendingSummonPlacement.casterPos.row);
        ctx.save();
        ctx.strokeStyle = "rgba(106,169,255,0.65)";
        ctx.setLineDash([6, 4]);
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(caster.x, caster.y, Math.max(6, radiusCells * zoom), 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }
    } else {
      updateSummonPlacementBanner();
    }

    // obstacles
    if (state.obstacles && state.obstacles.length){
      ctx.fillStyle = "rgba(255,255,255,0.10)";
      state.obstacles.forEach(o => {
        const x = panX + o.col*zoom;
        const y = panY + o.row*zoom;
        ctx.fillRect(x+1,y+1,zoom-2,zoom-2);
      });
    }

    // AoE overlays
    if (state.aoes && state.aoes.length){
      state.aoes.forEach(a => {
        renderAoeOverlay(a);
      });
    }
    if (aoeDragPreview){
      const aoeSource = state?.aoes?.find(a => Number(a.aid) === Number(aoeDragPreview.aid));
      if (aoeSource){
        const override = {};
        if (Number.isFinite(Number(aoeDragPreview.angle_deg))){
          override.angle_deg = Number(aoeDragPreview.angle_deg);
        }
        if (Number.isFinite(Number(aoeDragPreview.spread_deg))){
          override.spread_deg = Number(aoeDragPreview.spread_deg);
        }
        if (Number.isFinite(Number(aoeDragPreview.ax))){
          override.ax = Number(aoeDragPreview.ax);
        }
        if (Number.isFinite(Number(aoeDragPreview.ay))){
          override.ay = Number(aoeDragPreview.ay);
        }
        renderAoeOverlay(aoeSource, {
          cx: aoeDragPreview.cx,
          cy: aoeDragPreview.cy,
          preview: true,
          override: Object.keys(override).length ? override : null,
        });
      }
    }

    // measurement line
    if (measurement.start){
      const start = gridToScreen(measurement.start.col, measurement.start.row);
      ctx.save();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(255,233,106,0.9)";
      ctx.fillStyle = "rgba(255,233,106,0.9)";
      ctx.beginPath();
      ctx.arc(start.x, start.y, Math.max(6, zoom * 0.12), 0, Math.PI * 2);
      ctx.fill();
      if (measurement.end){
        const end = gridToScreen(measurement.end.col, measurement.end.row);
        ctx.beginPath();
        ctx.moveTo(start.x, start.y);
        ctx.lineTo(end.x, end.y);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(end.x, end.y, Math.max(6, zoom * 0.12), 0, Math.PI * 2);
        ctx.fill();
        const feetPerSquare = Math.max(1, Number(state.grid.feet_per_square || 5));
        const dx = measurement.end.col - measurement.start.col;
        const dy = measurement.end.row - measurement.start.row;
        const feet = Math.hypot(dx, dy) * feetPerSquare;
        const label = formatFeet(feet);
        const midX = (start.x + end.x) / 2;
        const midY = (start.y + end.y) / 2;
        ctx.font = `700 ${Math.max(11, Math.floor(zoom * 0.32))}px system-ui`;
        ctx.textAlign = "center";
        ctx.textBaseline = "bottom";
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillText(label, midX + 1, midY - 7 + 1);
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.fillText(label, midX, midY - 7);
      }
      ctx.restore();
    }

    if (losPreview && Date.now() <= losPreview.expiresAt){
      const start = gridToScreen(losPreview.start.col, losPreview.start.row);
      const end = gridToScreen(losPreview.end.col, losPreview.end.row);
      ctx.save();
      ctx.lineWidth = 3;
      ctx.setLineDash([8, 6]);
      ctx.strokeStyle = losPreview.blocked ? "rgba(255,120,120,0.95)" : "rgba(123,233,173,0.95)";
      ctx.beginPath();
      ctx.moveTo(start.x, start.y);
      ctx.lineTo(end.x, end.y);
      ctx.stroke();
      ctx.restore();
    }

    // tokens
    const tokens = sortedTokensForRender(state.units || []);
    // group labels by cell
    const cellMap = new Map();
    tokens.forEach(u => {
      const key = `${u.pos.col},${u.pos.row}`;
      if (!cellMap.has(key)) cellMap.set(key, []);
      cellMap.get(key).push(u);
    });

    // draw token circles first
    tokens.forEach(u => {
      const {x,y} = gridToScreen(u.pos.col,u.pos.row);
      const r = Math.max(10, zoom*0.35);
      const facingRad = (tokenFacingDeg(u) * Math.PI) / 180;
      const active = (state.active_cid !== null && cidMatches(state.active_cid, u.cid, "token.activeCid"));
      const mine = (claimedCid != null && cidMatches(claimedCid, u.cid, "token.claimedCid"));
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);

      // color
      const customFill = u.token_color ? rgbaFromHex(u.token_color, 0.28) : null;
      if (customFill){
        ctx.fillStyle = customFill;
      } else if (u.role === "enemy") {
        ctx.fillStyle = "rgba(255,91,91,0.28)";
      } else {
        ctx.fillStyle = "rgba(106,255,176,0.18)";
      }
      ctx.fill();

      const dmHl = (dmHighlightUntil.get(String(u.cid)) || 0) > Date.now();
      ctx.lineWidth = (active || dmHl) ? 3 : 2;
      const mountStroke = u.is_mount ? "rgba(106,169,255,0.98)" : null;
      const customBorderStroke = u.token_border_color ? rgbaFromHex(u.token_border_color, 0.95) : null;
      ctx.strokeStyle = dmHl ? "rgba(255,218,120,0.98)" : (mountStroke || customBorderStroke || (mine ? "rgba(106,169,255,0.95)" : (active ? "rgba(255,255,255,0.85)" : "rgba(255,255,255,0.25)")));
      ctx.stroke();
      if (u.is_mount){
        ctx.save();
        ctx.font = `${Math.max(10, Math.floor(zoom*0.28))}px system-ui`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(106,169,255,0.95)";
        ctx.fillText("", x, y - (r * 0.55));
        ctx.restore();
      }
      if (isUnitConcentrationLinked(u)){
        ctx.save();
        ctx.font = `${Math.max(10, Math.floor(zoom*0.3))}px system-ui`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(241,201,95,0.98)";
        ctx.fillText("", x + (r * 0.58), y - (r * 0.58));
        ctx.restore();
      }

      // condition markers inside
      const marks = (u.marks || "").trim();
      if (marks){
        ctx.font = `${Math.max(10, Math.floor(zoom*0.33))}px system-ui`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.fillText(marks, x, y);
      }
      const facingDotDistance = Math.max(2, r - Math.max(2, zoom * 0.13));
      const facingDotRadius = Math.max(1.6, zoom * 0.06);
      ctx.beginPath();
      ctx.arc(
        x + Math.cos(facingRad) * facingDotDistance,
        y + Math.sin(facingRad) * facingDotDistance,
        facingDotRadius,
        0,
        Math.PI * 2
      );
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.fill();

      const handle = tokenRotateHandle(u);
      if (handle){
        ctx.save();
        ctx.beginPath();
        ctx.arc(x, y, Math.max(12, handle.orbitR), 0, Math.PI * 2);
        ctx.lineWidth = 1;
        ctx.strokeStyle = "rgba(255,255,255,0.28)";
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(handle.x, handle.y, handle.hitR, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(0,0,0,0.88)";
        ctx.fill();
        ctx.font = `${Math.max(8, Math.floor((zoom * 0.22) * mapRotateHandleScale()))}px system-ui`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.fillText("", handle.x, handle.y);
        ctx.restore();
      }
    });

    // labels above: name or group name
    const labelBoxes = [];
    const labelFontSize = Math.max(11, Math.floor(zoom*0.32));
    const labelOffset = zoom*0.40;
    const labelPad = 2;
    const labelStep = Math.max(6, Math.floor(labelFontSize * 0.7));
    const labelOffsets = [0, -labelStep, labelStep, -2*labelStep, 2*labelStep];
    const labelEntries = [];
    cellMap.forEach((arr, key) => {
      const [col,row] = key.split(",").map(Number);
      const {x,y} = gridToScreen(col,row);
      let label = "";
      if (arr.length >= 2){
        const names = arr.map(a => a.name).join(", ");
        label = `Group (${arr.length}): ${names}`;
      } else {
        label = arr[0].name;
      }
      const isActive = arr.some(a => state.active_cid !== null && cidMatches(state.active_cid, a.cid, "label.activeCid"));
      labelEntries.push({label, x, y: y - labelOffset, isActive});
    });
    labelEntries.sort((a, b) => Number(a.isActive) - Number(b.isActive));
    ctx.textAlign = "center";
    ctx.textBaseline = "bottom";
    ctx.font = `600 ${labelFontSize}px system-ui`;
    const overlaps = (a, b) => !(a.x2 < b.x1 || a.x1 > b.x2 || a.y2 < b.y1 || a.y1 > b.y2);
    labelEntries.forEach(entry => {
      const width = ctx.measureText(entry.label).width;
      let placed = false;
      for (const offset of labelOffsets){
        const y = entry.y + offset;
        const box = {
          x1: entry.x - width / 2 - labelPad,
          x2: entry.x + width / 2 + labelPad,
          y1: y - labelFontSize - labelPad,
          y2: y + labelPad,
        };
        if (!labelBoxes.some(b => overlaps(b, box))){
          // shadow
          ctx.fillStyle = "rgba(0,0,0,0.55)";
          ctx.fillText(entry.label, entry.x + 1, y + 1);
          ctx.fillStyle = "rgba(232,238,247,0.92)";
          ctx.fillText(entry.label, entry.x, y);
          labelBoxes.push(box);
          placed = true;
          break;
        }
      }
      if (!placed && (showAllNames || entry.isActive)){
        const y = entry.y;
        const box = {
          x1: entry.x - width / 2 - labelPad,
          x2: entry.x + width / 2 + labelPad,
          y1: y - labelFontSize - labelPad,
          y2: y + labelPad,
        };
        ctx.fillStyle = "rgba(0,0,0,0.55)";
        ctx.fillText(entry.label, entry.x + 1, y + 1);
        ctx.fillStyle = "rgba(232,238,247,0.92)";
        ctx.fillText(entry.label, entry.x, y);
        labelBoxes.push(box);
      }
    });

  }

  function centerOnPoint(col, row){
    if (!state || !state.grid) return false;
    if (!gridReady()) return false;
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    const cols = state.grid.cols, rows = state.grid.rows;
    const desiredX = (w / 2) - (Number(col) + 0.5) * zoom;
    const desiredY = (h / 2) - (Number(row) + 0.5) * zoom;
    const gridW = cols * zoom;
    const gridH = rows * zoom;
    if (gridW <= w) {
      panX = Math.floor((w - gridW) / 2);
    } else {
      const minX = w - gridW;
      panX = Math.min(0, Math.max(minX, desiredX));
    }
    if (gridH <= h) {
      panY = Math.floor((h - gridH) / 2);
    } else {
      const minY = h - gridH;
      panY = Math.min(0, Math.max(minY, desiredY));
    }
    return true;
  }

  function centerOnClaimed(){
    if (!state || !state.units || claimedCid === null || claimedCid === undefined) return false;
    if (!gridReady()) return false;
    const me = state.units.find(u => cidMatches(u.cid, claimedCid, "centerOnClaimed"));
    if (!me) return false;
    const ok = centerOnPoint(me.pos.col, me.pos.row);
    if (ok){
      centeredCid = String(claimedCid);
      draw();
    }
    return ok;
  }

  function centerOnGridCenter(){
    if (!state || !state.grid) return false;
    if (!gridReady()) return false;
    const cols = Number(state.grid.cols || 0);
    const rows = Number(state.grid.rows || 0);
    const col = Math.max(0, (cols - 1) / 2);
    const row = Math.max(0, (rows - 1) / 2);
    const ok = centerOnPoint(col, row);
    if (ok){
      draw();
    }
    return ok;
  }

  function autoCenterOnJoin(){
    if (!gridReady()) return;
    if (claimedCid !== null && claimedCid !== undefined){
      if (!initialCenterDone || (initialCenterFallback && centeredCid !== String(claimedCid))){
        if (centerOnClaimed()){
          initialCenterDone = true;
          initialCenterFallback = false;
        }
      }
    } else if (!initialCenterDone) {
      if (centerOnGridCenter()){
        initialCenterDone = true;
        initialCenterFallback = true;
      }
    }
  }

  function formatTurnOrderLabel(unit){
    if (!unit) return "";
    const role = String(unit.role || "enemy");
    let label = `${unit.name} (${role})`;
    if (unit.summoned_by_cid !== undefined && unit.summoned_by_cid !== null){
      label += `  controlled by #${unit.summoned_by_cid}`;
    }
    if ((role === "pc" || role === "ally") && Number.isFinite(Number(unit.hp))){
      label += ` ${Number(unit.hp)} HP`;
    }
    return label;
  }

  function hideTurnOrderBubble(){
    if (!activeTurnOrderBubbleEl){
      return;
    }
    activeTurnOrderBubbleEl.classList.remove("show");
  }

  function showTurnOrderBubble(chip, unit){
    if (!activeTurnOrderBubbleEl){
      return;
    }
    if (!chip || !unit){
      hideTurnOrderBubble();
      return;
    }
    activeTurnOrderBubbleEl.textContent = formatTurnOrderLabel(unit);
    activeTurnOrderBubbleEl.classList.add("show");
    const container = activeTurnOrderBubbleEl.offsetParent || activeTurnOrderEl;
    if (!container){
      return;
    }
    const containerRect = container.getBoundingClientRect();
    const chipRect = chip.getBoundingClientRect();
    const bubbleRect = activeTurnOrderBubbleEl.getBoundingClientRect();
    let left = chipRect.left - containerRect.left + (chipRect.width / 2);
    let top = chipRect.top - containerRect.top - bubbleRect.height - 8;
    if (top < 0){
      top = chipRect.bottom - containerRect.top + 8;
    }
    const minLeft = bubbleRect.width / 2;
    const maxLeft = containerRect.width - bubbleRect.width / 2;
    if (maxLeft >= minLeft){
      left = Math.min(Math.max(left, minLeft), maxLeft);
    } else {
      left = containerRect.width / 2;
    }
    top = Math.max(top, 0);
    const maxTop = Math.max(0, containerRect.height - bubbleRect.height);
    top = Math.min(top, maxTop);
    activeTurnOrderBubbleEl.style.left = `${left}px`;
    activeTurnOrderBubbleEl.style.top = `${top}px`;
  }

  function updateTurnOrder(){
    if (!activeTurnOrderEl){
      return;
    }
    const TURN_CHIP_NAME_MAX = 20;
    const TURN_CHIP_CONDITION_MAX = 24;
    const formatTurnChipName = (name) => {
      const fullName = String(name ?? "");
      if (fullName.length <= TURN_CHIP_NAME_MAX){
        return fullName;
      }
      return `${fullName.slice(0, TURN_CHIP_NAME_MAX - 1).trimEnd()}`;
    };
    const formatTurnChipConditions = (text) => {
      const fullText = normalizeTextValue(text);
      if (!fullText) return "";
      if (fullText.length <= TURN_CHIP_CONDITION_MAX){
        return fullText;
      }
      return `${fullText.slice(0, TURN_CHIP_CONDITION_MAX - 1).trimEnd()}`;
    };
    const order = Array.isArray(state?.turn_order) ? state.turn_order : [];
    activeTurnOrderEl.innerHTML = "";
    if (!order.length){
      if (activeTurnOrderStatusEl){
        activeTurnOrderStatusEl.textContent = "";
      }
      if (activeTurnOrderBubbleEl){
        hideTurnOrderBubble();
      }
      return;
    }
    const activeCid = normalizeCid(state?.active_cid, "turnOrder.activeCid");
    const activeIndex = activeCid === null
      ? -1
      : order.findIndex(cid => cidMatches(cid, activeCid, "turnOrder.activeIndex"));
    const claimedIndex = (claimedCid === null || claimedCid === undefined)
      ? -1
      : order.findIndex(cid => cidMatches(cid, claimedCid, "turnOrder.claimedIndex"));
    const unitsByCid = new Map();
    if (Array.isArray(state?.units)){
      state.units.forEach((unit) => {
        if (unit && unit.cid !== undefined && unit.cid !== null){
          const unitCid = normalizeCid(unit.cid, "turnOrder.unitCid");
          if (unitCid !== null){
            unitsByCid.set(unitCid, unit);
          }
        }
      });
    }
    const chipByCid = new Map();
    order.forEach((cid, idx) => {
      const cidValue = normalizeCid(cid, "turnOrder.orderCid");
      const unit = cidValue !== null ? unitsByCid.get(cidValue) : undefined;
      const chip = document.createElement("div");
      chip.className = "turn-chip";
      const role = String(unit?.role || "enemy");
      const isFriendly = role !== "enemy";
      chip.classList.add(isFriendly ? "friendly" : "enemy");
      if (idx === claimedIndex){
        chip.classList.add("claimed");
      }
      if (idx === activeIndex){
        chip.classList.add("active");
      }
      chip.setAttribute("role", "button");
      chip.setAttribute("tabindex", "0");
      const baseUnitName = unit?.name ? String(unit.name) : `#${cid}`;
      const unitName = unit?.is_mount ? `${baseUnitName} (steed)` : baseUnitName;
      const truncatedUnitName = formatTurnChipName(unitName);
      const conditionText = formatTurnChipConditions(unit?.marks);
      const fullLabel = conditionText ? `${unitName}  ${conditionText}` : unitName;
      chip.setAttribute("aria-label", `Turn ${idx + 1}: ${fullLabel}`);
      chip.setAttribute("data-full-name", unitName);
      chip.setAttribute("title", fullLabel);
      if (cidValue !== null){
        chip.dataset.cid = String(cidValue);
      }
      if (idx === claimedIndex){
        const claimedMarker = document.createElement("span");
        claimedMarker.className = "turn-chip-marker claimed-marker";
        claimedMarker.setAttribute("aria-hidden", "true");
        chip.appendChild(claimedMarker);
      }
      if (idx === activeIndex){
        const activeMarker = document.createElement("span");
        activeMarker.className = "turn-chip-marker active-marker";
        activeMarker.setAttribute("aria-hidden", "true");
        chip.appendChild(activeMarker);
      }
      const indexEl = document.createElement("span");
      indexEl.className = "turn-chip-index";
      indexEl.textContent = String(idx + 1);
      chip.appendChild(indexEl);
      const nameEl = document.createElement("span");
      nameEl.className = "turn-chip-name";
      const concentrationLabel = isUnitConcentrationLinked(unit) ? `${truncatedUnitName} ` : truncatedUnitName;
      nameEl.textContent = conditionText ? `${concentrationLabel}  ${conditionText}` : concentrationLabel;
      nameEl.setAttribute("data-full-name", unitName);
      nameEl.setAttribute("title", fullLabel);
      chip.appendChild(nameEl);
      chip.addEventListener("click", () => {
        if (cidValue === null) return;
        setSelectedTurnCid(cidValue);
      });
      chip.addEventListener("keydown", (ev) => {
        if (ev.key === "Enter" || ev.key === " "){
          ev.preventDefault();
          if (cidValue === null) return;
          setSelectedTurnCid(cidValue);
        }
      });
      chip.addEventListener("mouseenter", () => {
        if (cidValue === null) return;
        hoveredTurnCid = cidValue;
        showTurnOrderBubble(chip, unit);
      });
      chip.addEventListener("mouseleave", () => {
        if (cidValue !== null && hoveredTurnCid === cidValue){
          hoveredTurnCid = null;
        }
        hideTurnOrderBubble();
      });
      activeTurnOrderEl.appendChild(chip);
      if (cidValue !== null){
        chipByCid.set(cidValue, chip);
      }
    });
    const setSelectedTurnCid = (cid) => {
      selectedTurnCid = cid;
      chipByCid.forEach((chip, key) => {
        chip.classList.toggle("selected", key === cid);
      });
    };
    const claimedUnit = (claimedIndex >= 0 && claimedCid != null) ? unitsByCid.get(claimedCid) : null;
    if (activeTurnOrderStatusEl){
      const activeOrderCid = activeIndex >= 0 ? normalizeCid(order[activeIndex], "turnOrder.activeDisplayCid") : null;
      const activeUnit = activeOrderCid !== null ? unitsByCid.get(activeOrderCid) : null;
      const roundLabel = Number.isFinite(Number(state?.round_num)) ? `Round ${state.round_num}` : "";
      const isClaimedTurn = claimedCid !== null && activeOrderCid !== null && claimedCid === activeOrderCid;
      const activeLabel = isClaimedTurn
        ? "Your turn"
        : activeUnit?.name ? `${activeUnit.name}'s turn` : "Turn: ";
      let statusText = roundLabel ? `${activeLabel}  ${roundLabel}` : activeLabel;
      if (claimedIndex >= 0 && claimedUnit && !isMapView && !isClaimedTurn){
        statusText = `${statusText}  You are #${claimedIndex + 1}: ${claimedUnit.name}`;
      }
      activeTurnOrderStatusEl.textContent = statusText;
    }
    let fallbackCid = selectedTurnCid;
    if (fallbackCid === null || !chipByCid.has(fallbackCid)){
      if (claimedIndex >= 0){
        fallbackCid = claimedCid;
      } else if (activeIndex >= 0){
        fallbackCid = normalizeCid(order[activeIndex], "turnOrder.fallbackActiveCid");
      } else {
        fallbackCid = normalizeCid(order[0], "turnOrder.fallbackFirstCid");
      }
    }
    setSelectedTurnCid(fallbackCid);
  }

  function normalizeActionEntry(entry, defaultType){
    if (!entry) return null;
    if (typeof entry === "string"){
      const name = String(entry || "").trim();
      if (!name) return null;
      return {name, description: "", type: defaultType};
    }
    if (typeof entry !== "object") return null;
    const name = normalizeTextValue(entry.name);
    if (!name) return null;
    const description = normalizeTextValue(entry.description || entry.desc) || "";
    const type = normalizeLowerValue(entry.type) || defaultType;
    const normalized = {name, description, type};
    if (entry.id != null) normalized.id = String(entry.id);
    if (entry.attack_overlay_mode != null) normalized.attack_overlay_mode = String(entry.attack_overlay_mode);
    if (entry.attack_count != null) normalized.attack_count = Number(entry.attack_count);
    if (entry.resolve_prompt != null) normalized.resolve_prompt = String(entry.resolve_prompt);
    if (entry.attack_weapon && typeof entry.attack_weapon === "object") normalized.attack_weapon = {...entry.attack_weapon};
    return normalized;
  }

  function normalizeActionList(entries, defaultType){
    const list = Array.isArray(entries) ? entries : [];
    return list
      .map((entry) => normalizeActionEntry(entry, defaultType))
      .filter(Boolean);
  }

  function isSpellActionEntry(entry){
    const name = normalizeLowerValue(entry?.name);
    return name === "magic" || name === "cast a spell" || name === "cast spell" || name === "spellcasting";
  }

  function getWildShapeAttackCount(unit){
    const actions = normalizeActionList(unit?.actions, "action");
    const multi = actions.find((entry) => normalizeLowerValue(entry?.name) === "multiattack");
    if (!multi) return 1;
    const explicit = Number(multi.attack_count);
    if (Number.isFinite(explicit) && explicit >= 2) return Math.max(2, Math.floor(explicit));
    const text = normalizeLowerValue(multi.description);
    if (!text) return 1;
    const words = {one: 1, two: 2, three: 3, four: 4, five: 5};
    let total = 0;
    Object.entries(words).forEach(([word, value]) => {
      const matches = text.match(new RegExp(`\\b${word}\\b[^.]*?\\battack\\b`, "g"));
      if (Array.isArray(matches)) total += matches.length * value;
    });
    const digitMatches = text.match(/\b(\d+)\b[^.]*?\battack\b/g);
    if (Array.isArray(digitMatches)){
      digitMatches.forEach((chunk) => {
        const match = chunk.match(/\b(\d+)\b/);
        const value = Number(match?.[1]);
        if (Number.isFinite(value) && value > 0) total += value;
      });
    }
    return total >= 2 ? Math.min(10, total) : 1;
  }

  function weaponFromWildShapeAction(entry, unit){
    if (!entry || typeof entry !== "object") return null;
    if (entry.attack_weapon && typeof entry.attack_weapon === "object"){
      return {
        ...entry.attack_weapon,
        id: String(entry.attack_weapon.id || entry.id || entry.name || "").trim(),
        name: String(entry.attack_weapon.name || entry.name || "Wild Shape Attack").trim(),
      };
    }
    const desc = String(entry.description || "").trim();
    if (!desc) return null;
    const lower = normalizeLowerValue(desc);
    if (!lower.includes("attack roll") || !lower.includes("hit")) return null;
    const toHitMatch = desc.match(/attack roll\s*:\s*([+\-]?\d+)/i);
    const rangeMatch = desc.match(/(?:reach|range)\s*(\d+)\s*ft/i);
    const damageMatch = desc.match(/hit\s*:\s*[^.]*?\(([^)]+)\)\s*([a-zA-Z]+)\s+damage/i);
    const name = String(entry.name || "Wild Shape Attack").trim() || "Wild Shape Attack";
    const idBase = String(entry.id || name).trim().toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "");
    const weapon = {
      id: idBase || "wild-shape-attack",
      name,
      category: lower.includes("ranged attack roll") ? "ranged_weapon" : "melee_weapon",
      range: rangeMatch ? `${Math.floor(Number(rangeMatch[1]) || 5)} ft` : (lower.includes("ranged attack roll") ? "60 ft" : "5 ft"),
    };
    if (toHitMatch){
      const toHit = Number(toHitMatch[1]);
      if (Number.isFinite(toHit)) weapon.to_hit = Math.floor(toHit);
    }
    if (damageMatch){
      weapon.one_handed = {
        damage_formula: String(damageMatch[1] || "").trim(),
        damage_type: String(damageMatch[2] || "").trim().toLowerCase(),
      };
    }
    const multiattackCount = getWildShapeAttackCount(unit);
    return {
      ...weapon,
      attack_count: multiattackCount,
      resolve_prompt: String(entry.resolve_prompt || `Attack target with ${name}.`).trim(),
    };
  }

  function populateActionSelect(selectEl, options, placeholder){
    if (!selectEl) return;
    const previousValue = selectEl.value;
    selectEl.textContent = "";
    const placeholderOption = document.createElement("option");
    placeholderOption.value = "";
    placeholderOption.textContent = placeholder;
    selectEl.appendChild(placeholderOption);
    const normalized = normalizeActionList(options, "action");
    normalized.forEach((item) => {
      const option = document.createElement("option");
      option.value = item.name;
      option.textContent = item.name;
      selectEl.appendChild(option);
    });
    if (previousValue && normalized.some((item) => item.name === previousValue)){
      selectEl.value = previousValue;
    } else {
      selectEl.value = "";
    }
  }

  function populateAttackWeaponSelect(){
    if (!attackWeaponSelectEl) return;
    const weapons = getClaimedWeapons();
    const defaultWeapon = getDefaultAttackWeapon(weapons);
    const defaultWeaponId = String(defaultWeapon?.id || defaultWeapon?.name || "").trim();
    attackWeaponSelectEl.textContent = "";
    const placeholderOption = document.createElement("option");
    placeholderOption.value = "";
    placeholderOption.textContent = "Auto (first configured)";
    attackWeaponSelectEl.appendChild(placeholderOption);
    weapons.forEach((weapon) => {
      const option = document.createElement("option");
      option.value = String(weapon.id || weapon.name || "").trim();
      const rangeFt = parseWeaponRangeFeet(weapon);
      option.textContent = `${String(weapon.name || weapon.id || "Weapon")} (${Math.round(rangeFt)} ft)`;
      attackWeaponSelectEl.appendChild(option);
    });
    if (selectedAttackWeaponId && weapons.some((weapon) => String(weapon.id || weapon.name || "").trim() === selectedAttackWeaponId)){
      attackWeaponSelectEl.value = selectedAttackWeaponId;
    } else if (defaultWeaponId){
      attackWeaponSelectEl.value = defaultWeaponId;
    } else {
      attackWeaponSelectEl.value = "";
    }
  }


  function isFriendlyToMe(unit, me){
    if (!unit) return false;
    if (unit.ally === true) return true;
    const role = normalizeTextValue(unit.role);
    if (role === "pc" || role === "ally") return true;
    if (me && unit.summoned_by_cid != null && Number(unit.summoned_by_cid) === Number(me.cid)) return true;
    return false;
  }

  function isMountableFor(unit, me){
    if (!unit) return false;
    if (unit.can_be_mounted || unit.is_mount) return true;
    if (me && unit.summoned_by_cid != null && Number(unit.summoned_by_cid) === Number(me.cid)) return true;
    return false;
  }

  function mountCandidatePair(){
    const me = getClaimedUnit();
    const units = state?.units || state?.combatants || [];
    if (!me || !Array.isArray(units)) return null;
    if (me.rider_cid || me.mounted_by_cid) return null;
    const sameTile = units.filter(u =>
      u &&
      Number(u?.pos?.col)===Number(me?.pos?.col) &&
      Number(u?.pos?.row)===Number(me?.pos?.row) &&
      Number(u?.cid)!==Number(me?.cid)
    );
    if (!sameTile.length) return null;
    const mount = sameTile
      .filter(u => !u.rider_cid && !u.mounted_by_cid)
      .sort((a, b) => {
        const aTrueMount = (a?.can_be_mounted || a?.is_mount) ? 0 : 1;
        const bTrueMount = (b?.can_be_mounted || b?.is_mount) ? 0 : 1;
        if (aTrueMount !== bTrueMount) return aTrueMount - bTrueMount;
        return Number(a?.cid ?? 0) - Number(b?.cid ?? 0);
      })[0];
    if (!mount) return null;
    return {rider: me, mount};
  }

  function updateMountControls(){
    const me = getClaimedUnit();
    const pair = mountCandidatePair();
    pendingMountPair = pair;
    if (mountBtn){
      mountBtn.classList.toggle("hidden", !pair);
      mountBtn.classList.toggle("glow", !!pair);
    }
    if (dismountBtn){
      dismountBtn.classList.toggle("hidden", !(me && me.rider_cid));
    }
  }


  function tokenPriorityScore(unit){
    if (!unit) return -1;
    const cid = normalizeCid(unit.cid, "token.priority.cid");
    if (cid === null) return -1;
    const activeCid = normalizeCid(state?.active_cid, "token.priority.active");
    const claimed = normalizeCid(claimedCid, "token.priority.claimed");
    const scoreBase = Number(cid) * -0.001;
    if (activeCid !== null && cidMatches(activeCid, cid, "token.priority.activeMatch")) return 4000 + scoreBase;
    if (claimed !== null && cidMatches(claimed, cid, "token.priority.claimedMatch")) return 3000 + scoreBase;
    return 1000 + scoreBase;
  }

  function sortedTokensForRender(tokens){
    const list = Array.isArray(tokens) ? tokens.slice() : [];
    list.sort((a, b) => tokenPriorityScore(a) - tokenPriorityScore(b));
    return list;
  }

  function updateHud(){
    if (!state){ return; }
    const active = state.active_cid;
    const round = state.round_num;
    turnEl.textContent = (active === null) ? "Turn: (not started)" : `Round ${round}`;
    const myTurn = claimedCid != null && active !== null && cidMatches(active, claimedCid, "hud.myTurn");
    if (resetTurnBtn){
      resetTurnBtn.disabled = !myTurn;
    }
    if (dismissSummonsBtn){
      dismissSummonsBtn.disabled = claimedCid == null;
    }
    const updatePlayerHpBar = (unit) => {
      if (!playerHpBarWrap || !playerHpBarFill || !playerHpBarLabel){
        return;
      }
      const hp = Number(unit?.hp ?? NaN);
      const maxHpRaw = Number(unit?.max_hp ?? NaN);
      const maxHp = Number.isFinite(maxHpRaw) && maxHpRaw > 0
        ? maxHpRaw
        : (Number.isFinite(hp) && hp > 0 ? hp : 0);
      if (!Number.isFinite(hp) || maxHp <= 0){
        playerHpBarWrap.classList.remove("show");
        return;
      }
      const pct = Math.max(0, Math.min(100, (hp / maxHp) * 100));
      playerHpBarWrap.classList.add("show");
      playerHpBarFill.style.width = `${pct}%`;
      playerHpBarFill.classList.toggle("mid", pct <= 50 && pct > 20);
      playerHpBarFill.classList.toggle("low", pct <= 20);
      playerHpBarLabel.textContent = `HP ${Math.round(hp)}/${Math.round(maxHp)}`;
    };
    let meForHud = null;
    if (claimedCid && state.units){
      const me = state.units.find(u => cidMatches(u.cid, claimedCid, "hud.claimedUnit"));
      if (me){
        meForHud = me;
        meEl.textContent = me.name;
        const modeLabel = movementModeLabel(me.movement_mode);
        moveEl.textContent = `Move: ${me.move_remaining}/${me.move_total} (${modeLabel})`;
        moveEl.setAttribute("title", "Click to cycle movement mode");
        actionEl.textContent = `Action: ${me.action_remaining ?? 0}`;
        if (attackResourceEl){
          attackResourceEl.textContent = `Attacks: ${me.attack_resource_remaining ?? 0}`;
        }
        bonusActionEl.textContent = `Bonus Action: ${me.bonus_action_remaining ?? 0}`;
        if (reactionEl){
          reactionEl.textContent = `Reaction: ${me.reaction_remaining ?? 0}`;
        }
        useActionBtn.disabled = Number(me.action_remaining || 0) <= 0;
        useBonusActionBtn.disabled = Number(me.bonus_action_remaining || 0) <= 0;
        if (useReactionBtn){
          useReactionBtn.disabled = Number(me.reaction_remaining || 0) <= 0;
        }
        populateActionSelect(actionSelectEl, me.actions, "None/Custom");
        populateActionSelect(bonusActionSelectEl, me.bonus_actions, "None/Custom");
        if (actionSelectEl){
          actionSelectEl.disabled = false;
        }
        if (bonusActionSelectEl){
          bonusActionSelectEl.disabled = false;
        }
        populateAttackWeaponSelect();
        if (attackWeaponSelectEl){
          attackWeaponSelectEl.disabled = false;
        }
        if (attackOverlayToggleBtn){
          attackOverlayToggleBtn.disabled = false;
        }
        if (standUpBtn){
          standUpBtn.disabled = !(myTurn && me.is_prone);
        }
        updatePlayerHpBar(me);
      } else {
        updatePlayerHpBar(null);
        moveEl.removeAttribute("title");
        actionEl.textContent = "Action: ";
        if (attackResourceEl){
          attackResourceEl.textContent = "Attacks: ";
        }
        bonusActionEl.textContent = "Bonus Action: ";
        if (reactionEl){
          reactionEl.textContent = "Reaction: ";
        }
        useActionBtn.disabled = true;
        useBonusActionBtn.disabled = true;
        if (useReactionBtn){
          useReactionBtn.disabled = true;
        }
        populateActionSelect(actionSelectEl, [], "None/Custom");
        populateActionSelect(bonusActionSelectEl, [], "None/Custom");
        if (actionSelectEl){
          actionSelectEl.disabled = true;
        }
        if (bonusActionSelectEl){
          bonusActionSelectEl.disabled = true;
        }
        populateAttackWeaponSelect();
        if (attackWeaponSelectEl){
          attackWeaponSelectEl.disabled = true;
        }
        if (attackOverlayToggleBtn){
          attackOverlayToggleBtn.disabled = false;
        }
        if (standUpBtn){
          standUpBtn.disabled = true;
        }
      }
    } else {
      updatePlayerHpBar(null);
      moveEl.removeAttribute("title");
      actionEl.textContent = "Action: ";
      if (attackResourceEl){
        attackResourceEl.textContent = "Attacks: ";
      }
      bonusActionEl.textContent = "Bonus Action: ";
      if (reactionEl){
        reactionEl.textContent = "Reaction: ";
      }
      useActionBtn.disabled = true;
      useBonusActionBtn.disabled = true;
      if (useReactionBtn){
        useReactionBtn.disabled = true;
      }
      populateActionSelect(actionSelectEl, [], "None/Custom");
      populateActionSelect(bonusActionSelectEl, [], "None/Custom");
      if (actionSelectEl){
        actionSelectEl.disabled = true;
      }
      if (bonusActionSelectEl){
        bonusActionSelectEl.disabled = true;
      }
      populateAttackWeaponSelect();
      if (attackWeaponSelectEl){
        attackWeaponSelectEl.disabled = true;
      }
      if (attackOverlayToggleBtn){
        attackOverlayToggleBtn.disabled = false;
      }
      if (standUpBtn){
        standUpBtn.disabled = true;
      }
    }
    renderSpellSlotMonitor();
    renderResourcePools();
    updateTurnOrder();
    updateSpellPanelVisibility();
    applyMapViewReadOnlyControls();
    updateEndTurnState();
    updateEndTurnReadyVisual(meForHud, myTurn);
    updateAurasButton();
    renderEffectsOverlay();
    updateClaimOverlay();
  }

  function showActionPicker(){
    if (!actionPickerModal) return;
    actionPickerModal.classList.add("show");
    actionPickerModal.setAttribute("aria-hidden", "false");
  }

  function hideActionPicker(){
    if (!actionPickerModal) return;
    actionPickerModal.classList.remove("show");
    actionPickerModal.setAttribute("aria-hidden", "true");
    if (actionPickerList){
      actionPickerList.textContent = "";
    }
  }

  function setWarCasterModalOpen(open){
    if (!warCasterModal) return;
    warCasterModal.classList.toggle("show", !!open);
    warCasterModal.setAttribute("aria-hidden", open ? "false" : "true");
  }

  function playerHasWarCasterFeat(){
    const profile = getPlayerProfile(getClaimedPlayerName());
    if (!profile || typeof profile !== "object"){
      return false;
    }
    const hasWarCasterName = (value) => normalizeLowerValue(value) === "war caster";
    const features = Array.isArray(profile.features) ? profile.features : [];
    for (const feature of features){
      if (typeof feature === "string" && hasWarCasterName(feature)){
        return true;
      }
      if (feature && typeof feature === "object"){
        if (hasWarCasterName(feature.name) || hasWarCasterName(feature.id)){
          return true;
        }
      }
    }
    return false;
  }

  function getPreparedReactionSpellEntries(){
    const preparedSet = getPreparedSpellFilterSet();
    if (!(preparedSet instanceof Set) || !preparedSet.size){
      return [];
    }
    return cachedSpellPresets
      .filter((preset) => {
        const slug = getPresetSlug(preset);
        return slug && preparedSet.has(getSpellKey(slug)) && getSpellActionType(preset) === "reaction";
      })
      .sort((a, b) => normalizeTextValue(a?.name).localeCompare(normalizeTextValue(b?.name)))
      .map((preset) => ({
        name: normalizeTextValue(preset.name),
        description: normalizeTextValue(preset.description),
        spend: "reaction",
        kind: "reaction_spell",
        spellSlug: getPresetSlug(preset),
      }))
      .filter((entry) => entry.name && entry.spellSlug);
  }

  function isWarCasterEligibleSpellPreset(preset){
    if (!preset || getSpellActionType(preset) !== "action"){
      return false;
    }
    if (isAoePreset(preset) || isSummonPreset(preset)){
      return false;
    }
    const baseSlotLevel = Number.isFinite(Number(preset?.level)) ? Math.max(0, Math.floor(Number(preset.level))) : 0;
    const targeting = getSpellTargetingConfig(preset, baseSlotLevel);
    return Boolean(targeting && Number(targeting.projectileCount || 1) === 1);
  }

  function getWarCasterEligibleSpellPresets(){
    const preparedSet = getPreparedSpellFilterSet();
    if (!(preparedSet instanceof Set) || !preparedSet.size){
      return [];
    }
    return cachedSpellPresets
      .filter((preset) => {
        const slug = getPresetSlug(preset);
        return slug && preparedSet.has(getSpellKey(slug)) && isWarCasterEligibleSpellPreset(preset);
      })
      .sort((a, b) => normalizeTextValue(a?.name).localeCompare(normalizeTextValue(b?.name)));
  }

  function getWarCasterTargets(){
    const me = getClaimedUnit();
    const units = Array.isArray(state?.units) ? state.units : [];
    return units.filter((entry) => {
      if (!entry || !me || cidMatches(entry.cid, me.cid, "warCaster.self")){
        return false;
      }
      return !isFriendlyToMe(entry, me);
    });
  }

  function populateWarCasterModal(){
    if (!warCasterSpellSelect || !warCasterTargetSelect){
      return {spells: [], targets: []};
    }
    const spells = getWarCasterEligibleSpellPresets();
    const targets = getWarCasterTargets();
    warCasterSpellSelect.textContent = "";
    spells.forEach((preset) => {
      const opt = document.createElement("option");
      opt.value = getPresetSlug(preset);
      opt.textContent = normalizeTextValue(preset.name);
      warCasterSpellSelect.appendChild(opt);
    });
    warCasterTargetSelect.textContent = "";
    targets.forEach((target) => {
      const opt = document.createElement("option");
      opt.value = String(target.cid);
      opt.textContent = `${target.name || `#${target.cid}`} (CID ${target.cid})`;
      warCasterTargetSelect.appendChild(opt);
    });
    const activeEnemy = targets.find((entry) => cidMatches(entry.cid, state?.active_cid, "warCaster.defaultTarget"));
    if (activeEnemy){
      warCasterTargetSelect.value = String(activeEnemy.cid);
    }
    return {spells, targets};
  }

  function runSpellTargetingAgainstTarget(target){
    if (!target || !pendingSpellTargeting){
      return;
    }
    const me = getClaimedUnit();
    const isFriendlyTarget = !!me && (cidMatches(target.cid, me.cid, "spellTargeting.self") || isFriendlyToMe(target, me));
    const targetSide = normalizeLowerValue(pendingSpellTargeting.targetSide || "enemy");
    if (targetSide === "friendly" && !isFriendlyTarget){
      localToast("Pick a friendly target, matey.");
      return;
    }
    if (targetSide !== "friendly" && isFriendlyTarget){
      localToast("Pick an enemy target, matey.");
      return;
    }
    if (pendingSpellTargeting.mode === "save"){
      send({
        type: "spell_target_request",
        cid: activeControlledUnitCid(),
        target_cid: Number(target.cid),
        spell_name: pendingSpellTargeting.spellName,
        spell_slug: pendingSpellTargeting.spellSlug || null,
        spell_id: pendingSpellTargeting.spellId || null,
        spell_mode: "save",
        save_type: pendingSpellTargeting.saveType || null,
        save_dc: Number.isFinite(Number(pendingSpellTargeting.saveDc)) ? Number(pendingSpellTargeting.saveDc) : null,
        roll_save: true,
      });
      return;
    }
    const autoHit = pendingSpellTargeting.mode === "auto_hit";
    if (autoHit && pendingSpellTargeting.skipResolveAttack){
      const actionCid = activeControlledUnitCid();
      if (actionCid === null){
        localToast("Not yer turn yet, matey.");
        return;
      }
      send({
        type: "spell_target_request",
        cid: actionCid,
        target_cid: Number(target.cid),
        spell_name: pendingSpellTargeting.spellName,
        spell_slug: pendingSpellTargeting.spellSlug || null,
        spell_id: pendingSpellTargeting.spellId || null,
        spell_mode: pendingSpellTargeting.mode,
        save_type: pendingSpellTargeting.saveType || null,
        save_dc: Number.isFinite(Number(pendingSpellTargeting.saveDc)) ? Number(pendingSpellTargeting.saveDc) : null,
        roll_save: false,
        hit: true,
        critical: false,
        damage_entries: [],
      });
      consumeSpellTargetingShot();
      return;
    }
    pendingAttackResolve = {
      mode: "spell",
      targetCid: Number(target.cid),
      targetName: String(target.name || "target"),
      spellName: pendingSpellTargeting.spellName,
      spellSlug: pendingSpellTargeting.spellSlug || null,
      spellId: pendingSpellTargeting.spellId || null,
      spellMode: pendingSpellTargeting.mode,
      saveType: pendingSpellTargeting.saveType || "",
      saveDc: pendingSpellTargeting.saveDc,
      forceHit: autoHit,
      rollSave: false,
    };
    if (attackResolveBody){
      const details = [
        pendingSpellTargeting.damageDice ? `Damage: ${pendingSpellTargeting.damageDice}${pendingSpellTargeting.damageType ? ` ${pendingSpellTargeting.damageType}` : ""}.` : "",
        pendingSpellTargeting.description ? pendingSpellTargeting.description : "",
      ].filter(Boolean).join(" ");
      attackResolveBody.textContent = `Resolve ${pendingSpellTargeting.spellName} on ${pendingAttackResolve.targetName}.`
        + (details ? ` ${details}` : "");
    }
    if (attackDamageRows){
      attackDamageRows.textContent = "";
      addAttackDamageRow("", pendingSpellTargeting.damageType || "");
    }
    if (attackResolveHit) attackResolveHit.checked = autoHit;
    if (attackResolveMiss) attackResolveMiss.checked = !autoHit;
    if (attackResolveHit) attackResolveHit.disabled = autoHit;
    if (attackResolveMiss) attackResolveMiss.disabled = autoHit;
    syncAttackResolveDamageVisibility();
    setAttackResolveModalOpen(true);
  }

  function openWarCasterModal(){
    if (!playerHasWarCasterFeat()){
      localToast("War Caster feat not found on your sheet.");
      return;
    }
    const {spells, targets} = populateWarCasterModal();
    if (!spells.length){
      localToast("No War Caster eligible prepared spells.");
      return;
    }
    if (!targets.length){
      localToast("No enemy targets available.");
      return;
    }
    setWarCasterModalOpen(true);
  }

  function buildActionPickerItem(entry){
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "action-picker-item";
    const nameEl = document.createElement("div");
    nameEl.className = "action-picker-name";
    const spendLabel = entry.spend === "bonus" ? "Bonus Action" : (entry.spend === "reaction" ? "Reaction" : "Action");
    nameEl.textContent = `${entry.name} (${spendLabel})`;
    btn.appendChild(nameEl);
    if (entry.description){
      const descEl = document.createElement("div");
      descEl.className = "action-picker-meta";
      descEl.textContent = entry.description;
      btn.appendChild(descEl);
    }
    btn.addEventListener("click", () => {
      hideActionPicker();
      const actionName = normalizeLowerValue(entry?.name);
      const actionCid = activeControlledUnitCid();
      const activeUnit = actionCid === null ? null : getUnitByCid(actionCid);
      const claimedUnit = getClaimedUnit();
      const claimedName = normalizeLowerValue(claimedUnit?.name);
      const isJohnTwilight = claimedName === "john twilight" || claimedName.startsWith("john twilight (");
      const isManifestEcho = actionName === "summon johns echo" || actionName === "manifest echo";
      const isSwapEcho = actionName === "swap with johns echo" || actionName === "swap with echo";
      if (isJohnTwilight && isManifestEcho){
        if (claimedCid == null || !claimedUnit || !claimedUnit.pos){
          localToast("Could not find caster position, matey.");
          return;
        }
        pendingSummonPlacement = {
          mode: "echo_summon",
          actionType: "bonus_action",
          summonQuantity: 1,
          positions: [],
          casterPos: {col: Number(claimedUnit.pos.col), row: Number(claimedUnit.pos.row)},
          maxRangeFt: 15,
        };
        rebuildSummonValidCells();
        updateSummonPlacementBanner();
        localToast("Echo placement started. Choose a valid highlighted square.");
        return;
      }
      if (isJohnTwilight && isSwapEcho){
        if (claimedCid == null) return;
        const msg = {type: "echo_swap", cid: claimedCid};
        if (isPlanning){
          planningMutate(msg);
          draw();
          updateHud();
        }
        send(msg);
        return;
      }
      if (entry.kind === "war_caster"){
        openWarCasterModal();
        return;
      }
      if (entry.spend === "reaction" && actionName === "opportunity attack"){
        const unit = getClaimedUnit();
        if (Number(unit?.reaction_remaining || 0) <= 0){
          localToast("No reactions left, matey.");
          return;
        }
        const meleeWeapon = getPrimaryMeleeAttackWeapon();
        if (!meleeWeapon){
          localToast("No melee weapon configured for opportunity attacks.");
          return;
        }
        const meleeWeaponId = String(meleeWeapon.id || "").trim();
        if (meleeWeaponId){
          selectedAttackWeaponId = meleeWeaponId;
          if (attackWeaponSelectEl){
            attackWeaponSelectEl.value = meleeWeaponId;
          }
        }
        pendingOpportunityAttack = true;
        setAttackOverlayMode(true);
        localToast(`Opportunity attack ready with ${String(meleeWeapon.name || "weapon")}. Pick an enemy target.`);
        return;
      }
      if (entry.kind === "reaction_spell"){
        const preset = spellPresetBySlug.get(getSpellKey(entry.spellSlug))
          || cachedSpellPresets.find((candidate) => getSpellKey(getPresetSlug(candidate)) === getSpellKey(entry.spellSlug));
        if (!preset){
          localToast("Could not find that spell preset, matey.");
          return;
        }
        if (castPresetInput){
          castPresetInput.value = normalizeTextValue(preset.name);
        }
        applySpellPreset(preset);
        pendingSpellActionType = "reaction";
        setCastOverlayOpen(true);
        return;
      }
      if (isSpellActionEntry(entry)){
        pendingSpellActionType = entry.spend === "bonus" ? "bonus_action" : (entry.spend === "reaction" ? "reaction" : "action");
        setCastOverlayOpen(true);
        return;
      }
      if (entry.spend === "action" && claimedUnit?.is_wild_shaped){
        const wildShapeWeapon = weaponFromWildShapeAction(entry, claimedUnit);
        if (wildShapeWeapon){
          pendingActionAttackWeapon = {
            ...wildShapeWeapon,
            attack_count: Number.isFinite(Number(entry.attack_count)) ? Math.max(1, Math.floor(Number(entry.attack_count))) : Number(wildShapeWeapon.attack_count || 1),
            resolve_prompt: String(entry.resolve_prompt || wildShapeWeapon.resolve_prompt || "").trim(),
          };
          setAttackOverlayMode(true);
          localToast(pendingActionAttackWeapon.resolve_prompt || `Pick a target for ${String(wildShapeWeapon.name || "attack")}.`);
          return;
        }
      }
      if (actionName === "wild shape"){
        if (!isClaimedUnitDruid()){
          localToast("Only Druids level 2+ can use Wild Shape.");
          return;
        }
        setWildShapePickOverlayOpen(true);
        return;
      }
      if (actionName === "end wildshape early"){
        if (claimedCid == null){
          localToast("Claim a character first, matey.");
          return;
        }
        send({type:"wild_shape_revert", cid: claimedCid});
        return;
      }
      if (actionCid === null || !activeUnit) return;
      const msg = {
        type: "perform_action",
        cid: actionCid,
        spend: entry.spend,
        action: entry.name,
      };
      if (isPlanning){
        planningMutate(msg);
        draw();
        updateHud();
      }
      send(msg);
    });
    return btn;
  }

  function openActionPicker(mode){
    const unitCid = activeControlledUnitCid();
    const unit = unitCid === null ? null : getUnitByCid(unitCid);
    if (!unit || unitCid === null){
      localToast("Claim a character first, matey.");
      return;
    }
    if (!actionPickerList || !actionPickerTitle){
      return;
    }
    const actions = normalizeActionList(unit.actions, "action");
    const bonusActions = normalizeActionList(unit.bonus_actions, "bonus_action");
    const reactions = normalizeActionList(unit.reactions, "reaction");
    const items = [];
    if (mode === "action"){
      actionPickerTitle.textContent = "Choose an Action";
      actions.forEach((entry) => items.push({...entry, spend: "action"}));
    } else if (mode === "bonus"){
      actionPickerTitle.textContent = "Choose a Bonus Action";
      bonusActions.forEach((entry) => items.push({...entry, spend: "bonus"}));
    } else if (mode === "reaction"){
      actionPickerTitle.textContent = "Choose a Reaction";
      reactions.forEach((entry) => items.push({...entry, spend: "reaction"}));
      getPreparedReactionSpellEntries().forEach((entry) => items.push(entry));
      if (playerHasWarCasterFeat()){
        items.push({
          name: "War Caster Spell",
          description: "Cast a qualifying action spell as a reaction against a single enemy target.",
          spend: "reaction",
          kind: "war_caster",
        });
      }
    } else {
      actionPickerTitle.textContent = "Choose Dash";
      const dashEntries = (list, spend) => {
        list.forEach((entry) => {
          if (normalizeLowerValue(entry.name) === "dash"){
            items.push({...entry, spend});
          }
        });
      };
      dashEntries(actions, "action");
      dashEntries(bonusActions, "bonus");
    }
    actionPickerList.textContent = "";
    if (!items.length){
      const empty = document.createElement("div");
      empty.className = "action-picker-meta";
      empty.textContent = "No available actions.";
      actionPickerList.appendChild(empty);
    } else {
      items.forEach((entry) => {
        actionPickerList.appendChild(buildActionPickerItem(entry));
      });
    }
    showActionPicker();
  }

  function hideTurnModal(){
    if (!turnModal) return;
    turnModal.classList.remove("show");
    turnModal.setAttribute("aria-hidden", "true");
  }

  function playTurnAlert(){
    turnAlertAudio.currentTime = 0;
    turnAlertAudio.play().catch((err) => {
      console.warn("Turn alert audio failed to play.", err);
    });
  }

  function playKoAlert(){
    koAlertAudio.currentTime = 0;
    koAlertAudio.play().catch((err) => {
      console.warn("KO audio failed to play.", err);
    });
  }

  function fireVibrate(){
    if (!lastVibrateSupported) return false;
    const didVibrate = vibrate([200, 120, 200]);
    if (!didVibrate){
      lastVibrateSupported = false;
      console.debug("Vibration blocked or unsupported.");
    }
    return didVibrate;
  }

  async function unlockTurnAudio(){
    userHasInteracted = true;
    try {
      turnAlertAudio.muted = true;
      turnAlertAudio.currentTime = 0;
      await turnAlertAudio.play();
      turnAlertAudio.pause();
      turnAlertAudio.currentTime = 0;
      turnAlertAudio.muted = false;
      audioUnlocked = true;
      localToast('Turn sounds enabled.');
    } catch (err){
      turnAlertAudio.muted = false;
      console.warn('Turn alert audio unlock failed.', err);
    }
    if (pendingTurnAlert){
      pendingTurnAlert = false;
      playTurnAlert();
    }
    if (pendingVibrate){
      fireVibrate();
      pendingVibrate = false;
    }
  }

  function handleUserGesture(){
    userHasInteracted = true;
    if (!notificationPermissionAsked){
      maybeRequestNotificationPermission();
    }
    if (!audioUnlocked){
      unlockTurnAudio();
      return;
    }
    if (pendingTurnAlert){
      pendingTurnAlert = false;
      playTurnAlert();
    }
    if (pendingVibrate){
      fireVibrate();
      pendingVibrate = false;
    }
  }

  function maybeNotifyTurnStart(){
    if (!("Notification" in window)) return;
    if (Notification.permission !== "granted") return;
    try {
      const title = "It's your turn!";
      const body = 'Act now in Initiative Tracker.';
      const notification = new Notification(title, {body, tag: 'turn-alert', renotify: true});
      notification.onclick = () => {
        window.focus();
        notification.close();
      };
    } catch (err){
      console.warn('Turn notification failed.', err);
    }
  }

  async function maybeRequestNotificationPermission(){
    if (notificationPermissionAsked) return;
    notificationPermissionAsked = true;
    localStorage.setItem(notificationPermissionAskedKey, "1");
    if (!("Notification" in window)) return;
    if (Notification.permission !== "default") return;
    try {
      await Notification.requestPermission();
    } catch (err){
      console.warn("Notification permission prompt failed.", err);
    }
  }

  function showTurnModal(){
    if (!turnModal) return;
    if (focusTabOnTurn){
      try { window.focus(); } catch (err){ console.debug('window.focus blocked.', err); }
    }
    maybeNotifyTurnStart();
    if (document.visibilityState === "hidden") return;
    turnModal.classList.add("show");
    turnModal.setAttribute("aria-hidden", "false");
    if (audioUnlocked){
      playTurnAlert();
    } else {
      pendingTurnAlert = true;
    }
    if (userHasInteracted || navigator.userActivation?.hasBeenActive){
      fireVibrate();
    } else {
      pendingVibrate = true;
    }
  }

  function maybeShowTurnAlert(){
    if (!state || !claimedCid) return;
    const activeCid = state.active_cid;
    const roundRaw = state.round_num;
    const round = Number.isFinite(Number(roundRaw)) ? Number(roundRaw) : roundRaw;
    const activeCidValue = normalizeCid(activeCid, "turnAlert.activeCid");
    const lastActiveCidValue = normalizeCid(lastActiveCid, "turnAlert.lastActiveCid");
    const lastRound = Number.isFinite(Number(lastTurnRound)) ? Number(lastTurnRound) : lastTurnRound;
    const isNowMyTurn = activeCidValue !== null && activeCidValue === claimedCid;
    const activeChanged = activeCidValue !== lastActiveCidValue;
    const roundChanged = round !== lastRound;
    if (!turnAlertPrimed){
      lastActiveCid = activeCid;
      lastTurnRound = round;
      turnAlertPrimed = true;
      return;
    }
    if (isNowMyTurn && (activeChanged || roundChanged)){
      showTurnModal();
    }
    lastActiveCid = activeCid;
    lastTurnRound = round;
  }

  const planningFreezeTypes = new Set([
    "state",
    "unit_update",
    "units_snapshot",
    "terrain_update",
    "terrain_patch",
    "grid_update",
    "aoe_patch",
  ]);

  function connect(){
    if (!wsUrl){
      setConn(false, "Disconnected");
      scheduleReconnect(1000);
      return;
    }
    try {
      ws = new WebSocket(wsUrl);
    } catch (err){
      console.warn("WebSocket connect failed.", err);
      setConn(false, "Disconnected");
      scheduleReconnect(1000);
      return;
    }
    ws.addEventListener("open", () => {
      reconnecting = false;
      setConn(true, "Connected");
      if (!isMapView){
        send({type:"client_hello", client_id: clientId});
      }
      send({type:"grid_request"});
      send({type:"terrain_request"});
      refreshMapViewLogPolling();
    });
    ws.addEventListener("close", (ev) => {
      const wasReconnect = reconnecting;
      reconnecting = false;
      const serverError = ev && ev.code === 1011;
      if (serverError){
        setConn(false, "Server error while preparing state.");
        scheduleReconnect(1000);
      } else if (wasReconnect){
        setConn(false, "Reconnecting");
        scheduleReconnect(200);
      } else {
        setConn(false, "Disconnected");
        scheduleReconnect(1000);
      }
    });
    ws.addEventListener("message", (ev) => {
      let msg = null;
      try { msg = JSON.parse(ev.data); } catch(e){ return; }
      if (isPlanning && planningSnapshotLocked && planningFreezeTypes.has(msg.type)){
        return;
      }
      if (msg.type === "static_data"){
        // Merge static data into state (sent once on connection)
        if (!state){ state = {}; }
        if (Object.prototype.hasOwnProperty.call(msg || {}, "pcs") || Object.prototype.hasOwnProperty.call(msg || {}, "claimable")){
          lastPcList = msg.pcs || msg.claimable || [];
        }
        markClaimMessageSeen("static_data");
        logClaimMessage("static_data", lastPcList);
        if (msg.data && typeof msg.data === "object"){
          if (Array.isArray(msg.data.spell_presets)){
            state.spell_presets = msg.data.spell_presets;
            requestAnimationFrame(() => {
              updateSpellPresetOptions(state?.spell_presets || []);
            });
          }
          if (msg.data.player_spells && typeof msg.data.player_spells === "object"){
            state.player_spells = msg.data.player_spells;
          }
          if (msg.data.player_profiles && typeof msg.data.player_profiles === "object"){
            state.player_profiles = msg.data.player_profiles;
          }
          if (msg.data.resource_pools && typeof msg.data.resource_pools === "object"){
            state.resource_pools = msg.data.resource_pools;
          }
          if (Array.isArray(msg.data.monster_choices)){
            state.monster_choices = msg.data.monster_choices;
          }
          }
        updateClaimOverlay();
      } else if (msg.type === "preset"){
        if (msg.preset && typeof msg.preset === "object"){
          applyGuiPreset(msg.preset, {persist: true});
          persistLocalPreset(msg.preset);
        } else {
          setPresetStatus("No preset saved.", 2500);
        }
      } else if (msg.type === "preset_saved"){
        setPresetStatus("Saved!");
      } else if (msg.type === "preset_error"){
        setPresetStatus(msg.error || "Preset error.", 2500);
      } else if (msg.type === "state"){
        stateUpdateCounter += 1;
        const oldSpellPresets = state?.spell_presets;
        const oldPlayerSpells = state?.player_spells;
        const oldPlayerProfiles = state?.player_profiles;
        const oldMonsterChoices = state?.monster_choices;
        const oldResourcePools = state?.resource_pools;
        const oldGrid = state?.grid;
        const oldTerrain = state?.rough_terrain;
        const oldObstacles = state?.obstacles;
        state = (msg.state && typeof msg.state === "object") ? msg.state : {};
        // Preserve static data from previous state if not in new message
        // Only preserve if old values exist and new values are undefined (not just missing)
        if (!state.spell_presets && Array.isArray(oldSpellPresets)){
          state.spell_presets = oldSpellPresets;
        }
        if (!state.player_spells && oldPlayerSpells && typeof oldPlayerSpells === "object"){
          state.player_spells = oldPlayerSpells;
        }
        if (!state.player_profiles && oldPlayerProfiles && typeof oldPlayerProfiles === "object"){
          state.player_profiles = oldPlayerProfiles;
        }
        if (!state.monster_choices && Array.isArray(oldMonsterChoices)){
          state.monster_choices = oldMonsterChoices;
        }
        if (!state.resource_pools && oldResourcePools && typeof oldResourcePools === "object"){
          state.resource_pools = oldResourcePools;
        }
        if (!state.grid && oldGrid){
          state.grid = oldGrid;
        }
        if (!state.rough_terrain && Array.isArray(oldTerrain)){
          state.rough_terrain = oldTerrain;
        }
        if (!state.obstacles && Array.isArray(oldObstacles)){
          state.obstacles = oldObstacles;
        }
        if (isMapView){
          claimedCid = null;
          claimStatus = "unclaimed";
        }
        if (!Array.isArray(state.spell_presets)){
          state.spell_presets = [];
        }
        requestAnimationFrame(() => {
          updateSpellPresetOptions(state.spell_presets);
        });
        if (Object.prototype.hasOwnProperty.call(msg || {}, "pcs") || Object.prototype.hasOwnProperty.call(msg || {}, "claimable")){
          lastPcList = msg.pcs || msg.claimable || [];
        }
        markClaimMessageSeen("state");
        logClaimMessage("state", lastPcList);
        maybeAutoClaimFromState(msg, lastPcList);
        updateWaitingOverlay();
        draw();
        updateHud();
        updateMountControls();
        queueMicrotask(updateMountControls);
        maybeShowTurnAlert();
        autoCenterOnJoin();
        
        // Use server-authoritative claim state from "you" field
        if (msg.you && "claimed_cid" in msg.you){
          applyServerClaim(msg.you.claimed_cid, msg.you.claimed_name, msg.you.claim_rev);
        } else {
          // Fallback to old logic if "you" field not present (backwards compatibility)
          const claimsMap = (state && typeof state.claims === "object" && state.claims) ? state.claims : {};
          const serverClaimedCid = Object.entries(claimsMap).reduce((found, entry) => {
            if (found !== null && found !== undefined) return found;
            const [cidKey, ownerClientId] = entry;
            if (String(ownerClientId || "") !== clientId) return null;  // Not mine, continue searching
            return normalizeCid(cidKey, "state.claimsCid");
          }, null);
          if (serverClaimedCid !== null && serverClaimedCid !== undefined){
            claimedCid = serverClaimedCid;
            claimStatus = "claimed";
            clearClaimInFlight();
            const claimedName = getClaimablePcName(claimedCid, lastPcList || []) || `#${claimedCid}`;
            if (meEl){
              meEl.textContent = claimedName;
            }
          } else if (!claimInFlight){
            claimedCid = null;
            claimStatus = "unclaimed";
            if (meEl){
              meEl.textContent = "(unclaimed)";
            }
          }
        }
        
        if (!claimedCid){
          showNoOwnedPcToast(msg.pcs || msg.claimable || []);
        }
        refreshTurnAlertStatus();
        if (isPlanning){
          planningSnapshotLocked = true;
        }
        handleAutoClaimStateUpdate();
      } else if (msg.type === "turn_update"){
        if (!state){ state = {}; }
        if ("active_cid" in msg){
          state.active_cid = msg.active_cid;
        }
        if ("round_num" in msg){
          state.round_num = msg.round_num;
        }
        if ("turn_order" in msg){
          state.turn_order = msg.turn_order;
        }
        updateHud();
        maybeShowTurnAlert();
        draw();
        updateMountControls();
        queueMicrotask(updateMountControls);
      } else if (msg.type === "units_snapshot"){
        if (!state){ state = {}; }
        state.units = Array.isArray(msg.units) ? msg.units : [];
        updateHud();
        draw();
        updateMountControls();
        queueMicrotask(updateMountControls);
      } else if (msg.type === "unit_update"){
        const updates = Array.isArray(msg.updates) ? msg.updates : [];
        if (updates.length){
          applyUnitUpdates(updates);
          updateHud();
          draw();
          updateMountControls();
          queueMicrotask(updateMountControls);
        }
      } else if (msg.type === "force_claim"){
        if (isMapView) return;
        const applied = applyServerClaim(
          msg.you && Object.prototype.hasOwnProperty.call(msg.you, "claimed_cid") ? msg.you.claimed_cid : msg.cid,
          msg.you?.claimed_name,
          msg.you?.claim_rev ?? msg.claim_rev,
        );
        if (applied && claimedCid !== null && claimedCid !== undefined){
          autoCenterOnJoin();
          if (spellbookOverlay?.classList.contains("show")){
            syncSpellbookClaimedPlayer();
            renderSpellbook();
          }
        }
        updateHud();
        localToast(msg.text || "Assigned by the DM.");
        refreshTurnAlertStatus();
        checkAutoClaimResolved();
      } else if (msg.type === "force_unclaim"){
        if (isMapView) return;
        applyServerClaim(null, null, msg.claim_rev);
        shownNoOwnedToast = false;
        showNoOwnedPcToast(msg.pcs || lastPcList || []);
        if (spellbookOverlay?.classList.contains("show")){
          renderSpellbook();
        }
        refreshTurnAlertStatus();
        updateHud();
        handleAutoClaimFailure();
      } else if (msg.type === "claim_ack"){
        if (isMapView) return;
        if (msg.ok === false){
          claimStatus = "unclaimed";
          clearClaimInFlight();
        }
        if (msg.you && Object.prototype.hasOwnProperty.call(msg.you, "claimed_cid")){
          applyServerClaim(msg.you.claimed_cid, msg.you.claimed_name, msg.you.claim_rev ?? msg.claim_rev);
        } else {
          applyServerClaim(msg.claimed_cid, null, msg.claim_rev);
        }
        if (claimedCid !== null && claimedCid !== undefined){
          autoCenterOnJoin();
        }
        refreshTurnAlertStatus();
        updateHud();
      } else if (msg.type === "unclaim_ack"){
        if (isMapView) return;
        applyServerClaim(null, null, msg.claim_rev);
        refreshTurnAlertStatus();
        updateHud();
      } else if (msg.type === "toast"){
        localToast(msg.text || "");
      } else if (msg.type === "mount_prompt"){
        pendingMountRequestId = msg.request_id || null;
        if (mountPromptBody){
          mountPromptBody.textContent = `${msg.rider_name || "Someone"} wants to mount you. OK?`;
        }
        if (mountPromptModal){
          mountPromptModal.classList.add("show");
          mountPromptModal.setAttribute("aria-hidden", "false");
        }
      } else if (msg.type === "initiative_prompt"){
        const targetCid = Number(msg.cid);
        pendingInitiativeCid = Number.isFinite(targetCid) ? targetCid : claimedCid;
        if (initiativePromptBody){
          const who = typeof msg.name === "string" && msg.name.trim() ? msg.name.trim() : "your character";
          initiativePromptBody.textContent = `Roll initiative for ${who} and enter your total.`;
        }
        if (initiativePromptInput){
          initiativePromptInput.value = "";
        }
        if (initiativePromptModal){
          initiativePromptModal.classList.add("show");
          initiativePromptModal.setAttribute("aria-hidden", "false");
        }
      } else if (msg.type === "battle_log"){
        const lines = Array.isArray(msg.lines) ? msg.lines : [];
        renderBattleLogOverlay(lines);
        dmLogLines = lines;
        const units = state?.units || [];
        const now = Date.now();
        lines.slice(-4).forEach((line)=>{ const text=String(line||""); const unit=units.find(u=>text.includes(u.name)); if (unit){ dmHighlightUntil.set(String(unit.cid), now+2200); }});
        renderDmLogPanel();
      } else if (msg.type === "attack_result"){
        const me = getClaimedUnit();
        if (me && cidMatches(msg.attacker_cid, me.cid, "attackResult.attacker")){
          if (Number.isFinite(Number(msg.action_remaining))){
            me.action_remaining = Number(msg.action_remaining);
          }
          if (Number.isFinite(Number(msg.attack_resource_remaining))){
            me.attack_resource_remaining = Number(msg.attack_resource_remaining);
          }
          updateHud();
          draw();
        }
        if (Array.isArray(msg.weapon_property_notes) && msg.weapon_property_notes.length){
          localToast(msg.weapon_property_notes.join(" "));
        }
        if (Array.isArray(msg.cleave_candidates) && msg.cleave_candidates.length){
          openCleavePrompt(msg);
        }
      } else if (msg.type === "spell_target_result"){
        if (msg.needs_damage_prompt){
          const target = getUnitByCid(msg.target_cid);
          if (pendingSpellTargeting && target){
            const wounded = Number(target.hp || 0) < Number(target.max_hp || target.hp || 0);
            const damageDice = wounded && pendingSpellTargeting.damageDiceWhenWounded
              ? pendingSpellTargeting.damageDiceWhenWounded
              : pendingSpellTargeting.damageDice;
            pendingAttackResolve = {
              mode: "spell",
              targetCid: Number(msg.target_cid),
              targetName: String(msg.target_name || target.name || "target"),
              spellName: pendingSpellTargeting.spellName,
              spellSlug: pendingSpellTargeting.spellSlug || null,
              spellId: pendingSpellTargeting.spellId || null,
              spellMode: "save",
              saveType: pendingSpellTargeting.saveType || "",
              saveDc: pendingSpellTargeting.saveDc,
              forceHit: true,
              rollSave: false,
            };
            if (attackResolveBody){
              const details = [
                damageDice ? `Damage: ${damageDice}${pendingSpellTargeting.damageType ? ` ${pendingSpellTargeting.damageType}` : ""}.` : "",
                pendingSpellTargeting.description ? pendingSpellTargeting.description : "",
              ].filter(Boolean).join(" ");
              attackResolveBody.textContent = `Target failed save. Resolve ${pendingSpellTargeting.spellName} on ${pendingAttackResolve.targetName}.`
                + (details ? ` ${details}` : "");
            }
            if (attackDamageRows){
              attackDamageRows.textContent = "";
              addAttackDamageRow("", pendingSpellTargeting.damageType || "");
            }
            if (attackResolveHit) attackResolveHit.checked = true;
            if (attackResolveMiss) attackResolveMiss.checked = false;
            if (attackResolveHit) attackResolveHit.disabled = true;
            if (attackResolveMiss) attackResolveMiss.disabled = true;
            if (attackResolveCrit) attackResolveCrit.checked = false;
            syncAttackResolveDamageVisibility();
            setAttackResolveModalOpen(true);
          }
        } else if (msg.save_result && msg.save_result.passed && pendingSpellTargeting){
          pendingSpellTargeting.remainingShots = Math.max(0, Number(pendingSpellTargeting.remainingShots || 0) - 1);
          if (pendingSpellTargeting.remainingShots <= 0){
            clearSpellTargetingSession("");
          } else {
            localToast(`${pendingSpellTargeting.remainingShots} target${pendingSpellTargeting.remainingShots === 1 ? "" : "s"} remaining.`);
          }
        }
      } else if (msg.type === "grid_update"){
        if (!state){ state = {}; }
        if ("grid" in msg){
          state.grid = msg.grid;
        }
        if (gridReady()){
          const cols = state.grid.cols;
          const rows = state.grid.rows;
          const gridChanged = cols !== lastGrid.cols || rows !== lastGrid.rows;
          if (gridChanged){
            fittedToGrid = false;
            lastGrid = {cols, rows};
          }
        }
        updateWaitingOverlay();
        lastGridVersion = msg.version ?? lastGridVersion;
        send({type:"grid_ack", version: msg.version});
        draw();
      } else if (msg.type === "terrain_update"){
        applyTerrainPayload(msg.terrain);
        updateWaitingOverlay();
        send({type:"terrain_ack", version: msg.version});
        draw();
      } else if (msg.type === "terrain_patch"){
        applyTerrainPatch(msg);
        updateWaitingOverlay();
        draw();
      } else if (msg.type === "aoe_patch"){
        applyAoePatch(msg);
        draw();
      } else if (msg.type === "aoe_move_ack"){
        console.log("[AOE move ack]", msg);
        if (msg.ok === false){
          const reasonCode = typeof msg.reason_code === "string" ? msg.reason_code : "";
          const reason = reasonCode ? reasonCode.replace(/_/g, " ").toLowerCase() : "";
          const reasonText = reason ? reason[0].toUpperCase() + reason.slice(1) : "";
          localToast(reasonText ? `AOE move rejected (${reasonText}).` : "AOE move rejected.");
        }
      } else if (msg.type === "play_audio"){
        if (!msg.audio) return;
        if (msg.audio !== "ko") return;
        if (!audioUnlocked) return;
        if (msg.cid !== undefined && msg.cid !== null){
          if (!claimedCid || !cidMatches(msg.cid, claimedCid, "playAudio.cid")) return;
        }
        playKoAlert();
      }
    });
  }

  // input
  function pointerPos(ev){
    const r = canvas.getBoundingClientRect();
    return {x: ev.clientX - r.left, y: ev.clientY - r.top};
  }

  function normalizeFacingDeg(value){
    const num = Number(value);
    if (!Number.isFinite(num)) return 0;
    let normalized = num % 360;
    if (normalized < 0) normalized += 360;
    return normalized;
  }

  function tokenFacingDeg(unit){
    if (rotatingToken && Number(rotatingToken.cid) === Number(unit?.cid) && Number.isFinite(Number(rotatePreviewDeg))){
      return normalizeFacingDeg(rotatePreviewDeg);
    }
    return normalizeFacingDeg(unit?.facing_deg);
  }

  function tokenRotateHandle(unit){
    if (!unit || !unit.pos) return null;
    const isCurrentlyRotating = rotatingToken && Number(rotatingToken.cid) === Number(unit?.cid);
    if (!shiftMoveMode && !isCurrentlyRotating) return null;
    const rotationCid = normalizeCid(activeControlledUnitCid(), "rotateHandle.controlledCid");
    if (rotationCid === null || !cidMatches(unit.cid, rotationCid, "rotateHandle.cid")) return null;
    const {x, y} = gridToScreen(unit.pos.col, unit.pos.row);
    const r = Math.max(10, zoom * 0.35);
    const handleScale = mapRotateHandleScale();
    const orbitR = r + (Math.max(7, zoom * 0.2) * handleScale);
    const facingRad = (tokenFacingDeg(unit) * Math.PI) / 180;
    return {
      x: x + Math.cos(facingRad) * orbitR,
      y: y + Math.sin(facingRad) * orbitR,
      centerX: x,
      centerY: y,
      orbitR,
      hitR: Math.max(6, zoom * 0.15) * handleScale,
    };
  }

  function hitTestRotateHandle(p){
    const units = state?.units || [];
    for (let i = 0; i < units.length; i++){
      const handle = tokenRotateHandle(units[i]);
      if (!handle) continue;
      const dx = p.x - handle.x;
      const dy = p.y - handle.y;
      if (dx * dx + dy * dy <= handle.hitR * handle.hitR){
        return units[i];
      }
    }
    return null;
  }

  function isRotatableAoeKind(kind){
    const token = String(kind || "").toLowerCase();
    return token === "line" || token === "cone" || token === "cube" || token === "wall" || token === "square";
  }

  function syncOwnedRotatableAoesWithFacing(cid, facingDeg){
    if (!state || !Array.isArray(state.aoes)) return;
    const ownerCid = Number(cid);
    if (!Number.isFinite(ownerCid)) return;
    const facing = normalizeFacingDeg(facingDeg);
    state.aoes = state.aoes.map((aoe) => {
      if (!aoe || Number(aoe.owner_cid) !== ownerCid || !isRotatableAoeKind(aoe.kind)){
        return aoe;
      }
      const next = {...aoe, angle_deg: facing};
      if ((next.kind === "line" || next.kind === "wall") && Number.isFinite(Number(next.ax)) && Number.isFinite(Number(next.ay))){
        const halfLengthSquares = Number(next.length_sq || 0) / 2;
        if (Number.isFinite(halfLengthSquares) && halfLengthSquares > 0){
          const rad = (facing * Math.PI) / 180;
          next.cx = Number(next.ax) + Math.cos(rad) * halfLengthSquares;
          next.cy = Number(next.ay) + Math.sin(rad) * halfLengthSquares;
        }
      } else if (next.kind === "cone" && Number.isFinite(Number(next.ax)) && Number.isFinite(Number(next.ay))){
        next.cx = Number(next.ax);
        next.cy = Number(next.ay);
      }
      return next;
    });
  }

  function syncFacingFromRotatableAoe(aoe, angleDeg){
    if (!aoe || !isRotatableAoeKind(aoe.kind)) return;
    const ownerCid = Number(aoe.owner_cid);
    if (!Number.isFinite(ownerCid)) return;
    const unit = getUnitByCid(ownerCid);
    if (!unit) return;
    unit.facing_deg = normalizeFacingDeg(angleDeg);
  }

  function hitTestToken(p){
    if (!state || !state.units) return null;
    const hits = [];
    for (let i = 0; i < state.units.length; i++){
      const u = state.units[i];
      const {x,y} = gridToScreen(u.pos.col,u.pos.row);
      const r = Math.max(12, zoom*0.45);
      const dx = p.x - x, dy = p.y - y;
      if (dx*dx + dy*dy <= r*r){
        hits.push(u);
      }
    }
    if (!hits.length) return null;
    const activeCid = normalizeCid(state?.active_cid, "hitTest.active");
    if (activeCid !== null){
      const activeHit = hits.find((u) => cidMatches(u.cid, activeCid, "hitTest.activeMatch"));
      if (activeHit) return activeHit;
    }
    const claimed = normalizeCid(claimedCid, "hitTest.claimed");
    if (claimed !== null){
      const claimedHit = hits.find((u) => cidMatches(u.cid, claimed, "hitTest.claimedMatch"));
      if (claimedHit) return claimedHit;
      const mountHit = hits.find((u) => {
        const riderCid = normalizeCid(u?.mounted_by_cid, "hitTest.mountRider");
        const summonedBy = normalizeCid(u?.summoned_by_cid, "hitTest.mountSummoned");
        return (
          (riderCid !== null && cidMatches(riderCid, claimed, "hitTest.mountByClaimed"))
          || (summonedBy !== null && cidMatches(summonedBy, claimed, "hitTest.mountSummonByClaimed"))
        );
      });
      if (mountHit) return mountHit;
    }
    const renderSorted = sortedTokensForRender(hits);
    return renderSorted[renderSorted.length - 1] || null;
  }


  function buildCellMap(tokens){
    const cellMap = new Map();
    tokens.forEach(u => {
      const key = `${u.pos.col},${u.pos.row}`;
      if (!cellMap.has(key)) cellMap.set(key, []);
      cellMap.get(key).push(u);
    });
    return cellMap;
  }

  function groupLabelFromTokens(arr){
    if (!arr || !arr.length) return "";
    const groupName = arr.find(a => a.group_name || a.group_label || a.group)
      ?.group_name
      ?? arr.find(a => a.group_label)?.group_label
      ?? arr.find(a => a.group)?.group;
    if (groupName) return groupName;
    const names = arr.map(a => a.name).filter(Boolean);
    if (!names.length) return `Group (${arr.length})`;
    const first = names[0];
    const allSame = names.every(n => n === first);
    if (allSame){
      return `${arr.length}x ${first}`;
    }
    if (showAllNames){
      return `Group (${arr.length}): ${names.join(", ")}`;
    }
    return `Group (${arr.length})`;
  }

  function setTokenTooltip(text, clientX, clientY){
    if (!tokenTooltip) return;
    if (!text){
      tokenTooltip.classList.remove("show");
      tokenTooltip.setAttribute("aria-hidden", "true");
      return;
    }
    const wrapRect = mapWrap?.getBoundingClientRect();
    if (!wrapRect) return;
    tokenTooltip.textContent = text;
    const pad = 12;
    const left = clientX - wrapRect.left + pad;
    const top = clientY - wrapRect.top + pad;
    tokenTooltip.style.left = `${left}px`;
    tokenTooltip.style.top = `${top}px`;
    tokenTooltip.classList.add("show");
    tokenTooltip.setAttribute("aria-hidden", "false");
  }

  function clampZoom(value){
    return Math.min(90, Math.max(0.1, value));
  }

  function zoomAt(newZoom, focusX, focusY){
    const preZoom = zoom;
    const nextZoom = clampZoom(newZoom);
    if (Math.abs(nextZoom - preZoom) < 0.01) return;
    const col = (focusX - panX) / preZoom;
    const row = (focusY - panY) / preZoom;
    zoom = nextZoom;
    panX = focusX - col * zoom;
    panY = focusY - row * zoom;
    draw();
  }

  const activePointers = new Map();
  let pinchState = null;
  const AOE_TOUCH_HOLD_MS = 320;
  const AOE_TOUCH_MOVE_THRESHOLD = 8;

  function enforceLoginGate(){
    return false;
  }

  function startPinch(){
    if (activePointers.size < 2) return;
    const pts = Array.from(activePointers.values());
    const dx = pts[0].x - pts[1].x;
    const dy = pts[0].y - pts[1].y;
    const dist = Math.hypot(dx, dy);
    pinchState = {startDist: dist || 1, startZoom: zoom};
  }

  function updatePinch(){
    if (!pinchState || activePointers.size < 2) return;
    const pts = Array.from(activePointers.values());
    const midX = (pts[0].x + pts[1].x) / 2;
    const midY = (pts[0].y + pts[1].y) / 2;
    const dx = pts[0].x - pts[1].x;
    const dy = pts[0].y - pts[1].y;
    const dist = Math.hypot(dx, dy);
    if (pinchState.startDist <= 0) return;
    const scale = dist / pinchState.startDist;
    zoomAt(pinchState.startZoom * scale, midX, midY);
  }

  function clearAoeDragPending(){
    if (aoeDragPending?.timerId){
      clearTimeout(aoeDragPending.timerId);
    }
    aoeDragPending = null;
  }

  function beginAoeDrag({aid, offsetCol, offsetRow, centerCol, centerRow}){
    aoeDragging = {aid, offsetCol, offsetRow, isRotating: false};
    aoeDragPreview = {aid, cx: centerCol, cy: centerRow};
  }

  function getAoeById(aid){
    if (!state || !Array.isArray(state.aoes)) return null;
    return state.aoes.find(a => Number(a?.aid) === Number(aid)) || null;
  }

  function resolveAoeAnchor(aoe){
    const ax = Number(aoe?.ax);
    const ay = Number(aoe?.ay);
    if (Number.isFinite(ax) && Number.isFinite(ay)){
      return {ax, ay};
    }
    const cx = Number(aoe?.cx ?? 0);
    const cy = Number(aoe?.cy ?? 0);
    return {
      ax: Number.isFinite(cx) ? cx : 0,
      ay: Number.isFinite(cy) ? cy : 0,
    };
  }

  function isAoeRotateMode(ev, aoe){
    if (!aoe) return false;
    const kind = String(aoe.kind || "");
    if (kind !== "line" && kind !== "cone" && kind !== "cube" && kind !== "wall" && kind !== "square") return false;
    return !!(ev?.shiftKey || shiftMoveMode);
  }

  function activateAoeDragPending(){
    if (!aoeDragPending) return;
    const pending = aoeDragPending;
    clearAoeDragPending();
    beginAoeDrag(pending);
  }

  function allowAoeDrag(ev){
    if (isMapView) return false;
    if (isAdminClient()) return true;
    if (!claimedCid) return false;
    if (lockMyAoes) return false;
    if (ev.pointerType === "touch") return true;
    if (isPlanning) return true;
    return true;
  }

  canvas.addEventListener("pointerdown", (ev) => {
    if (enforceLoginGate()) return;
    setTokenTooltip(null);
    canvas.setPointerCapture(ev.pointerId);
    const p = pointerPos(ev);
    activePointers.set(ev.pointerId, p);
    if (activePointers.size >= 2){
      dragging = null;
      rotatingToken = null;
      rotatePreviewDeg = null;
      panning = null;
      clearAoeDragPending();
      startPinch();
      return;
    }
    if (measurementMode){
      setMeasurementPoint(p);
      return;
    }
    if (isMapView){
      if (!lockMap){
        panning = {x: p.x, y: p.y, panX, panY};
      }
      return;
    }
    if (attackOverlayMode){
      return;
    }

    const isTouchPointer = ev.pointerType === "touch";
    const isAoeDragMouse = ev.pointerType === "mouse" && (ev.button === 0 || ev.button === 1);
    if ((shiftMoveMode || ev.shiftKey) && (isAoeDragMouse || isTouchPointer) && allowAoeDrag(ev)){
      const hitAoe = hitTestAoe(p);
      if (hitAoe){
        ev.preventDefault();
        const gridPos = screenToGridFloat(p.x, p.y);
        const centerCol = Number(hitAoe.cx ?? 0);
        const centerRow = Number(hitAoe.cy ?? 0);
        const pendingPayload = {
          pointerId: ev.pointerId,
          aid: Number(hitAoe.aid),
          offsetCol: gridPos.col - centerCol,
          offsetRow: gridPos.row - centerRow,
          centerCol,
          centerRow,
          startX: p.x,
          startY: p.y,
        };
        clearAoeDragPending();
        if (isTouchPointer){
          aoeDragPending = {
            ...pendingPayload,
            timerId: setTimeout(() => {
              if (aoeDragPending?.pointerId !== ev.pointerId) return;
              activateAoeDragPending();
            }, AOE_TOUCH_HOLD_MS),
          };
        } else {
          beginAoeDrag(pendingPayload);
        }
        return;
      }
    }
    const rotateHit = hitTestRotateHandle(p);
    if (rotateHit){
      const rotationCid = normalizeCid(activeControlledUnitCid(), "rotate.hit.controlledCid");
      if (rotationCid === null || !cidMatches(rotateHit.cid, rotationCid, "rotate.hitCid")){
        send({type:"toast", text:"Arrr, that token aint yers."});
        return;
      }
      rotatingToken = {cid: Number(rotateHit.cid)};
      const {x, y} = gridToScreen(rotateHit.pos.col, rotateHit.pos.row);
      rotatePreviewDeg = normalizeFacingDeg((Math.atan2(p.y - y, p.x - x) * 180) / Math.PI);
      draw();
      return;
    }
    const hit = hitTestToken(p);
    if (hit){
      // only drag own token
      const controlledCid = activeControlledUnitCid();
      const mountMoveCid = getMountMovementCid();
      const canDragMount = mountMoveCid !== null && cidMatches(hit.cid, mountMoveCid, "dragToken.mountCid");
      const canDragSelf = controlledCid !== null && cidMatches(hit.cid, controlledCid, "dragToken.hitCid");
      if (!claimedCid || (!canDragSelf && !canDragMount)){
        send({type:"toast", text:"Arrr, that token aint yers."});
        return;
      }
      // only on your (or controlled summon's shared) turn
      if (controlledCid === null){
        send({type:"toast", text:"Not yer turn yet, matey."});
        return;
      }
      const mountUnitForDrag = mountMoveCid !== null ? getUnitByCid(mountMoveCid) : null;
      // When mounted, dragging either the rider or mount should move the mount token.
      const shouldDragMount = !!mountUnitForDrag && (
        canDragMount || (claimedCid !== null && cidMatches(hit.cid, claimedCid, "dragToken.claimedCid"))
      );
      const dragCid = shouldDragMount ? mountMoveCid : hit.cid;
      const dragUnit = shouldDragMount ? mountUnitForDrag : hit;
      const dragCol = Number(dragUnit?.pos?.col ?? hit.pos.col);
      const dragRow = Number(dragUnit?.pos?.row ?? hit.pos.row);
      dragging = {cid: dragCid, startX: p.x, startY: p.y, origCol: dragCol, origRow: dragRow};
      return;
    }
    if ((isAoeDragMouse || isTouchPointer) && allowAoeDrag(ev)){
      const hitAoe = hitTestAoe(p);
      if (hitAoe){
        ev.preventDefault();
        const gridPos = screenToGridFloat(p.x, p.y);
        const centerCol = Number(hitAoe.cx ?? 0);
        const centerRow = Number(hitAoe.cy ?? 0);
        const pendingPayload = {
          pointerId: ev.pointerId,
          aid: Number(hitAoe.aid),
          offsetCol: gridPos.col - centerCol,
          offsetRow: gridPos.row - centerRow,
          centerCol,
          centerRow,
          startX: p.x,
          startY: p.y,
        };
        clearAoeDragPending();
        if (isTouchPointer){
          aoeDragPending = {
            ...pendingPayload,
            timerId: setTimeout(() => {
              if (aoeDragPending?.pointerId !== ev.pointerId) return;
              activateAoeDragPending();
            }, AOE_TOUCH_HOLD_MS),
          };
        } else {
          beginAoeDrag(pendingPayload);
        }
        return;
      }
    }
    // else pan (if map not locked)
    if (shiftMoveMode){
      return;
    }
    if (!lockMap){
      panning = {x: p.x, y: p.y, panX, panY};
    }
  });

  canvas.addEventListener("pointermove", (ev) => {
    if (enforceLoginGate()) return;
    const p = pointerPos(ev);
    if (activePointers.has(ev.pointerId)){
      activePointers.set(ev.pointerId, p);
    }
    if (aoeDragPending && aoeDragPending.pointerId === ev.pointerId){
      const dx = p.x - aoeDragPending.startX;
      const dy = p.y - aoeDragPending.startY;
      if (Math.hypot(dx, dy) >= AOE_TOUCH_MOVE_THRESHOLD){
        activateAoeDragPending();
      } else {
        setTokenTooltip(null);
        return;
      }
    }
    if (pinchState && activePointers.size >= 2){
      updatePinch();
      setTokenTooltip(null);
      return;
    }
    if (aoeDragging){
      const gridPos = screenToGridFloat(p.x, p.y);
      const aoe = getAoeById(aoeDragging.aid);
      const shouldRotate = isAoeRotateMode(ev, aoe);
      aoeDragging.isRotating = shouldRotate;
      if (shouldRotate && aoe){
        const kind = String(aoe.kind || "");
        const anchor = resolveAoeAnchor(aoe);
        const dx = gridPos.col - anchor.ax;
        const dy = gridPos.row - anchor.ay;
        if (Math.abs(dx) + Math.abs(dy) < 0.01){
          return;
        }
        const angleDeg = (Math.atan2(dy, dx) * 180) / Math.PI;
        const preview = {
          aid: aoeDragging.aid,
          angle_deg: angleDeg,
          ax: anchor.ax,
          ay: anchor.ay,
        };
        if (kind === "cone"){
          if (!Number.isFinite(Number(aoe.spread_deg)) && Number.isFinite(Number(aoe.angle_deg))){
            preview.spread_deg = Number(aoe.angle_deg);
          }
          preview.cx = anchor.ax;
          preview.cy = anchor.ay;
        } else if (kind === "cube"){
          preview.cx = Number(aoe.cx ?? 0);
          preview.cy = Number(aoe.cy ?? 0);
        } else {
          const lengthSq = Number(aoe.length_sq || 0);
          const halfLen = lengthSq / 2;
          const rad = (angleDeg * Math.PI) / 180;
          const cx = anchor.ax + Math.cos(rad) * halfLen;
          const cy = anchor.ay + Math.sin(rad) * halfLen;
          preview.cx = cx;
          preview.cy = cy;
        }
        aoeDragPreview = preview;
      } else {
        const cx = gridPos.col - aoeDragging.offsetCol;
        const cy = gridPos.row - aoeDragging.offsetRow;
        aoeDragPreview = {aid: aoeDragging.aid, cx, cy};
      }
      draw();
      setTokenTooltip(null);
      return;
    }
    if (rotatingToken){
      const unit = getUnitByCid(rotatingToken.cid);
      if (unit && unit.pos){
        const {x, y} = gridToScreen(unit.pos.col, unit.pos.row);
        rotatePreviewDeg = normalizeFacingDeg((Math.atan2(p.y - y, p.x - x) * 180) / Math.PI);
        draw();
      }
      setTokenTooltip(null);
      return;
    }
    if (dragging){
      // update local preview by shifting pan temporarily? simplest: draw ghost at pointer
      draw();
      // ghost
      ctx.save();
      ctx.globalAlpha = 0.85;
      ctx.beginPath();
      ctx.arc(p.x, p.y, Math.max(10, zoom*0.35), 0, Math.PI*2);
      ctx.fillStyle = "rgba(106,169,255,0.25)";
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(106,169,255,0.95)";
      ctx.stroke();
      ctx.restore();
      setTokenTooltip(null);
    } else if (panning){
      panX = panning.panX + (p.x - panning.x);
      panY = panning.panY + (p.y - panning.y);
      draw();
      setTokenTooltip(null);
    } else if (measurementMode){
      setTokenTooltip(null);
    } else {
      if (ev.pointerType === "touch"){
        setTokenTooltip(null);
        return;
      }
      const tokens = state?.units || [];
      const hit = hitTestToken(p);
      if (hit){
        const cellMap = buildCellMap(tokens);
        const key = `${hit.pos.col},${hit.pos.row}`;
        const group = cellMap.get(key) || [];
        const label = group.length > 1 ? groupLabelFromTokens(group) : (hit.name || "Unknown");
        setTokenTooltip(label, ev.clientX, ev.clientY);
      } else {
        setTokenTooltip(null);
      }
    }
  });

  canvas.addEventListener("pointerup", (ev) => {
    if (enforceLoginGate()) return;
    const p = pointerPos(ev);
    activePointers.delete(ev.pointerId);
    if (activePointers.size < 2){
      pinchState = null;
    }
    if (aoeDragPending?.pointerId === ev.pointerId){
      clearAoeDragPending();
    }
    setTokenTooltip(null);
    if (attackOverlayMode && !isMapView && !pendingSummonPlacement && !dragging && !panning && !aoeDragging){
      const me = getClaimedUnit();
      if (!me){
        localToast("Claim a character first, matey.");
        return;
      }
      const hit = hitTestToken(p);
      const selectingSpellTarget = !!pendingSpellTargeting;
      const selectingLayOnHandsTarget = !!pendingLayOnHandsTargeting;
      if (hit && (selectingSpellTarget || selectingLayOnHandsTarget || !cidMatches(hit.cid, me.cid, "attackOverlay.target"))){
        const isFriendlyTarget = cidMatches(hit.cid, me.cid, "attackOverlay.selfTarget") || isFriendlyToMe(hit, me);
        if (!pendingSpellTargeting && !pendingLayOnHandsTargeting && isFriendlyTarget){
          localToast("Pick an enemy target, matey.");
          return;
        }
        if (pendingSpellTargeting){
          const targetSide = normalizeLowerValue(pendingSpellTargeting.targetSide || "enemy");
          if (targetSide === "friendly" && !isFriendlyTarget){
            localToast("Pick a friendly target, matey.");
            return;
          }
          if (targetSide !== "friendly" && isFriendlyTarget){
            localToast("Pick an enemy target, matey.");
            return;
          }
        }
        if (pendingLayOnHandsTargeting){
          const rangeFt = Number.isFinite(Number(pendingLayOnHandsTargeting?.rangeFt))
            ? Number(pendingLayOnHandsTargeting.rangeFt)
            : 5;
          const distFt = distanceFeetBetweenCells(me.pos, hit.pos);
          if (distFt - rangeFt > 1e-6){
            localToast("Target be out of Lay on Hands range.");
            return;
          }
          pendingLayOnHandsResolve = {
            targetCid: Number(hit.cid),
            targetName: String(hit.name || "target"),
          };
          setLayOnHandsOverlayOpen(true);
          return;
        }
        const weapon = pendingSpellTargeting ? null : (pendingActionAttackWeapon || getSelectedAttackWeapon());
        if (!pendingSpellTargeting && !weapon){
          localToast("No configured weapon found, matey.");
          return;
        }
        const rangeFt = Number.isFinite(Number(pendingSpellTargeting?.rangeFt))
          ? Number(pendingSpellTargeting.rangeFt)
          : (parseWeaponRangeFeet(weapon) + (isMeleeWeapon(weapon) ? 3 : 0));
        const distFt = distanceFeetBetweenCells(me.pos, hit.pos);
        if (distFt - rangeFt > 1e-6){
          localToast("Target be out of attack range.");
          return;
        }
        if (!pendingSpellTargeting){
          openAttackResolveModal(hit, weapon);
          return;
        }
        if (pendingSpellTargeting.mode === "save"){
          const request = {
            type: "spell_target_request",
            cid: activeControlledUnitCid(),
            target_cid: Number(hit.cid),
            spell_name: pendingSpellTargeting.spellName,
            spell_slug: pendingSpellTargeting.spellSlug || null,
            spell_id: pendingSpellTargeting.spellId || null,
            spell_mode: "save",
            save_type: pendingSpellTargeting.saveType || null,
            save_dc: Number.isFinite(Number(pendingSpellTargeting.saveDc)) ? Number(pendingSpellTargeting.saveDc) : null,
            roll_save: true,
          };
          send(request);
          return;
        }
        const autoHit = pendingSpellTargeting.mode === "auto_hit";
        pendingAttackResolve = {
          mode: "spell",
          targetCid: Number(hit.cid),
          targetName: String(hit.name || "target"),
          spellName: pendingSpellTargeting.spellName,
          spellSlug: pendingSpellTargeting.spellSlug || null,
          spellId: pendingSpellTargeting.spellId || null,
          spellMode: pendingSpellTargeting.mode,
          saveType: pendingSpellTargeting.saveType || "",
          saveDc: pendingSpellTargeting.saveDc,
          forceHit: autoHit,
          rollSave: false,
        };
        if (attackResolveBody){
          const details = [
            pendingSpellTargeting.damageDice ? `Damage: ${pendingSpellTargeting.damageDice}${pendingSpellTargeting.damageType ? ` ${pendingSpellTargeting.damageType}` : ""}.` : "",
            pendingSpellTargeting.description ? pendingSpellTargeting.description : "",
          ].filter(Boolean).join(" ");
          attackResolveBody.textContent = `Resolve ${pendingSpellTargeting.spellName} on ${pendingAttackResolve.targetName}.`
            + (details ? ` ${details}` : "");
        }
        if (attackDamageRows){
          attackDamageRows.textContent = "";
          addAttackDamageRow("", pendingSpellTargeting.damageType || "");
        }
        if (attackResolveHit) attackResolveHit.checked = autoHit;
        if (attackResolveMiss) attackResolveMiss.checked = !autoHit;
        if (attackResolveHit) attackResolveHit.disabled = autoHit;
        if (attackResolveMiss) attackResolveMiss.disabled = autoHit;
        syncAttackResolveDamageVisibility();
        setAttackResolveModalOpen(true);
        return;
      }
    }
    if (pendingSummonPlacement && !isMapView && !dragging && !panning && !aoeDragging){
      const g = screenToGrid(p.x, p.y);
      if (!gridReady()){
        localToast("Map not ready yet, matey.");
        return;
      }
      const cols = Number(state?.grid?.cols || 0);
      const rows = Number(state?.grid?.rows || 0);
      if (g.col < 0 || g.row < 0 || g.col >= cols || g.row >= rows){
        localToast("That square be off the map.");
        return;
      }
      if (!isSummonPlacementCellValid(g)){
        localToast("That square is out of rangeselect a valid square.");
        return;
      }
      pendingSummonPlacement.positions.push({col: g.col, row: g.row});
      if (pendingSummonPlacement.mode === "echo_summon"){
        if (claimedCid == null){
          clearSummonPlacementState();
          return;
        }
        const pos = pendingSummonPlacement.positions[0] || {col: g.col, row: g.row};
        const msg = {type: "echo_summon", cid: claimedCid, to: {col: Number(pos.col), row: Number(pos.row)}};
        if (isPlanning){
          planningMutate(msg);
          draw();
          updateHud();
        }
        send(msg);
        clearSummonPlacementState();
        return;
      }
      const remaining = pendingSummonPlacement.summonQuantity - pendingSummonPlacement.positions.length;
      if (remaining > 0){
        localToast(`${remaining} summon placement(s) remaining.`);
        return;
      }
      const payload = {
        ...pendingSummonPlacement.payload,
        summon_positions: pendingSummonPlacement.positions.slice(),
      };
      const castType = pendingSummonPlacement.mode === "custom_summon" ? "cast_aoe" : "cast_spell";
      const msg = {type: castType, payload, action_type: pendingSummonPlacement.actionType};
      if (pendingSummonPlacement.spellSlug){
        msg.spell_slug = pendingSummonPlacement.spellSlug;
      }
      if (pendingSummonPlacement.spellId){
        msg.spell_id = pendingSummonPlacement.spellId;
      }
      if (Number.isFinite(pendingSummonPlacement.slotLevel)){
        msg.slot_level = pendingSummonPlacement.slotLevel;
      }
      msg.summon_choice = pendingSummonPlacement.summonChoice;
      msg.summon_quantity = pendingSummonPlacement.summonQuantity;
      msg.variant = pendingSummonPlacement.summonVariant || null;
      if (pendingSummonPlacement.mode === "custom_summon"){
        msg.payload.shape = "summon";
      }
      if (isPlanning){
        planningMutate(msg);
        draw();
        updateHud();
      }
      send(msg);
      clearSummonPlacementState();
      return;
    }

    if (aoeDragging){
      const gridPos = screenToGridFloat(p.x, p.y);
      const preview = aoeDragPreview || {};
      let targetCol = Math.round(gridPos.col - aoeDragging.offsetCol);
      let targetRow = Math.round(gridPos.row - aoeDragging.offsetRow);
      const toPayload = {};
      if (aoeDragging.isRotating && Number.isFinite(Number(preview?.angle_deg))){
        if (Number.isFinite(Number(preview?.cx))) targetCol = Number(preview.cx);
        if (Number.isFinite(Number(preview?.cy))) targetRow = Number(preview.cy);
        toPayload.angle_deg = Number(preview.angle_deg);
        if (Number.isFinite(Number(preview?.ax))) toPayload.ax = Number(preview.ax);
        if (Number.isFinite(Number(preview?.ay))) toPayload.ay = Number(preview.ay);
        if (Number.isFinite(Number(preview?.spread_deg))) toPayload.spread_deg = Number(preview.spread_deg);
      }
      toPayload.cx = targetCol;
      toPayload.cy = targetRow;
      const msg = {type:"aoe_move", aid: Number(aoeDragging.aid), to: toPayload};
      if (isPlanning){
        planningMutate(msg);
        draw();
        updateHud();
      }
      send(msg);
      aoeDragging = null;
      aoeDragPreview = null;
      draw();
      return;
    }
    if (rotatingToken){
      const facingDeg = Number.isFinite(Number(rotatePreviewDeg)) ? normalizeFacingDeg(rotatePreviewDeg) : 0;
      const unit = getUnitByCid(rotatingToken.cid);
      if (unit){
        unit.facing_deg = facingDeg;
        syncOwnedRotatableAoesWithFacing(unit.cid, facingDeg);
      }
      const msg = {type:"set_facing", cid: Number(rotatingToken.cid), facing_deg: facingDeg};
      if (isPlanning){
        planningMutate(msg);
        draw();
        updateHud();
      }
      send(msg);
      rotatingToken = null;
      rotatePreviewDeg = null;
      draw();
      return;
    }
    dragging && (function(){
      const g = screenToGrid(p.x, p.y);
      const msg = {type:"move", cid: Number(dragging.cid), to: {col: g.col, row: g.row}};
      if (isPlanning){
        planningMutate(msg);
        draw();
        updateHud();
      }
      send(msg);
      dragging = null;
    })();
    panning = null;
  });

  canvas.addEventListener("pointercancel", (ev) => {
    if (enforceLoginGate()) return;
    activePointers.delete(ev.pointerId);
    if (activePointers.size < 2){
      pinchState = null;
    }
    if (aoeDragPending?.pointerId === ev.pointerId){
      clearAoeDragPending();
    }
    if (aoeDragging){
      aoeDragging = null;
      aoeDragPreview = null;
      draw();
    }
    if (rotatingToken){
      rotatingToken = null;
      rotatePreviewDeg = null;
      draw();
    }
    setTokenTooltip(null);
  });

  canvas.addEventListener("pointerleave", () => {
    setTokenTooltip(null);
  });

  canvas.addEventListener("wheel", (ev) => {
    if (enforceLoginGate()) return;
    if (pinchState) return;
    ev.preventDefault();
    const p = pointerPos(ev);
    const delta = ev.deltaY || 0;
    const factor = delta > 0 ? 0.9 : 1.1;
    zoomAt(zoom * factor, p.x, p.y);
  }, {passive: false});

  if (zoomInBtn){
    zoomInBtn.addEventListener("click", () => {
      if (enforceLoginGate()) return;
      const r = canvas.getBoundingClientRect();
      zoomAt(zoom + 4, r.width / 2, r.height / 2);
    });
  }
  if (zoomOutBtn){
    zoomOutBtn.addEventListener("click", () => {
      if (enforceLoginGate()) return;
      const r = canvas.getBoundingClientRect();
      zoomAt(zoom - 4, r.width / 2, r.height / 2);
    });
  }
  if (lockMapBtn){
    lockMapBtn.addEventListener("click", (ev) => {
      if (enforceLoginGate()) return;
      lockMap = !lockMap;
      ev.target.textContent = lockMap ? "Unlock Map" : "Lock Map";
    });
  }
  if (lockAoeBtn){
    lockAoeBtn.addEventListener("click", () => {
      if (enforceLoginGate()) return;
      lockMyAoes = !lockMyAoes;
      persistToggle(lockMyAoesKey, lockMyAoes);
      updateAoeLockButton();
    });
  }
  if (auraToggleBtn){
    auraToggleBtn.addEventListener("click", () => {
      if (enforceLoginGate()) return;
      const next = !areAurasEnabled();
      if (!state || typeof state !== "object") state = {};
      state.auras_enabled = next;
      updateAurasButton();
      draw();
      send({type:"set_auras_enabled", enabled: next});
    });
  }
  if (centerMapBtn){
    centerMapBtn.addEventListener("click", () => {
      if (enforceLoginGate()) return;
      if (!centerOnClaimed()){
        centerOnGridCenter();
      }
    });
  }
  if (measureToggle){
    measureToggle.addEventListener("click", () => {
      if (enforceLoginGate()) return;
      measurementMode = !measurementMode;
      updateMeasurementControls();
    });
  }
  if (measureClear){
    measureClear.addEventListener("click", () => {
      if (enforceLoginGate()) return;
      clearMeasurement();
    });
  }
  if (tokenColorModeBtn){
    tokenColorModeBtn.addEventListener("click", () => {
      if (enforceLoginGate()) return;
      openClaimedColorModal();
    });
  }

  if (tokenColorInput){
    tokenColorInput.addEventListener("input", (ev) => {
      updateTokenColorSwatch(ev.target.value);
    });
  }
  if (tokenBorderColorInput){
    tokenBorderColorInput.addEventListener("input", (ev) => {
      updateTokenBorderColorSwatch(ev.target.value);
    });
  }
  if (tokenColorConfirm){
    tokenColorConfirm.addEventListener("click", () => {
      const claimedUnit = getClaimedUnit();
      if (!claimedUnit){
        localToast("Claim a character first, matey.");
        closeColorModal();
        return;
      }
      pendingClaim = claimedUnit;
      const color = validateTokenColor(tokenColorInput ? tokenColorInput.value : "");
      if (!color) return;
      const borderColor = normalizeHexColor(tokenBorderColorInput ? tokenBorderColorInput.value : "") || "#ffffff";
      localStorage.setItem("inittracker_tokenColor", color);
      localStorage.setItem("inittracker_tokenBorderColor", borderColor);
      const pendingCid = normalizeCid(pendingClaim.cid, "tokenColor.pendingCid");
      if (pendingCid === null) return;
      if (state?.units){
        const unit = state.units.find(u => cidMatches(u.cid, pendingCid, "tokenColor.unitCid"));
        if (unit){
          unit.token_color = color;
          unit.token_border_color = borderColor;
          draw();
        }
      }
      send({type:"set_color", cid: pendingCid, color, border_color: borderColor});
      meEl.textContent = pendingClaim.name;
      closeColorModal();
    });
  }
  if (tokenColorCancel){
    tokenColorCancel.addEventListener("click", () => {
      closeColorModal();
      showNoOwnedPcToast(lastPcList || []);
    });
  }
  if (switchCharacterBtn){
    switchCharacterBtn.addEventListener("click", () => {
      if (enforceLoginGate()) return;
      requestCharacterSwitch();
    });
  }
  if (claimConfirmBtn){
    claimConfirmBtn.addEventListener("click", () => {
      if (selectedClaimCid === null || selectedClaimCid === undefined){
        localToast("Pick a character first, matey.");
        return;
      }
      const cidValue = normalizeCid(selectedClaimCid, "confirm.selectedCid");
      if (cidValue === null) return;
      if (claimInFlight){
        return;
      }
      allowUnclaimed = false;
      storeLanSelection(cidValue, lastPcList || []);
      setClaimInFlight(cidValue);
      send({type:"claim", cid: cidValue, client_id: clientId});
      clearSpellFilters();
      clearAutoClaimPending();
      updateClaimOverlay();
      // Don't optimistically set claimedCid here - wait for server confirmation via "you" field
    });
  }
  if (claimContinueBtn){
    claimContinueBtn.addEventListener("click", () => {
      enterUnclaimedSpectatorMode();
    });
  }
  if (claimSpectatorBtn){
    claimSpectatorBtn.addEventListener("click", () => {
      enterUnclaimedSpectatorMode();
    });
  }

  let lastSpellPresetSignature = "";
  let cachedSpellPresets = [];
  let spellPresetBySlug = new Map();
  const normalizeSpellPresets = (presets) => {
    if (!Array.isArray(presets)) return [];
    return presets.filter(p => p && typeof p === "object").map((preset) => {
      const shape = String(preset?.shape || "").trim().toLowerCase();
      const summon = preset.summon && typeof preset.summon === "object" ? preset.summon : null;
      return {
        ...preset,
        isAoE: Boolean(shape && AOE_SHAPES.has(shape)),
        isSummon: Boolean(summon),
      };
    });
  };
  const formatSpellLevelLabel = (level) => {
    const num = Number(level);
    if (!Number.isFinite(num)) return "Unknown";
    if (num === 0) return "Cantrip";
    const suffix = num === 1 ? "st" : num === 2 ? "nd" : num === 3 ? "rd" : "th";
    return `${num}${suffix}`;
  };
  const formatListGroupLabel = (value) => String(value || "")
    .replace(/_/g, " ")
    .replace(/\\b\\w/g, (char) => char.toUpperCase());
  const normalizeTextValue = (value) => String(value || "").trim();
  const normalizeLowerValue = (value) => normalizeTextValue(value).toLowerCase();
  const getSpellTagSet = (preset) => {
    const tags = Array.isArray(preset?.tags) ? preset.tags.map((tag) => normalizeLowerValue(tag)) : [];
    return new Set(tags.filter(Boolean));
  };
  const hasSpellTag = (preset, tag) => getSpellTagSet(preset).has(normalizeLowerValue(tag));
  const resolveSpellActionTag = (preset) => {
    const tagSet = getSpellTagSet(preset);
    if (tagSet.has("aoe")) return "aoe";
    if (tagSet.has("attack") || tagSet.has("spell_attack_target")) return "attack";
    if (tagSet.has("save") || tagSet.has("spell_save_target")) return "save";
    if (tagSet.has("auto_hit") || tagSet.has("spell_auto_hit_target")) return "auto_hit";
    const areaShape = normalizeLowerValue(preset?.mechanics?.targeting?.area?.shape || preset?.shape);
    if (areaShape && AOE_SHAPES.has(areaShape)) return "aoe";
    const sequence = Array.isArray(preset?.mechanics?.sequence) ? preset.mechanics.sequence : [];
    for (const step of sequence){
      const kind = normalizeLowerValue(step?.check?.kind);
      if (kind === "spell_attack") return "attack";
      if (kind === "saving_throw") return "save";
    }
    return "";
  };
  const reportSpellTagMissing = (preset, extra = {}) => {
    const payload = {
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      url: location.href,
      message: "Spell cast blocked: missing spell action tag",
      level: "error",
      spell_name: normalizeTextValue(preset?.name) || "",
      spell_slug: normalizeTextValue(preset?.slug) || "",
      tags: Array.isArray(preset?.tags) ? preset.tags.filter(Boolean) : [],
      ...extra,
    };
    try {
      console.error("Spell cast missing tag", payload);
      fetch("/api/client-log", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify(payload),
      }).catch(() => {});
    } catch (err) {
      console.warn("Failed to report spell tag error.", err);
    }
  };
  const getSpellKey = (value) => normalizeLowerValue(value);
  const getPresetSlug = (preset) => {
    const slug = normalizeTextValue(preset?.slug);
    if (slug) return slug;
    return normalizeLowerValue(preset?.name).replace(/\\s+/g, "-");
  };
  const AOE_SHAPES = new Set(["circle", "square", "line", "sphere", "cube", "cone", "cylinder", "wall"]);
  const isAoePreset = (preset) => Boolean(preset?.isAoE);
  const isSummonPreset = (preset) => Boolean(preset?.isSummon);
  const CUSTOM_SUMMON_PRESET_NAME = "Custom Summon";
  const CUSTOM_SUMMON_PRESET = {
    name: CUSTOM_SUMMON_PRESET_NAME,
    slug: "custom-summon",
    isSummon: true,
    isCustomSummon: true,
    shape: "summon",
    summon: {choices: [{monster_slug: "custom-summon", name: "Custom Summon"}], quantities: [{quantity: 1}]},
  };
  const DEFAULT_CUSTOM_SUMMON_TEMPLATE = {
    name: "Custom summon",
    type: "construct",
    hp: 30,
    ac: 10,
    speeds: {walk: 30, swim: 0, fly: 0, burrow: 0, climb: 0},
    abilities: {str: 10, dex: 10, con: 10, int: 10, wis: 10, cha: 10},
  };
  const parseIntOrFallback = (value, fallback) => {
    const num = Number(value);
    return Number.isFinite(num) ? Math.floor(num) : fallback;
  };
  const clampInt = (value, min, max, fallback) => {
    const parsed = parseIntOrFallback(value, fallback);
    return Math.max(min, Math.min(max, parsed));
  };
  const normalizeMonsterChoiceTemplate = (choice) => {
    const template = choice?.template && typeof choice.template === "object" ? choice.template : {};
    const speeds = template.speeds && typeof template.speeds === "object" ? template.speeds : {};
    const abilities = template.abilities && typeof template.abilities === "object" ? template.abilities : {};
    return {
      name: normalizeTextValue(template.name || choice?.name || DEFAULT_CUSTOM_SUMMON_TEMPLATE.name),
      type: normalizeTextValue(template.type || DEFAULT_CUSTOM_SUMMON_TEMPLATE.type) || DEFAULT_CUSTOM_SUMMON_TEMPLATE.type,
      hp: Math.max(1, parseIntOrFallback(template.hp, DEFAULT_CUSTOM_SUMMON_TEMPLATE.hp)),
      ac: Math.max(1, parseIntOrFallback(template.ac, DEFAULT_CUSTOM_SUMMON_TEMPLATE.ac)),
      speeds: {
        walk: Math.max(1, parseIntOrFallback(speeds.walk, DEFAULT_CUSTOM_SUMMON_TEMPLATE.speeds.walk)),
        swim: Math.max(0, parseIntOrFallback(speeds.swim, DEFAULT_CUSTOM_SUMMON_TEMPLATE.speeds.swim)),
        fly: Math.max(0, parseIntOrFallback(speeds.fly, DEFAULT_CUSTOM_SUMMON_TEMPLATE.speeds.fly)),
        burrow: Math.max(0, parseIntOrFallback(speeds.burrow, DEFAULT_CUSTOM_SUMMON_TEMPLATE.speeds.burrow)),
        climb: Math.max(0, parseIntOrFallback(speeds.climb, DEFAULT_CUSTOM_SUMMON_TEMPLATE.speeds.climb)),
      },
      abilities: {
        str: clampInt(abilities.str, 1, 30, DEFAULT_CUSTOM_SUMMON_TEMPLATE.abilities.str),
        dex: clampInt(abilities.dex, 1, 30, DEFAULT_CUSTOM_SUMMON_TEMPLATE.abilities.dex),
        con: clampInt(abilities.con, 1, 30, DEFAULT_CUSTOM_SUMMON_TEMPLATE.abilities.con),
        int: clampInt(abilities.int, 1, 30, DEFAULT_CUSTOM_SUMMON_TEMPLATE.abilities.int),
        wis: clampInt(abilities.wis, 1, 30, DEFAULT_CUSTOM_SUMMON_TEMPLATE.abilities.wis),
        cha: clampInt(abilities.cha, 1, 30, DEFAULT_CUSTOM_SUMMON_TEMPLATE.abilities.cha),
      },
    };
  };
  const getCustomSummonMonsterChoices = () => {
    const list = Array.isArray(state?.monster_choices) ? state.monster_choices : [];
    return list
      .filter((entry) => entry && typeof entry === "object")
      .map((entry) => ({
        name: normalizeTextValue(entry.name),
        slug: normalizeTextValue(entry.slug),
        template: normalizeMonsterChoiceTemplate(entry),
      }))
      .filter((entry) => entry.slug && entry.name)
      .sort((a, b) => a.name.localeCompare(b.name));
  };
  const refreshCustomSummonMonsterOptions = () => {
    if (!castCustomSummonMonsterInput) return;
    const currentValue = normalizeTextValue(castCustomSummonMonsterInput.value);
    const searchText = normalizeLowerValue(castCustomSummonMonsterSearchInput?.value || "");
    const choices = getCustomSummonMonsterChoices().filter((entry) => {
      if (!searchText) return true;
      return normalizeLowerValue(entry.name).includes(searchText) || normalizeLowerValue(entry.slug).includes(searchText);
    });
    castCustomSummonMonsterInput.textContent = "";
    choices.forEach((entry) => {
      const opt = document.createElement("option");
      opt.value = entry.slug;
      opt.textContent = `${entry.name} (${entry.slug})`;
      castCustomSummonMonsterInput.appendChild(opt);
    });
    castCustomSummonMonsterInput.value = choices.some((entry) => entry.slug === currentValue)
      ? currentValue
      : (choices[0]?.slug || "");
  };
  const getSelectedCustomSummonChoice = () => {
    const slug = normalizeTextValue(castCustomSummonMonsterInput?.value);
    if (!slug) return null;
    return getCustomSummonMonsterChoices().find((entry) => entry.slug === slug) || null;
  };
  const applyCustomSummonTemplate = (choice, overwriteName = false) => {
    const template = normalizeMonsterChoiceTemplate(choice || {});
    if (castCustomSummonNameInput && (overwriteName || !normalizeTextValue(castCustomSummonNameInput.value))){
      castCustomSummonNameInput.value = template.name || DEFAULT_CUSTOM_SUMMON_TEMPLATE.name;
    }
    if (castNameInput && (overwriteName || !normalizeTextValue(castNameInput.value))){
      castNameInput.value = castCustomSummonNameInput?.value || template.name || DEFAULT_CUSTOM_SUMMON_TEMPLATE.name;
    }
    if (castCustomSummonTypeInput) castCustomSummonTypeInput.value = template.type;
    if (castCustomSummonHpInput) castCustomSummonHpInput.value = String(template.hp);
    if (castCustomSummonAcInput) castCustomSummonAcInput.value = String(template.ac);
    if (castCustomSummonWalkInput) castCustomSummonWalkInput.value = String(template.speeds.walk);
    if (castCustomSummonSwimInput) castCustomSummonSwimInput.value = String(template.speeds.swim);
    if (castCustomSummonFlyInput) castCustomSummonFlyInput.value = String(template.speeds.fly);
    if (castCustomSummonBurrowInput) castCustomSummonBurrowInput.value = String(template.speeds.burrow);
    if (castCustomSummonClimbInput) castCustomSummonClimbInput.value = String(template.speeds.climb);
    if (castCustomSummonStrInput) castCustomSummonStrInput.value = String(template.abilities.str);
    if (castCustomSummonDexInput) castCustomSummonDexInput.value = String(template.abilities.dex);
    if (castCustomSummonConInput) castCustomSummonConInput.value = String(template.abilities.con);
    if (castCustomSummonIntInput) castCustomSummonIntInput.value = String(template.abilities.int);
    if (castCustomSummonWisInput) castCustomSummonWisInput.value = String(template.abilities.wis);
    if (castCustomSummonChaInput) castCustomSummonChaInput.value = String(template.abilities.cha);
  };
  const loadPreparedSpellFilterList = () => {
    const name = getClaimedPlayerName();
    if (!name) return null;
    const config = getSpellbookConfig(name);
    const cantrips = config.cantrips || [];
    if (!config.prepared.length && !cantrips.length) return null;
    const merged = new Set([
      ...config.prepared.map(normalizeTextValue),
      ...cantrips.map(normalizeTextValue),
    ]);
    return Array.from(merged).filter(Boolean);
  };
  const getPreparedSpellFilterSet = () => {
    if (!claimedCid) return null;
    const list = loadPreparedSpellFilterList();
    const baseSet = list ? new Set(list.map(getSpellKey)) : new Set();
    const name = getClaimedPlayerName();
    const poolEntries = getPoolGrantedSpellEntries(name);
    const pools = new Map(getPlayerResourcePools(name).map((entry) => [getSpellKey(entry.id), entry]));
    poolEntries.forEach((entry) => {
      const slug = normalizeTextValue(entry.spell || entry.slug || entry.id);
      if (!slug) return;
      const consumes = entry.consumes_pool && typeof entry.consumes_pool === "object" ? entry.consumes_pool : {};
      const poolId = normalizeTextValue(consumes.id || consumes.pool);
      const costRaw = Number(consumes.cost ?? 1);
      const cost = Number.isFinite(costRaw) ? Math.max(1, Math.floor(costRaw)) : 1;
      const pool = pools.get(getSpellKey(poolId));
      const current = Number(pool?.current ?? 0);
      if (!poolId || current >= cost){
        baseSet.add(getSpellKey(slug));
      }
    });
    return baseSet;
  };
  const filterPresetsByKnownList = (presets, knownSpellSet) => {
    if (!knownSpellSet) return presets;
    if (knownSpellSet.size === 0) return [];
    return presets.filter((preset) => {
      const slug = getPresetSlug(preset);
      if (!slug) return false;
      return knownSpellSet.has(getSpellKey(slug));
    });
  };
  const getSpellListEntries = (lists) => {
    if (!lists || typeof lists !== "object") return [];
    const entries = [];
    Object.entries(lists).forEach(([group, values]) => {
      if (!Array.isArray(values)) return;
      values.forEach((value) => {
        const trimmed = normalizeTextValue(value);
        if (!trimmed) return;
        entries.push({group, value: trimmed});
      });
    });
    return entries;
  };
  const getPresetLevelNumber = (preset) => {
    const num = Number(preset?.level);
    return Number.isFinite(num) ? num : null;
  };
  const updateManualEntryBadge = (preset) => {
    if (!castManualEntryBadge) return;
    if (!preset){
      castManualEntryBadge.classList.remove("show");
      castManualEntryBadge.setAttribute("aria-hidden", "true");
      castManualEntryBadge.removeAttribute("title");
      castManualEntryBadge.removeAttribute("aria-label");
      return;
    }
    const reasons = [];
    const automation = normalizeLowerValue(preset.automation);
    if (automation === "partial" || automation === "manual"){
      reasons.push(`automation is ${automation}`);
    }
    if (!preset.shape && !isSummonPreset(preset)){
      reasons.push("shape is missing");
    }
    if (preset.incomplete){
      const missing = Array.isArray(preset.incomplete_fields)
        ? preset.incomplete_fields.map((field) => String(field || "").trim()).filter(Boolean)
        : [];
      if (missing.length){
        reasons.push(`missing ${missing.join(", ")}`);
      } else {
        reasons.push("missing dimensions");
      }
    }
    if (reasons.length){
      const tooltip = `Manual entry required: ${reasons.join("; ")}.`;
      castManualEntryBadge.classList.add("show");
      castManualEntryBadge.setAttribute("aria-hidden", "false");
      castManualEntryBadge.title = tooltip;
      castManualEntryBadge.setAttribute("aria-label", tooltip);
    } else {
      castManualEntryBadge.classList.remove("show");
      castManualEntryBadge.setAttribute("aria-hidden", "true");
      castManualEntryBadge.removeAttribute("title");
      castManualEntryBadge.removeAttribute("aria-label");
    }
  };
  function getSelectedSpellPreset(){
    const name = normalizeTextValue(castPresetInput?.value);
    if (!name) return null;
    if (name === CUSTOM_SUMMON_PRESET_NAME){
      return {...CUSTOM_SUMMON_PRESET};
    }
    return cachedSpellPresets.find(preset => normalizeTextValue(preset.name) === name) || null;
  }
  function normalizeSpellActionType(value){
    const raw = normalizeLowerValue(value);
    // Order matters: keep bonus action/reaction checks before generic action.
    if (/\bbonus[\s\-_]*action\b/.test(raw)) return "bonus_action";
    if (/\breaction\b/.test(raw)) return "reaction";
    if (/\baction\b/.test(raw)) return "action";
    return "action";
  }
  function getSpellActionType(preset){
    if (!preset) return "action";
    const castingTime = normalizeTextValue(preset.casting_time || preset.castingTime);
    return normalizeSpellActionType(castingTime);
  }
  function unitHasMagicAction(unit, actionType){
    const actions = normalizeActionList(unit?.actions, "action");
    const bonusActions = normalizeActionList(unit?.bonus_actions, "bonus_action");
    if (actionType === "bonus_action"){
      return [...bonusActions, ...actions].some((entry) => isSpellActionEntry(entry));
    }
    return actions.some((entry) => isSpellActionEntry(entry));
  }
  function canSpendSpellAction(unit, actionType){
    if (!unit) return {ok: false, reason: "Claim a character first, matey."};
    if (actionType === "bonus_action"){
      const remaining = Number(unit.spell_cast_remaining || 0);
      if (remaining <= 0){
        return {ok: false, reason: "You already cast a spell this turn."};
      }
      if (!unitHasMagicAction(unit, actionType)){
        return {ok: false, reason: "No bonus-action spellcasting available."};
      }
      if (Number(unit.bonus_action_remaining || 0) <= 0){
        return {ok: false, reason: "No bonus actions left, matey."};
      }
      return {ok: true};
    }
    if (actionType === "reaction"){
      if (Number(unit.reaction_remaining || 0) <= 0){
        return {ok: false, reason: "No reactions left, matey."};
      }
      return {ok: true};
    }
    const remaining = Number(unit.spell_cast_remaining || 0);
    if (remaining <= 0){
      return {ok: false, reason: "You already cast a spell this turn."};
    }
    if (!unitHasMagicAction(unit, actionType)){
      return {ok: false, reason: "No spellcasting action available."};
    }
    if (Number(unit.action_remaining || 0) <= 0){
      return {ok: false, reason: "No actions left, matey."};
    }
    return {ok: true};
  }

  let spellLibraryRecords = [];
  let spellLibraryLoadPromise = null;
  let spellLibraryLoadError = "";
  let spellLibrarySearchTerm = "";
  let spellLibrarySortMode = "alpha";
  let spellLibraryPreviousFocus = null;
  let spellbookMode = "known";
  let spellbookSearchTerm = "";
  let spellbookSortMode = "alpha";
  let spellbookKnownEnabled = true;
  let spellbookKnownLimit = null;
  let spellbookPreparedLimit = null;
  let spellbookCantripsMax = null;
  let pendingKnownSet = new Set();
  let pendingPreparedSet = new Set();
  let pendingKnownFreeSet = new Set();
  let pendingPreparedFreeSet = new Set();
  let pendingCantripsSet = new Set();
  let spellbookLeftSelection = new Set();
  let spellbookRightSelection = new Set();
  let spellbookPreviousFocus = null;
  let spellDetailPreviousFocus = null;
  let activeSpellDetailSlug = null;
  let rulesStatusCache = null;
  let rulesTocCache = [];
  let rulesSpellPagesCache = null;
  let rulesViewerLoaded = false;
  let rulesViewerReady = false;
  let rulesLastPage = Number(localStorage.getItem(rulesLastPageStorageKey) || 1) || 1;

  function getPlayerLevel(profile){
    const raw = profile?.leveling?.level ?? profile?.leveling?.total_level ?? profile?.leveling?.lvl;
    const value = Number(raw);
    return Number.isFinite(value) ? Math.max(0, Math.floor(value)) : 0;
  }

  function maxSpellLevelForCharacter(level){
    if (level >= 17) return 9;
    if (level >= 15) return 8;
    if (level >= 13) return 7;
    if (level >= 11) return 6;
    if (level >= 9) return 5;
    if (level >= 7) return 4;
    if (level >= 5) return 3;
    if (level >= 3) return 2;
    if (level >= 1) return 1;
    return 0;
  }

  function getPresetLevelBySlug(slug){
    const preset = spellPresetBySlug.get(getSpellKey(slug));
    return preset ? getPresetLevelNumber(preset) : null;
  }

  function sortSlugsByName(slugs){
    return slugs.slice().sort((a, b) => {
      const presetA = spellPresetBySlug.get(getSpellKey(a));
      const presetB = spellPresetBySlug.get(getSpellKey(b));
      const nameA = normalizeTextValue(presetA?.name || a);
      const nameB = normalizeTextValue(presetB?.name || b);
      return nameA.localeCompare(nameB);
    });
  }

  function getSpellbookSearchText(slug){
    const preset = spellPresetBySlug.get(getSpellKey(slug));
    const tags = Array.isArray(preset?.tags) ? preset.tags.filter(Boolean).join(" ") : "";
    return [
      preset?.name,
      slug,
      preset?.school,
      preset?.casting_time,
      preset?.range,
      tags,
    ].filter(Boolean).join(" ").toLowerCase();
  }

  function filterSpellbookSlugs(slugs){
    const query = spellbookSearchTerm.trim().toLowerCase();
    if (!query) return slugs.slice();
    return slugs.filter((slug) => getSpellbookSearchText(slug).includes(query));
  }

  function sortSpellbookSlugs(slugs){
    return slugs.slice().sort((a, b) => {
      const presetA = spellPresetBySlug.get(getSpellKey(a));
      const presetB = spellPresetBySlug.get(getSpellKey(b));
      const nameA = normalizeTextValue(presetA?.name || a);
      const nameB = normalizeTextValue(presetB?.name || b);
      if (spellbookSortMode === "level"){
        const levelA = Number.isFinite(getPresetLevelNumber(presetA)) ? getPresetLevelNumber(presetA) : 99;
        const levelB = Number.isFinite(getPresetLevelNumber(presetB)) ? getPresetLevelNumber(presetB) : 99;
        if (levelA !== levelB) return levelA - levelB;
      }
      return nameA.localeCompare(nameB);
    });
  }

  function getEligibleSpellSlugs(profile){
    const allowedLevel = maxSpellLevelForCharacter(getPlayerLevel(profile));
    const slugs = [];
    cachedSpellPresets.forEach((preset) => {
      const level = getPresetLevelNumber(preset);
      if (Number.isFinite(level) && level > allowedLevel){
        return;
      }
      const slug = getPresetSlug(preset);
      if (slug){
        slugs.push(slug);
      }
    });
    return sortSlugsByName(Array.from(new Set(slugs.map(normalizeTextValue).filter(Boolean))));
  }

  function getSpellLibraryDescription(data){
    if (!data || typeof data !== "object") return "";
    const text = data.text && typeof data.text === "object" ? data.text : null;
    const importRaw = data.import && typeof data.import === "object" ? data.import.raw : null;
    const summary = normalizeTextValue(text?.summary);
    if (summary) return summary;
    const rules = normalizeTextValue(text?.rules);
    if (rules) return rules;
    const description = normalizeTextValue(importRaw?.description);
    if (description) return description;
    return "";
  }

  function formatSpellLibraryLevel(level){
    const num = Number(level);
    if (!Number.isFinite(num)) return "Level ?";
    if (num === 0) return "Cantrip";
    return `Level ${num}`;
  }

  function formatSpellLibraryList(values){
    if (!Array.isArray(values) || !values.length) return "";
    return values.map((value) => formatListGroupLabel(value)).join(", ");
  }

  function normalizeSpellSourceKey(value){
    return String(value || "")
      .toLowerCase()
      .replaceAll("", "'")
      .replace(/\[[^\]]*\]/g, "")
      .replace(/[^a-z0-9]+/g, " ")
      .trim()
      .replace(/\s+/g, " ");
  }

  function spellSourcePageForRecord(record){
    const pages = rulesSpellPagesCache && typeof rulesSpellPagesCache === "object" ? rulesSpellPagesCache : null;
    if (!pages) return null;
    const candidates = [record?.name, record?.id ? String(record.id).replace(/[-_]+/g, " ") : ""];
    for (const candidate of candidates){
      const key = normalizeSpellSourceKey(candidate);
      if (!key) continue;
      const page = Number(pages[key]);
      if (Number.isFinite(page) && page > 0){
        return page;
      }
    }
    return null;
  }

  function buildSpellLibrarySearchText(record){
    const parts = [
      record.id,
      record.name,
      record.school,
      record.castingTime,
      record.range,
      record.duration,
      record.components,
      record.classes.join(" "),
      record.tags.join(" "),
      record.description,
    ];
    return parts.filter(Boolean).join(" ").toLowerCase();
  }

  function buildSpellLibraryRecord(entry){
    const parsed = entry && typeof entry === "object" ? entry.parsed : null;
    const data = parsed && typeof parsed === "object" ? parsed : null;
    const id = String(entry?.id || data?.id || "").trim();
    const name = typeof data?.name === "string" ? data.name : (id || "Unknown Spell");
    const level = Number.isFinite(data?.level) ? Number(data.level) : null;
    const classes = Array.isArray(data?.lists?.classes) ? data.lists.classes.filter(Boolean) : [];
    const tags = Array.isArray(data?.tags) ? data.tags.filter(Boolean) : [];
    const record = {
      id,
      name,
      level,
      classes,
      tags,
      school: normalizeTextValue(data?.school),
      castingTime: normalizeTextValue(data?.casting_time),
      range: normalizeTextValue(data?.range),
      duration: normalizeTextValue(data?.duration),
      components: normalizeTextValue(data?.components),
      ritual: data?.ritual,
      concentration: data?.concentration,
      description: getSpellLibraryDescription(data),
      color: normalizeHexColor(data?.color || ""),
      data,
      error: entry?.error,
    };
    record.searchText = buildSpellLibrarySearchText(record);
    return record;
  }

  async function loadSpellLibrary(){
    if (spellLibraryLoadPromise) return spellLibraryLoadPromise;
    spellLibraryLoadPromise = (async () => {
      if (spellLibraryStatus) spellLibraryStatus.textContent = "Loading spells";
      let ids = [];
      let bulkRecords = null;
      try {
        const response = await fetch("/api/spells?details=true");
        const payload = await response.json();
        if (Array.isArray(payload?.ids)){
          ids = payload.ids;
        }
        if (Array.isArray(payload?.spells)){
          bulkRecords = payload.spells;
        }
        spellLibraryLoadError = "";
      } catch (err){
        spellLibraryLoadError = "Unable to load spells.";
        if (spellLibraryStatus) spellLibraryStatus.textContent = spellLibraryLoadError;
        return [];
      }
      let results = bulkRecords;
      if (!Array.isArray(results) || !results.length){
        results = await Promise.all(
          ids.map(async (spellId) => {
            try {
              const response = await fetch(`/api/spells/${encodeURIComponent(spellId)}`);
              if (!response.ok){
                throw new Error(`HTTP ${response.status}`);
              }
              return await response.json();
            } catch (err){
              return {id: spellId, raw: null, parsed: null, error: String(err)};
            }
          })
        );
      }
      spellLibraryRecords = results.map(buildSpellLibraryRecord);
      return spellLibraryRecords;
    })();
    return spellLibraryLoadPromise;
  }

  function renderSpellLibrary(){
    if (!spellLibraryList) return;
    const query = spellLibrarySearchTerm.trim().toLowerCase();
    let records = spellLibraryRecords;
    if (query){
      records = records.filter((record) => record.searchText.includes(query));
    }
    if (!records.length && spellLibraryLoadError){
      if (spellLibraryStatus) spellLibraryStatus.textContent = spellLibraryLoadError;
      spellLibraryList.innerHTML = "";
      return;
    }
    const sorted = records.slice().sort((a, b) => {
      if (spellLibrarySortMode === "level"){
        const levelA = Number.isFinite(a.level) ? a.level : 999;
        const levelB = Number.isFinite(b.level) ? b.level : 999;
        if (levelA !== levelB) return levelA - levelB;
      }
      return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
    });
    spellLibraryList.innerHTML = "";
    if (spellLibraryStatus){
      spellLibraryStatus.textContent = sorted.length
        ? `${sorted.length} spell${sorted.length === 1 ? "" : "s"}`
        : "No spells match that search.";
    }
    if (!sorted.length) return;
    const fragment = document.createDocumentFragment();
    sorted.forEach((record) => {
      const details = document.createElement("details");
      details.className = "spell-library-card";
      const summary = document.createElement("summary");
      summary.className = "spell-library-summary";
      const title = document.createElement("span");
      title.className = "spell-library-summary-title";
      title.textContent = record.name || record.id || "Unnamed Spell";
      const meta = document.createElement("span");
      meta.className = "spell-library-summary-meta";
      meta.textContent = formatSpellLibraryLevel(record.level);
      summary.appendChild(title);
      summary.appendChild(meta);
      details.appendChild(summary);

      const body = document.createElement("div");
      body.className = "spell-library-detail-body";
      if (record.error && !record.data){
        const errorText = document.createElement("div");
        errorText.className = "spell-library-detail-description";
        errorText.textContent = "Spell data unavailable.";
        body.appendChild(errorText);
        details.appendChild(body);
        fragment.appendChild(details);
        return;
      }

      const grid = document.createElement("div");
      grid.className = "spell-library-detail-grid";
      const addRow = (label, value) => {
        if (!value && value !== 0) return;
        const labelEl = document.createElement("div");
        labelEl.className = "spell-library-detail-label";
        labelEl.textContent = label;
        const valueEl = document.createElement("div");
        valueEl.className = "spell-library-detail-value";
        valueEl.textContent = String(value);
        grid.appendChild(labelEl);
        grid.appendChild(valueEl);
      };

      addRow("Level", formatSpellLevelLabel(record.level));
      addRow("School", record.school);
      addRow("Casting Time", record.castingTime);
      addRow("Range", record.range);
      addRow("Duration", record.duration);
      addRow("Components", record.components);
      addRow("Classes", formatSpellLibraryList(record.classes));
      addRow("Tags", formatSpellLibraryList(record.tags));
      addRow("Ritual", record.ritual === true ? "Yes" : record.ritual === false ? "No" : "");
      addRow("Concentration", record.concentration === true ? "Yes" : record.concentration === false ? "No" : "");
      body.appendChild(grid);

      if (record.description){
        const description = document.createElement("div");
        description.className = "spell-library-detail-description";
        description.textContent = record.description;
        body.appendChild(description);
      }

      const sourcePage = spellSourcePageForRecord(record);
      if (sourcePage){
        const sourceRow = document.createElement("div");
        sourceRow.className = "spell-library-action-row";
        const sourceBtn = document.createElement("button");
        sourceBtn.className = "btn";
        sourceBtn.type = "button";
        sourceBtn.textContent = "Open Source";
        sourceBtn.addEventListener("click", (event) => {
          event.stopPropagation();
          showHelpModal();
          ensureRulesData()
            .then(() => jumpRulesPage(sourcePage))
            .catch(() => setHelpMessage("Failed to load rules metadata."));
        });
        sourceRow.appendChild(sourceBtn);
        body.appendChild(sourceRow);
      }

      const preset = spellPresetBySlug.get(getSpellKey(record.id))
        || cachedSpellPresets.find((entry) => normalizeLowerValue(entry?.name) === normalizeLowerValue(record.name));
      if (preset){
        const colorRow = document.createElement("div");
        colorRow.className = "spell-library-action-row";
        const colorWrap = document.createElement("div");
        colorWrap.className = "spell-library-color-row";
        const swatch = document.createElement("span");
        swatch.className = "spell-color-swatch";
        swatch.style.background = resolveSpellColor(preset.color);
        const colorLabel = document.createElement("span");
        colorLabel.className = "spell-library-detail-value";
        colorLabel.textContent = normalizeHexColor(preset.color || "") || "Default";
        colorWrap.appendChild(swatch);
        colorWrap.appendChild(colorLabel);
        const colorBtn = document.createElement("button");
        colorBtn.className = "btn";
        colorBtn.type = "button";
        colorBtn.textContent = "Edit Color";
        colorBtn.addEventListener("click", (event) => {
          event.stopPropagation();
          openSpellDetailOverlay(preset);
        });
        colorRow.appendChild(colorWrap);
        colorRow.appendChild(colorBtn);
        body.appendChild(colorRow);
      }

      details.appendChild(body);
      fragment.appendChild(details);
    });
    spellLibraryList.appendChild(fragment);
  }

  function openSpellLibraryOverlay(open){
    if (!spellLibraryOverlay) return;
    spellLibraryOverlay.classList.toggle("show", open);
    spellLibraryOverlay.setAttribute("aria-hidden", open ? "false" : "true");
    if (open){
      spellLibraryPreviousFocus = document.activeElement instanceof HTMLElement
        ? document.activeElement
        : null;
      if (spellLibrarySearchInput) spellLibrarySearchInput.value = spellLibrarySearchTerm;
      if (spellLibrarySortSelect) spellLibrarySortSelect.value = spellLibrarySortMode;
      loadSpellLibrary().then(() => renderSpellLibrary());
      if (spellLibrarySearchInput) spellLibrarySearchInput.focus();
    } else if (spellLibraryPreviousFocus){
      spellLibraryPreviousFocus.focus();
      spellLibraryPreviousFocus = null;
    }
  }

  function setSpellbookStatus(text){
    if (!spellbookStatus) return;
    spellbookStatus.textContent = text || "";
  }

  function toggleSpellbookSelection(slug, selectionSet){
    if (selectionSet.has(slug)){
      selectionSet.delete(slug);
    } else {
      selectionSet.add(slug);
    }
  }

  function renderSpellbookList(listEl, slugs, selectionSet, emptyLabel){
    if (!listEl) return;
    listEl.textContent = "";
    if (!slugs.length){
      const empty = document.createElement("div");
      empty.className = "spellbook-item";
      empty.textContent = emptyLabel || "No spells available.";
      empty.style.opacity = "0.6";
      listEl.appendChild(empty);
      return;
    }
    slugs.forEach((slug) => {
      const preset = spellPresetBySlug.get(getSpellKey(slug));
      const label = normalizeTextValue(preset?.name || slug);
      const level = getPresetLevelNumber(preset);
      const displayColor = resolveSpellColor(preset?.color);
      const item = document.createElement("button");
      item.type = "button";
      item.className = "spellbook-item";
      if (selectionSet.has(slug)){
        item.classList.add("selected");
        item.style.borderColor = displayColor;
        const highlight = rgbaFromHex(displayColor, 0.18);
        if (highlight){
          item.style.background = highlight;
        }
      }
      item.addEventListener("click", () => {
        toggleSpellbookSelection(slug, selectionSet);
        renderSpellbook();
      });
      const nameWrap = document.createElement("span");
      nameWrap.className = "spellbook-item-name";
      const colorDot = document.createElement("span");
      colorDot.className = "spellbook-color-dot";
      colorDot.style.background = displayColor;
      nameWrap.appendChild(colorDot);
      const nameSpan = document.createElement("span");
      nameSpan.textContent = label;
      nameWrap.appendChild(nameSpan);
      item.appendChild(nameWrap);
      const meta = document.createElement("small");
      if (Number.isFinite(level)){
        meta.textContent = level === 0 ? "Cantrip" : `Lv ${level}`;
      } else {
        meta.textContent = "Level ?";
      }
      item.appendChild(meta);
      listEl.appendChild(item);
    });
  }

  function resetSpellbookSelections(){
    spellbookLeftSelection = new Set();
    spellbookRightSelection = new Set();
  }

  function renderSpellbook(){
    const playerName = getClaimedPlayerName();
    const profile = playerName ? getPlayerProfile(playerName) : null;
    if (!profile){
      setSpellbookStatus("Claim a character to manage spells.");
      return;
    }
    if (spellbookKnownEnabledToggle){
      spellbookKnownEnabledToggle.checked = spellbookKnownEnabled;
    }
    if (spellbookTabKnown){
      spellbookTabKnown.classList.toggle("hidden", !spellbookKnownEnabled);
      spellbookTabKnown.classList.toggle("accent", spellbookMode === "known");
    }
    if (!spellbookKnownEnabled && spellbookMode === "known"){
      spellbookMode = "prepared";
    }
    if (spellbookTabPrepared){
      spellbookTabPrepared.classList.toggle("accent", spellbookMode === "prepared");
    }
    const eligibleSlugs = getEligibleSpellSlugs(profile);
    const rightSlugs = spellbookMode === "prepared"
      ? Array.from(pendingPreparedSet)
      : Array.from(new Set([...pendingKnownSet, ...pendingCantripsSet]));
    const rightSet = new Set(rightSlugs.map(getSpellKey));
    let leftSlugs = [];
    if (spellbookMode === "known"){
      leftSlugs = eligibleSlugs.filter((slug) => !rightSet.has(getSpellKey(slug)));
      if (spellbookLeftTitle) spellbookLeftTitle.textContent = "Eligible Spells";
      if (spellbookRightTitle) spellbookRightTitle.textContent = "Known & Cantrips";
    } else {
      if (spellbookKnownEnabled){
        const knownSlugs = sortSlugsByName(Array.from(new Set([...pendingKnownSet, ...pendingCantripsSet])));
        leftSlugs = knownSlugs.filter((slug) => !rightSet.has(getSpellKey(slug)));
        if (spellbookLeftTitle) spellbookLeftTitle.textContent = "Known & Cantrips";
      } else {
        leftSlugs = eligibleSlugs.filter((slug) => !rightSet.has(getSpellKey(slug)));
        if (spellbookLeftTitle) spellbookLeftTitle.textContent = "Eligible Spells";
      }
      if (spellbookRightTitle) spellbookRightTitle.textContent = "Prepared Spells";
    }
    const emptyLabel = spellbookSearchTerm.trim() ? "No spells match that search." : "No spells available.";
    const filteredLeft = filterSpellbookSlugs(leftSlugs);
    const filteredRight = filterSpellbookSlugs(rightSlugs);
    renderSpellbookList(spellbookLeftList, sortSpellbookSlugs(filteredLeft), spellbookLeftSelection, emptyLabel);
    renderSpellbookList(spellbookRightList, sortSpellbookSlugs(filteredRight), spellbookRightSelection, emptyLabel);
    const preparedCount = Array.from(pendingPreparedSet).filter((slug) => !pendingPreparedFreeSet.has(slug)).length;
    const preparedLimitLabel = Number.isFinite(spellbookPreparedLimit)
      ? `${preparedCount}/${spellbookPreparedLimit} prepared`
      : `${preparedCount} prepared`;
    const knownCount = Array.from(pendingKnownSet).filter((slug) => !pendingKnownFreeSet.has(slug)).length;
    const knownLimitLabel = Number.isFinite(spellbookKnownLimit)
      ? `${knownCount}/${spellbookKnownLimit} known`
      : `${knownCount} known`;
    const cantripCount = pendingCantripsSet.size;
    const cantripLimitLabel = Number.isFinite(spellbookCantripsMax)
      ? `${cantripCount}/${spellbookCantripsMax} cantrips`
      : `${cantripCount} cantrips`;
    setSpellbookStatus(`${knownLimitLabel}  ${cantripLimitLabel}  ${preparedLimitLabel}`);
  }

  function syncSpellbookClaimedPlayer(){
    const playerName = getClaimedPlayerName();
    const config = getSpellbookConfig(playerName);
    spellbookKnownEnabled = config.knownEnabled !== false;
    spellbookKnownLimit = config.knownLimit;
    spellbookPreparedLimit = config.max;
    spellbookCantripsMax = config.cantripsMax;
    pendingKnownSet = new Set(config.known.map(normalizeTextValue).filter(Boolean));
    pendingPreparedSet = new Set(config.prepared.map(normalizeTextValue).filter(Boolean));
    pendingKnownFreeSet = new Set(
      config.knownFree
        .map(normalizeTextValue)
        .filter((slug) => Boolean(slug) && pendingKnownSet.has(slug))
    );
    pendingPreparedFreeSet = new Set(
      config.preparedFree
        .map(normalizeTextValue)
        .filter((slug) => Boolean(slug) && pendingPreparedSet.has(slug))
    );
    pendingCantripsSet = new Set(config.cantrips.map(normalizeTextValue).filter(Boolean));
    spellbookMode = spellbookKnownEnabled ? "known" : "prepared";
    resetSpellbookSelections();
  }

  function openSpellbookOverlay(open){
    if (!spellbookOverlay) return;
    if (open && (claimedCid === null || claimedCid === undefined)){
      allowUnclaimed = false;
      localToast("Select your character to manage spells.");
      updateClaimOverlay();
      return;
    }
    spellbookOverlay.classList.toggle("show", open);
    spellbookOverlay.setAttribute("aria-hidden", open ? "false" : "true");
    if (open){
      spellbookPreviousFocus = document.activeElement instanceof HTMLElement
        ? document.activeElement
        : null;
      syncSpellbookClaimedPlayer();
      if (spellbookSearchInput) spellbookSearchInput.value = spellbookSearchTerm;
      if (spellbookSortSelect) spellbookSortSelect.value = spellbookSortMode;
      renderSpellbook();
      requestAnimationFrame(() => {
        spellbookBackBtn?.focus();
      });
    } else if (spellbookPreviousFocus){
      closeSpellDetailOverlay();
      spellbookPreviousFocus.focus();
      spellbookPreviousFocus = null;
    }
    updateModalOffsets();
    resize();
  }

  function applySpellbookAdd(){
    if (!spellbookLeftSelection.size) return;
    const additions = Array.from(spellbookLeftSelection);
    if (spellbookMode === "prepared"){
      additions.forEach((slug) => {
        if (pendingPreparedSet.has(slug)) return;
        const nextCount = Array.from(pendingPreparedSet).filter((item) => !pendingPreparedFreeSet.has(item)).length + 1;
        if (Number.isFinite(spellbookPreparedLimit) && nextCount > spellbookPreparedLimit){
          localToast(`Prepared spells limited to ${spellbookPreparedLimit}.`);
          return;
        }
        pendingPreparedSet.add(slug);
      });
    } else {
      additions.forEach((slug) => {
        const level = getPresetLevelBySlug(slug);
        if (level === 0){
          const nextCount = pendingCantripsSet.size + 1;
          if (Number.isFinite(spellbookCantripsMax) && nextCount > spellbookCantripsMax){
            localToast(`Cantrips limited to ${spellbookCantripsMax}.`);
            return;
          }
          pendingCantripsSet.add(slug);
        } else {
          if (!spellbookKnownEnabled){
            return;
          }
          const nextCount = Array.from(pendingKnownSet).filter((item) => !pendingKnownFreeSet.has(item)).length + 1;
          if (Number.isFinite(spellbookKnownLimit) && nextCount > spellbookKnownLimit){
            localToast(`Known spells limited to ${spellbookKnownLimit}.`);
            return;
          }
          pendingKnownSet.add(slug);
        }
      });
    }
    resetSpellbookSelections();
    renderSpellbook();
  }

  function applySpellbookRemove(){
    if (!spellbookRightSelection.size) return;
    const removals = Array.from(spellbookRightSelection);
    if (spellbookMode === "prepared"){
      removals.forEach((slug) => {
        pendingPreparedSet.delete(slug);
        pendingPreparedFreeSet.delete(slug);
      });
    } else {
      removals.forEach((slug) => {
        const level = getPresetLevelBySlug(slug);
        if (level === 0){
          pendingCantripsSet.delete(slug);
        } else {
          pendingKnownSet.delete(slug);
          pendingKnownFreeSet.delete(slug);
        }
      });
    }
    resetSpellbookSelections();
    renderSpellbook();
  }

  function showSpellbookConfirm(){
    if (!spellbookConfirmModal) return;
    const playerName = getClaimedPlayerName() || "player";
    const fileName = playerName.replace(/[^a-z0-9._-]+/gi, "-");
    if (spellbookConfirmText){
      spellbookConfirmText.textContent = `Overwrite players/${fileName}.yaml?`;
    }
    spellbookConfirmModal.classList.add("show");
    spellbookConfirmModal.setAttribute("aria-hidden", "false");
  }

  function hideSpellbookConfirm(){
    if (!spellbookConfirmModal) return;
    spellbookConfirmModal.classList.remove("show");
    spellbookConfirmModal.setAttribute("aria-hidden", "true");
  }

  async function saveSpellbookChanges(){
    const playerName = getClaimedPlayerName();
    if (!playerName){
      localToast("Claim a character first.");
      return;
    }
    const payload = {
      known_enabled: spellbookKnownEnabled,
      known_list: Array.from(pendingKnownSet),
      prepared_list: Array.from(pendingPreparedSet),
      cantrips_list: Array.from(pendingCantripsSet),
    };
    try {
      const response = await fetch(`/api/players/${encodeURIComponent(playerName)}/spellbook`, {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify(payload),
      });
      if (!response.ok){
        throw new Error(`Failed (${response.status})`);
      }
      const data = await response.json();
      if (data?.player && state?.player_profiles){
        state.player_profiles[data.player.name] = data.player;
      }
      localToast("Spellbook saved.");
      hideSpellbookConfirm();
      refreshSpellPresetOptions();
    } catch (err){
      console.warn("Failed to save spellbook.", err);
      localToast("Unable to save spellbook.");
    }
  }

  function setSpellDetailStatus(text){
    if (!spellDetailStatus) return;
    spellDetailStatus.textContent = text || "";
  }

  function updateSpellDetailColorInputs(color){
    const fallback = color || DEFAULT_SPELL_COLOR;
    if (spellDetailColorSwatch){
      spellDetailColorSwatch.style.background = fallback;
    }
    if (spellDetailColorInput){
      spellDetailColorInput.value = fallback;
    }
    if (spellDetailColorValue){
      spellDetailColorValue.value = color ? color.toUpperCase() : fallback.toUpperCase();
    }
  }

  async function saveSpellDetailColor(slug, color){
    if (!slug) return;
    setSpellDetailStatus("Saving color");
    try {
      const response = await fetch(`/api/spells/${encodeURIComponent(slug)}/color`, {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({color}),
      });
      if (!response.ok){
        throw new Error(`Failed (${response.status})`);
      }
      const data = await response.json();
      const updatedColor = normalizeHexColor(data?.spell?.color || color) || color;
      const preset = spellPresetBySlug.get(getSpellKey(slug));
      if (preset){
        preset.color = updatedColor;
      }
      updateSpellPresetOptions(cachedSpellPresets);
      updateSpellPresetDetails(preset || null);
      if (spellDetailOverlay?.classList.contains("show")){
        renderSpellDetailOverlay(preset || null);
      }
      setSpellDetailStatus("Color saved.");
    } catch (err){
      console.warn("Failed to save spell color.", err);
      setSpellDetailStatus("Unable to save color.");
      localToast("Unable to save spell color.");
    }
  }

  function renderSpellDetailOverlay(preset){
    if (!spellDetailGrid || !spellDetailName || !spellDetailMeta) return;
    if (!preset){
      spellDetailName.textContent = "Spell";
      spellDetailMeta.textContent = "";
      spellDetailGrid.textContent = "";
      updateSpellDetailColorInputs("");
      setSpellDetailStatus("");
      return;
    }
    const name = normalizeTextValue(preset.name) || normalizeTextValue(preset.slug) || "Spell";
    const levelLabel = formatSpellLevelLabel(preset.level);
    const school = normalizeTextValue(preset.school) || "Unknown";
    spellDetailName.textContent = name;
    spellDetailMeta.textContent = `${levelLabel}  ${school}`;
    const color = normalizeHexColor(preset.color || "");
    const displayColor = resolveSpellColor(preset.color);
    updateSpellDetailColorInputs(displayColor || "");
    setSpellDetailStatus("");
    const fields = [
      {label: "Level", value: levelLabel},
      {label: "School", value: school},
    ];
    const optionalFields = buildOptionalSpellDetails(preset);
    spellDetailGrid.textContent = "";
    [...fields, ...optionalFields].forEach((field) => {
      if (!field || (!field.value && field.value !== 0)) return;
      const row = document.createElement("div");
      row.className = "spell-details-row";
      const label = document.createElement("span");
      label.className = "spell-details-label";
      label.textContent = field.label;
      const value = document.createElement("span");
      value.className = "spell-details-value";
      value.textContent = field.value || "";
      row.appendChild(label);
      row.appendChild(value);
      spellDetailGrid.appendChild(row);
    });
  }

  function openSpellDetailOverlay(preset){
    if (!spellDetailOverlay) return;
    if (!preset){
      return;
    }
    activeSpellDetailSlug = getPresetSlug(preset);
    spellDetailOverlay.classList.add("show");
    spellDetailOverlay.setAttribute("aria-hidden", "false");
    spellDetailPreviousFocus = document.activeElement instanceof HTMLElement ? document.activeElement : null;
    if (spellDetailTitle){
      spellDetailTitle.textContent = normalizeTextValue(preset.name) || "Spell Details";
    }
    renderSpellDetailOverlay(preset);
    if (spellDetailBackBtn){
      spellDetailBackBtn.focus();
    }
  }

  function closeSpellDetailOverlay(){
    if (!spellDetailOverlay) return;
    spellDetailOverlay.classList.remove("show");
    spellDetailOverlay.setAttribute("aria-hidden", "true");
    activeSpellDetailSlug = null;
    if (spellDetailPreviousFocus){
      spellDetailPreviousFocus.focus();
      spellDetailPreviousFocus = null;
    }
  }

  function commitSpellDetailColor(raw){
    const color = normalizeHexColor(raw || "");
    if (!color){
      localToast("Pick a valid hex color, matey.");
      return;
    }
    updateSpellDetailColorInputs(color);
    if (activeSpellDetailSlug){
      saveSpellDetailColor(activeSpellDetailSlug, color);
    }
  }

  const updateSpellPresetDetails = (preset) => {
    if (!spellPresetDetails) return;
    if (!preset){
      spellPresetDetails.textContent = "Select a preset to see spell details.";
      updateManualEntryBadge(null);
      return;
    }
    updateManualEntryBadge(preset);
    const detailsGrid = document.createElement("div");
    detailsGrid.className = "spell-details-grid";
    const levelLabel = formatSpellLevelLabel(preset.level);
    const tags = Array.isArray(preset.tags) ? preset.tags.filter(Boolean) : [];
    const tagLabel = tags.length ? tags.join(", ") : "";
    const castingTime = normalizeTextValue(preset.casting_time) || "";
    const range = normalizeTextValue(preset.range) || "";
    const ritual = preset.ritual === true ? "Yes" : preset.ritual === false ? "No" : "";
    const concentration = preset.concentration === true ? "Yes" : preset.concentration === false ? "No" : "";
    const color = normalizeHexColor(preset.color || "");
    const displayColor = resolveSpellColor(preset.color);
    const lists = getSpellListEntries(preset.lists);
    const listLabel = lists.length
      ? lists.map((entry) => `${formatListGroupLabel(entry.group)}: ${entry.value}`).join("  ")
      : "";
    const fields = [
      {label: "Level", value: levelLabel},
      {label: "School", value: normalizeTextValue(preset.school) || ""},
      {label: "Tags", value: tagLabel},
      {label: "Casting", value: castingTime},
      {label: "Range", value: range},
      {label: "Ritual", value: ritual},
      {label: "Concentration", value: concentration},
      {label: "Lists", value: listLabel},
      {label: "Color", value: color || displayColor, color: displayColor},
    ];
    fields.forEach((field) => {
      const row = document.createElement("div");
      row.className = "spell-details-row";
      const label = document.createElement("span");
      label.className = "spell-details-label";
      label.textContent = field.label;
      const value = document.createElement("span");
      value.className = "spell-details-value";
      if (field.color){
        const swatch = document.createElement("span");
        swatch.className = "spell-color-swatch";
        swatch.style.background = field.color;
        value.appendChild(swatch);
        const text = document.createElement("span");
        text.textContent = ` ${field.value}`;
        value.appendChild(text);
      } else {
        value.textContent = field.value;
      }
      row.appendChild(label);
      row.appendChild(value);
      detailsGrid.appendChild(row);
    });
    spellPresetDetails.textContent = "";
    spellPresetDetails.appendChild(detailsGrid);
  };
  function formatSpellDamageLabel(preset){
    const base = preset?.default_damage ?? preset?.dice ?? "";
    const baseLabel = base !== null && base !== undefined && String(base).trim() ? String(base).trim() : "";
    const damageTypes = Array.isArray(preset?.damage_types)
      ? preset.damage_types.map((entry) => String(entry || "").trim()).filter(Boolean)
      : [];
    if (baseLabel && damageTypes.length){
      return `${baseLabel} (${damageTypes.join(", ")})`;
    }
    if (baseLabel) return baseLabel;
    if (damageTypes.length) return damageTypes.join(", ");
    return "";
  }
  function hasAoeShape(preset){
    if (!preset || typeof preset !== "object") return false;
    return Boolean(
      preset.shape ||
      preset.radius_ft ||
      preset.side_ft ||
      preset.length_ft ||
      preset.width_ft ||
      preset.angle_deg ||
      preset.height_ft ||
      preset.thickness_ft
    );
  }
  function buildOptionalSpellDetails(preset){
    if (!preset || typeof preset !== "object") return [];
    const tags = Array.isArray(preset.tags) ? preset.tags.filter(Boolean) : [];
    const lists = getSpellListEntries(preset.lists);
    const listLabel = lists.length
      ? lists.map((entry) => `${formatListGroupLabel(entry.group)}: ${entry.value}`).join("  ")
      : "";
    const fields = [
      {label: "Casting Time", value: normalizeTextValue(preset.casting_time)},
      {label: "Range", value: normalizeTextValue(preset.range)},
      {label: "Ritual", value: preset.ritual === true ? "Yes" : preset.ritual === false ? "No" : ""},
      {label: "Concentration", value: preset.concentration === true ? "Yes" : preset.concentration === false ? "No" : ""},
      {label: "Tags", value: tags.length ? tags.join(", ") : ""},
      {label: "Lists", value: listLabel},
      {label: "Shape", value: normalizeTextValue(preset.shape)},
      {label: "Radius (ft)", value: Number.isFinite(Number(preset.radius_ft)) ? String(preset.radius_ft) : ""},
      {label: "Side (ft)", value: Number.isFinite(Number(preset.side_ft)) ? String(preset.side_ft) : ""},
      {label: "Length (ft)", value: Number.isFinite(Number(preset.length_ft)) ? String(preset.length_ft) : ""},
      {label: "Width (ft)", value: Number.isFinite(Number(preset.width_ft)) ? String(preset.width_ft) : ""},
      {label: "Angle (deg)", value: Number.isFinite(Number(preset.angle_deg)) ? String(preset.angle_deg) : ""},
      {label: "Height (ft)", value: Number.isFinite(Number(preset.height_ft)) ? String(preset.height_ft) : ""},
      {label: "Duration (turns)", value: Number.isFinite(Number(preset.duration_turns)) ? String(preset.duration_turns) : ""},
      {label: "Save", value: preset.save_type ? String(preset.save_type || "").toUpperCase() : ""},
      {label: "Save DC", value: Number.isFinite(Number(preset.save_dc)) ? String(preset.save_dc) : ""},
      {label: "Damage", value: formatSpellDamageLabel(preset)},
      {label: "Half on Save", value: preset.half_on_pass ? "Yes" : ""},
      {label: "Automation", value: normalizeTextValue(preset.automation)},
    ];
    return fields.filter((field) => field.value);
  }
  const spellFilterState = {
    search: "",
    levelMin: "",
    levelMax: "",
    schools: [],
    tags: [],
    castingTime: "",
    range: "",
    ritualOnly: false,
    concentrationOnly: false,
    lists: [],
  };

  const readCheckedValues = (container) => {
    if (!container) return [];
    return Array.from(container.querySelectorAll('input[type="checkbox"]:checked')).map((input) => String(input.value || "")).filter(Boolean);
  };

  const updateMultiSelectSummary = (detailsEl, label, values) => {
    if (!detailsEl) return;
    const summary = detailsEl.querySelector('summary');
    if (!summary) return;
    summary.textContent = values.length ? `${label}: ${values.join(', ')}` : `${label}: Any`;
  };

  const renderCheckboxOptions = (container, values, selectedValues, name) => {
    if (!container) return;
    const selected = new Set((selectedValues || []).map(normalizeLowerValue));
    container.textContent = "";
    values.forEach((value, idx) => {
      const id = `${name}_${idx}`;
      const label = document.createElement('label');
      const input = document.createElement('input');
      input.type = 'checkbox';
      input.id = id;
      input.value = value;
      input.checked = selected.has(normalizeLowerValue(value));
      label.appendChild(input);
      const span = document.createElement('span');
      span.textContent = value;
      label.appendChild(span);
      container.appendChild(label);
    });
  };

  const updateSelectOptions = (selectEl, values) => {
    if (!selectEl) return;
    const currentValue = selectEl.value;
    selectEl.textContent = '';
    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = 'Any';
    selectEl.appendChild(placeholder);
    values.forEach((value) => {
      const opt = document.createElement('option');
      opt.value = value;
      opt.textContent = value;
      selectEl.appendChild(opt);
    });
    selectEl.value = values.includes(currentValue) ? currentValue : '';
  };

  const loadSpellFilterState = () => {
    try {
      const raw = localStorage.getItem(spellFilterStorageKey);
      if (!raw) return;
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== 'object') return;
      spellFilterState.search = normalizeTextValue(parsed.search);
      spellFilterState.levelMin = normalizeTextValue(parsed.levelMin);
      spellFilterState.levelMax = normalizeTextValue(parsed.levelMax);
      spellFilterState.schools = Array.isArray(parsed.schools) ? parsed.schools.map(normalizeTextValue).filter(Boolean) : [];
      spellFilterState.tags = Array.isArray(parsed.tags) ? parsed.tags.map(normalizeTextValue).filter(Boolean) : [];
      spellFilterState.castingTime = normalizeTextValue(parsed.castingTime);
      spellFilterState.range = normalizeTextValue(parsed.range);
      spellFilterState.ritualOnly = parsed.ritualOnly === true;
      spellFilterState.concentrationOnly = parsed.concentrationOnly === true;
      spellFilterState.lists = Array.isArray(parsed.lists) ? parsed.lists.map(normalizeTextValue).filter(Boolean) : [];
    } catch (err){
      console.warn('Unable to load spell filter state.', err);
    }
  };

  const saveSpellFilterState = () => {
    try {
      localStorage.setItem(spellFilterStorageKey, JSON.stringify(spellFilterState));
    } catch (err){
      console.warn('Unable to save spell filter state.', err);
    }
  };

  const syncSpellFilterInputsFromState = () => {
    if (castSearchInput) castSearchInput.value = spellFilterState.search;
    if (castFilterLevelMinInput) castFilterLevelMinInput.value = spellFilterState.levelMin;
    if (castFilterLevelMaxInput) castFilterLevelMaxInput.value = spellFilterState.levelMax;
    if (castFilterCastingTimeInput) castFilterCastingTimeInput.value = spellFilterState.castingTime;
    if (castFilterRangeInput) castFilterRangeInput.value = spellFilterState.range;
    if (castFilterRitualInput) castFilterRitualInput.checked = spellFilterState.ritualOnly;
    if (castFilterConcentrationInput) castFilterConcentrationInput.checked = spellFilterState.concentrationOnly;
  };

  const applySpellFilterStateFromInputs = () => {
    spellFilterState.search = normalizeTextValue(castSearchInput?.value);
    spellFilterState.levelMin = normalizeTextValue(castFilterLevelMinInput?.value);
    spellFilterState.levelMax = normalizeTextValue(castFilterLevelMaxInput?.value);
    spellFilterState.schools = readCheckedValues(castFilterSchoolOptions);
    spellFilterState.tags = readCheckedValues(castFilterTagOptions);
    spellFilterState.castingTime = normalizeTextValue(castFilterCastingTimeInput?.value);
    spellFilterState.range = normalizeTextValue(castFilterRangeInput?.value);
    spellFilterState.ritualOnly = castFilterRitualInput?.checked === true;
    spellFilterState.concentrationOnly = castFilterConcentrationInput?.checked === true;
    spellFilterState.lists = readCheckedValues(castFilterListOptions);
    saveSpellFilterState();
  };

  const updateSpellFilterSummary = () => {
    const parts = [];
    if (spellFilterState.search) parts.push(`Search: ${spellFilterState.search}`);
    if (spellFilterState.levelMin || spellFilterState.levelMax){
      const from = spellFilterState.levelMin || 'Any';
      const to = spellFilterState.levelMax || 'Any';
      parts.push(`Level: ${from}-${to}`);
    }
    if (spellFilterState.schools.length) parts.push(`School: ${spellFilterState.schools.join(', ')}`);
    if (spellFilterState.tags.length) parts.push(`Tags: ${spellFilterState.tags.join(', ')}`);
    if (spellFilterState.lists.length) parts.push(`Lists: ${spellFilterState.lists.join(', ')}`);
    if (spellFilterState.castingTime) parts.push(`Casting: ${spellFilterState.castingTime}`);
    if (spellFilterState.range) parts.push(`Range: ${spellFilterState.range}`);
    if (spellFilterState.ritualOnly) parts.push('Ritual only');
    if (spellFilterState.concentrationOnly) parts.push('Concentration only');
    if (spellFilterSummary){
      spellFilterSummary.textContent = parts.length ? parts.join('  ') : 'No filters active.';
    }
    updateMultiSelectSummary(castFilterSchoolMulti, 'Schools', spellFilterState.schools);
    updateMultiSelectSummary(castFilterTagMulti, 'Tags', spellFilterState.tags);
    updateMultiSelectSummary(castFilterListMulti, 'Lists', spellFilterState.lists);
  };

  const updateSpellFilterOptions = () => {
    const schools = new Set();
    const castingTimes = new Set();
    const ranges = new Set();
    const tags = new Set();
    const lists = new Set();
    cachedSpellPresets.forEach((preset) => {
      const school = normalizeTextValue(preset.school);
      if (school) schools.add(school);
      const castingTime = normalizeTextValue(preset.casting_time);
      if (castingTime) castingTimes.add(castingTime);
      const range = normalizeTextValue(preset.range);
      if (range) ranges.add(range);
      (Array.isArray(preset.tags) ? preset.tags : []).forEach((tag) => {
        const value = normalizeTextValue(tag);
        if (value) tags.add(value);
      });
      getSpellListEntries(preset.lists).forEach((entry) => {
        lists.add(`${formatListGroupLabel(entry.group)}: ${entry.value}`);
      });
    });
    renderCheckboxOptions(castFilterSchoolOptions, Array.from(schools).sort((a,b)=>a.localeCompare(b)), spellFilterState.schools, 'school_filter');
    renderCheckboxOptions(castFilterTagOptions, Array.from(tags).sort((a,b)=>a.localeCompare(b)), spellFilterState.tags, 'tag_filter');
    renderCheckboxOptions(castFilterListOptions, Array.from(lists).sort((a,b)=>a.localeCompare(b)), spellFilterState.lists, 'list_filter');
    updateSelectOptions(castFilterCastingTimeInput, Array.from(castingTimes).sort((a,b)=>a.localeCompare(b)));
    updateSelectOptions(castFilterRangeInput, Array.from(ranges).sort((a,b)=>a.localeCompare(b)));
    syncSpellFilterInputsFromState();
    updateSpellFilterSummary();
  };

  const matchesSpellFilters = (preset) => {
    const levelNum = getPresetLevelNumber(preset);
    const min = spellFilterState.levelMin === '' ? null : Number(spellFilterState.levelMin);
    const max = spellFilterState.levelMax === '' ? null : Number(spellFilterState.levelMax);
    if (Number.isFinite(levelNum)){
      if (min !== null && levelNum < min) return false;
      if (max !== null && levelNum > max) return false;
    }

    if (spellFilterState.schools.length){
      const selected = spellFilterState.schools.map(normalizeLowerValue);
      if (!selected.includes(normalizeLowerValue(preset.school))) return false;
    }

    if (spellFilterState.castingTime){
      if (!normalizeLowerValue(preset.casting_time).includes(normalizeLowerValue(spellFilterState.castingTime))) return false;
    }
    if (spellFilterState.range){
      if (!normalizeLowerValue(preset.range).includes(normalizeLowerValue(spellFilterState.range))) return false;
    }
    if (spellFilterState.ritualOnly && preset.ritual !== true) return false;
    if (spellFilterState.concentrationOnly && preset.concentration !== true) return false;

    if (spellFilterState.tags.length){
      const presetTags = Array.isArray(preset.tags) ? preset.tags.map(normalizeLowerValue) : [];
      if (!spellFilterState.tags.every((tag) => presetTags.includes(normalizeLowerValue(tag)))) return false;
    }

    if (spellFilterState.lists.length){
      const presetLists = getSpellListEntries(preset.lists).map((entry) => `${formatListGroupLabel(entry.group)}: ${entry.value}`.toLowerCase());
      if (!spellFilterState.lists.every((item) => presetLists.includes(item.toLowerCase()))) return false;
    }

    if (spellFilterState.search){
      const haystack = [preset.name, preset.description, preset.casting_time, preset.range, preset.school, ...(Array.isArray(preset.tags) ? preset.tags : [])]
        .map(normalizeLowerValue)
        .join(' ');
      if (!haystack.includes(normalizeLowerValue(spellFilterState.search))) return false;
    }
    return true;
  };

  loadSpellFilterState();

  const refreshSpellPresetOptions = () => {
    if (!castPresetInput) return;
    const currentValue = String(castPresetInput.value || "");
    castPresetInput.textContent = "";
    castPresetInput.disabled = false;

    const customOption = document.createElement("option");
    customOption.value = "";
    customOption.textContent = "Custom";
    castPresetInput.appendChild(customOption);

    const customSummonOption = document.createElement("option");
    customSummonOption.value = CUSTOM_SUMMON_PRESET_NAME;
    customSummonOption.textContent = CUSTOM_SUMMON_PRESET_NAME;
    castPresetInput.appendChild(customSummonOption);

    const availablePresets = cachedSpellPresets.slice();
    const preparedSpellSet = getPreparedSpellFilterSet();
    const filtered = filterPresetsByKnownList(availablePresets, preparedSpellSet)
      .filter(matchesSpellFilters);

    const groups = new Map();
    filtered.forEach((preset) => {
      const level = getPresetLevelNumber(preset);
      const key = level === null ? "unknown" : String(level);
      if (!groups.has(key)){
        groups.set(key, []);
      }
      groups.get(key).push(preset);
    });
    const orderedLevels = [];
    for (let i = 0; i <= 9; i += 1){
      if (groups.has(String(i))){
        orderedLevels.push(String(i));
      }
    }
    if (groups.has("unknown")){
      orderedLevels.push("unknown");
    }
    orderedLevels.forEach((levelKey) => {
      const list = groups.get(levelKey) || [];
      list.sort((a, b) => normalizeTextValue(a.name).localeCompare(normalizeTextValue(b.name)));
      const optgroup = document.createElement("optgroup");
      optgroup.label = levelKey === "unknown"
        ? "Unknown Level"
        : formatSpellLevelLabel(Number(levelKey));
      list.forEach((preset) => {
        const name = normalizeTextValue(preset.name);
        if (!name) return;
        const opt = document.createElement("option");
        opt.value = name;
        const playerName = getClaimedPlayerName();
        const poolEntry = getPoolGrantedSpellEntries(playerName).find((entry) => getSpellKey(entry.spell || entry.slug || entry.id) === getSpellKey(getPresetSlug(preset)));
        if (poolEntry){
          const consumes = poolEntry.consumes_pool && typeof poolEntry.consumes_pool === "object" ? poolEntry.consumes_pool : {};
          const label = normalizeTextValue(consumes.label || consumes.id || consumes.pool || "Pool");
          const cost = Number.isFinite(Number(consumes.cost)) ? Math.max(1, Math.floor(Number(consumes.cost))) : 1;
          const pool = getPlayerResourcePools(getClaimedPlayerName()).find((entry) => getSpellKey(entry.id) === getSpellKey(consumes.id || consumes.pool));
          const freeText = pool && Number(pool.current) >= cost ? `free (${label} -${cost})` : `pool empty (${label})`;
          opt.textContent = `${name}  ${freeText}`;
        } else {
          opt.textContent = name;
        }
        optgroup.appendChild(opt);
      });
      if (optgroup.children.length){
        castPresetInput.appendChild(optgroup);
      }
    });

    if (!filtered.length){
      const empty = document.createElement("option");
      empty.value = "";
      empty.textContent = "No spells match filters";
      empty.disabled = true;
      castPresetInput.appendChild(empty);
    }

    const validValues = new Set(filtered.map((preset) => normalizeTextValue(preset.name)));
    validValues.add("");
    validValues.add(CUSTOM_SUMMON_PRESET_NAME);
    castPresetInput.value = validValues.has(currentValue) ? currentValue : "";
    updateSpellPresetDetails(getSelectedSpellPreset());
  };

  const updateSpellPresetOptions = (presets) => {
    const list = normalizeSpellPresets(presets);
    refreshCustomSummonMonsterOptions();
    const signature = JSON.stringify(list.map(p => [
      String(p.slug || ""),
      String(p.name || ""),
      String(p.shape || ""),
      String(p.level || ""),
      String(p.school || ""),
      String(p.casting_time || ""),
      String(p.range || ""),
      String(p.ritual || ""),
      String(p.concentration || ""),
      String(p.color || ""),
      String(p.is_aoe || ""),
      String(p.action_type || ""),
      JSON.stringify(p.tags || []),
      JSON.stringify(p.lists || {}),
      JSON.stringify(p.upcast || {}),
      JSON.stringify(p.scaling || {}),
      JSON.stringify(p.summon || {}),
      String(p.isAoE || ""),
      String(p.isSummon || ""),
    ]));
    if (signature === lastSpellPresetSignature){
      return;
    }
    lastSpellPresetSignature = signature;
    cachedSpellPresets = list;
    spellPresetBySlug = new Map();
    list.forEach((preset) => {
      const slug = getPresetSlug(preset);
      if (slug){
        spellPresetBySlug.set(getSpellKey(slug), preset);
      }
    });
    updateSpellFilterOptions();
    refreshSpellPresetOptions();
    if (spellbookOverlay?.classList.contains("show")){
      renderSpellbook();
    }
  };

  const registerSpellFilterListener = (input, useInputEvent = false) => {
    if (!input) return;
    const handler = () => {
      applySpellFilterStateFromInputs();
      updateSpellFilterSummary();
      refreshSpellPresetOptions();
    };
    input.addEventListener('change', handler);
    if (useInputEvent){
      input.addEventListener('input', handler);
    }
  };

  registerSpellFilterListener(castSearchInput, true);
  registerSpellFilterListener(castFilterLevelMinInput);
  registerSpellFilterListener(castFilterLevelMaxInput);
  registerSpellFilterListener(castFilterCastingTimeInput);
  registerSpellFilterListener(castFilterRangeInput);
  registerSpellFilterListener(castFilterRitualInput);
  registerSpellFilterListener(castFilterConcentrationInput);

  [castFilterSchoolOptions, castFilterTagOptions, castFilterListOptions].forEach((container) => {
    container?.addEventListener('change', () => {
      applySpellFilterStateFromInputs();
      updateSpellFilterSummary();
      refreshSpellPresetOptions();
    });
  });

  openSpellFiltersBtn?.addEventListener('click', () => {
    spellFilterModal?.classList.add('show');
    spellFilterModal?.setAttribute('aria-hidden', 'false');
  });
  closeSpellFiltersBtn?.addEventListener('click', () => {
    spellFilterModal?.classList.remove('show');
    spellFilterModal?.setAttribute('aria-hidden', 'true');
  });
  applySpellFiltersBtn?.addEventListener('click', () => {
    applySpellFilterStateFromInputs();
    updateSpellFilterSummary();
    refreshSpellPresetOptions();
    spellFilterModal?.classList.remove('show');
    spellFilterModal?.setAttribute('aria-hidden', 'true');
  });
  const clearSpellFilters = () => {
    Object.assign(spellFilterState, {
      search: '', levelMin: '', levelMax: '', schools: [], tags: [], castingTime: '', range: '', ritualOnly: false, concentrationOnly: false, lists: [],
    });
    saveSpellFilterState();
    updateSpellFilterOptions();
    refreshSpellPresetOptions();
  };
  clearSpellFiltersBtn?.addEventListener('click', () => {
    clearSpellFilters();
  });

  const setCastFieldEnabled = (input, enabled) => {
    if (!input) return;
    input.disabled = !enabled;
    input.readOnly = !enabled;
  };

  const setCastFieldVisible = (field, visible) => {
    if (!field) return;
    field.style.display = visible ? "" : "none";
  };

  const titleCaseFromSlug = (value) => normalizeTextValue(value)
    .split("-")
    .filter(Boolean)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join(" ");

  const getSummonChoices = (preset) => {
    const choices = Array.isArray(preset?.summon?.choices) ? preset.summon.choices : [];
    return choices.filter((choice) => choice && typeof choice === "object").map((choice) => {
      const slug = normalizeTextValue(choice.monster_slug);
      const fallback = titleCaseFromSlug(slug);
      return {
        ...choice,
        monster_slug: slug,
        variants: Array.isArray(choice.variants) ? choice.variants.map(v => normalizeTextValue(v)).filter(Boolean) : [],
        name: normalizeTextValue(choice.name) || fallback || "Unknown creature",
      };
    });
  };

  const getSpellAppearanceOptions = (preset) => {
    const topLevelOptions = preset?.appearance_options;
    const mechanicsOptions = preset?.mechanics?.ui?.appearance_options;
    const options = Array.isArray(topLevelOptions)
      ? topLevelOptions
      : (Array.isArray(mechanicsOptions) ? mechanicsOptions : []);
    return options.map((option) => String(option || "").trim()).filter(Boolean);
  };

  const getSummonQuantityRule = (preset, slotLevel, selectedChoice) => {
    const count = preset?.summon?.count;
    if (!count || typeof count !== "object") return {min: 1, max: 1, fixed: 1};
    const selectedSlug = normalizeTextValue(selectedChoice);
    const parseEntries = (entry) => {
      if (!entry || typeof entry !== "object") return [];
      const options = Array.isArray(entry.options) ? entry.options : [entry];
      return options
        .filter(opt => opt && typeof opt === "object")
        .map((opt) => {
          const qty = Number(opt.quantity);
          const creatureOptions = Array.isArray(opt.creature_options)
            ? opt.creature_options.map((slug) => normalizeTextValue(slug)).filter(Boolean)
            : [];
          return {
            quantity: Number.isFinite(qty) && qty > 0 ? Math.floor(qty) : null,
            creature_options: creatureOptions,
          };
        })
        .filter(opt => Number.isFinite(opt.quantity));
    };
    const pickBySlot = () => {
      const base = count.base && typeof count.base === "object" ? count.base : null;
      const overrides = Array.isArray(count.slot_overrides) ? count.slot_overrides : [];
      const slot = Number.isFinite(Number(slotLevel)) ? Math.floor(Number(slotLevel)) : Number(base?.slot_level || preset?.level || 0);
      const match = overrides.find((entry) => Number(entry?.slot_level) === slot);
      return parseEntries(match || base);
    };
    let quantities = [];
    if (count.kind === "variable_by_slot"){
      quantities = pickBySlot();
    } else {
      const min = Number(count.min);
      const max = Number(count.max);
      if (Number.isFinite(min) && Number.isFinite(max)){
        return {min: Math.floor(min), max: Math.floor(max), fixed: min === max ? Math.floor(min) : null};
      }
      quantities = parseEntries(count);
    }
    if (!quantities.length){
      return {min: 1, max: 1, fixed: 1};
    }
    const matching = selectedSlug
      ? quantities.filter((item) => !item.creature_options.length || item.creature_options.includes(selectedSlug))
      : quantities;
    const pool = matching.length ? matching : quantities;
    const values = Array.from(new Set(pool.map(item => item.quantity))).sort((a, b) => a - b);
    if (!values.length){
      return {min: 1, max: 1, fixed: 1};
    }
    return {
      min: values[0],
      max: values[values.length - 1],
      fixed: values.length === 1 ? values[0] : null,
    };
  };

  let castSummonValidation = {ok: true, reason: ""};
  const validateSummonForm = (preset, showToast = false) => {
    if (!isSummonPreset(preset)){
      castSummonValidation = {ok: true, reason: ""};
      if (castSubmitBtn) castSubmitBtn.disabled = false;
      return castSummonValidation;
    }
    const choices = getSummonChoices(preset);
    const selectedChoice = normalizeTextValue(castSummonChoiceInput?.value || choices[0]?.monster_slug || "");
    const quantityRule = getSummonQuantityRule(preset, Number(castSlotLevelInput?.value), selectedChoice);
    const rawQty = Number(castSummonQuantityInput?.value);
    const selectedVariant = normalizeTextValue(castSummonVariantInput?.value || "");
    const quantity = Number.isFinite(rawQty) ? Math.floor(rawQty) : null;
    let reason = "";
    if (!selectedChoice){
      reason = "Pick a summon option first, matey.";
    } else if (preset?.summon?.mount && !selectedVariant){
      reason = "Pick a mount variant first, matey.";
    } else if (!Number.isFinite(quantity) || quantity <= 0){
      reason = "Enter a valid summon quantity, matey.";
    } else if (quantityRule.fixed !== null && quantity !== quantityRule.fixed){
      reason = `This spell summons exactly ${quantityRule.fixed}.`;
    } else if (quantity < quantityRule.min || quantity > quantityRule.max){
      reason = `Summon quantity must be between ${quantityRule.min} and ${quantityRule.max}.`;
    }
    castSummonValidation = {ok: !reason, reason};
    if (castSubmitBtn) castSubmitBtn.disabled = !castSummonValidation.ok;
    if (showToast && reason){
      localToast(reason);
    }
    return castSummonValidation;
  };

  const updateSummonOptions = (preset) => {
    const summonSpell = isSummonPreset(preset);
    const customSummon = Boolean(preset?.isCustomSummon);
    const appearanceOptions = getSpellAppearanceOptions(preset);
    const hasAppearanceOptions = !summonSpell && appearanceOptions.length > 0;
    if (summonOptions){
      summonOptions.classList.toggle("hidden", !summonSpell);
    }
    if (aoeOptions){
      aoeOptions.classList.toggle("hidden", summonSpell);
    }
    castSummonChoiceField?.classList.toggle("hidden", customSummon || !summonSpell);
    castSummonQuantityField?.classList.toggle("hidden", !summonSpell);
    castSummonVariantField?.classList.toggle("hidden", customSummon || (!summonSpell && !hasAppearanceOptions));
    castCustomSummonNameField?.classList.toggle("hidden", !customSummon);
    castCustomSummonMonsterSearchField?.classList.toggle("hidden", !customSummon);
    castCustomSummonMonsterField?.classList.toggle("hidden", !customSummon);
    castCustomSummonTypeField?.classList.toggle("hidden", !customSummon);
    castCustomSummonHpField?.classList.toggle("hidden", !customSummon);
    castCustomSummonAcField?.classList.toggle("hidden", !customSummon);
    castCustomSummonWalkField?.classList.toggle("hidden", !customSummon);
    castCustomSummonSwimField?.classList.toggle("hidden", !customSummon);
    castCustomSummonFlyField?.classList.toggle("hidden", !customSummon);
    castCustomSummonBurrowField?.classList.toggle("hidden", !customSummon);
    castCustomSummonClimbField?.classList.toggle("hidden", !customSummon);
    castCustomSummonStrField?.classList.toggle("hidden", !customSummon);
    castCustomSummonDexField?.classList.toggle("hidden", !customSummon);
    castCustomSummonConField?.classList.toggle("hidden", !customSummon);
    castCustomSummonIntField?.classList.toggle("hidden", !customSummon);
    castCustomSummonWisField?.classList.toggle("hidden", !customSummon);
    castCustomSummonChaField?.classList.toggle("hidden", !customSummon);
    castCustomSummonRangeField?.classList.toggle("hidden", !customSummon);

    const disableForSummon = (input) => {
      if (!input) return;
      input.disabled = summonSpell;
      if (summonSpell && !customSummon){
        input.readOnly = true;
      }
    };
    [castShapeInput, castDefaultDamageInput, castDiceInput, castDamageTypeInput, castAddDamageTypeBtn, castColorInput].forEach(disableForSummon);
    if (!summonSpell){
      if (castSummonVariantLabel){
        castSummonVariantLabel.textContent = hasAppearanceOptions ? "Appearance" : "Variant";
      }
      if (castSummonVariantInput){
        const currentAppearance = String(castSummonVariantInput.value || "").trim();
        castSummonVariantInput.innerHTML = "";
        if (hasAppearanceOptions){
          appearanceOptions.forEach((option) => {
            const opt = document.createElement("option");
            opt.value = option;
            opt.textContent = option;
            castSummonVariantInput.appendChild(opt);
          });
          castSummonVariantInput.value = currentAppearance || appearanceOptions[0] || "";
        } else {
          castSummonVariantInput.value = "";
        }
      }
      if (castShapeInput) castShapeInput.readOnly = false;
      if (castDefaultDamageInput) castDefaultDamageInput.readOnly = false;
      if (castDiceInput) castDiceInput.readOnly = false;
      if (castDamageTypeInput) castDamageTypeInput.readOnly = false;
      if (castColorInput) castColorInput.readOnly = false;
      if (castSummonMeta) castSummonMeta.textContent = "";
      if (castSubmitBtn) castSubmitBtn.disabled = false;
      return;
    }

    if (customSummon){
      const hasMonsterSelection = normalizeTextValue(castCustomSummonMonsterInput?.value);
      refreshCustomSummonMonsterOptions();
      const selectedChoice = getSelectedCustomSummonChoice();
      if (!hasMonsterSelection || !selectedChoice || selectedChoice.slug !== hasMonsterSelection){
        applyCustomSummonTemplate(selectedChoice || null, !hasMonsterSelection);
      }
      if (castSummonQuantityInput){
        const currentQty = Number(castSummonQuantityInput.value);
        castSummonQuantityInput.min = "1";
        castSummonQuantityInput.max = "20";
        castSummonQuantityInput.value = String(Number.isFinite(currentQty) && currentQty > 0 ? Math.floor(currentQty) : 1);
        castSummonQuantityInput.readOnly = false;
      }
      if (castCustomSummonRangeInput){
        const currentRange = Number(castCustomSummonRangeInput.value);
        castCustomSummonRangeInput.value = String(Number.isFinite(currentRange) && currentRange >= 0 ? Math.floor(currentRange) : 30);
      }
      if (castSummonMeta){
        const qty = Math.max(1, Math.floor(Number(castSummonQuantityInput?.value || 1)));
        const range = Math.max(0, Math.floor(Number(castCustomSummonRangeInput?.value || 30)));
        const monsterLabel = selectedChoice ? `${selectedChoice.name} (${selectedChoice.slug})` : "manual";
        castSummonMeta.textContent = `Custom summon placement  Source: ${monsterLabel}  Quantity: ${qty}  Range: ${range} ft`;
      }
      castSummonValidation = {ok: true, reason: ""};
      if (castSubmitBtn) castSubmitBtn.disabled = false;
      return;
    }

    const choices = getSummonChoices(preset);
    if (castSummonChoiceInput){
      const current = normalizeTextValue(castSummonChoiceInput.value);
      castSummonChoiceInput.innerHTML = "";
      choices.forEach((choice) => {
        const opt = document.createElement("option");
        opt.value = choice.monster_slug;
        const desc = normalizeTextValue(choice.description || choice.notes);
        opt.textContent = desc ? `${choice.name}  ${desc}` : choice.name;
        castSummonChoiceInput.appendChild(opt);
      });
      castSummonChoiceInput.value = current || choices[0]?.monster_slug || "";
      if (!castSummonChoiceInput.value && choices[0]?.monster_slug){
        castSummonChoiceInput.value = choices[0].monster_slug;
      }
    }
    const selectedChoice = normalizeTextValue(castSummonChoiceInput?.value || choices[0]?.monster_slug || "");
    const selectedChoiceEntry = choices.find((choice) => normalizeTextValue(choice.monster_slug) === selectedChoice) || choices[0] || null;
    const variants = Array.isArray(selectedChoiceEntry?.variants) ? selectedChoiceEntry.variants : [];
    if (castSummonVariantInput){
      const currentVariant = normalizeTextValue(castSummonVariantInput.value || "");
      castSummonVariantInput.innerHTML = "";
      const mountMode = Boolean(preset?.summon?.mount);
      if (castSummonVariantLabel){
        castSummonVariantLabel.textContent = "Variant";
      }
      castSummonVariantField?.classList.toggle("hidden", !mountMode);
      if (mountMode){
        variants.forEach((variant) => {
          const opt = document.createElement("option");
          opt.value = variant;
          opt.textContent = variant;
          castSummonVariantInput.appendChild(opt);
        });
        castSummonVariantInput.value = currentVariant || variants[0] || "";
      }
    }
    const rule = getSummonQuantityRule(preset, Number(castSlotLevelInput?.value), selectedChoice);
    if (castSummonQuantityInput){
      castSummonQuantityInput.min = String(rule.min);
      castSummonQuantityInput.max = String(rule.max);
      if (rule.fixed !== null){
        castSummonQuantityInput.value = String(rule.fixed);
        castSummonQuantityInput.readOnly = true;
      } else {
        const currentQty = Number(castSummonQuantityInput.value);
        const nextQty = Number.isFinite(currentQty)
          ? Math.min(rule.max, Math.max(rule.min, Math.floor(currentQty)))
          : rule.min;
        castSummonQuantityInput.value = String(nextQty);
        castSummonQuantityInput.readOnly = false;
      }
    }
    if (castSummonMeta){
      const initiativeMode = normalizeTextValue(preset?.summon?.initiative?.mode);
      const controlCommands = normalizeTextValue(preset?.summon?.control?.commands);
      const quantityInfo = rule.fixed !== null
        ? `Quantity: fixed at ${rule.fixed}`
        : `Quantity: ${rule.min}${rule.max}`;
      const metaBits = [quantityInfo];
      if (initiativeMode){
        metaBits.push(`Initiative: ${initiativeMode.replace(/_/g, " ")}`);
      }
      if (controlCommands){
        metaBits.push(`Control: ${controlCommands}`);
      }
      castSummonMeta.textContent = metaBits.join("  ");
    }
    validateSummonForm(preset, false);
  };

  const updateCastShapeFields = () => {
    const preset = getSelectedSpellPreset();
    if (isSummonPreset(preset)){
      [castRadiusField, castSideField, castLengthField, castWidthField, castAngleField, castOrientField, castThicknessField, castHeightField].forEach((field) => setCastFieldVisible(field, false));
      [castRadiusInput, castSideInput, castLengthInput, castWidthInput, castAngleInput, castOrientInput, castThicknessInput, castHeightInput].forEach((input) => setCastFieldEnabled(input, false));
      return;
    }
    const isAoeSpell = resolveSpellActionTag(preset) === "aoe";
    const automationLevel = normalizeLowerValue(preset?.automation || preset?.mechanics?.automation);
    if ((preset && !isAoeSpell) || automationLevel === "full"){
      [castRadiusField, castSideField, castLengthField, castWidthField, castAngleField, castOrientField, castThicknessField, castHeightField].forEach((field) => setCastFieldVisible(field, false));
      [castRadiusInput, castSideInput, castLengthInput, castWidthInput, castAngleInput, castOrientInput, castThicknessInput, castHeightInput].forEach((input) => setCastFieldEnabled(input, false));
      return;
    }
    const shape = String(castShapeInput?.value || "").toLowerCase();
    const usesRadius = shape === "circle" || shape === "sphere" || shape === "cylinder";
    const usesSide = shape === "square" || shape === "cube";
    const usesLength = shape === "line" || shape === "cone" || shape === "wall";
    const usesWidth = shape === "line" || shape === "wall";
    const usesAngle = shape === "line" || shape === "cone" || shape === "wall";
    const usesOrient = shape === "line" || shape === "cone" || shape === "wall";
    const usesThickness = shape === "wall";
    const usesHeight = shape === "wall" || shape === "cylinder";
    setCastFieldVisible(castRadiusField, usesRadius);
    setCastFieldVisible(castSideField, usesSide);
    setCastFieldVisible(castLengthField, usesLength);
    setCastFieldVisible(castWidthField, usesWidth);
    setCastFieldVisible(castAngleField, usesAngle);
    setCastFieldVisible(castOrientField, usesOrient);
    setCastFieldVisible(castThicknessField, usesThickness);
    setCastFieldVisible(castHeightField, usesHeight);
    setCastFieldEnabled(castRadiusInput, usesRadius);
    setCastFieldEnabled(castSideInput, usesSide);
    setCastFieldEnabled(castLengthInput, usesLength);
    setCastFieldEnabled(castWidthInput, usesWidth);
    setCastFieldEnabled(castAngleInput, usesAngle);
    setCastFieldEnabled(castOrientInput, usesOrient);
    setCastFieldEnabled(castThicknessInput, usesThickness);
    setCastFieldEnabled(castHeightInput, usesHeight);
  };

  const updateCastAutomationFields = (preset) => {
    if (!preset){
      setCastFieldVisible(castShapeField, true);
      setCastFieldEnabled(castShapeInput, true);
      [castDcTypeField, castDcValueField, castDefaultDamageField, castDiceField].forEach((field) => setCastFieldVisible(field, true));
      [castDcTypeInput, castDcValueInput, castDefaultDamageInput, castDiceInput].forEach((input) => setCastFieldEnabled(input, true));
      return;
    }
    const summonSpell = isSummonPreset(preset);
    const spellActionTag = resolveSpellActionTag(preset);
    const isAoeSpell = spellActionTag === "aoe";
    const automationLevel = normalizeLowerValue(preset?.automation || preset?.mechanics?.automation);
    const fullyAutomated = automationLevel === "full";
    const showShapeField = !summonSpell && isAoeSpell && !fullyAutomated;
    setCastFieldVisible(castShapeField, showShapeField);
    setCastFieldEnabled(castShapeInput, showShapeField);
    const showManualDamageFields = !summonSpell && !fullyAutomated;
    setCastFieldVisible(castDcTypeField, showManualDamageFields);
    setCastFieldEnabled(castDcTypeInput, showManualDamageFields);
    setCastFieldVisible(castDcValueField, showManualDamageFields);
    setCastFieldEnabled(castDcValueInput, showManualDamageFields);
    setCastFieldVisible(castDefaultDamageField, showManualDamageFields);
    setCastFieldEnabled(castDefaultDamageInput, showManualDamageFields);
    setCastFieldVisible(castDiceField, showManualDamageFields);
    setCastFieldEnabled(castDiceInput, showManualDamageFields);
  };

  if (castShapeInput){
    castShapeInput.addEventListener("change", updateCastShapeFields);
    updateCastShapeFields();
  }
  updateSummonOptions(null);
  updateCastAutomationFields(getSelectedSpellPreset());

  const parseDiceSpec = (value) => {
    if (typeof value !== "string") return null;
    const raw = value.trim().toLowerCase();
    const match = raw.match(/^(\\d+)d(4|6|8|10|12)$/);
    if (!match) return null;
    const count = Number(match[1]);
    const sides = Number(match[2]);
    if (!Number.isFinite(count) || count <= 0) return null;
    return {count, sides};
  };

  const formatDiceSpec = (spec) => `${spec.count}d${spec.sides}`;

  const normalizeUpcastConfig = (upcast) => {
    if (!upcast || typeof upcast !== "object") return null;
    const baseLevel = Number(upcast.base_level);
    if (!Number.isFinite(baseLevel) || baseLevel < 0){
      console.warn("Invalid upcast base_level; ignoring upcast config.", upcast);
      return null;
    }
    const rawIncrements = Array.isArray(upcast.increments) ? upcast.increments : [];
    const increments = [];
    const slotAddDice = typeof upcast.add_per_slot_above === "string" ? upcast.add_per_slot_above : "";
    if (slotAddDice && parseDiceSpec(slotAddDice)){
      increments.push({
        levels_per_increment: 1,
        add_dice: slotAddDice,
      });
    }
    rawIncrements.forEach((entry) => {
      if (!entry || typeof entry !== "object"){
        console.warn("Invalid upcast increment entry; skipping.", entry);
        return;
      }
      const addDice = typeof entry.add_dice === "string" ? entry.add_dice : "";
      if (!parseDiceSpec(addDice)){
        console.warn("Invalid upcast add_dice; skipping.", entry);
        return;
      }
      const levelsPer = Number(entry.levels_per_increment);
      if (Number.isFinite(levelsPer) && levelsPer > 0){
        increments.push({
          levels_per_increment: levelsPer,
          add_dice: addDice,
        });
        return;
      }
      const levelThreshold = Number(entry.level);
      if (Number.isFinite(levelThreshold) && levelThreshold > baseLevel){
        increments.push({
          level: levelThreshold,
          add_dice: addDice,
        });
        return;
      }
      console.warn("Invalid upcast increment entry; skipping.", entry);
    });
    if (!increments.length){
      console.warn("Upcast increments contained no valid entries; ignoring upcast config.", upcast);
      return null;
    }
    return {base_level: baseLevel, increments};
  };

  const computeUpcastValues = (baseDice, baseDefaultDamage, upcastConfig, slotLevel) => {
    if (!upcastConfig || !Number.isFinite(slotLevel)) return {dice: baseDice, defaultDamage: baseDefaultDamage};
    const baseLevel = Number(upcastConfig.base_level);
    if (!Number.isFinite(baseLevel)) return {dice: baseDice, defaultDamage: baseDefaultDamage};
    const deltaLevels = Math.floor(slotLevel - baseLevel);
    if (deltaLevels <= 0) return {dice: baseDice, defaultDamage: baseDefaultDamage};
    const baseDiceSpec = parseDiceSpec(baseDice) || parseDiceSpec(baseDefaultDamage);
    let totalDiceSpec = baseDiceSpec ? {count: baseDiceSpec.count, sides: baseDiceSpec.sides} : null;
    let applied = false;
    (upcastConfig.increments || []).forEach((inc) => {
      const addDiceSpec = parseDiceSpec(inc.add_dice);
      if (!addDiceSpec) return;
      let steps = 0;
      const levelsPer = Number(inc.levels_per_increment);
      if (Number.isFinite(levelsPer) && levelsPer > 0){
        steps = Math.floor(deltaLevels / levelsPer);
      } else {
        const levelThreshold = Number(inc.level);
        if (Number.isFinite(levelThreshold) && slotLevel >= levelThreshold){
          steps = 1;
        }
      }
      if (steps <= 0) return;
      const addCount = addDiceSpec.count * steps;
      if (!totalDiceSpec){
        totalDiceSpec = {count: addCount, sides: addDiceSpec.sides};
        applied = true;
        return;
      }
      if (totalDiceSpec.sides !== addDiceSpec.sides){
        console.warn("Upcast dice sides mismatch; skipping increment.", inc);
        return;
      }
      totalDiceSpec.count += addCount;
      applied = true;
    });
    const dice = totalDiceSpec ? formatDiceSpec(totalDiceSpec) : baseDice;
    let defaultDamage = baseDefaultDamage;
    if (applied){
      const defaultDamageDice = parseDiceSpec(baseDefaultDamage);
      if (defaultDamageDice || baseDefaultDamage === null || baseDefaultDamage === ""){
        defaultDamage = dice;
      }
    }
    return {dice, defaultDamage};
  };

  const castDamageTypes = new Set();
  let castDurationTurns = null;
  let castOverTime = null;
  let castMovePerTurnFt = null;
  let castTriggerOnStartOrEnter = null;
  let castPersistent = null;
  let castPinnedDefault = null;
  let castUpcastConfig = null;
  let castBaseDice = null;
  let castBaseDefaultDamage = null;
  function clearSpellTargetingSession(showToastMessage = ""){
    pendingSpellTargeting = null;
    if (attackOverlayMode){
      setAttackOverlayMode(false);
    }
    if (showToastMessage){
      localToast(showToastMessage);
    }
  }
  function consumeSpellTargetingShot(){
    if (!pendingSpellTargeting){
      return;
    }
    pendingSpellTargeting.remainingShots = Math.max(0, Number(pendingSpellTargeting.remainingShots || 0) - 1);
    if (pendingSpellTargeting.remainingShots <= 0){
      clearSpellTargetingSession("");
    } else {
      localToast(`${pendingSpellTargeting.remainingShots} target${pendingSpellTargeting.remainingShots === 1 ? "" : "s"} remaining.`);
    }
  }
  function getSpellTargetingConfig(preset, slotLevel){
    if (!preset || isAoePreset(preset) || isSummonPreset(preset)){
      return null;
    }
    const uiConfig = preset?.mechanics?.ui?.spell_targeting;
    const modeRaw = normalizeLowerValue(uiConfig?.mode);
    const mode = modeRaw || resolveSpellActionTag(preset);
    if (!mode) return null;
    const baseCount = Number(uiConfig?.projectiles_base);
    const addPerSlot = Number(uiConfig?.add_per_slot_above);
    const baseSlotLevel = Number.isFinite(Number(uiConfig?.base_slot_level))
      ? Math.floor(Number(uiConfig.base_slot_level))
      : Math.max(0, Math.floor(Number(preset?.level || 0)));
    const selectedSlot = Number.isFinite(Number(slotLevel)) ? Math.floor(Number(slotLevel)) : baseSlotLevel;
    const countBase = Number.isFinite(baseCount) && baseCount > 0 ? Math.floor(baseCount) : 1;
    const countAdd = Number.isFinite(addPerSlot) ? Math.floor(addPerSlot) : 0;
    const projectileCount = Math.max(1, countBase + Math.max(0, selectedSlot - baseSlotLevel) * countAdd);
    const damageTypes = Array.from(castDamageTypes);
    const fallbackType = String((Array.isArray(preset?.damage_types) ? preset.damage_types[0] : "") || "").trim().toLowerCase();
    if (!damageTypes.length && fallbackType){
      damageTypes.push(fallbackType);
    }
    const description = normalizeTextValue(preset?.description) || "";
    const targetSideRaw = normalizeLowerValue(uiConfig?.target_side);
    const targetSide = targetSideRaw === "friendly" ? "friendly" : "enemy";
    const overlayColor = normalizeHexColor(uiConfig?.overlay_color || "");
    const skipResolveAttack = hasSpellTag(preset, "skip_resolve_attack");
    return {
      mode,
      rangeFt: parseSpellTargetRangeFeet(preset),
      saveType: normalizeLowerValue(preset?.save_type),
      saveDc: Number.isFinite(Number(castDcValueInput?.value)) ? Math.floor(Number(castDcValueInput.value)) : null,
      damageType: damageTypes[0] || "",
      damageDice: String(castDiceInput?.value || castDefaultDamageInput?.value || "").trim(),
      damageDiceWhenWounded: String(uiConfig?.damage_dice_when_wounded || "").trim(),
      description,
      projectileCount,
      targetSide,
      overlayColor,
      skipResolveAttack,
    };
  }
  function startSpellTargetingSession(config, preset, slotLevel){
    if (!config) return;
    pendingSpellTargeting = {
      mode: config.mode,
      spellName: String(castNameInput?.value || preset?.name || "Spell").trim() || "Spell",
      spellSlug: normalizeTextValue(preset?.slug) || null,
      spellId: normalizeTextValue(preset?.id) || null,
      slotLevel: Number.isFinite(Number(slotLevel)) ? Math.floor(Number(slotLevel)) : null,
      rangeFt: Number.isFinite(Number(config.rangeFt)) ? Number(config.rangeFt) : null,
      saveType: config.saveType || "",
      saveDc: Number.isFinite(Number(config.saveDc)) ? Number(config.saveDc) : null,
      damageType: String(config.damageType || "").trim().toLowerCase(),
      damageDice: String(config.damageDice || "").trim(),
      damageDiceWhenWounded: String(config.damageDiceWhenWounded || "").trim(),
      description: String(config.description || "").trim(),
      remainingShots: Math.max(1, Number(config.projectileCount || 1)),
      targetSide: String(config.targetSide || "enemy").toLowerCase() === "friendly" ? "friendly" : "enemy",
      overlayColor: normalizeHexColor(config.overlayColor || "") || null,
      skipResolveAttack: config.skipResolveAttack === true,
    };
    setCastOverlayOpen(false);
    setAttackOverlayMode(true);
    const shotLabel = pendingSpellTargeting.remainingShots > 1
      ? ` (${pendingSpellTargeting.remainingShots} targets)`
      : "";
    localToast(`Select target${shotLabel} for ${pendingSpellTargeting.spellName}.`);
  }
  const setCastDamageTypes = (types) => {
    castDamageTypes.clear();
    if (Array.isArray(types)){
      types.forEach((entry) => {
        const dtype = String(entry || "").trim();
        if (dtype){
          castDamageTypes.add(dtype);
        }
      });
    }
    if (castDamageTypeInput){
      const firstType = Array.from(castDamageTypes)[0] || "";
      const selectValues = Array.from(castDamageTypeInput.options || []).map((opt) => String(opt?.value || "").trim());
      castDamageTypeInput.value = firstType && selectValues.includes(firstType) ? firstType : "";
    }
    renderCastDamageTypes();
  };
  const renderCastDamageTypes = () => {
    if (!castDamageTypeList) return;
    castDamageTypeList.textContent = "";
    for (const dtype of castDamageTypes){
      const chip = document.createElement("span");
      chip.className = "chip damage-type-chip";
      const label = document.createElement("span");
      label.textContent = dtype;
      const removeBtn = document.createElement("button");
      removeBtn.type = "button";
      removeBtn.setAttribute("aria-label", `Remove ${dtype}`);
      removeBtn.textContent = "";
      removeBtn.addEventListener("click", () => {
        castDamageTypes.delete(dtype);
        renderCastDamageTypes();
      });
      chip.appendChild(label);
      chip.appendChild(removeBtn);
      castDamageTypeList.appendChild(chip);
    }
  };
  const addCastDamageType = (value) => {
    const dtype = String(value || "").trim();
    if (!dtype){
      localToast("Choose a damage type first, matey.");
      return;
    }
    if (castDamageTypes.has(dtype)){
      localToast("That damage type be added already.");
      return;
    }
    castDamageTypes.add(dtype);
    renderCastDamageTypes();
  };

  const applySpellPreset = (preset) => {
    if (!preset || typeof preset !== "object") return;
    if (castNameInput && preset.name){
      castNameInput.value = String(preset.name || "");
    }
    if (preset?.isCustomSummon && castCustomSummonNameInput){
      refreshCustomSummonMonsterOptions();
      applyCustomSummonTemplate(getSelectedCustomSummonChoice(), false);
      castCustomSummonNameInput.value = normalizeTextValue(castCustomSummonNameInput.value) || "Custom summon";
      if (castNameInput) castNameInput.value = castCustomSummonNameInput.value;
    }
    if (castShapeInput){
      castShapeInput.value = preset.shape ? String(preset.shape || "").toLowerCase() : "";
    }
    updateSummonOptions(preset);
    updateCastAutomationFields(preset);
    updateCastShapeFields();
    if (castRadiusInput){
      castRadiusInput.value = Number.isFinite(Number(preset.radius_ft)) ? Number(preset.radius_ft) : "";
    }
    if (castSideInput){
      castSideInput.value = Number.isFinite(Number(preset.side_ft)) ? Number(preset.side_ft) : "";
    }
    if (castLengthInput){
      castLengthInput.value = Number.isFinite(Number(preset.length_ft)) ? Number(preset.length_ft) : "";
    }
    if (castWidthInput){
      castWidthInput.value = Number.isFinite(Number(preset.width_ft)) ? Number(preset.width_ft) : "";
    }
    if (castAngleInput){
      castAngleInput.value = Number.isFinite(Number(preset.angle_deg)) ? Number(preset.angle_deg) : "";
    }
    if (castOrientInput){
      castOrientInput.value = preset.orient ? String(preset.orient || "").toLowerCase() : "vertical";
    }
    if (castThicknessInput){
      castThicknessInput.value = Number.isFinite(Number(preset.thickness_ft)) ? Number(preset.thickness_ft) : "";
    }
    if (castHeightInput){
      castHeightInput.value = Number.isFinite(Number(preset.height_ft)) ? Number(preset.height_ft) : "";
    }
    if (castDcTypeInput){
      castDcTypeInput.value = preset.save_type ? String(preset.save_type || "").toLowerCase() : "";
    }
    if (castDcValueInput){
      const presetDc = Number(preset.save_dc);
      castDcValueInput.value = Number.isFinite(presetDc) ? Number(presetDc) : "";
      if (!Number.isFinite(presetDc)){
        applyDefaultSpellSaveDc();
      }
    }
    if (castDefaultDamageInput){
      const defaultDamage = preset.default_damage;
      castDefaultDamageInput.value = defaultDamage !== undefined && defaultDamage !== null ? String(defaultDamage) : "";
      castBaseDefaultDamage = defaultDamage !== undefined && defaultDamage !== null ? String(defaultDamage) : "";
    }
    if (castDiceInput){
      const dice = preset.dice;
      castDiceInput.value = dice !== undefined && dice !== null ? String(dice) : "";
      castBaseDice = dice !== undefined && dice !== null ? String(dice) : "";
    }
    if (castColorInput){
      castColorInput.value = normalizeHexColor(preset.color || "") || DEFAULT_SPELL_COLOR;
    }
    setCastDamageTypes(preset.damage_types);
    if (Number.isFinite(Number(preset.duration_turns))){
      castDurationTurns = Number(preset.duration_turns);
    } else {
      castDurationTurns = null;
    }
    if (typeof preset.over_time === "boolean"){
      castOverTime = preset.over_time;
    } else {
      castOverTime = null;
    }
    const movePerTurn = Number(preset.move_per_turn_ft);
    if (Number.isFinite(movePerTurn)){
      castMovePerTurnFt = movePerTurn;
    } else {
      castMovePerTurnFt = null;
    }
    if (preset.trigger_on_start_or_enter){
      castTriggerOnStartOrEnter = String(preset.trigger_on_start_or_enter || "").toLowerCase();
    } else {
      castTriggerOnStartOrEnter = null;
    }
    if (typeof preset.persistent === "boolean"){
      castPersistent = preset.persistent;
    } else {
      castPersistent = null;
    }
    if (typeof preset.pinned_default === "boolean"){
      castPinnedDefault = preset.pinned_default;
    } else {
      castPinnedDefault = null;
    }
    castUpcastConfig = normalizeUpcastConfig(preset.upcast);
    if (castSlotLevelInput){
      const presetLevel = Number.isFinite(Number(preset.level)) ? Math.max(0, Math.floor(Number(preset.level))) : 0;
      const baseLevel = castUpcastConfig && Number.isFinite(Number(castUpcastConfig.base_level))
        ? Math.max(0, Math.floor(Number(castUpcastConfig.base_level)))
        : presetLevel;
      castSlotLevelInput.disabled = false;
      castSlotLevelInput.readOnly = false;
      castSlotLevelInput.min = String(Math.max(0, baseLevel));
      castSlotLevelInput.value = String(Math.max(0, baseLevel));
    }
    const slotLevelValue = Number(castSlotLevelInput?.value);
    const upcastValues = computeUpcastValues(castBaseDice, castBaseDefaultDamage, castUpcastConfig, slotLevelValue);
    if (castDiceInput && upcastValues.dice !== undefined && upcastValues.dice !== null){
      castDiceInput.value = String(upcastValues.dice || "");
    }
    if (castDefaultDamageInput && upcastValues.defaultDamage !== undefined && upcastValues.defaultDamage !== null){
      castDefaultDamageInput.value = String(upcastValues.defaultDamage || "");
    }
  };

  const updateUpcastFields = () => {
    if (!castUpcastConfig) return;
    const slotLevelValue = Number(castSlotLevelInput?.value);
    const upcastValues = computeUpcastValues(castBaseDice, castBaseDefaultDamage, castUpcastConfig, slotLevelValue);
    if (castDiceInput && upcastValues.dice !== undefined && upcastValues.dice !== null){
      castDiceInput.value = String(upcastValues.dice || "");
    }
    if (castDefaultDamageInput && upcastValues.defaultDamage !== undefined && upcastValues.defaultDamage !== null){
      castDefaultDamageInput.value = String(upcastValues.defaultDamage || "");
    }
  };

  function validateCastSlotSelection(preset, showToast = false){
    const playerName = getClaimedPlayerName();
    const presetSlug = normalizeTextValue(getPresetSlug(preset));
    const poolEntry = getPoolGrantedSpellEntries(playerName).find((entry) => getSpellKey(entry.spell || entry.slug || entry.id) === getSpellKey(presetSlug));
    if (poolEntry){
      const consumes = poolEntry.consumes_pool && typeof poolEntry.consumes_pool === "object" ? poolEntry.consumes_pool : {};
      const poolId = normalizeTextValue(consumes.id || consumes.pool);
      const cost = Number.isFinite(Number(consumes.cost)) ? Math.max(1, Math.floor(Number(consumes.cost))) : 1;
      const pool = getPlayerResourcePools(playerName).find((entry) => getSpellKey(entry.id) === getSpellKey(poolId));
      if (pool && Number(pool.current) >= cost){
        return {ok: true, slotLevel: null, consumesPool: {id: poolId, cost}};
      }
      const preparedSet = getPreparedSpellFilterSet();
      const inPreparedList = preparedSet instanceof Set && preparedSet.has(getSpellKey(presetSlug));
      if (!inPreparedList){
        const msg = "That resource pool be exhausted, matey.";
        if (showToast) localToast(msg);
        return {ok: false, reason: msg};
      }
    }
    const baseLevel = Number.isFinite(Number(preset?.level)) ? Math.max(0, Math.floor(Number(preset.level))) : 0;
    const rawLevel = Number(castSlotLevelInput?.value);
    const slotLevel = Number.isFinite(rawLevel) ? Math.floor(rawLevel) : baseLevel;
    if (slotLevel < baseLevel){
      const msg = "Ye can't downcast that spell, matey.";
      if (showToast) localToast(msg);
      return {ok: false, reason: msg};
    }
    const profile = getPlayerProfile(playerName);
    if (slotLevel >= 1 && getAvailableSlotCountAtOrAbove(profile, slotLevel) <= 0){
      const msg = "No spell slots left for that level, matey.";
      if (showToast) localToast(msg);
      return {ok: false, reason: msg};
    }
    return {ok: true, slotLevel};
  }

  if (castPresetInput){
    castPresetInput.addEventListener("change", () => {
      const name = String(castPresetInput.value || "").trim();
      if (!name){
        castDurationTurns = null;
        castOverTime = null;
        castMovePerTurnFt = null;
        castTriggerOnStartOrEnter = null;
        castPersistent = null;
        castPinnedDefault = null;
        castUpcastConfig = null;
        castBaseDice = null;
        castBaseDefaultDamage = null;
        if (castDefaultDamageInput){
          castDefaultDamageInput.value = "";
        }
        if (castDiceInput){
          castDiceInput.value = "";
        }
        if (castDcValueInput){
          castDcValueInput.value = "";
          applyDefaultSpellSaveDc();
        }
        if (castSlotLevelInput){
          castSlotLevelInput.value = "";
          castSlotLevelInput.min = "0";
          castSlotLevelInput.disabled = false;
          castSlotLevelInput.readOnly = false;
        }
        updateSummonOptions(null);
        updateCastAutomationFields(null);
        updateCastShapeFields();
        updateSpellPresetDetails(null);
        return;
      }
      const preset = getSelectedSpellPreset();
      updateSpellPresetDetails(preset || null);
      applySpellPreset(preset);
    });
  }

  if (castSlotLevelInput){
    castSlotLevelInput.addEventListener("input", () => {
      updateUpcastFields();
      const preset = getSelectedSpellPreset();
      const check = validateCastSlotSelection(preset, false);
      castSlotLevelInput.setCustomValidity(check.ok ? "" : (check.reason || "Invalid slot level"));
      updateSummonOptions(preset);
      validateSummonForm(preset, false);
    });
  }

  if (castSummonChoiceInput){
    castSummonChoiceInput.addEventListener("change", () => {
      const preset = getSelectedSpellPreset();
      updateSummonOptions(preset);
      validateSummonForm(preset, false);
    });
  }

  if (castSummonVariantInput){
    castSummonVariantInput.addEventListener("change", () => {
      const preset = getSelectedSpellPreset();
      validateSummonForm(preset, false);
    });
  }

  if (castSummonQuantityInput){
    castSummonQuantityInput.addEventListener("input", () => {
      const preset = getSelectedSpellPreset();
      updateSummonOptions(preset);
      validateSummonForm(preset, false);
    });
  }

  if (castCustomSummonRangeInput){
    castCustomSummonRangeInput.addEventListener("input", () => {
      const preset = getSelectedSpellPreset();
      updateSummonOptions(preset);
    });
  }

  if (castCustomSummonMonsterSearchInput){
    castCustomSummonMonsterSearchInput.addEventListener("input", () => {
      refreshCustomSummonMonsterOptions();
      const preset = getSelectedSpellPreset();
      if (preset?.isCustomSummon){
        updateSummonOptions(preset);
      }
    });
  }

  if (castCustomSummonMonsterInput){
    castCustomSummonMonsterInput.addEventListener("change", () => {
      applyCustomSummonTemplate(getSelectedCustomSummonChoice(), true);
      const preset = getSelectedSpellPreset();
      if (preset?.isCustomSummon){
        updateSummonOptions(preset);
      }
    });
  }

  if (castCustomSummonNameInput){
    castCustomSummonNameInput.addEventListener("input", () => {
      const preset = getSelectedSpellPreset();
      if (preset?.isCustomSummon && castNameInput){
        castNameInput.value = normalizeTextValue(castCustomSummonNameInput.value) || "Custom summon";
      }
    });
  }

  if (castAddDamageTypeBtn){
    castAddDamageTypeBtn.addEventListener("click", () => {
      addCastDamageType(castDamageTypeInput?.value || "");
    });
  }

  if (castForm){
    castForm.addEventListener("submit", (ev) => {
      ev.preventDefault();
      if (!claimedCid){
        localToast("Claim a character first, matey.");
        return;
      }
      if (!state){
        localToast("Map not ready yet, matey.");
        return;
      }
      const preset = getSelectedSpellPreset();
      const spellActionType = getSpellActionType(preset);
      const actionType = pendingSpellActionType || spellActionType;
      if (pendingSpellActionType && pendingSpellActionType !== spellActionType){
        const expectedLabel = spellActionType === "bonus_action" ? "bonus action" : spellActionType;
        localToast(`That spell uses a ${expectedLabel}.`);
        return;
      }
      pendingSpellActionType = null;
      const unit = getClaimedUnit();
      const actionCheck = canSpendSpellAction(unit, actionType);
      if (!actionCheck.ok){
        localToast(actionCheck.reason || "You can't cast right now.");
        return;
      }
      const actionLabel = actionType === "bonus_action" ? "bonus action" : actionType;
      const spellName = normalizeTextValue(castNameInput?.value) || "this spell";
      if (!confirm(`Cast ${spellName} using your ${actionLabel}?`)){
        return;
      }
      const concentrationSpell = normalizeTextValue(unit?.concentration_spell || unit?.concentrationSpell || "");
      const concentrationKey = normalizeLowerValue(concentrationSpell);
      const pendingConcentrationKey = normalizeLowerValue(preset?.slug || spellName);
      if (
        preset?.concentration === true
        && unit?.concentrating
        && concentrationKey
        && concentrationKey !== pendingConcentrationKey
      ){
        const concentrationLabel = concentrationSpell
          .split(/[-_\\s]+/)
          .filter(Boolean)
          .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
          .join(" ");
        if (!confirm(`You're concentrating on ${concentrationLabel}. Casting ${spellName} will end it. Continue?`)){
          return;
        }
      }
      const shape = String(castShapeInput?.value || "").toLowerCase();
      const spellActionTag = resolveSpellActionTag(preset);
      const aoeSpell = spellActionTag === "aoe";
      const summonSpell = isSummonPreset(preset);
      const customSummon = Boolean(preset?.isCustomSummon);
      if (!customSummon && !summonSpell && !spellActionTag){
        localToast("No tag found for that spell, matey.");
        reportSpellTagMissing(preset, {source: "cast_form_submit"});
        return;
      }
      if (aoeSpell && !shape){
        localToast("Pick a spell shape first, matey.");
        return;
      }
      const slotCheck = validateCastSlotSelection(preset, true);
      if (!slotCheck.ok){
        return;
      }
      const slotLevel = Number.isFinite(slotCheck.slotLevel) ? Math.floor(Number(slotCheck.slotLevel)) : null;
      if (summonSpell && !customSummon){
        const summonValidation = validateSummonForm(preset, true);
        if (!summonValidation.ok){
          return;
        }
        const choices = getSummonChoices(preset);
        const summonChoice = normalizeTextValue(castSummonChoiceInput?.value || choices[0]?.monster_slug || "");
        const summonVariant = normalizeTextValue(castSummonVariantInput?.value || "");
        const summonQuantity = Number(castSummonQuantityInput?.value);
        const presetSlug = normalizeTextValue(preset?.slug);
        const presetId = normalizeTextValue(preset?.id);
        const normalizedQuantity = Number.isFinite(summonQuantity) && summonQuantity > 0 ? Math.floor(summonQuantity) : 1;
        const payload = {
          action_type: actionType,
          name: String(castNameInput?.value || "").trim() || null,
          slot_level: slotLevel,
          spell_slug: presetSlug || null,
          spell_id: presetId || null,
          summon_choice: summonChoice || null,
          summon_quantity: normalizedQuantity,
          variant: summonVariant || null,
        };
        const caster = getClaimedUnit();
        if (!caster || !caster.pos){
          localToast("Could not find caster position, matey.");
          return;
        }
        pendingSummonPlacement = {
          actionType,
          slotLevel,
          spellSlug: presetSlug || null,
          spellId: presetId || null,
          summonChoice: summonChoice || null,
          summonVariant: summonVariant || null,
          summonQuantity: normalizedQuantity,
          casterPos: {col: Number(caster.pos.col), row: Number(caster.pos.row)},
          maxRangeFt: parseSpellRangeFeet(preset?.range),
          positions: [],
          payload,
          spellName,
        };
        rebuildSummonValidCells();
        updateSummonPlacementBanner();
        localToast("Summon placement started. Choose valid highlighted squares.");
        return;
      }
      if (customSummon){
        const summonQuantity = Number(castSummonQuantityInput?.value);
        const normalizedQuantity = Number.isFinite(summonQuantity) && summonQuantity > 0 ? Math.floor(summonQuantity) : 1;
        const customRangeRaw = Number(castCustomSummonRangeInput?.value);
        const customRangeFt = Number.isFinite(customRangeRaw) && customRangeRaw >= 0 ? Math.floor(customRangeRaw) : 30;
        const customMonsterSlug = normalizeTextValue(castCustomSummonMonsterInput?.value);
        const summonName = normalizeTextValue(castCustomSummonNameInput?.value) || normalizeTextValue(castNameInput?.value) || "Custom summon";
        const hp = Math.max(1, parseIntOrFallback(castCustomSummonHpInput?.value, DEFAULT_CUSTOM_SUMMON_TEMPLATE.hp));
        const ac = Math.max(1, parseIntOrFallback(castCustomSummonAcInput?.value, DEFAULT_CUSTOM_SUMMON_TEMPLATE.ac));
        const summonType = normalizeTextValue(castCustomSummonTypeInput?.value) || DEFAULT_CUSTOM_SUMMON_TEMPLATE.type;
        const speeds = {
          walk: Math.max(1, parseIntOrFallback(castCustomSummonWalkInput?.value, DEFAULT_CUSTOM_SUMMON_TEMPLATE.speeds.walk)),
          swim: Math.max(0, parseIntOrFallback(castCustomSummonSwimInput?.value, DEFAULT_CUSTOM_SUMMON_TEMPLATE.speeds.swim)),
          fly: Math.max(0, parseIntOrFallback(castCustomSummonFlyInput?.value, DEFAULT_CUSTOM_SUMMON_TEMPLATE.speeds.fly)),
          burrow: Math.max(0, parseIntOrFallback(castCustomSummonBurrowInput?.value, DEFAULT_CUSTOM_SUMMON_TEMPLATE.speeds.burrow)),
          climb: Math.max(0, parseIntOrFallback(castCustomSummonClimbInput?.value, DEFAULT_CUSTOM_SUMMON_TEMPLATE.speeds.climb)),
        };
        const abilities = {
          str: clampInt(castCustomSummonStrInput?.value, 1, 30, DEFAULT_CUSTOM_SUMMON_TEMPLATE.abilities.str),
          dex: clampInt(castCustomSummonDexInput?.value, 1, 30, DEFAULT_CUSTOM_SUMMON_TEMPLATE.abilities.dex),
          con: clampInt(castCustomSummonConInput?.value, 1, 30, DEFAULT_CUSTOM_SUMMON_TEMPLATE.abilities.con),
          int: clampInt(castCustomSummonIntInput?.value, 1, 30, DEFAULT_CUSTOM_SUMMON_TEMPLATE.abilities.int),
          wis: clampInt(castCustomSummonWisInput?.value, 1, 30, DEFAULT_CUSTOM_SUMMON_TEMPLATE.abilities.wis),
          cha: clampInt(castCustomSummonChaInput?.value, 1, 30, DEFAULT_CUSTOM_SUMMON_TEMPLATE.abilities.cha),
        };
        const payload = {
          action_type: actionType,
          shape: "summon",
          name: summonName,
          monster_slug: customMonsterSlug || null,
          type: summonType,
          hp,
          ac,
          speeds,
          abilities,
          summon_choice: "custom",
          summon_quantity: normalizedQuantity,
          summon_range_ft: customRangeFt,
          slot_level: slotLevel,
        };
        const caster = getClaimedUnit();
        if (!caster || !caster.pos){
          localToast("Could not find caster position, matey.");
          return;
        }
        pendingSummonPlacement = {
          mode: "custom_summon",
          actionType,
          slotLevel,
          spellSlug: null,
          spellId: null,
          summonChoice: "custom",
          summonVariant: null,
          summonQuantity: normalizedQuantity,
          casterPos: {col: Number(caster.pos.col), row: Number(caster.pos.row)},
          maxRangeFt: customRangeFt,
          positions: [],
          payload,
          spellName: summonName,
        };
        rebuildSummonValidCells();
        updateSummonPlacementBanner();
        localToast("Custom summon placement started. Choose valid highlighted squares.");
        return;
      }
      const parsePositive = (value) => {
        const num = parseFloat(value || "");
        return Number.isFinite(num) && num > 0 ? num : null;
      };
      const parseNonnegative = (value) => {
        const num = parseFloat(value || "");
        return Number.isFinite(num) && num >= 0 ? num : null;
      };
      const radiusFt = parsePositive(castRadiusInput?.value);
      const sideFt = parsePositive(castSideInput?.value);
      const lengthFt = parsePositive(castLengthInput?.value);
      const widthFt = parsePositive(castWidthInput?.value);
      const angleRaw = String(castAngleInput?.value || "").trim();
      const angleDegInput = angleRaw ? parseNonnegative(castAngleInput?.value) : null;
      const casterFacingDeg = normalizeFacingDeg(getClaimedUnit()?.facing_deg);
      const angleDeg = angleDegInput !== null ? angleDegInput : casterFacingDeg;
      const widthRaw = String(castWidthInput?.value || "").trim();
      const thicknessFt = parsePositive(castThicknessInput?.value);
      const thicknessRaw = String(castThicknessInput?.value || "").trim();
      const heightFt = parsePositive(castHeightInput?.value);
      const heightRaw = String(castHeightInput?.value || "").trim();
      const orientValue = String(castOrientInput?.value || "vertical").toLowerCase();
      const orient = orientValue === "horizontal" ? "horizontal" : "vertical";
      if (shape === "circle" && radiusFt === null){
        localToast("Enter a valid radius, matey.");
        return;
      }
      if ((shape === "sphere" || shape === "cylinder") && radiusFt === null){
        localToast("Enter a valid radius, matey.");
        return;
      }
      if (shape === "cylinder" && heightRaw && heightFt === null){
        localToast("Enter a valid height, matey.");
        return;
      }
      if (shape === "square" && sideFt === null){
        localToast("Enter a valid side length, matey.");
        return;
      }
      if (shape === "cube" && sideFt === null){
        localToast("Enter a valid side length, matey.");
        return;
      }
      if (shape === "line" && (lengthFt === null || widthFt === null)){
        localToast("Enter a valid line size, matey.");
        return;
      }
      if (shape === "cone" && lengthFt === null){
        localToast("Enter a valid cone length, matey.");
        return;
      }
      if (shape === "cone" && angleRaw && (angleDeg === null || angleDeg <= 0)){
        localToast("Enter a valid cone angle, matey.");
        return;
      }
      if ((shape === "line" || shape === "wall") && angleRaw && angleDeg === null){
        localToast("Enter a valid angle, matey.");
        return;
      }
      if (shape === "wall" && widthRaw && widthFt === null){
        localToast("Enter a valid wall width, matey.");
        return;
      }
      if (shape === "wall" && thicknessRaw && thicknessFt === null){
        localToast("Enter a valid wall thickness, matey.");
        return;
      }
      if (shape === "wall" && heightRaw && heightFt === null){
        localToast("Enter a valid wall height, matey.");
        return;
      }
      if (shape === "wall"){
        if (lengthFt === null){
          localToast("Enter a valid wall length, matey.");
          return;
        }
        if (widthFt === null && (thicknessFt === null || heightFt === null)){
          localToast("Enter a valid wall thickness and height (or width), matey.");
          return;
        }
      }
      const dcType = String(castDcTypeInput?.value || "").trim().toLowerCase();
      const dcValue = parseInt(castDcValueInput?.value || "", 10);
      const damageTypes = Array.from(castDamageTypes);
      if (!damageTypes.length){
        const fallbackType = String(castDamageTypeInput?.value || "").trim();
        if (fallbackType){
          damageTypes.push(fallbackType);
        }
      }
      const damageType = damageTypes.length === 1 ? damageTypes[0] : "";
      const name = String(castNameInput?.value || "").trim();
      const appearanceSelection = aoeSpell ? String(castSummonVariantInput?.value || "").trim() : "";
      const baseName = name || String(castNameInput?.placeholder || "Spell").trim();
      const appearanceName = appearanceSelection
        ? `${baseName} (${appearanceSelection})`
        : name;
      const color = normalizeHexColor(castColorInput?.value || "") || null;
      let defaultDamage = String(castDefaultDamageInput?.value || "").trim();
      let dice = String(castDiceInput?.value || "").trim();
      if (castUpcastConfig){
        const slotLevelValue = Number(castSlotLevelInput?.value);
        const upcastValues = computeUpcastValues(
          castBaseDice || dice,
          castBaseDefaultDamage || defaultDamage,
          castUpcastConfig,
          slotLevelValue
        );
        if (upcastValues.dice !== undefined && upcastValues.dice !== null){
          dice = String(upcastValues.dice || "");
        }
        if (upcastValues.defaultDamage !== undefined && upcastValues.defaultDamage !== null){
          defaultDamage = String(upcastValues.defaultDamage || "");
        }
      }
      const center = defaultAoeCenter();
      if (aoeSpell && shape !== "line"){
        const caster = getClaimedUnit();
        if (caster && caster.pos){
          const start = {col: Number(caster.pos.col), row: Number(caster.pos.row)};
          const end = {col: Number(center.cx), row: Number(center.cy)};
          const blocked = isLineOfSightBlocked(start, end);
          setLosPreview(start, end, blocked);
          if (blocked){
            localToast("No line of sight to spell center.");
            return;
          }
        }
      }
      const payload = {
        shape,
        action_type: actionType,
        dc: Number.isFinite(dcValue) ? dcValue : null,
        save_type: dcType || null,
        damage_type: damageType || null,
        damage_types: damageTypes,
        name: appearanceName || null,
        color,
        cx: center.cx,
        cy: center.cy,
      };
      if (typeof preset?.concentration === "boolean"){
        payload.concentration = preset.concentration;
      }
      if (Number.isFinite(preset?.level)){
        payload.level = Math.max(0, Math.floor(Number(preset.level)));
      }
      if (defaultDamage){
        payload.default_damage = defaultDamage;
      }
      if (dice){
        payload.dice = dice;
      }
      if (Number.isFinite(Number(castDurationTurns)) && Number(castDurationTurns) >= 0){
        payload.duration_turns = Number(castDurationTurns);
      }
      if (typeof castOverTime === "boolean"){
        payload.over_time = castOverTime;
      }
      if (Number.isFinite(Number(castMovePerTurnFt)) && Number(castMovePerTurnFt) >= 0){
        payload.move_per_turn_ft = Number(castMovePerTurnFt);
      }
      if (castTriggerOnStartOrEnter){
        payload.trigger_on_start_or_enter = castTriggerOnStartOrEnter;
      }
      if (typeof castPersistent === "boolean"){
        payload.persistent = castPersistent;
      }
      if (typeof castPinnedDefault === "boolean"){
        payload.pinned_default = castPinnedDefault;
      }
      if (aoeSpell && shape === "circle"){
        payload.radius_ft = radiusFt;
      } else if (aoeSpell && (shape === "sphere" || shape === "cylinder")){
        payload.radius_ft = radiusFt;
        if (heightFt !== null){
          payload.height_ft = heightFt;
        }
      } else if (aoeSpell && (shape === "square" || shape === "cube")){
        payload.side_ft = sideFt;
      } else if (aoeSpell && shape === "line"){
        payload.length_ft = lengthFt;
        payload.width_ft = widthFt;
        payload.orient = orient;
        if (angleDeg !== null){
          payload.angle_deg = angleDeg;
        }
      } else if (aoeSpell && shape === "cone"){
        payload.length_ft = lengthFt;
        payload.angle_deg = angleDeg !== null ? angleDeg : 90;
        payload.orient = orient;
      } else if (aoeSpell && shape === "wall"){
        payload.length_ft = lengthFt;
        payload.orient = orient;
        if (widthFt !== null){
          payload.width_ft = widthFt;
        }
        if (thicknessFt !== null){
          payload.thickness_ft = thicknessFt;
        }
        if (heightFt !== null){
          payload.height_ft = heightFt;
        }
        if (angleDeg !== null){
          payload.angle_deg = angleDeg;
        }
      }
      const msg = {type: aoeSpell ? "cast_aoe" : "cast_spell", payload, action_type: actionType};
      const spellTargetConfig = !aoeSpell ? getSpellTargetingConfig(preset, slotLevel) : null;
      const presetSlug = normalizeTextValue(preset?.slug);
      const presetId = normalizeTextValue(preset?.id);
      if (presetSlug){
        msg.spell_slug = presetSlug;
      }
      if (presetId){
        msg.spell_id = presetId;
      }
      if (Number.isFinite(slotLevel)){
        msg.slot_level = slotLevel;
      }
      if (slotCheck.consumesPool){
        msg.payload = msg.payload || {};
        msg.payload.consumes_pool = {id: slotCheck.consumesPool.id, cost: slotCheck.consumesPool.cost};
        msg.consumes_pool_id = slotCheck.consumesPool.id;
        msg.consumes_pool_cost = slotCheck.consumesPool.cost;
      }
      if (isPlanning){
        planningMutate(msg);
        draw();
        updateHud();
      }
      send(msg);
      if (!aoeSpell && spellTargetConfig){
        startSpellTargetingSession(spellTargetConfig, preset, slotLevel);
      }
    });
  }

  if (dashBtn){
    dashBtn.addEventListener("click", () => {
      if (isMapView) return;
      if (!claimedCid) return;
      openActionPicker("dash");
    });
  }
  if (dashActionBtn){
    dashActionBtn.addEventListener("click", () => {
      if (isMapView) return;
      const actionCid = activeControlledUnitCid();
      if (actionCid === null) return;
      const msg = {type:"dash", cid: actionCid, spend:"action"};
      if (isPlanning){
        planningMutate(msg);
        draw();
        updateHud();
      }
      send(msg);
      hideDashModal();
    });
  }
  if (dashBonusActionBtn){
    dashBonusActionBtn.addEventListener("click", () => {
      if (isMapView) return;
      const actionCid = activeControlledUnitCid();
      if (actionCid === null) return;
      const msg = {type:"dash", cid: actionCid, spend:"bonus"};
      if (isPlanning){
        planningMutate(msg);
        draw();
        updateHud();
      }
      send(msg);
      hideDashModal();
    });
  }
  if (dashCancelBtn){
    dashCancelBtn.addEventListener("click", () => {
      hideDashModal();
    });
  }
  if (actionPickerCancelBtn){
    actionPickerCancelBtn.addEventListener("click", () => {
      hideActionPicker();
    });
  }
  if (battleLogBtn){
    battleLogBtn.addEventListener("click", () => {
      if (battleLogViewPrefs?.visible){
        hideLogModal();
      } else {
        showLogModal();
      }
    });
  }
  if (logCloseBtn){
    logCloseBtn.addEventListener("click", () => {
      hideLogModal();
    });
  }
  if (logHeader && logModal){
    let dragState = null;
    const endLogDrag = () => {
      if (!dragState) return;
      battleLogViewPrefs.left = dragState.left;
      battleLogViewPrefs.top = dragState.top;
      persistBattleLogViewPrefs();
      dragState = null;
    };
    logHeader.addEventListener("pointerdown", (event) => {
      if (event.pointerType === "mouse" && event.button !== 0) return;
      const target = event.target instanceof Element ? event.target : null;
      if (target?.closest("button")) return;
      const modalRect = logModal.getBoundingClientRect();
      const maxLeft = Math.max(0, window.innerWidth - modalRect.width);
      const maxTop = Math.max(0, window.innerHeight - modalRect.height);
      dragState = {
        pointerId: event.pointerId,
        offsetX: event.clientX - modalRect.left,
        offsetY: event.clientY - modalRect.top,
        maxLeft,
        maxTop,
        left: Math.min(maxLeft, Math.max(0, modalRect.left)),
        top: Math.min(maxTop, Math.max(0, modalRect.top)),
      };
      logModal.style.right = "auto";
      logModal.style.bottom = "auto";
      logHeader.setPointerCapture?.(event.pointerId);
      event.preventDefault();
    });
    logHeader.addEventListener("pointermove", (event) => {
      if (!dragState || event.pointerId !== dragState.pointerId) return;
      const left = Math.min(dragState.maxLeft, Math.max(0, event.clientX - dragState.offsetX));
      const top = Math.min(dragState.maxTop, Math.max(0, event.clientY - dragState.offsetY));
      dragState.left = Math.round(left);
      dragState.top = Math.round(top);
      logModal.style.left = `${dragState.left}px`;
      logModal.style.top = `${dragState.top}px`;
    });
    logHeader.addEventListener("pointerup", endLogDrag);
    logHeader.addEventListener("pointercancel", endLogDrag);
  }
  if (logResizeHandle && logModal){
    let resizeState = null;
    const endLogResize = () => {
      if (!resizeState) return;
      persistBattleLogViewPrefs();
      resizeState = null;
    };
    logResizeHandle.addEventListener("pointerdown", (event) => {
      if (event.pointerType === "mouse" && event.button !== 0) return;
      const modalRect = logModal.getBoundingClientRect();
      resizeState = {
        pointerId: event.pointerId,
        startX: event.clientX,
        startY: event.clientY,
        width: modalRect.width,
        height: modalRect.height,
      };
      logResizeHandle.setPointerCapture?.(event.pointerId);
      event.preventDefault();
    });
    logResizeHandle.addEventListener("pointermove", (event) => {
      if (!resizeState || event.pointerId !== resizeState.pointerId) return;
      const width = Math.max(260, resizeState.width + (event.clientX - resizeState.startX));
      const height = Math.max(180, resizeState.height + (event.clientY - resizeState.startY));
      logModal.style.width = `${Math.round(width)}px`;
      logModal.style.height = `${Math.round(height)}px`;
      battleLogViewPrefs.width = Math.round(width);
      battleLogViewPrefs.height = Math.round(height);
    });
    logResizeHandle.addEventListener("pointerup", endLogResize);
    logResizeHandle.addEventListener("pointercancel", endLogResize);
  }
  if (configBtn){
    configBtn.addEventListener("click", () => {
      if (!configModal) return;
      if (configModal.classList.contains("show")){
        hideConfigModal();
        return;
      }
      showConfigModal();
    });
  }
  if (initiativeToggleBtn){
    initiativeToggleBtn.addEventListener("click", () => {
      toggleInitiativeBar();
    });
  }
  if (planningBtn){
    planningBtn.classList.toggle("hidden", isPlanning);
    planningBtn.disabled = isPlanning;
    planningBtn.setAttribute("aria-disabled", isPlanning ? "true" : "false");
    if (!isPlanning){
      planningBtn.addEventListener("click", () => {
        const baseUrl = window.LAN_BASE_URL || window.location.origin;
        const planningUrl = new URL(`${baseUrl.replace(/\/$/, "")}/planning`);
        if (clientId){
          planningUrl.searchParams.set("client_id", clientId);
        }
        if (claimedCid !== null && claimedCid !== undefined){
          planningUrl.searchParams.set("player_cid", String(claimedCid));
        }
        window.open(planningUrl.toString(), "_blank", "noopener,noreferrer");
      });
    }
  }
  if (configCloseBtn){
    configCloseBtn.addEventListener("click", () => {
      hideConfigModal();
    });
  }
  if (configModal){
    configModal.addEventListener("click", (event) => {
      if (event.target === configModal){
        hideConfigModal();
      }
    });
  }
  const mapViewSettingInputs = [
    mapViewTextSizeInput,
    mapViewBarHeightInput,
    mapViewChipPaddingInput,
    mapViewChipGapInput,
    mapViewCornerRadiusInput,
    mapViewRotateHandleScaleInput,
    mapViewShowTitleInput,
    mapViewShowStatusInput,
    mapViewShowIndexInput,
  ].filter(Boolean);
  mapViewSettingInputs.forEach((inputEl) => {
    inputEl.addEventListener("input", () => {
      if (!mapViewSettings){
        mapViewSettings = readMapViewSettings();
      }
      mapViewSettings = {
        ...mapViewSettings,
        textSize: Number(mapViewTextSizeInput?.value || mapViewSettings.textSize),
        barHeight: Number(mapViewBarHeightInput?.value || mapViewSettings.barHeight),
        chipPadding: Number(mapViewChipPaddingInput?.value || mapViewSettings.chipPadding),
        chipGap: Number(mapViewChipGapInput?.value || mapViewSettings.chipGap),
        cornerRadius: Number(mapViewCornerRadiusInput?.value || mapViewSettings.cornerRadius),
        rotateHandleScale: Number(mapViewRotateHandleScaleInput?.value || mapViewSettings.rotateHandleScale),
        showTitle: !!mapViewShowTitleInput?.checked,
        showStatus: !!mapViewShowStatusInput?.checked,
        showIndex: !!mapViewShowIndexInput?.checked,
      };
      applyMapViewSettings(mapViewSettings);
      persistMapViewSettings();
    });
  });
  if (sheetHeightInput){
    sheetHeightInput.addEventListener("input", () => {
      applySheetHeight(Number(sheetHeightInput.value));
      persistSheetHeight();
    });
  }
  if (battleLogFontFamilyInput){
    battleLogFontFamilyInput.addEventListener("change", () => {
      battleLogViewPrefs.fontFamily = battleLogFontFamilyInput.value || battleLogViewPrefs.fontFamily;
      applyBattleLogViewPrefs();
      persistBattleLogViewPrefs();
    });
  }
  if (battleLogFontSizeInput){
    battleLogFontSizeInput.addEventListener("input", () => {
      battleLogViewPrefs.fontSize = Math.max(11, Math.min(28, Number(battleLogFontSizeInput.value) || 14));
      applyBattleLogViewPrefs();
      persistBattleLogViewPrefs();
    });
  }
  if (logModal && window.ResizeObserver){
    const logResizeObserver = new ResizeObserver((entries) => {
      const box = entries?.[0]?.contentRect;
      if (!box || !battleLogViewPrefs?.visible) return;
      battleLogViewPrefs.width = Math.round(box.width);
      battleLogViewPrefs.height = Math.round(box.height);
      persistBattleLogViewPrefs();
    });
    logResizeObserver.observe(logModal);
  }
  if (presetSaveBtn){
    presetSaveBtn.addEventListener("click", () => {
      const preset = buildGuiPreset();
      persistLocalPreset(preset);
      send({type: "save_preset", preset});
    });
  }
  if (presetLoadBtn){
    presetLoadBtn.addEventListener("click", () => {
      send({type: "load_preset"});
    });
  }
  if (focusTabOnTurnInput){
    focusTabOnTurnInput.checked = focusTabOnTurn;
    focusTabOnTurnInput.addEventListener("change", (event) => {
      focusTabOnTurn = event.target.checked;
      localStorage.setItem(focusTabOnTurnStorageKey, focusTabOnTurn ? "1" : "0");
    });
  }
  if (unlockAudioBtn){
    unlockAudioBtn.addEventListener("click", () => {
      unlockTurnAudio();
    });
  }
  if (enableNotificationsBtn){
    enableNotificationsBtn.addEventListener("click", async () => {
      if (!("Notification" in window)){
        setNotificationStatus("Notifications are not supported.");
        return;
      }
      try {
        if (!swRegistration){
          swRegistration = await navigator.serviceWorker.ready;
        }
      } catch (err){
        console.warn("Service worker not ready.", err);
        setNotificationStatus("Service worker not ready.");
        return;
      }
      const permission = await Notification.requestPermission();
      if (permission !== "granted"){
        setNotificationStatus("Notifications blocked.");
        return;
      }
      if (!("PushManager" in window)){
        setNotificationStatus("Push is not supported.");
        return;
      }
      try {
        const existing = await swRegistration.pushManager.getSubscription();
        if (existing){
          setNotificationStatus("Notifications already enabled.");
          return;
        }
        if (!pushPublicKey){
          setNotificationStatus("Missing push public key.");
          return;
        }
        const subscription = await swRegistration.pushManager.subscribe({
          userVisibleOnly: true,
          applicationServerKey: urlBase64ToUint8Array(pushPublicKey),
        });
        console.log("Push subscription:", JSON.stringify(subscription));
        setNotificationStatus("Notifications enabled.");
      } catch (err){
        console.warn("Push subscription failed.", err);
        setNotificationStatus("Failed to enable notifications.");
      }
    });
  }
  if (enableTurnAlertsBtn){
    enableTurnAlertsBtn.addEventListener("click", async () => {
      try {
        const identity = getTurnAlertIdentity();
        await ensurePushSubscribed({
          vapidPublicKey: pushPublicKey,
          playerId: identity.playerId,
        });
        localToast("Turn alerts enabled.");
      } catch (err){
        const message = err?.message ? String(err.message) : "Failed to enable alerts.";
        setTurnAlertStatus(message);
        localToast(message);
      }
    });
  }
  if (hideTurnAlertsBtn && turnAlertsPanel){
    hideTurnAlertsBtn.addEventListener("click", () => {
      localStorage.setItem(turnAlertHideKey, "1");
      turnAlertsPanel.classList.add("hidden");
    });
  }
  if (castOverlayOpenBtn){
    castOverlayOpenBtn.addEventListener("click", () => {
      setCastOverlayOpen(true);
    });
  }
  if (castOverlayBackBtn){
    castOverlayBackBtn.addEventListener("click", () => {
      setCastOverlayOpen(false);
    });
  }
  if (spellLibraryBtn){
    spellLibraryBtn.addEventListener("click", () => {
      openSpellLibraryOverlay(true);
    });
  }
  if (spellLibraryCloseBtn){
    spellLibraryCloseBtn.addEventListener("click", () => {
      openSpellLibraryOverlay(false);
    });
  }
  if (spellLibrarySearchInput){
    spellLibrarySearchInput.addEventListener("input", (event) => {
      spellLibrarySearchTerm = String(event.target.value || "");
      renderSpellLibrary();
    });
  }
  if (spellLibrarySortSelect){
    spellLibrarySortSelect.addEventListener("change", (event) => {
      spellLibrarySortMode = String(event.target.value || "alpha");
      renderSpellLibrary();
    });
  }
  if (spellbookOpenBtn){
    spellbookOpenBtn.addEventListener("click", () => {
      openSpellbookOverlay(true);
    });
  }
  if (wildShapeManageOpenBtn){
    wildShapeManageOpenBtn.addEventListener("click", () => {
      if (!isClaimedUnitDruid()){
        localToast("Only Druids level 2+ can manage Wild Shapes.");
        return;
      }
      setWildShapeOverlayOpen(true);
    });
  }
  if (wildShapeMenuCloseBtn){
    wildShapeMenuCloseBtn.addEventListener("click", () => setWildShapeMenuOpen(false));
  }
  if (wildShapeMenuManageFormsBtn){
    wildShapeMenuManageFormsBtn.addEventListener("click", () => {
      setWildShapeMenuOpen(false);
      setWildShapeOverlayOpen(true);
    });
  }
  if (wildShapeMenuApplyBtn){
    wildShapeMenuApplyBtn.addEventListener("click", () => setWildShapePickOverlayOpen(true));
  }
  if (wildShapeMenuRevertBtn){
    wildShapeMenuRevertBtn.addEventListener("click", () => {
      if (!claimedCid) return;
      send({type:"wild_shape_revert", cid: claimedCid});
      setWildShapeMenuOpen(false);
    });
  }
  if (wildShapeMenuRegainUseBtn){
    wildShapeMenuRegainUseBtn.addEventListener("click", () => {
      if (!claimedCid) return;
      send({type:"wild_shape_regain_use", cid: claimedCid});
      setWildShapeMenuOpen(false);
    });
  }
  if (wildShapeMenuRegainSpellBtn){
    wildShapeMenuRegainSpellBtn.addEventListener("click", () => {
      if (!claimedCid) return;
      send({type:"wild_shape_regain_spell", cid: claimedCid});
      setWildShapeMenuOpen(false);
    });
  }
  if (wildShapeMenuManagePoolBtn){
    wildShapeMenuManagePoolBtn.addEventListener("click", () => setWildShapePoolOverlayOpen(true));
  }
  if (wildShapePoolBackBtn){
    wildShapePoolBackBtn.addEventListener("click", () => setWildShapePoolOverlayOpen(false));
  }
  if (wildShapePoolDecBtn){
    wildShapePoolDecBtn.addEventListener("click", () => {
      if (!wildShapePoolCurrentInput) return;
      const value = Math.max(Number(wildShapePoolCurrentInput.min || 0), Number(wildShapePoolCurrentInput.value || 0) - 1);
      wildShapePoolCurrentInput.value = String(value);
    });
  }
  if (wildShapePoolIncBtn){
    wildShapePoolIncBtn.addEventListener("click", () => {
      if (!wildShapePoolCurrentInput) return;
      const max = Number(wildShapePoolCurrentInput.max || 0);
      const value = Math.min(max, Number(wildShapePoolCurrentInput.value || 0) + 1);
      wildShapePoolCurrentInput.value = String(value);
    });
  }
  if (wildShapePoolApplyBtn){
    wildShapePoolApplyBtn.addEventListener("click", () => {
      if (!claimedCid || !wildShapePoolCurrentInput) return;
      send({type:"wild_shape_pool_set_current", cid: claimedCid, current: Number(wildShapePoolCurrentInput.value || 0)});
      setWildShapePoolOverlayOpen(false);
      setWildShapeMenuOpen(false);
    });
  }
  if (wildShapePickBackBtn){
    wildShapePickBackBtn.addEventListener("click", () => setWildShapePickOverlayOpen(false));
  }
  if (secondWindCancelBtn){
    secondWindCancelBtn.addEventListener("click", () => setSecondWindOverlayOpen(false));
  }
  if (secondWindUseBtn){
    secondWindUseBtn.addEventListener("click", () => {
      if (!claimedCid) return;
      const rolled = Number(secondWindRollInput?.value ?? "");
      if (!Number.isFinite(rolled) || rolled < 1 || rolled > 10){
        localToast("Enter your Second Wind d10 roll (1-10). Add fighter level automatically.");
        return;
      }
      const msg = {type:"second_wind_use", cid: claimedCid, healing_roll: Math.floor(rolled)};
      if (isPlanning){
        planningMutate(msg);
        draw();
        updateHud();
      }
      send(msg);
      setSecondWindOverlayOpen(false);
    });
  }
  if (layOnHandsCancelBtn){
    layOnHandsCancelBtn.addEventListener("click", () => {
      setLayOnHandsOverlayOpen(false);
      pendingLayOnHandsResolve = null;
      pendingLayOnHandsTargeting = null;
      if (attackOverlayMode){
        setAttackOverlayMode(false);
      }
    });
  }
  if (layOnHandsUseBtn){
    layOnHandsUseBtn.addEventListener("click", () => {
      if (!claimedCid) return;
      if (!pendingLayOnHandsResolve){
        localToast("Pick a Lay on Hands target first.");
        return;
      }
      const pools = getPlayerResourcePools(getClaimedPlayerName());
      const pool = pools.find((entry) => entry.id === "lay_on_hands");
      const available = Math.max(0, Number(pool?.current || 0));
      const amount = Math.floor(Number(layOnHandsAmountInput?.value ?? ""));
      if (!Number.isFinite(amount) || amount <= 0){
        localToast("Enter a valid Lay on Hands healing amount.");
        return;
      }
      if (amount > available){
        localToast("Not enough Lay on Hands points remaining.");
        return;
      }
      const msg = {type:"lay_on_hands_use", cid: claimedCid, target_cid: pendingLayOnHandsResolve.targetCid, amount};
      if (isPlanning){
        planningMutate(msg);
        draw();
        updateHud();
      }
      send(msg);
      setLayOnHandsOverlayOpen(false);
      pendingLayOnHandsResolve = null;
      pendingLayOnHandsTargeting = null;
      if (attackOverlayMode){
        setAttackOverlayMode(false);
      }
    });
  }
  if (wildShapeBackBtn){
    wildShapeBackBtn.addEventListener("click", () => setWildShapeOverlayOpen(false));
  }
  if (wildShapeSearchInput){
    wildShapeSearchInput.addEventListener("input", () => renderWildShapeOverlay());
  }
  if (wildShapeShowLockedInput){
    wildShapeShowLockedInput.addEventListener("change", () => renderWildShapeOverlay());
  }
  if (wildShapeLeftList){
    wildShapeLeftList.addEventListener("click", (event) => {
      const item = event.target?.closest?.("[data-wildshape-id]");
      if (!item) return;
      const id = String(item.dataset.wildshapeId || "").trim().toLowerCase();
      if (!id) return;
      wildShapeSelectedAvailable = id;
      const entry = wildShapeAllowedMap.get(id);
      if (entry?.allowed === false){
        const reason = wildShapeLockReason(entry);
        if (wildShapeStatusEl) wildShapeStatusEl.textContent = `Locked: ${reason}.`;
      }
      renderWildShapeOverlay();
    });
  }
  if (wildShapeRightList){
    wildShapeRightList.addEventListener("click", (event) => {
      const item = event.target?.closest?.("[data-wildshape-known-id]");
      if (!item) return;
      const id = String(item.dataset.wildshapeKnownId || "").trim().toLowerCase();
      if (!id) return;
      wildShapeSelectedKnown = id;
      renderWildShapeOverlay();
    });
  }
  if (wildShapeAddBtn){
    wildShapeAddBtn.addEventListener("click", () => {
      const {limit} = getWildShapeProfileData();
      if (!wildShapeSelectedAvailable) return;
      const entry = wildShapeAllowedMap.get(wildShapeSelectedAvailable);
      if (entry?.allowed === false){
        localToast(`That form is locked: ${wildShapeLockReason(entry) || "not available"}.`);
        return;
      }
      if (wildShapeKnownDraft.includes(wildShapeSelectedAvailable)) return;
      if (wildShapeKnownDraft.length >= limit){
        localToast("No known form slots remaining.");
        return;
      }
      wildShapeKnownDraft.push(wildShapeSelectedAvailable);
      renderWildShapeOverlay();
    });
  }
  if (wildShapeRemoveBtn){
    wildShapeRemoveBtn.addEventListener("click", () => {
      if (!wildShapeSelectedKnown) return;
      wildShapeKnownDraft = wildShapeKnownDraft.filter((id) => id !== wildShapeSelectedKnown);
      renderWildShapeOverlay();
    });
  }
  if (wildShapeSaveBtn){
    wildShapeSaveBtn.addEventListener("click", () => {
      if (claimedCid == null) return;
      send({type:"wild_shape_set_known", cid: claimedCid, known: wildShapeKnownDraft});
      setWildShapeOverlayOpen(false);
    });
  }
  if (spellbookBackBtn){
    spellbookBackBtn.addEventListener("click", () => {
      openSpellbookOverlay(false);
    });
  }
  if (spellbookBackFloatingBtn){
    spellbookBackFloatingBtn.addEventListener("click", () => {
      openSpellbookOverlay(false);
    });
  }
  if (spellDetailBackBtn){
    spellDetailBackBtn.addEventListener("click", () => {
      closeSpellDetailOverlay();
    });
  }
  if (spellDetailColorInput){
    spellDetailColorInput.addEventListener("input", (event) => {
      const value = String(event.target.value || "");
      updateSpellDetailColorInputs(normalizeHexColor(value) || value);
    });
    spellDetailColorInput.addEventListener("change", (event) => {
      commitSpellDetailColor(event.target.value || "");
    });
  }
  if (spellDetailColorValue){
    spellDetailColorValue.addEventListener("change", (event) => {
      commitSpellDetailColor(event.target.value || "");
    });
  }
  if (spellbookTabKnown){
    spellbookTabKnown.addEventListener("click", () => {
      spellbookMode = "known";
      resetSpellbookSelections();
      renderSpellbook();
    });
  }
  if (spellbookTabPrepared){
    spellbookTabPrepared.addEventListener("click", () => {
      spellbookMode = "prepared";
      resetSpellbookSelections();
      renderSpellbook();
    });
  }
  if (spellbookKnownEnabledToggle){
    spellbookKnownEnabledToggle.addEventListener("change", (event) => {
      spellbookKnownEnabled = !!event.target.checked;
      if (!spellbookKnownEnabled){
        spellbookMode = "prepared";
      }
      resetSpellbookSelections();
      renderSpellbook();
    });
  }
  if (spellbookSearchInput){
    spellbookSearchInput.addEventListener("input", (event) => {
      spellbookSearchTerm = String(event.target.value || "");
      renderSpellbook();
    });
  }
  if (spellbookSortSelect){
    spellbookSortSelect.addEventListener("change", (event) => {
      spellbookSortMode = String(event.target.value || "alpha");
      renderSpellbook();
    });
  }
  if (spellbookAddBtn){
    spellbookAddBtn.addEventListener("click", () => {
      applySpellbookAdd();
    });
  }
  if (spellbookRemoveBtn){
    spellbookRemoveBtn.addEventListener("click", () => {
      applySpellbookRemove();
    });
  }
  if (spellbookSaveBtn){
    spellbookSaveBtn.addEventListener("click", () => {
      showSpellbookConfirm();
    });
  }
  if (spellbookConfirmCancel){
    spellbookConfirmCancel.addEventListener("click", () => {
      hideSpellbookConfirm();
    });
  }
  if (spellbookConfirmYes){
    spellbookConfirmYes.addEventListener("click", () => {
      saveSpellbookChanges();
    });
  }
  if (spellbookConfirmModal){
    spellbookConfirmModal.addEventListener("click", (event) => {
      if (event.target === spellbookConfirmModal){
        hideSpellbookConfirm();
      }
    });
  }
  if (mapViewTurnOrderEl){
    mapViewTurnOrderEl.addEventListener("click", (event) => {
      const chip = event.target.closest(".turn-chip");
      const chipCid = normalizeCid(chip?.dataset?.cid, "turnOrder.click.cid");
      if (chipCid !== null && canSelectControlledUnitCid(chipCid)){
        selectedTurnCid = chipCid;
        const unit = getUnitByCid(chipCid);
        if (unit?.name && unitControllableThisTurn(chipCid)){
          localToast(`Controlling ${unit.name}.`);
        }
        updateTurnOrder();
        updateHud();
        draw();
        return;
      }
    });
  }

  if (connEl && connPopoverEl){
    connEl.addEventListener("click", (event) => {
      event.stopPropagation();
      const isOpen = connPopoverEl.classList.contains("show");
      setConnPopover(!isOpen);
    });
  }
  if (connReconnectBtn){
    connReconnectBtn.addEventListener("click", () => {
      softReconnect();
    });
  }
  document.addEventListener("click", (event) => {
    if (!connPopoverEl || !connEl) return;
    if (connPopoverEl.contains(event.target) || connEl.contains(event.target)) return;
    closeConnPopover();
  });
  document.addEventListener("keydown", (event) => {
    if (event.key === "Escape"){
      if (spellbookConfirmModal?.classList.contains("show")){
        hideSpellbookConfirm();
        return;
      }
      if (helpModal?.classList.contains("show")){
        hideHelpModal();
        return;
      }
      if (spellLibraryOverlay?.classList.contains("show")){
        openSpellLibraryOverlay(false);
        return;
      }
      if (spellDetailOverlay?.classList.contains("show")){
        closeSpellDetailOverlay();
        return;
      }
      if (spellbookOverlay?.classList.contains("show")){
        openSpellbookOverlay(false);
        return;
      }
      if (castOverlay?.classList.contains("show")){
        setCastOverlayOpen(false);
        return;
      }
      closeConnPopover();
    }
  });
  document.addEventListener("keydown", (event) => {
    if (isShiftKey(event)){
      shiftMoveMode = true;
      draw();
    }
  });
  document.addEventListener("keyup", (event) => {
    if (isShiftKey(event)){
      shiftMoveMode = false;
      draw();
    }
  });
  if (toggleTopbarTitle){
    toggleTopbarTitle.addEventListener("change", (event) => {
      showTopbarTitle = !!event.target.checked;
      persistToggle(uiToggleKeys.topbarTitle, showTopbarTitle);
      applyUiConfig();
    });
  }
  if (toggleConnIndicator){
    toggleConnIndicator.addEventListener("change", (event) => {
      showConnIndicator = !!event.target.checked;
      persistToggle(uiToggleKeys.connIndicator, showConnIndicator);
      applyUiConfig();
    });
  }
  if (connStyleButtons.length){
    connStyleButtons.forEach((button) => {
      button.addEventListener("click", () => {
        const nextStyle = button.dataset.connStyle === "compact" ? "compact" : "full";
        if (connStyle === nextStyle) return;
        connStyle = nextStyle;
        persistChoice(uiSelectKeys.connStyle, connStyle);
        applyUiConfig();
      });
    });
  }
  if (toggleLockMap){
    toggleLockMap.addEventListener("change", (event) => {
      showLockMap = !!event.target.checked;
      persistToggle(uiToggleKeys.lockMap, showLockMap);
      applyUiConfig();
    });
  }
  if (toggleCenterMap){
    toggleCenterMap.addEventListener("change", (event) => {
      showCenterMap = !!event.target.checked;
      persistToggle(uiToggleKeys.centerMap, showCenterMap);
      applyUiConfig();
    });
  }
  if (toggleMeasure){
    toggleMeasure.addEventListener("change", (event) => {
      showMeasure = !!event.target.checked;
      persistToggle(uiToggleKeys.measure, showMeasure);
      applyUiConfig();
    });
  }
  if (toggleMeasureClear){
    toggleMeasureClear.addEventListener("change", (event) => {
      showMeasureClear = !!event.target.checked;
      persistToggle(uiToggleKeys.measureClear, showMeasureClear);
      applyUiConfig();
    });
  }
  if (toggleZoomIn){
    toggleZoomIn.addEventListener("change", (event) => {
      showZoomIn = !!event.target.checked;
      persistToggle(uiToggleKeys.zoomIn, showZoomIn);
      applyUiConfig();
    });
  }
  if (toggleZoomOut){
    toggleZoomOut.addEventListener("change", (event) => {
      showZoomOut = !!event.target.checked;
      persistToggle(uiToggleKeys.zoomOut, showZoomOut);
      applyUiConfig();
    });
  }
  if (toggleBattleLog){
    toggleBattleLog.addEventListener("change", (event) => {
      showBattleLog = !!event.target.checked;
      persistToggle(uiToggleKeys.battleLog, showBattleLog);
      applyUiConfig();
    });
  }
  if (initiativeStyleSelect){
    initiativeStyleSelect.addEventListener("change", (event) => {
      const value = event.target.value;
      initiativeStyle = ["full", "compact", "hidden"].includes(value) ? value : "full";
      persistChoice(uiSelectKeys.initiativeStyle, initiativeStyle);
      applyUiConfig();
    });
  }
  if (toggleUseAction){
    toggleUseAction.addEventListener("change", (event) => {
      showUseAction = !!event.target.checked;
      persistToggle(uiToggleKeys.useAction, showUseAction);
      applyUiConfig();
    });
  }
  if (toggleUseBonusAction){
    toggleUseBonusAction.addEventListener("change", (event) => {
      showUseBonusAction = !!event.target.checked;
      persistToggle(uiToggleKeys.useBonusAction, showUseBonusAction);
      applyUiConfig();
    });
  }
  if (toggleDash){
    toggleDash.addEventListener("change", (event) => {
      showDash = !!event.target.checked;
      persistToggle(uiToggleKeys.dash, showDash);
      applyUiConfig();
    });
  }
  if (toggleStandUp){
    toggleStandUp.addEventListener("change", (event) => {
      showStandUp = !!event.target.checked;
      persistToggle(uiToggleKeys.standUp, showStandUp);
      applyUiConfig();
    });
  }
  if (toggleResetTurn){
    toggleResetTurn.addEventListener("change", (event) => {
      showResetTurn = !!event.target.checked;
      persistToggle(uiToggleKeys.resetTurn, showResetTurn);
      applyUiConfig();
    });
  }
  if (toggleSpellMenu){
    toggleSpellMenu.addEventListener("change", (event) => {
      hideSpellMenu = !!event.target.checked;
      persistToggle(uiToggleKeys.hideSpellMenu, hideSpellMenu);
      applyUiConfig();
    });
  }
  if (toggleLockMenus){
    toggleLockMenus.addEventListener("change", (event) => {
      menusLocked = !!event.target.checked;
      persistToggle(uiToggleKeys.lockMenus, menusLocked);
      applyUiConfig();
    });
  }
  Object.entries(hotkeyConfig).forEach(([action, config]) => {
    if (!config || !config.input) return;
    config.input.addEventListener("keydown", (event) => {
      event.preventDefault();
      if (event.key === "Escape"){
        config.input.blur();
        return;
      }
      if (event.key === "Backspace" || event.key === "Delete"){
        setHotkey(action, "");
        return;
      }
      const combo = normalizeHotkeyEvent(event);
      if (!combo) return;
      setHotkey(action, combo);
    });
    config.input.addEventListener("focus", () => {
      config.input.select();
    });
  });
  if (attackOverlayToggleBtn){
    attackOverlayToggleBtn.addEventListener("click", () => {
      if (pendingSpellTargeting && attackOverlayMode){
        clearSpellTargetingSession("Spell targeting cancelled.");
        return;
      }
      setAttackOverlayMode(!attackOverlayMode);
    });
  }
  if (attackWeaponSelectEl){
    attackWeaponSelectEl.addEventListener("change", (event) => {
      selectedAttackWeaponId = String(event.target.value || "").trim();
      draw();
    });
  }
  useActionBtn.addEventListener("click", () => {
    if (isMapView) return;
    if (!claimedCid) return;
    openActionPicker("action");
  });
  useBonusActionBtn.addEventListener("click", () => {
    if (isMapView) return;
    if (!claimedCid) return;
    openActionPicker("bonus");
  });
  if (useReactionBtn){
    useReactionBtn.addEventListener("click", () => {
      if (isMapView) return;
      if (!claimedCid) return;
      openActionPicker("reaction");
    });
  }
  if (warCasterCancelBtn){
    warCasterCancelBtn.addEventListener("click", () => {
      setWarCasterModalOpen(false);
    });
  }
  if (warCasterCastBtn){
    warCasterCastBtn.addEventListener("click", () => {
      const spellSlug = normalizeTextValue(warCasterSpellSelect?.value);
      const targetCid = normalizeCid(warCasterTargetSelect?.value, "warCaster.target");
      if (!spellSlug || targetCid === null){
        localToast("Pick a spell and target first.");
        return;
      }
      const preset = spellPresetBySlug.get(getSpellKey(spellSlug))
        || cachedSpellPresets.find((entry) => getSpellKey(getPresetSlug(entry)) === getSpellKey(spellSlug));
      if (!preset){
        localToast("Could not find that spell preset, matey.");
        return;
      }
      const unit = getClaimedUnit();
      const actionCheck = canSpendSpellAction(unit, "reaction");
      if (!actionCheck.ok){
        localToast(actionCheck.reason || "Cannot cast that reaction right now.");
        return;
      }
      applySpellPreset(preset);
      const slotCheck = validateCastSlotSelection(preset, true);
      if (!slotCheck.ok){
        return;
      }
      const slotLevel = Number.isFinite(slotCheck.slotLevel) ? Math.floor(Number(slotCheck.slotLevel)) : null;
      const payload = {action_type: "reaction", name: normalizeTextValue(preset.name) || "Spell"};
      if (slotCheck.consumesPool){
        payload.consumes_pool = {id: slotCheck.consumesPool.id, cost: slotCheck.consumesPool.cost};
      }
      const msg = {
        type: "cast_spell",
        payload,
        action_type: "reaction",
        spell_slug: normalizeTextValue(getPresetSlug(preset)) || null,
        spell_id: normalizeTextValue(preset.id) || null,
      };
      if (Number.isFinite(slotLevel)){
        msg.slot_level = slotLevel;
      }
      if (slotCheck.consumesPool){
        msg.consumes_pool_id = slotCheck.consumesPool.id;
        msg.consumes_pool_cost = slotCheck.consumesPool.cost;
      }
      send(msg);
      const config = getSpellTargetingConfig(preset, slotLevel);
      if (config){
        startSpellTargetingSession(config, preset, slotLevel);
        const target = getUnitByCid(targetCid);
        runSpellTargetingAgainstTarget(target);
      }
      setWarCasterModalOpen(false);
    });
  }
  if (standUpBtn){
    standUpBtn.addEventListener("click", () => {
      if (isMapView) return;
      if (!claimedCid) return;
      const msg = {type:"stand_up", cid: claimedCid};
      if (isPlanning){
        planningMutate(msg);
        draw();
        updateHud();
      }
      send(msg);
    });
  }
  if (resetTurnBtn){
    resetTurnBtn.addEventListener("click", () => {
      if (isMapView) return;
      if (!claimedCid) return;
      const msg = {type:"reset_turn", cid: claimedCid};
      if (isPlanning){
        planningMutate(msg);
        draw();
        updateHud();
      }
      send(msg);
    });
  }

  if (mountBtn){
    mountBtn.addEventListener("click", () => {
      const pair = pendingMountPair || mountCandidatePair();
      if (!pair) return;
      send({type:"mount_request", rider_cid:Number(pair.rider.cid), mount_cid:Number(pair.mount.cid)});
    });
  }
  if (dismountBtn){
    dismountBtn.addEventListener("click", () => send({type:"dismount"}));
  }
  if (mountPromptYes){
    mountPromptYes.addEventListener("click", () => {
      send({type:"mount_response", request_id: pendingMountRequestId, accept:true});
      if (mountPromptModal){ mountPromptModal.classList.remove("show"); mountPromptModal.setAttribute("aria-hidden", "true"); }
    });
  }
  if (mountPromptNo){
    mountPromptNo.addEventListener("click", () => {
      send({type:"mount_response", request_id: pendingMountRequestId, accept:false});
      if (mountPromptModal){ mountPromptModal.classList.remove("show"); mountPromptModal.setAttribute("aria-hidden", "true"); }
    });
  }

  function submitInitiativePrompt(){
    const raw = initiativePromptInput ? String(initiativePromptInput.value || "").trim() : "";
    const total = Number(raw);
    if (!raw || !Number.isFinite(total)){
      localToast("Enter a valid initiative total.");
      return;
    }
    const cid = Number.isFinite(Number(pendingInitiativeCid)) ? Number(pendingInitiativeCid) : Number(claimedCid);
    if (!Number.isFinite(cid)){
      localToast("No claimed character to update.");
      return;
    }
    send({type:"initiative_roll", cid, initiative: Math.trunc(total)});
    if (initiativePromptModal){
      initiativePromptModal.classList.remove("show");
      initiativePromptModal.setAttribute("aria-hidden", "true");
    }
    pendingInitiativeCid = null;
  }

  if (initiativePromptSubmit){
    initiativePromptSubmit.addEventListener("click", () => submitInitiativePrompt());
  }
  if (initiativePromptCancel){
    initiativePromptCancel.addEventListener("click", () => {
      if (initiativePromptModal){
        initiativePromptModal.classList.remove("show");
        initiativePromptModal.setAttribute("aria-hidden", "true");
      }
      pendingInitiativeCid = null;
    });
  }
  if (initiativePromptInput){
    initiativePromptInput.addEventListener("keydown", (event) => {
      if (event.key === "Enter"){
        event.preventDefault();
        submitInitiativePrompt();
      }
    });
  }
  if (attackResolveMiss){
    attackResolveMiss.addEventListener("change", () => {
      syncAttackResolveDamageVisibility();
    });
  }
  if (attackResolveHit){
    attackResolveHit.addEventListener("change", () => {
      syncAttackResolveDamageVisibility();
    });
  }
  if (attackDamageAdd){
    attackDamageAdd.addEventListener("click", () => addAttackDamageRow());
  }
  if (attackResolveCancel){
    attackResolveCancel.addEventListener("click", () => setAttackResolveModalOpen(false));
  }
  if (cleavePromptCancel){
    cleavePromptCancel.addEventListener("click", () => setCleavePromptOpen(false));
  }
  if (attackResolveSubmit){
    attackResolveSubmit.addEventListener("click", () => {
      if (!pendingAttackResolve){
        setAttackResolveModalOpen(false);
        return;
      }
      const hit = !(attackResolveMiss && attackResolveMiss.checked);
      const critical = hit && !!(attackResolveCrit && attackResolveCrit.checked);
      const damageEntries = [];
      if (hit && attackDamageRows){
        Array.from(attackDamageRows.querySelectorAll(".damage-type-controls")).forEach((row) => {
          const amountInput = row.querySelector("input");
          const typeSelect = row.querySelector("select");
          const amount = Number(String(amountInput?.value || "").trim());
          if (!Number.isFinite(amount) || amount <= 0) return;
          damageEntries.push({
            amount: Math.floor(amount),
            type: String(typeSelect?.value || "").trim().toLowerCase(),
          });
        });
      }
      const actionCid = pendingAttackResolve.opportunityAttack ? normalizeCid(claimedCid, "attackResolve.opportunityCid") : activeControlledUnitCid();
      if (actionCid === null){
        localToast("Not yer turn yet, matey.");
        setAttackResolveModalOpen(false);
        return;
      }
      if (pendingAttackResolve.mode === "spell"){
        send({
          type: "spell_target_request",
          cid: actionCid,
          target_cid: Number(pendingAttackResolve.targetCid),
          spell_name: String(pendingAttackResolve.spellName || "").trim(),
          spell_slug: pendingAttackResolve.spellSlug || null,
          spell_id: pendingAttackResolve.spellId || null,
          spell_mode: String(pendingAttackResolve.spellMode || "attack"),
          save_type: pendingAttackResolve.saveType || null,
          save_dc: Number.isFinite(Number(pendingAttackResolve.saveDc)) ? Number(pendingAttackResolve.saveDc) : null,
          roll_save: !!pendingAttackResolve.rollSave,
          hit: pendingAttackResolve.forceHit ? true : hit,
          critical,
          damage_entries: damageEntries,
        });
        consumeSpellTargetingShot();
      } else {
        send({
          type: "attack_request",
          cid: actionCid,
          target_cid: Number(pendingAttackResolve.targetCid),
          weapon_id: String(pendingAttackResolve.weaponId || "").trim(),
          weapon_name: String(pendingAttackResolve.weaponName || "").trim(),
          weapon: pendingAttackResolve.weapon && typeof pendingAttackResolve.weapon === "object" ? {...pendingAttackResolve.weapon} : null,
          attack_count: Number.isFinite(Number(pendingAttackResolve.attackCount)) ? Math.max(1, Math.floor(Number(pendingAttackResolve.attackCount))) : null,
          mastery_free_attack: pendingAttackResolve.masteryFreeAttack || null,
          opportunity_attack: !!pendingAttackResolve.opportunityAttack,
          hit: hit,
          critical,
          damage_entries: damageEntries,
        });
      }
      setAttackResolveModalOpen(false);
    });
  }

  if (endTurnBtn){
    endTurnBtn.addEventListener("click", () => {
      if (isMapView) return;
      if (!claimedCid){
        localToast("Claim a character first, matey.");
        return;
      }
      const endTurnCid = activeControlledUnitCid();
      if (endTurnCid === null){
        localToast("Not yer turn yet, matey.");
        updateEndTurnState();
        return;
      }
      send({type:"end_turn", cid: endTurnCid});
    });
  }
  if (dismissSummonsBtn){
    dismissSummonsBtn.addEventListener("click", () => {
      if (isMapView) return;
      if (!claimedCid){
        localToast("Claim a character first, matey.");
        return;
      }
      const summonedUnits = Array.isArray(state?.units)
        ? state.units.filter(u => cidMatches(u?.summoned_by_cid, claimedCid, "dismissSummons.owner"))
        : [];
      if (!summonedUnits.length){
        localToast("Ye have no summons to dismiss.");
        return;
      }
      const summonList = summonedUnits.map(u => `- ${u?.name || `#${u?.cid ?? "?"}`}`).join("\n");
      const confirmed = window.confirm(
        `Are ye sure ye want to dismiss these summons?\n${summonList}`
      );
      if (!confirmed) return;
      send({type:"dismiss_summons", target_caster_cid: claimedCid, cid: claimedCid});
    });
  }
  if (moveEl){
    moveEl.addEventListener("click", () => {
      if (isMapView) return;
      if (!claimedCid){
        localToast("Claim a character first, matey.");
        return;
      }
      send({type:"cycle_movement_mode", cid: claimedCid});
    });
  }
  if (toggleSheetPanelBtn){
    toggleSheetPanelBtn.addEventListener("click", () => {
      setSheetPanelHidden(!sheetPanelHidden);
    });
  }
  if (turnModalOk){
    turnModalOk.addEventListener("click", () => {
      handleUserGesture();
      hideTurnModal();
    });
  }

  document.addEventListener("keydown", (event) => {
    if (event.defaultPrevented) return;
    if (isTypingTarget(event.target)) return;
    const combo = normalizeHotkeyEvent(event);
    if (!combo) return;
    const action = hotkeyBindings.get(combo);
    if (!action) return;
    event.preventDefault();
    const config = hotkeyConfig[action];
    if (config && typeof config.action === "function"){
      config.action();
    }
  });
  document.addEventListener("pointerdown", handleUserGesture, {passive: true});
  document.addEventListener("keydown", handleUserGesture);

  const mapWrap = document.querySelector(".mapWrap");
  if (mapWrap && window.ResizeObserver){
    const ro = new ResizeObserver(() => resize());
    ro.observe(mapWrap);
  }
  resize();
  updateMeasurementControls();
  updateWaitingOverlay();
  setAttackOverlayMode(false);

  if (toggleDmLogPanelInput){
    toggleDmLogPanelInput.checked = dmUiPrefs.showLogPanel === true;
    toggleDmLogPanelInput.addEventListener('change', ()=>{ dmUiPrefs.showLogPanel = toggleDmLogPanelInput.checked; saveDmUiPrefs(); renderDmLogPanel(); });
  }
  if (toggleDmMapPreviewInput){
    toggleDmMapPreviewInput.checked = dmUiPrefs.showMapPreview === true;
    toggleDmMapPreviewInput.addEventListener('change', ()=>{ dmUiPrefs.showMapPreview = toggleDmMapPreviewInput.checked; saveDmUiPrefs(); renderDmLogPanel(); renderDmPreview(); });
  }

  connect();
})();
</script>
</body>
</html>
"""
