<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <meta name="apple-mobile-web-app-title" content="InitTracker LAN" />
  <link rel="apple-touch-icon" href="/assets/graphic.png" />
  <link rel="manifest" href="/assets/manifest.webmanifest" />
  <title>InitTracker LAN</title>
  <script>window.PUSH_PUBLIC_KEY=__PUSH_PUBLIC_KEY__;</script>
  <style>
    :root{
      --bg:#0b0d10;
      --panel:#141923;
      --panel2:#0f1320;
      --text:#e8eef7;
      --muted:#93a2b8;
      --accent:#6aa9ff;
      --danger:#ff5b5b;
      --safeInsetTop: env(safe-area-inset-top, 0px);
      --safeInsetBottom: env(safe-area-inset-bottom, 0px);
      --modalTopOffset: 0px;
      --modalBottomOffset: 0px;
      --topbar-height: 0px;
      --bottombar-height: 0px;
    }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--text); font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif; overflow:hidden;}
    .app{height:100dvh; display:flex; flex-direction:column; min-height:0;}
    .topbar{
      padding: calc(10px + var(--safeInsetTop)) 12px 10px 12px;
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border-bottom: 1px solid rgba(255,255,255,0.08);
      display:flex; align-items:center; gap:10px; flex-wrap:wrap;
      position:sticky; top:0; z-index:20;
    }
    .map-view{
      --map-view-bar-height: 84px;
      --map-view-order-font-size: 14px;
      --map-view-order-gap: 8px;
      --map-view-order-chip-pad-y: 6px;
      --map-view-order-chip-pad-x: 10px;
      --map-view-order-radius: 999px;
      --map-view-bar-bg: rgba(14,18,26,0.92);
      --map-view-bar-border: rgba(255,255,255,0.1);
    }
    .map-view-only .topbar,
    .map-view-only .sheet-wrap,
    .map-view-only .cast-overlay,
    .map-view-only .menu-popover,
    .map-view-only .conn-popover,
    .map-view-only .spell-library-overlay,
    .map-view-only .spell-detail-overlay,
    .map-view-only .spellbook-overlay,
    .map-view-only .turn-modal,
    .map-view-only .modal:not(#mapViewSettingsModal){
      display:none !important;
    }
    .map-view .mapWrap{
      flex:1 1 auto;
    }
    .map-view-bar{
      position:sticky;
      top:0;
      z-index:25;
      display:none;
      flex-direction:column;
      gap:8px;
      padding: calc(10px + var(--safeInsetTop)) 16px 10px 16px;
      background: var(--map-view-bar-bg);
      border-bottom: 1px solid var(--map-view-bar-border);
      min-height: var(--map-view-bar-height);
      backdrop-filter: blur(12px);
    }
    .map-view-only.map-view-show-bar .map-view-bar{
      display:flex;
    }
    .map-view-bar-row{
      display:flex;
      align-items:center;
      gap:12px;
      flex-wrap:wrap;
    }
    .map-view-title{
      font-size: 14px;
      font-weight: 700;
      color: var(--text);
      letter-spacing: 0.2px;
    }
    .map-view-status{
      font-size: 12px;
      color: var(--muted);
    }
    .map-view-actions{
      margin-left:auto;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    .map-view-turn-order{
      display:flex;
      gap: var(--map-view-order-gap);
      overflow:auto;
      align-items:center;
      padding-bottom: 2px;
    }
    .map-view .turn-chip{
      font-size: var(--map-view-order-font-size);
      padding: var(--map-view-order-chip-pad-y) var(--map-view-order-chip-pad-x);
      border-radius: var(--map-view-order-radius);
    }
    .map-view .turn-chip-index{
      font-size: calc(var(--map-view-order-font-size) * 0.7);
    }
    .map-view .turn-order-status{
      font-size: 12px;
      color: var(--muted);
    }
    .map-view-hide-index .turn-chip-index{
      display:none;
    }
    .map-view-hide-status #mapViewTurnOrderStatus{
      display:none;
    }
    .map-view-hide-title .map-view-title{
      display:none;
    }
    .topbar h1{font-size:14px; margin:0; font-weight:650;}
    .pill{font-size:12px; color:var(--muted); padding:6px 10px; border:1px solid rgba(255,255,255,0.10); border-radius:999px;}
    .conn-wrap{
      position:relative;
      display:inline-flex;
      align-items:center;
    }
    .conn-pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      cursor:pointer;
      background: transparent;
      font: inherit;
    }
    .conn-full-text{display:inline;}
    .conn-compact-label,
    .conn-compact-dot{display:none;}
    .conn-compact .conn-full-text{display:none;}
    .conn-compact .conn-compact-label,
    .conn-compact .conn-compact-dot{display:inline-flex;}
    .conn-compact-label{font-weight:700; letter-spacing:0.5px;}
    .conn-compact-dot{
      width:8px;
      height:8px;
      border-radius:50%;
      background: var(--accent);
    }
    .conn-popover{
      position:absolute;
      top: calc(100% + 10px);
      left: 0;
      min-width: 160px;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(15,19,32,0.98);
      box-shadow: 0 12px 30px rgba(0,0,0,0.45);
      display:flex;
      flex-direction:column;
      gap:10px;
      opacity:0;
      transform: translateY(-4px);
      pointer-events:none;
      transition: opacity 0.15s ease, transform 0.15s ease;
      z-index: 30;
    }
    .conn-popover::before{
      content:"";
      position:absolute;
      top: -6px;
      left: 16px;
      width: 12px;
      height: 12px;
      background: rgba(15,19,32,0.98);
      border-left: 1px solid rgba(255,255,255,0.12);
      border-top: 1px solid rgba(255,255,255,0.12);
      transform: rotate(45deg);
    }
    .conn-popover.show{
      opacity:1;
      transform: translateY(0);
      pointer-events:auto;
    }
    .conn-popover-status{
      font-size:12px;
      color: var(--muted);
    }
    .conn-style-toggle{
      display:inline-flex;
      gap:6px;
      flex-wrap:wrap;
    }
    .conn-style-btn{
      padding:6px 10px;
      font-size:12px;
    }
    .conn-style-btn.active{
      border-color: rgba(106,169,255,0.65);
      background: rgba(106,169,255,0.2);
      color: var(--text);
    }
    .menu-wrap{
      position:relative;
      display:inline-flex;
      align-items:center;
    }
    .menu-btn{
      display:inline-flex;
      align-items:center;
      gap:6px;
    }
    .menu-popover{
      position:absolute;
      top: calc(100% + 10px);
      left: 0;
      min-width: 190px;
      padding: 6px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(15,19,32,0.98);
      box-shadow: 0 12px 30px rgba(0,0,0,0.45);
      display:flex;
      flex-direction:column;
      gap:6px;
      opacity:0;
      transform: translateY(-4px);
      pointer-events:none;
      transition: opacity 0.15s ease, transform 0.15s ease;
      z-index: 30;
    }
    .menu-popover.show{
      opacity:1;
      transform: translateY(0);
      pointer-events:auto;
    }
    .menu-item{
      border:none;
      background: transparent;
      color: var(--text);
      font-size: 13px;
      font-weight: 600;
      text-align: left;
      padding: 8px 10px;
      border-radius: 10px;
      cursor:pointer;
    }
    .menu-item:hover,
    .menu-item:focus{
      background: rgba(255,255,255,0.08);
      outline:none;
    }
    .hidden{display:none !important;}
    .spacer{flex:1;}
    .btn{
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 13px;
      font-weight: 650;
      touch-action: manipulation;
    }
    .btn:active{transform: translateY(1px);}
    .btn.danger{background: rgba(255,91,91,0.14); border-color: rgba(255,91,91,0.35);}
    .btn.accent{background: rgba(106,169,255,0.14); border-color: rgba(106,169,255,0.35);}
    .topbar-controls{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
    }

    .mapWrap{flex:1 1 auto; min-height:0; position:relative; overflow:hidden; background:#0a0c12;}
    canvas{position:absolute; inset:0; width:100%; height:100%; touch-action:none;}
    .map-tooltip{
      position:absolute;
      z-index:4;
      pointer-events:none;
      max-width:240px;
      padding:4px 8px;
      border-radius:6px;
      background:rgba(16,18,24,0.92);
      color:#eef2f7;
      font-size:12px;
      font-weight:600;
      box-shadow:0 2px 8px rgba(0,0,0,0.35);
      opacity:0;
      transition:opacity 0.08s ease;
      white-space:nowrap;
    }
    .map-tooltip.show{opacity:1;}
    .waiting{
      position:absolute; inset:0; display:none; align-items:center; justify-content:center;
      background: rgba(10,12,18,0.82); color: var(--muted); font-size: 16px; letter-spacing: 0.4px;
      text-transform: lowercase;
    }
    .waiting.show{display:flex;}

    .sheet-wrap{
      position:sticky; bottom:0; z-index:20;
      display:flex; flex-direction:column;
      background: rgba(20,25,35,0.92);
      border-top: 1px solid rgba(255,255,255,0.08);
      backdrop-filter: blur(10px);
      min-height: 180px;
      max-height: 75vh;
    }
    .sheet-handle{
      height: 18px;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor: ns-resize;
      touch-action: none;
      flex:0 0 auto;
    }
    .menus-locked .sheet-handle{
      cursor: not-allowed;
      opacity: 0.45;
      pointer-events: none;
    }
    .sheet-handle::before{
      content:"";
      width: 44px;
      height: 4px;
      border-radius: 999px;
      background: rgba(255,255,255,0.25);
    }
    .sheet{
      padding: 10px 12px calc(12px + var(--safeInsetBottom)) 12px;
      display:flex;
      flex-direction:column;
      flex:1 1 auto;
      min-height:0;
    }
    .sheet-content{
      display:flex;
      flex-direction:column;
      flex:1 1 auto;
      min-height:0;
    }
    .cast-panel{
      margin-top: 10px;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.1);
      background: rgba(10,14,22,0.55);
    }
    .turn-alerts-panel{
      margin-top: 10px;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.1);
      background: rgba(10,14,22,0.55);
    }
    .turn-alerts-panel legend{
      padding: 0 6px;
      font-weight: 700;
    }
    .turn-alerts-row{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .turn-alerts-status{
      font-size: 12px;
      color: var(--muted);
    }
    .turn-alerts-note{
      margin-top: 6px;
      font-size: 11px;
      color: var(--muted);
    }
    .cast-panel summary{
      cursor:pointer;
      font-weight:700;
      list-style:none;
    }
    .cast-panel summary::-webkit-details-marker{display:none;}
    .cast-panel[open] summary{margin-bottom:8px;}
    .cast-menu-trigger{
      margin-top: 10px;
      display:flex;
    }
    .cast-menu-trigger .btn{
      flex:1;
    }
    .cast-overlay{
      background: var(--bg);
      display:none;
      flex-direction:column;
      padding: 10px 12px calc(12px + var(--safeInsetBottom)) 12px;
      z-index:40;
      height:100%;
      overflow:auto;
      flex:1 1 auto;
      min-height: 0;
    }
    .cast-overlay.show{
      display:flex;
    }
    .cast-overlay-header{
      display:flex;
      align-items:center;
      gap:12px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
    }
    .cast-overlay-header .btn{
      white-space: nowrap;
    }
    .cast-overlay-title{
      font-size: 14px;
      font-weight: 700;
    }
    .cast-overlay-spacer{
      flex:1;
    }
    .cast-overlay-body{
      margin-top: 10px;
      overflow:auto;
      flex:1 1 auto;
      min-height:0;
    }
    .cast-overlay .cast-panel{
      margin-top: 0;
      padding: 0;
      border: none;
      background: transparent;
    }
    .spell-select-overlay{
      position:fixed;
      inset: 0;
      top: var(--topbar-height);
      bottom: var(--bottombar-height);
      background: var(--bg);
      display:none;
      flex-direction:column;
      padding: 10px 12px calc(12px + var(--safeInsetBottom)) 12px;
      z-index:45;
      min-height:0;
    }
    .spell-select-overlay.show{
      display:flex;
    }
    .spell-select-header{
      display:flex;
      align-items:center;
      gap:12px;
      padding-bottom:8px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      flex-wrap:wrap;
    }
    .spell-select-title{
      font-size: 14px;
      font-weight: 700;
    }
    .spell-select-spacer{
      flex:1;
    }
    .spell-select-body{
      margin-top: 10px;
      display:flex;
      flex-direction:column;
      gap:10px;
      flex:1 1 auto;
      min-height:0;
    }
    .spell-select-summary{
      font-size: 12px;
      color: var(--muted);
    }
    .spell-select-table-wrap{
      overflow:auto;
      max-height: calc(100dvh - var(--topbar-height) - var(--bottombar-height) - 170px);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(8,12,20,0.6);
    }
    .spell-select-table{
      width:100%;
      border-collapse: collapse;
      font-size: 12px;
    }
    .spell-select-table th,
    .spell-select-table td{
      padding: 8px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.06);
      text-align:left;
      vertical-align:top;
    }
    .spell-select-check-col,
    .spell-select-check-cell{
      width: 38px;
      text-align:center;
    }
    .spell-select-overlay:not(.selecting) .spell-select-check-col,
    .spell-select-overlay:not(.selecting) .spell-select-check-cell{
      display:none;
    }
    .spell-select-table th{
      position: sticky;
      top: 0;
      background: rgba(12,16,26,0.98);
      z-index: 2;
      font-size: 11px;
      letter-spacing: 0.3px;
      text-transform: uppercase;
      color: var(--muted);
    }
    .spell-select-table tr:last-child td{
      border-bottom:none;
    }
    .spell-select-name-btn{
      background: none;
      border: none;
      padding: 0;
      color: var(--accent);
      cursor:pointer;
      font-weight: 600;
      text-align:left;
    }
    .spell-select-link{
      color: var(--accent);
      text-decoration: none;
      font-weight: 600;
    }
    .spell-select-link:hover{
      text-decoration: underline;
    }
    .spell-select-details-row td{
      padding-top: 0;
      background: rgba(10,14,22,0.45);
    }
    .spell-select-details-row details{
      padding: 6px 0 10px 0;
    }
    .spell-select-details-row summary{
      cursor:pointer;
      list-style:none;
      font-weight: 700;
      color: var(--text);
    }
    .spell-select-details-row summary::-webkit-details-marker{display:none;}
    .spell-select-details-grid{
      margin-top: 8px;
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 6px;
      font-size: 11px;
      color: var(--muted);
    }
    .spell-select-actions{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .spell-select-overlay:not(.selecting) .spell-select-save-btn{
      display:none;
    }
    .spell-select-details-item strong{
      color: var(--text);
      font-weight: 600;
      display:block;
      margin-bottom: 2px;
    }
    .spell-select-controls{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .spell-select-controls select{
      flex:1;
    }
    .form-grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap:8px;
    }
    .spell-filter-panel{
      margin-bottom: 10px;
      padding: 8px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.1);
      background: rgba(8,12,20,0.6);
    }
    .spell-filter-panel legend{
      padding: 0 6px;
      font-weight: 700;
      font-size: 12px;
    }
    .spell-details{
      margin-top: 10px;
      padding: 8px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.1);
      background: rgba(8,12,20,0.6);
      font-size: 12px;
      color: var(--muted);
    }
    .spell-details-grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 6px;
    }
    .spell-details-row{
      display:flex;
      gap:6px;
      align-items:baseline;
    }
    .spell-details-label{
      font-size: 11px;
      color: var(--muted);
      min-width: 64px;
    }
    .spell-details-value{
      font-size: 12px;
      color: var(--text);
      font-weight: 600;
    }
    .spellbook-overlay{
      position: fixed;
      inset: 0;
      height: calc(var(--spellbook-vh, 1vh) * 100);
      max-height: 100dvh;
      background: rgba(10, 12, 16, 0.9);
      backdrop-filter: blur(8px);
      display: none;
      flex-direction: column;
      z-index: 60;
    }
    .spellbook-overlay.show{display:flex;}
    .spell-detail-overlay{
      position: fixed;
      inset: 0;
      height: calc(var(--spellbook-vh, 1vh) * 100);
      max-height: 100dvh;
      background: rgba(10, 12, 16, 0.95);
      backdrop-filter: blur(10px);
      display: none;
      flex-direction: column;
      z-index: 95;
    }
    .spell-detail-overlay.show{display:flex;}
    .spell-detail-header{
      padding: calc(12px + var(--safeInsetTop)) 14px 12px 14px;
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border-bottom: 1px solid rgba(255,255,255,0.08);
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .spell-detail-title{
      font-size: 15px;
      font-weight: 700;
    }
    .spell-detail-spacer{flex:1;}
    .spell-detail-body{
      padding: 14px;
      padding-bottom: calc(14px + var(--safeInsetBottom));
      overflow:auto;
      flex: 1 1 auto;
      min-height: 0;
      display:flex;
      flex-direction:column;
      gap: 14px;
    }
    .spell-detail-card{
      background: rgba(20,25,35,0.92);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      padding: 12px 14px;
      display:flex;
      flex-direction:column;
      gap: 12px;
    }
    .spell-detail-heading{
      font-size: 14px;
      font-weight: 700;
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .spell-detail-meta{
      font-size: 12px;
      color: var(--muted);
    }
    .spell-detail-color-row{
      display:flex;
      align-items:center;
      gap:12px;
      flex-wrap:wrap;
    }
    .spell-detail-color-value{
      width: 96px;
      text-transform: uppercase;
    }
    .spell-color-swatch{
      width: 18px;
      height: 18px;
      border-radius: 50%;
      border: 1px solid rgba(255,255,255,0.4);
      background: rgba(255,255,255,0.2);
      display:inline-block;
      flex: 0 0 auto;
    }
    .spellbook-color-dot{
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: 1px solid rgba(255,255,255,0.4);
      background: rgba(255,255,255,0.2);
      flex: 0 0 auto;
      margin-right: 6px;
    }
    .spell-library-overlay{
      position: fixed;
      inset: 0;
      background: rgba(10, 12, 16, 0.95);
      backdrop-filter: blur(6px);
      display: none;
      flex-direction: column;
      z-index: 80;
    }
    .spell-library-overlay.show{display:flex;}
    .spell-library-header{
      padding: calc(12px + var(--safeInsetTop)) 14px 12px 14px;
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border-bottom: 1px solid rgba(255,255,255,0.08);
      display:flex;
      align-items:center;
      gap:12px;
      flex-wrap:wrap;
    }
    .spell-library-title{
      font-size: 15px;
      font-weight: 700;
    }
    .spell-library-spacer{flex:1;}
    .spell-library-controls{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .spell-library-controls input,
    .spell-library-controls select{
      background: rgba(15,19,32,0.75);
      border: 1px solid rgba(255,255,255,0.15);
      color: var(--text);
      padding: 6px 10px;
      border-radius: 8px;
      font-size: 12px;
    }
    .spell-library-body{
      padding: 12px 14px calc(14px + var(--safeInsetBottom)) 14px;
      overflow:auto;
      flex: 1 1 auto;
      min-height: 0;
    }
    .spell-library-status{
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 10px;
    }
    .spell-library-list{
      display:flex;
      flex-direction: column;
      gap: 12px;
    }
    .spell-library-card{
      background: rgba(20,25,35,0.92);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      display:flex;
      flex-direction: column;
    }
    .spell-library-card summary{
      list-style: none;
      cursor: pointer;
      padding: 12px 14px;
    }
    .spell-library-card summary::-webkit-details-marker{display:none;}
    .spell-library-summary{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }
    .spell-library-summary-title{
      font-size: 14px;
      font-weight: 700;
    }
    .spell-library-summary-meta{
      font-size: 12px;
      color: var(--muted);
    }
    .spell-library-detail-body{
      border-top: 1px solid rgba(255,255,255,0.08);
      padding: 10px 14px 12px 14px;
      display:flex;
      flex-direction: column;
      gap: 10px;
    }
    .spell-library-detail-grid{
      display:grid;
      grid-template-columns: minmax(120px, 180px) minmax(0, 1fr);
      gap: 6px 12px;
    }
    .spell-library-detail-label{
      font-size: 12px;
      color: var(--muted);
      font-weight: 600;
    }
    .spell-library-detail-value{
      font-size: 12px;
      color: var(--text);
      white-space: pre-wrap;
      word-break: break-word;
    }
    .spell-library-detail-description{
      font-size: 12px;
      color: var(--text);
      white-space: pre-wrap;
      line-height: 1.4;
    }
    .spell-library-action-row{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
    }
    .spell-library-color-row{
      display:flex;
      align-items:center;
      gap: 8px;
    }
    .spell-library-color-row .spell-color-swatch{
      width: 16px;
      height: 16px;
    }
    .spellbook-header{
      padding: calc(12px + var(--safeInsetTop)) 14px 12px 14px;
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border-bottom: 1px solid rgba(255,255,255,0.08);
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .spellbook-title{font-size:14px; font-weight:650;}
    .spellbook-spacer{flex:1;}
    .spellbook-body{
      display:flex;
      flex-direction:column;
      gap:12px;
      padding:12px;
      padding-bottom: calc(12px + var(--safeInsetBottom) + 56px);
      overflow:hidden;
      flex:1;
      min-height: 0;
    }
    .spellbook-tabs{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-items:center;
    }
    .spellbook-controls{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-items:center;
    }
    .spellbook-controls input,
    .spellbook-controls select{
      background: rgba(15,19,32,0.75);
      border: 1px solid rgba(255,255,255,0.15);
      color: var(--text);
      padding: 6px 10px;
      border-radius: 8px;
      font-size: 12px;
    }
    .spellbook-columns{
      display:grid;
      grid-template-columns: 1fr auto 1fr;
      gap:12px;
      flex:1;
      min-height:0;
    }
    .spellbook-column{
      background: var(--panel);
      border:1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      padding:10px;
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    .spellbook-column-title{
      font-size:12px;
      color: var(--muted);
      margin-bottom:8px;
      text-transform: uppercase;
      letter-spacing:0.8px;
    }
    .spellbook-list{
      display:flex;
      flex-direction:column;
      gap:6px;
      overflow:auto;
      flex:1;
      padding-right:4px;
    }
    .spellbook-item{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:8px;
      background: rgba(255,255,255,0.05);
      border:1px solid transparent;
      border-radius:8px;
      padding:8px 10px;
      color: var(--text);
      cursor:pointer;
      font-size:13px;
    }
    .spellbook-item-name{
      display:flex;
      align-items:center;
      gap:6px;
      flex:1;
      min-width:0;
    }
    .spellbook-item-name span{
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .spellbook-item.selected{
      border-color: var(--accent);
      background: rgba(106,169,255,0.18);
    }
    .spellbook-item small{
      color: var(--muted);
      font-size:11px;
    }
    .spellbook-actions{
      display:flex;
      flex-direction:column;
      gap:8px;
      justify-content:center;
    }
    .spellbook-status{
      font-size:12px;
      color: var(--muted);
      min-height:16px;
    }
    .spellbook-confirm-text{
      font-size:14px;
      margin:0 0 10px 0;
    }
    .spellbook-back-fab{
      position: fixed;
      left: 16px;
      bottom: calc(16px + var(--safeInsetBottom));
      z-index: 1;
      box-shadow: 0 10px 24px rgba(0,0,0,0.35);
    }
    .manual-entry-badge{
      display: none;
      align-items: center;
      gap: 4px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(255,180,90,0.6);
      background: rgba(255,140,60,0.2);
      color: #ffcc9b;
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.4px;
    }
    .manual-entry-badge.show{
      display: inline-flex;
    }
    .form-field{display:flex; flex-direction:column; gap:4px;}
    .form-field label{font-size:11px; color:var(--muted);}
    .form-field input,
    .form-field select{
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      border-radius: 8px;
      padding: 6px 8px;
      font-size: 12px;
    }
    .form-field select{
      background: var(--panel2);
      color: var(--text);
    }
    .form-field select option{
      background: var(--panel2);
      color: var(--text);
    }
    .form-field input[type="color"]{
      padding:0;
      height:36px;
      width:100%;
      border:none;
      background:none;
    }
    .damage-type-controls{
      display:flex;
      gap:6px;
      align-items:center;
    }
    .damage-type-controls select{flex:1;}
    .damage-type-list{
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      min-height:24px;
    }
    .damage-type-chip{
      display:inline-flex;
      align-items:center;
      gap:6px;
    }
    .chip button{
      border:none;
      background:none;
      color: var(--text);
      font-size: 14px;
      cursor:pointer;
      padding:0;
      line-height:1;
    }
    .form-actions{margin-top:10px; display:flex; gap:8px; flex-wrap:wrap;}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .row + .row{margin-top:10px;}
    .sheet-actions{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .initiative-hidden .sheet-turn-order-row{display:none;}
    .initiative-compact .turn-order{max-height: 60px; overflow:auto;}
    .initiative-compact .turn-order-status{display:none;}
    .label{font-size:12px; color:var(--muted);}
    .value{font-size:14px; font-weight:700;}
    .chip{font-size:12px; padding:6px 10px; border-radius:999px; border:1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.05);}
    .chip input{margin-right:6px;}
    .turn-order{display:flex; flex-wrap:wrap; gap:6px; align-items:center;}
    .turn-chip{
      min-width: 26px;
      font-size:12px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.04);
      color: var(--text);
      display:inline-flex;
      align-items:center;
      gap:6px;
    }
    .turn-chip-index{font-weight:700;}
    .turn-chip-name{
      max-width: 140px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .turn-chip-marker{
      display:none;
      width:8px;
      height:8px;
      border-radius:50%;
      background: rgba(255,255,255,0.3);
      flex:0 0 auto;
    }
    .turn-chip-marker.active-marker{
      background: var(--accent);
      box-shadow: 0 0 6px rgba(106,169,255,0.6);
    }
    .turn-chip-marker.claimed-marker{
      background: rgba(106,169,255,0.55);
      border: 1px solid rgba(106,169,255,0.85);
    }
    .initiative-compact .turn-chip-name{display:none;}
    .initiative-compact .turn-chip-marker{display:inline-block;}
    .initiative-compact .turn-chip.active{
      background: rgba(106,169,255,0.2);
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(106,169,255,0.5);
    }
    .turn-chip.claimed{
      border-color: rgba(106,169,255,0.45);
      box-shadow: inset 0 0 0 1px rgba(106,169,255,0.18);
    }
    .turn-chip.active{
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(106,169,255,0.35);
    }
    .modal{
      position:fixed; inset:0; background: rgba(0,0,0,0.55);
      display:none; align-items:center; justify-content:center;
      padding: calc(var(--modalTopOffset) + 12px) 14px calc(var(--modalBottomOffset) + 12px);
      z-index: 80;
    }
    .modal.show{display:flex;}
    .card{
      width:min(520px, 100%);
      background: var(--panel);
      border:1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 12px 40px rgba(0,0,0,0.5);
      display:flex;
      flex-direction:column;
      overflow:auto;
      max-height: calc(100dvh - var(--safeInsetTop) - var(--safeInsetBottom) - var(--modalTopOffset) - var(--modalBottomOffset) - 24px);
    }
    .config-card{overflow:hidden;}
    .card-scroll{
      max-height: calc(100dvh - var(--safeInsetTop) - var(--safeInsetBottom) - var(--modalTopOffset) - var(--modalBottomOffset) - 24px);
      overflow:auto;
    }
    .modal-body{
      flex: 1 1 auto;
      min-height: 0;
      overflow: auto;
    }
    .card h2{margin:0 0 8px 0; font-size:16px;}
    .list{max-height: 50vh; overflow:auto; border:1px solid rgba(255,255,255,0.10); border-radius:12px;}
    .item{
      padding: 12px;
      border-bottom:1px solid rgba(255,255,255,0.08);
      display:flex; align-items:center; gap:10px;
      touch-action: manipulation;
    }
    .item:last-child{border-bottom:none;}
    .item .name{font-weight:750;}
    .item .meta{font-size:12px; color:var(--muted);}
    .item:active{background: rgba(255,255,255,0.04);}
    .hint{font-size:12px; color:var(--muted); margin-top:10px; line-height:1.4;}
    .hint.hidden{display:none;}
    .modal-actions{display:flex; gap:10px; flex-wrap:wrap; margin-top:12px;}
    .modal-actions .btn{flex:1; min-width:120px;}
    .action-picker-list{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-top:4px;
    }
    .action-picker-item{
      border:1px solid rgba(255,255,255,0.12);
      border-radius:12px;
      padding:10px;
      background: rgba(15,20,30,0.6);
      text-align:left;
      color: var(--text);
      cursor:pointer;
    }
    .action-picker-item .action-picker-name{
      font-weight:650;
      margin-bottom:4px;
    }
    .action-picker-item .action-picker-meta{
      font-size:12px;
      color: var(--muted);
      line-height:1.4;
    }
    .admin-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:8px;
    }
    .admin-status{
      font-size:12px;
      color: var(--muted);
      margin-bottom:8px;
    }
    .admin-session-list{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-top:6px;
    }
    .admin-session{
      border:1px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      padding: 10px;
      background: rgba(10,14,22,0.55);
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .admin-session-top{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      flex-wrap:wrap;
    }
    .admin-session-ip{
      font-weight:700;
      font-size:13px;
    }
    .admin-session-meta{
      font-size:12px;
      color: var(--muted);
    }
    .admin-session-status{
      font-size:11px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.16);
    }
    .admin-session-status.connected{
      border-color: rgba(106,169,255,0.55);
      color: var(--accent);
    }
    .admin-session-status.offline{
      border-color: rgba(255,255,255,0.2);
      color: var(--muted);
    }
    .admin-session-assign{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }
    .admin-session-assign select{
      flex:1 1 200px;
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      border-radius: 8px;
      padding: 6px 8px;
      font-size: 12px;
    }
    .admin-login-fields{
      display:flex;
      flex-direction:column;
      gap:12px;
      margin-top: 10px;
    }
    .admin-login-fields label{
      font-size: 12px;
      color: var(--muted);
    }
    .admin-login-input{
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.12);
      background: #0f1422;
      color: var(--text);
      font-size: 14px;
    }
    .config-section{margin-top:8px;}
    .config-section summary{
      cursor:pointer;
      list-style:none;
      font-weight:700;
      font-size:14px;
      padding: 6px 4px;
    }
    .config-section summary::-webkit-details-marker{display:none;}
    .config-list{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-top:8px;
    }
    .config-item{
      display:flex;
      flex-direction:column;
      gap:8px;
      padding: 10px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,0.1);
      background: rgba(10,14,22,0.55);
    }
    .config-item-title{font-size:13px; font-weight:650;}
    .config-controls{display:flex; align-items:center; gap:8px; flex-wrap:wrap;}
    .preset-actions{display:flex; align-items:center; gap:8px; flex-wrap:wrap;}
    .preset-status{font-size:12px; color:var(--accent); min-height:16px;}
    .config-toggle{
      display:flex;
      align-items:center;
      gap:6px;
      font-size:12px;
      color: var(--muted);
    }
    .config-toggle input{transform: scale(1.05);}
    .hotkey-input{
      width:120px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      padding:6px 8px;
      font-size:12px;
    }
    .hotkey-input.conflict{
      border-color: rgba(255,91,91,0.55);
      box-shadow: 0 0 0 1px rgba(255,91,91,0.3);
    }
    .hotkey-conflict{
      min-height:14px;
      font-size:11px;
      color: var(--danger);
    }
    .hotkey-hint{font-size:11px; color: var(--muted);}
    .color-row{display:flex; align-items:center; gap:12px; flex-wrap:wrap;}
    .color-swatch{width:36px; height:36px; border-radius:50%; border:2px solid rgba(255,255,255,0.2); background:#6aa9ff;}
    .color-input{width:64px; height:44px; border:none; background:none; padding:0;}
    .turn-modal{
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 20px 14px;
      background: rgba(0,0,0,0.6);
      opacity:0;
      pointer-events:none;
      transition: opacity 0.2s ease;
    }
    .turn-modal.show{
      opacity:1;
      pointer-events:auto;
    }
    .turn-card{
      width:min(380px, 100%);
      background: var(--panel);
      border:1px solid rgba(255,255,255,0.16);
      border-radius: 16px;
      padding: 18px 16px;
      text-align:center;
      box-shadow: 0 16px 40px rgba(0,0,0,0.5);
      display:flex;
      flex-direction:column;
      max-height: calc(100vh - var(--safeInsetTop) - var(--safeInsetBottom) - 40px);
    }
    .turn-card h2{margin:0 0 12px 0; font-size:18px;}
    .log-content{
      overflow:auto;
      flex:1;
      min-height:0;
      padding: 10px;
      border:1px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      background: rgba(8,10,16,0.65);
      font-size: 12px;
      white-space: pre-wrap;
      line-height: 1.4;
    }
    .initiative-order-content{
      flex:1 1 auto;
      min-height:0;
      overflow:auto;
      position:relative;
    }
    .sheet-turn-order-row{
      flex:1 1 auto;
      min-height:0;
      align-items:stretch;
    }
    .turn-order-status{
      margin-top: 6px;
      font-size: 12px;
      color: var(--muted);
    }
    .turn-order-bubble{
      position:absolute;
      left:0;
      top:0;
      transform: translate(-50%, 0);
      background: rgba(16,20,28,0.95);
      border: 1px solid rgba(255,255,255,0.16);
      border-radius: 999px;
      padding: 6px 12px;
      font-size: 12px;
      color: var(--text);
      box-shadow: 0 10px 24px rgba(0,0,0,0.4);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s ease;
      z-index: 2;
      max-width: 240px;
      text-align: center;
    }
    .turn-order-bubble.show{
      opacity: 1;
    }
    .turn-chip.selected{
      border-color: rgba(255,255,255,0.5);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.18);
    }
    @media (max-width: 720px), (max-height: 720px){
      .btn{padding: 6px 8px; font-size: 12px;}
      .topbar{gap:8px; padding: calc(8px + var(--safeInsetTop)) 10px 8px 10px;}
      .sheet{padding: 8px 10px calc(10px + var(--safeInsetBottom)) 10px;}
    }
  </style>
</head>
<body>
<div class="app">
  <div class="map-view-bar" id="mapViewBar" aria-label="Map view initiative bar">
    <div class="map-view-bar-row">
      <div class="map-view-title">InitTracker Map View</div>
      <div class="map-view-status" id="mapViewConnStatus">Connecting…</div>
      <div class="map-view-actions">
        <button class="btn" id="mapViewSettingsBtn" type="button">View Settings</button>
      </div>
    </div>
    <div class="map-view-bar-row">
      <div class="turn-order map-view-turn-order" id="mapViewTurnOrder" aria-label="Initiative order"></div>
      <div class="turn-order-bubble" id="mapViewTurnOrderBubble" role="status" aria-live="polite"></div>
    </div>
    <div class="map-view-bar-row">
      <div class="turn-order-status" id="mapViewTurnOrderStatus"></div>
    </div>
  </div>
  <div class="topbar">
    <h1 id="topbarTitle">InitTracker LAN</h1>
    <div class="conn-wrap">
      <button class="pill conn-pill" id="conn" type="button" title="Connecting…" aria-haspopup="dialog" aria-expanded="false">
        <span class="conn-full-text" id="connFullText">Connecting…</span>
        <span class="conn-compact-label" id="connCompactLabel" aria-hidden="true">C</span>
        <span class="conn-compact-dot" id="connDot" aria-hidden="true"></span>
      </button>
      <div class="conn-popover" id="connPopover" role="dialog" aria-hidden="true">
        <div class="conn-popover-status" id="connPopoverStatus">Connecting…</div>
        <button class="btn" id="connReconnectBtn" type="button">Reconnect</button>
      </div>
    </div>
    <div class="menu-wrap">
      <button class="btn menu-btn" id="adminMenuBtn" type="button" aria-haspopup="menu" aria-expanded="false">
        Admin <span aria-hidden="true">▾</span>
      </button>
      <div class="menu-popover" id="adminMenuPopover" role="menu" aria-hidden="true">
        <button class="menu-item" id="adminMenuOpen" type="button" role="menuitem">Sessions</button>
        <button class="menu-item" id="adminMenuRefresh" type="button" role="menuitem">Refresh Sessions</button>
      </div>
    </div>
    <div class="spacer"></div>
    <button class="btn" id="spellLibraryBtn" type="button">Spellbook</button>
    <button class="btn" id="configBtn" aria-controls="configModal" aria-expanded="false">Config</button>
    <div class="topbar-controls">
      <button class="btn" id="lockMap">Lock Map</button>
      <button class="btn" id="centerMap">Center on Me</button>
      <button class="btn" id="tokenColorModeBtn">Token Color</button>
      <button class="btn" id="measureToggle" aria-pressed="false">Measure</button>
      <button class="btn" id="measureClear">Clear Measure</button>
      <button class="btn accent" id="zoomIn">Zoom +</button>
      <button class="btn accent" id="zoomOut">Zoom −</button>
      <button class="btn" id="battleLog">Battle Log</button>
    </div>
  </div>

  <div class="mapWrap">
    <canvas id="c"></canvas>
    <div class="waiting" id="waitingOverlay">(waiting for combat...)</div>
    <div class="map-tooltip" id="tokenTooltip" role="tooltip" aria-hidden="true"></div>

    <div class="modal" id="colorModal" aria-hidden="true">
      <div class="card">
        <h2>Pick yer token color</h2>
        <div class="row color-row">
          <div class="color-swatch" id="tokenColorSwatch"></div>
          <input class="color-input" type="color" id="tokenColorInput" value="#6aa9ff" />
          <div class="label">No red or white, matey.</div>
        </div>
        <div class="modal-actions">
          <button class="btn accent" id="tokenColorConfirm">Confirm</button>
          <button class="btn" id="tokenColorCancel">Cancel</button>
        </div>
      </div>
    </div>
    <div class="modal" id="actionPickerModal" aria-hidden="true">
      <div class="card card-scroll">
        <h2 id="actionPickerTitle">Choose an Action</h2>
        <div class="action-picker-list" id="actionPickerList"></div>
        <div class="modal-actions">
          <button class="btn" id="actionPickerCancel">Cancel</button>
        </div>
      </div>
    </div>
    <div class="modal" id="dashModal" aria-hidden="true">
      <div class="card">
        <h2>Use Action or Bonus Action?</h2>
        <div class="modal-actions">
          <button class="btn accent" id="dashAction">Use Action</button>
          <button class="btn accent" id="dashBonusAction">Use Bonus Action</button>
          <button class="btn" id="dashCancel">Cancel</button>
        </div>
      </div>
    </div>
    <div class="modal" id="logModal" aria-hidden="true">
      <div class="card card-scroll">
        <h2>Battle Log</h2>
        <div class="log-content" id="logContent">Loading…</div>
        <div class="modal-actions">
          <button class="btn accent" id="logRefresh">Refresh</button>
          <button class="btn" id="logClose">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="configModal" aria-hidden="true">
      <div class="card config-card">
        <h2>Config</h2>
        <div class="modal-body">
          <details class="config-section">
            <summary>Top Bar</summary>
            <div class="config-list">
              <div class="config-item">
                <div class="config-item-title">InitTracker LAN title</div>
                <div class="config-controls">
                  <label class="config-toggle"><input type="checkbox" id="toggleTopbarTitle" />Show</label>
                  <input class="hotkey-input" id="hotkeyTopbarTitle" data-hotkey-action="toggleTopbarTitle" placeholder="Hotkey" readonly />
                </div>
                <div class="hotkey-conflict" id="hotkeyConflictTopbarTitle"></div>
              </div>
              <div class="config-item">
                <div class="config-item-title">Connection indicator</div>
                <div class="config-controls">
                  <label class="config-toggle"><input type="checkbox" id="toggleConnIndicator" />Show</label>
                  <div class="conn-style-toggle" role="group" aria-label="Connection indicator style">
                    <button class="btn conn-style-btn" type="button" data-conn-style="full">Full</button>
                    <button class="btn conn-style-btn" type="button" data-conn-style="compact">Compact</button>
                  </div>
                  <input class="hotkey-input" id="hotkeyConnStyle" data-hotkey-action="toggleConnStyle" placeholder="Hotkey" readonly />
                </div>
                <div class="hotkey-conflict" id="hotkeyConflictConnStyle"></div>
              </div>
              <div class="config-item">
                <div class="config-item-title">Lock Map</div>
                <div class="config-controls">
                  <label class="config-toggle"><input type="checkbox" id="toggleLockMap" />Show</label>
                  <input class="hotkey-input" id="hotkeyLockMap" data-hotkey-action="lockMap" placeholder="Hotkey" readonly />
                </div>
                <div class="hotkey-conflict" id="hotkeyConflictLockMap"></div>
              </div>
              <div class="config-item">
                <div class="config-item-title">Center on Me</div>
                <div class="config-controls">
                  <label class="config-toggle"><input type="checkbox" id="toggleCenterMap" />Show</label>
                  <input class="hotkey-input" id="hotkeyCenterMap" data-hotkey-action="centerMap" placeholder="Hotkey" readonly />
                </div>
                <div class="hotkey-conflict" id="hotkeyConflictCenterMap"></div>
              </div>
              <div class="config-item">
                <div class="config-item-title">Measure</div>
                <div class="config-controls">
                  <label class="config-toggle"><input type="checkbox" id="toggleMeasure" />Show</label>
                  <input class="hotkey-input" id="hotkeyMeasure" data-hotkey-action="measure" placeholder="Hotkey" readonly />
                </div>
                <div class="hotkey-conflict" id="hotkeyConflictMeasure"></div>
              </div>
              <div class="config-item">
                <div class="config-item-title">Clear Measure</div>
                <div class="config-controls">
                  <label class="config-toggle"><input type="checkbox" id="toggleMeasureClear" />Show</label>
                  <input class="hotkey-input" id="hotkeyMeasureClear" data-hotkey-action="measureClear" placeholder="Hotkey" readonly />
                </div>
                <div class="hotkey-conflict" id="hotkeyConflictMeasureClear"></div>
              </div>
              <div class="config-item">
                <div class="config-item-title">Zoom +</div>
                <div class="config-controls">
                  <label class="config-toggle"><input type="checkbox" id="toggleZoomIn" />Show</label>
                  <input class="hotkey-input" id="hotkeyZoomIn" data-hotkey-action="zoomIn" placeholder="Hotkey" readonly />
                </div>
                <div class="hotkey-conflict" id="hotkeyConflictZoomIn"></div>
              </div>
              <div class="config-item">
                <div class="config-item-title">Zoom -</div>
                <div class="config-controls">
                  <label class="config-toggle"><input type="checkbox" id="toggleZoomOut" />Show</label>
                  <input class="hotkey-input" id="hotkeyZoomOut" data-hotkey-action="zoomOut" placeholder="Hotkey" readonly />
                </div>
                <div class="hotkey-conflict" id="hotkeyConflictZoomOut"></div>
              </div>
              <div class="config-item">
              <div class="config-item-title">Battle Log</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="toggleBattleLog" />Show</label>
                <input class="hotkey-input" id="hotkeyBattleLog" data-hotkey-action="battleLog" placeholder="Hotkey" readonly />
              </div>
              <div class="hotkey-conflict" id="hotkeyConflictBattleLog"></div>
            </div>
          </div>
        </details>
        <details class="config-section">
          <summary>Bottom Bar</summary>
          <div class="config-list">
            <div class="config-item">
              <div class="config-item-title">Initiative strip</div>
              <div class="config-controls">
                <select id="initiativeStyleSelect">
                  <option value="full">Full</option>
                  <option value="compact">Compact</option>
                  <option value="hidden">Hidden</option>
                </select>
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Action</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="toggleUseAction" />Show</label>
                <input class="hotkey-input" id="hotkeyUseAction" data-hotkey-action="useAction" placeholder="Hotkey" readonly />
              </div>
              <div class="hotkey-conflict" id="hotkeyConflictUseAction"></div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Bonus Action</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="toggleUseBonusAction" />Show</label>
                <input class="hotkey-input" id="hotkeyUseBonusAction" data-hotkey-action="useBonusAction" placeholder="Hotkey" readonly />
              </div>
              <div class="hotkey-conflict" id="hotkeyConflictUseBonusAction"></div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Dash</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="toggleDash" />Show</label>
                <input class="hotkey-input" id="hotkeyDash" data-hotkey-action="dash" placeholder="Hotkey" readonly />
              </div>
              <div class="hotkey-conflict" id="hotkeyConflictDash"></div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Stand</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="toggleStandUp" />Show</label>
                <input class="hotkey-input" id="hotkeyStandUp" data-hotkey-action="standUp" placeholder="Hotkey" readonly />
              </div>
              <div class="hotkey-conflict" id="hotkeyConflictStandUp"></div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Reset</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="toggleResetTurn" />Show</label>
                <input class="hotkey-input" id="hotkeyResetTurn" data-hotkey-action="resetTurn" placeholder="Hotkey" readonly />
              </div>
              <div class="hotkey-conflict" id="hotkeyConflictResetTurn"></div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Hide spell menu for non spell casters</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="toggleSpellMenu" />Hide</label>
              </div>
            </div>
          </div>
        </details>
        <details class="config-section">
          <summary>Notifications</summary>
          <div class="config-list">
            <div class="config-item">
              <div class="config-item-title">Push notifications</div>
              <div class="config-controls">
                <button class="btn" id="enableNotifications" type="button">Enable</button>
                <div class="preset-status" id="notificationStatus" aria-live="polite"></div>
              </div>
            </div>
          </div>
        </details>
        <div class="hint hidden" id="iosInstallHint">
          Open Safari → Share → Add to Home Screen.
          <a href="https://support.apple.com/en-us/HT201366" target="_blank" rel="noopener">Learn more</a>
        </div>
        </div>
        <div class="modal-actions">
          <button class="btn" id="configClose">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="mapViewSettingsModal" aria-hidden="true">
      <div class="card">
        <h2>Map View Settings</h2>
        <div class="modal-body">
          <div class="form-grid">
            <div class="form-field">
              <label for="mapViewTextSize">Text size</label>
              <input id="mapViewTextSize" type="range" min="10" max="28" step="1" />
            </div>
            <div class="form-field">
              <label for="mapViewBarHeight">Bar height</label>
              <input id="mapViewBarHeight" type="range" min="56" max="140" step="2" />
            </div>
            <div class="form-field">
              <label for="mapViewChipPadding">Chip padding</label>
              <input id="mapViewChipPadding" type="range" min="4" max="18" step="1" />
            </div>
            <div class="form-field">
              <label for="mapViewChipGap">Chip gap</label>
              <input id="mapViewChipGap" type="range" min="2" max="20" step="1" />
            </div>
            <div class="form-field">
              <label for="mapViewCornerRadius">Chip radius</label>
              <input id="mapViewCornerRadius" type="range" min="6" max="40" step="2" />
            </div>
            <div class="form-field">
              <label>Visibility</label>
              <div class="config-list">
                <label class="config-toggle"><input type="checkbox" id="mapViewShowTitle" />Show title</label>
                <label class="config-toggle"><input type="checkbox" id="mapViewShowStatus" />Show status</label>
                <label class="config-toggle"><input type="checkbox" id="mapViewShowIndex" />Show index</label>
              </div>
            </div>
          </div>
          <div class="hint">Right-click the map to show or hide the map view bar.</div>
        </div>
        <div class="modal-actions">
          <button class="btn" id="mapViewSettingsClose">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="adminModal" aria-hidden="true">
      <div class="card card-scroll">
        <div class="admin-header">
          <h2>Admin Sessions</h2>
          <button class="btn" id="adminRefresh" type="button">Refresh</button>
        </div>
        <div class="admin-status" id="adminStatus">Loading…</div>
        <div class="admin-session-list" id="adminSessionList"></div>
        <div class="hint">Assignments persist per IP address and auto-apply on reconnect.</div>
        <div class="modal-actions">
          <button class="btn" id="adminClose">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="adminLoginModal" aria-hidden="true">
      <div class="card">
        <h2>Admin Login</h2>
        <div class="hint">Enter the DM password to manage LAN sessions.</div>
        <div class="admin-login-fields">
          <label for="adminPasswordInput">Admin password</label>
          <input class="admin-login-input" id="adminPasswordInput" type="password" autocomplete="current-password" />
        </div>
        <div class="admin-status" id="adminLoginStatus"></div>
        <div class="modal-actions">
          <button class="btn" id="adminLoginSubmit" type="button">Login</button>
          <button class="btn" id="adminLoginCancel" type="button">Cancel</button>
        </div>
      </div>
    </div>
  </div>

  <div class="sheet-wrap" id="sheetWrap">
    <div class="sheet-handle" id="sheetHandle" role="separator" aria-orientation="horizontal" aria-label="Resize sheet"></div>
    <div class="sheet" id="sheet">
      <div class="sheet-content">
      <div class="row">
        <div class="label">Ye be:</div>
        <div class="value" id="me">(unclaimed)</div>
        <div class="spacer"></div>
        <div class="sheet-actions">
          <button class="btn" id="useAction">Use Action</button>
          <button class="btn" id="useBonusAction">Use Bonus Action</button>
          <button class="btn" id="dash">Dash</button>
          <button class="btn" id="standUp">Stand Up</button>
          <button class="btn" id="resetTurn">Reset Turn</button>
          <button class="btn danger" id="endTurn">End Turn</button>
        </div>
      </div>
      <div class="row">
        <div class="form-field">
          <label for="actionSelect">Action</label>
          <select id="actionSelect">
            <option value="">None/Custom</option>
          </select>
        </div>
        <div class="form-field">
          <label for="bonusActionSelect">Bonus Action</label>
          <select id="bonusActionSelect">
            <option value="">None/Custom</option>
          </select>
        </div>
      </div>
      <div class="row sheet-turn-order-row">
        <div class="initiative-order-content">
          <div class="turn-order" id="turnOrder" aria-label="Turn order"></div>
          <div class="turn-order-status" id="turnOrderStatus"></div>
          <div class="turn-order-bubble" id="turnOrderBubble" role="status" aria-live="polite"></div>
        </div>
      </div>
      <div class="row">
        <div class="chip" id="move">Move: —</div>
        <div class="chip" id="action">Action: —</div>
        <div class="chip" id="bonusAction">Bonus Action: —</div>
        <div class="chip" id="reaction">Reaction: —</div>
        <div class="chip" id="turn">Turn: —</div>
        <div class="chip" id="note">Tip: drag yer token</div>
        <label class="chip"><input type="checkbox" id="showAllNames">Show All Names</label>
      </div>
      <fieldset class="turn-alerts-panel" id="turnAlertsPanel">
        <legend>Turn Alerts</legend>
        <div class="turn-alerts-row">
          <div class="turn-alerts-status" id="turnAlertStatus" aria-live="polite">Not installed.</div>
          <button class="btn" id="enableTurnAlerts" type="button">Enable Turn Alerts</button>
          <button class="btn" id="hideTurnAlerts" type="button">Hide</button>
        </div>
        <div class="turn-alerts-note">Only works when installed as an app.</div>
      </fieldset>
      <div class="cast-menu-trigger" id="castMenuTrigger">
        <button class="btn" id="castOverlayOpen" type="button">Cast Spell</button>
      </div>
      </div>
    </div>
    <div class="cast-overlay hidden" id="sheetCastView" aria-hidden="true">
      <div class="cast-overlay-header">
        <button class="btn" id="castOverlayBack" type="button">Back</button>
        <div class="cast-overlay-title" id="castOverlayTitle">Cast Spell</div>
        <div class="cast-overlay-spacer"></div>
        <button class="btn" id="spellbookOpen" type="button">Manage Spells</button>
      </div>
      <div class="cast-overlay-body" role="dialog" aria-modal="true" aria-labelledby="castOverlayTitle">
        <div class="cast-panel" id="castPanel">
          <form id="castForm">
            <fieldset class="spell-filter-panel" id="spellFilterPanel">
              <legend>Spell Filters</legend>
              <div class="form-grid">
                <div class="form-field">
                  <label for="castFilterLevel">Level</label>
                  <select id="castFilterLevel">
                    <option value="" selected>Any</option>
                    <option value="0">Cantrip</option>
                    <option value="1">1st</option>
                    <option value="2">2nd</option>
                    <option value="3">3rd</option>
                    <option value="4">4th</option>
                    <option value="5">5th</option>
                    <option value="6">6th</option>
                    <option value="7">7th</option>
                    <option value="8">8th</option>
                    <option value="9">9th</option>
                  </select>
                </div>
              <div class="form-field">
                <label for="castFilterSchool">School</label>
                <select id="castFilterSchool">
                  <option value="" selected>Any</option>
                </select>
              </div>
              <div class="form-field">
                <label for="castFilterTags">Tags</label>
                <input id="castFilterTags" type="text" placeholder="fire, area" />
              </div>
              <div class="form-field">
                <label for="castFilterCastingTime">Casting Time</label>
                <select id="castFilterCastingTime">
                  <option value="" selected>Any</option>
                </select>
              </div>
              <div class="form-field">
                <label for="castFilterRange">Range</label>
                <select id="castFilterRange">
                  <option value="" selected>Any</option>
                </select>
              </div>
              <div class="form-field">
                <label for="castFilterRitual">Ritual</label>
                <select id="castFilterRitual">
                  <option value="" selected>Any</option>
                  <option value="true">Yes</option>
                  <option value="false">No</option>
                </select>
              </div>
              <div class="form-field">
                <label for="castFilterConcentration">Concentration</label>
                <select id="castFilterConcentration">
                  <option value="" selected>Any</option>
                  <option value="true">Yes</option>
                  <option value="false">No</option>
                </select>
              </div>
              <div class="form-field">
                <label for="castFilterList">Lists</label>
                <select id="castFilterList">
                  <option value="" selected>Any</option>
                </select>
              </div>
            </div>
          </fieldset>
          <div class="form-grid">
            <div class="form-field">
              <label for="castPreset">Preset <span class="manual-entry-badge" id="castManualEntryBadge" title="Manual entry required.">Manual entry required</span></label>
              <div class="spell-select-controls">
                <select id="castPreset">
                  <option value="" selected>Custom</option>
                </select>
              </div>
            </div>
            <div class="form-field">
              <label for="castName">Name</label>
              <input id="castName" type="text" placeholder="Fireball" />
            </div>
            <div class="form-field">
              <label for="castShape">Shape</label>
              <select id="castShape">
                <option value="" selected>Choose shape</option>
                <option value="circle">Circle</option>
                <option value="square">Square</option>
                <option value="line">Line</option>
                <option value="sphere">Sphere</option>
                <option value="cube">Cube</option>
                <option value="cone">Cone</option>
                <option value="cylinder">Cylinder</option>
                <option value="wall">Wall</option>
              </select>
            </div>
            <div class="form-field cast-size-field" id="castRadiusField">
              <label for="castRadius">Radius (ft)</label>
              <input id="castRadius" type="number" min="5" step="5" value="10" readonly disabled />
            </div>
            <div class="form-field cast-size-field" id="castSideField">
              <label for="castSide">Side (ft)</label>
              <input id="castSide" type="number" min="5" step="5" value="10" readonly disabled />
            </div>
            <div class="form-field cast-size-field" id="castLengthField">
              <label for="castLength">Length (ft)</label>
              <input id="castLength" type="number" min="5" step="5" value="30" readonly disabled />
            </div>
            <div class="form-field cast-size-field" id="castWidthField">
              <label for="castWidth">Width (ft)</label>
              <input id="castWidth" type="number" min="5" step="5" value="5" readonly disabled />
            </div>
            <div class="form-field cast-size-field" id="castAngleField">
              <label for="castAngle">Angle (deg)</label>
              <input id="castAngle" type="number" min="0" step="5" value="90" readonly disabled />
            </div>
            <div class="form-field cast-size-field" id="castOrientField">
              <label for="castOrient">Orientation</label>
              <select id="castOrient" disabled>
                <option value="vertical" selected>Vertical</option>
                <option value="horizontal">Horizontal</option>
              </select>
            </div>
            <div class="form-field cast-size-field" id="castThicknessField">
              <label for="castThickness">Thickness (ft)</label>
              <input id="castThickness" type="number" min="1" step="1" value="5" readonly disabled />
            </div>
            <div class="form-field cast-size-field" id="castHeightField">
              <label for="castHeight">Height (ft)</label>
              <input id="castHeight" type="number" min="1" step="1" value="10" readonly disabled />
            </div>
            <div class="form-field">
              <label for="castDcType">DC Type</label>
              <select id="castDcType">
                <option value="">None</option>
                <option value="str">STR</option>
                <option value="dex">DEX</option>
                <option value="con">CON</option>
                <option value="int">INT</option>
                <option value="wis">WIS</option>
                <option value="cha">CHA</option>
              </select>
            </div>
            <div class="form-field">
              <label for="castDcValue">Save DC</label>
              <input id="castDcValue" type="number" min="0" step="1" placeholder="15" />
            </div>
            <div class="form-field">
              <label for="castDefaultDamage">Default Damage</label>
              <input id="castDefaultDamage" type="text" placeholder="28" />
            </div>
            <div class="form-field">
              <label for="castDice">Damage Dice</label>
              <input id="castDice" type="text" placeholder="8d6" />
            </div>
            <div class="form-field">
              <label for="castSlotLevel">Slot Level</label>
              <input id="castSlotLevel" type="number" min="0" step="1" placeholder="1" disabled />
            </div>
            <div class="form-field">
              <label for="castDamageType">Damage Types</label>
              <div class="damage-type-controls">
                <select id="castDamageType">
                  <option value="" selected>Select a type</option>
__DAMAGE_TYPE_OPTIONS__
                </select>
                <button class="btn" type="button" id="castAddDamageType">Add</button>
              </div>
              <div class="damage-type-list" id="castDamageTypeList" aria-live="polite"></div>
            </div>
            <div class="form-field">
              <label for="castColor">Color</label>
              <input id="castColor" type="color" value="#6aa9ff" />
            </div>
          </div>
          <div class="spell-details" id="spellPresetDetails" aria-live="polite">
            Select a preset to see spell details.
          </div>
          <div class="form-actions">
            <button class="btn accent" type="submit">Cast</button>
          </div>
        </form>
      </div>
    </div>
  </div>
  </div>
</div>
<div class="spellbook-overlay" id="spellbookOverlay" aria-hidden="true">
  <div class="spellbook-header">
    <button class="btn" id="spellbookBack" type="button">Back</button>
    <div class="spellbook-title" id="spellbookTitle">Manage Spells</div>
    <div class="spellbook-spacer"></div>
    <button class="btn accent" id="spellbookSave" type="button">Save</button>
  </div>
  <div class="spellbook-body">
    <div class="spellbook-tabs">
      <button class="btn" id="spellbookTabKnown" type="button">Known Spells</button>
      <button class="btn" id="spellbookTabPrepared" type="button">Prepared Spells</button>
      <label class="chip spellbook-toggle"><input type="checkbox" id="spellbookKnownEnabled" />Known spells enabled</label>
    </div>
    <div class="spellbook-controls">
      <input id="spellbookSearch" type="search" placeholder="Search spells..." />
      <select id="spellbookSort">
        <option value="alpha" selected>Name</option>
        <option value="level">Level</option>
      </select>
    </div>
    <div class="spellbook-columns">
      <div class="spellbook-column">
        <div class="spellbook-column-title" id="spellbookLeftTitle">All Spells</div>
        <div class="spellbook-list" id="spellbookLeftList"></div>
      </div>
      <div class="spellbook-column spellbook-actions">
        <button class="btn" id="spellbookAdd" type="button">Add →</button>
        <button class="btn" id="spellbookRemove" type="button">← Remove</button>
      </div>
      <div class="spellbook-column">
        <div class="spellbook-column-title" id="spellbookRightTitle">Known Spells</div>
        <div class="spellbook-list" id="spellbookRightList"></div>
      </div>
    </div>
    <div class="spellbook-status" id="spellbookStatus"></div>
  </div>
  <button class="btn spellbook-back-fab" id="spellbookBackFloating" type="button" aria-label="Close spellbook">Close</button>
</div>
<div class="spell-detail-overlay" id="spellDetailOverlay" aria-hidden="true">
  <div class="spell-detail-header">
    <button class="btn" id="spellDetailBack" type="button">Back</button>
    <div class="spell-detail-title" id="spellDetailTitle">Spell Details</div>
    <div class="spell-detail-spacer"></div>
  </div>
  <div class="spell-detail-body">
    <div class="spell-detail-card">
      <div class="spell-detail-heading">
        <span id="spellDetailName">Spell</span>
        <span class="spell-detail-meta" id="spellDetailMeta"></span>
      </div>
      <div class="form-field">
        <label for="spellDetailColorInput">Spell Color</label>
        <div class="spell-detail-color-row">
          <span class="spell-color-swatch" id="spellDetailColorSwatch"></span>
          <input class="color-input" type="color" id="spellDetailColorInput" value="#6aa9ff" />
          <input class="spell-detail-color-value" id="spellDetailColorValue" type="text" inputmode="text" autocomplete="off" />
        </div>
      </div>
      <div class="spell-detail-meta" id="spellDetailStatus"></div>
    </div>
    <div class="spell-detail-card">
      <div class="spell-detail-heading">Spell Details</div>
      <div class="spell-details-grid" id="spellDetailGrid"></div>
    </div>
  </div>
</div>
<div class="modal" id="spellbookConfirmModal" aria-hidden="true">
  <div class="card">
    <h2>Confirm Spellbook</h2>
    <p class="spellbook-confirm-text" id="spellbookConfirmText">Overwrite player file?</p>
    <div class="modal-actions">
      <button class="btn" id="spellbookConfirmCancel" type="button">Cancel</button>
      <button class="btn accent" id="spellbookConfirmYes" type="button">Overwrite</button>
    </div>
  </div>
</div>
<div class="spell-library-overlay" id="spellLibraryOverlay" aria-hidden="true">
  <div class="spell-library-header">
    <button class="btn" id="spellLibraryClose" type="button">Back</button>
    <div class="spell-library-title">Spellbook</div>
    <div class="spell-library-spacer"></div>
    <div class="spell-library-controls">
      <input id="spellLibrarySearch" type="search" placeholder="Search spells..." />
      <select id="spellLibrarySort">
        <option value="alpha" selected>Name</option>
        <option value="level">Level</option>
      </select>
    </div>
  </div>
  <div class="spell-library-body">
    <div class="spell-library-status" id="spellLibraryStatus">Loading spells…</div>
    <div class="spell-library-list" id="spellLibraryList"></div>
  </div>
</div>
<div class="turn-modal" id="turnModal" aria-hidden="true">
  <div class="turn-card" role="dialog" aria-live="assertive">
    <h2>It’s your turn!</h2>
    <button class="btn accent" id="turnModalOk">OK</button>
  </div>
</div>

<script>
(() => {
  const logClientError = (payload) => {
    try {
      console.error("Client error:", payload);
      fetch("/api/client-log", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify(payload),
      }).catch(() => {});
    } catch (err) {
      console.error("Failed to report client error:", err);
    }
  };

  window.onerror = (message, source, line, column, error) => {
    const stack = error?.stack ? String(error.stack) : "";
    logClientError({
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      url: location.href,
      stack: stack || `${message} at ${source}:${line}:${column}`,
    });
  };

  window.onunhandledrejection = (event) => {
    const reason = event?.reason;
    const stack = reason?.stack ? String(reason.stack) : "";
    const message = reason?.message ? String(reason.message) : String(reason || "");
    logClientError({
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      url: location.href,
      stack: stack || message || "Unhandled promise rejection",
    });
  };
})();

(() => {
  document.addEventListener("contextmenu", (e) => e.preventDefault());
  const canVibrate = "vibrate" in navigator;
  function vibrate(pattern){
    if (!canVibrate) return false;
    return navigator.vibrate(pattern);
  }

  const qs = new URLSearchParams(location.search);
  const normalizedPath = location.pathname.replace(/\/+$/, "") || "/";
  const isMapView = normalizedPath === "/map_view";
  const wsPath = isMapView ? "/ws_view" : "/ws";
  const wsProto = (location.protocol === "https:") ? "wss" : "ws";
  const wsOrigin = (() => {
    const origin = (location.origin && location.origin !== "null") ? location.origin : "";
    if (origin){
      return origin.replace(/^http/, "ws");
    }
    const host = location.host || location.hostname;
    return host ? `${wsProto}://${host}` : "";
  })();
  const wsUrl = wsOrigin ? `${wsOrigin}${wsPath}` : "";
  const pushPublicKey = (window.PUSH_PUBLIC_KEY || "").trim();
  const turnAlertStorageKey = "inittracker_turnAlertSubscription";
  const turnAlertHideKey = "inittracker_hideTurnAlerts";
  let swRegistration = null;

  function setNotificationStatus(message){
    if (!notificationStatus) return;
    notificationStatus.textContent = message;
  }

  function setTurnAlertStatus(message){
    if (!turnAlertStatus) return;
    turnAlertStatus.textContent = message;
  }

  function isStandaloneDisplay(){
    return window.matchMedia("(display-mode: standalone)").matches || window.navigator.standalone;
  }

  function getTurnAlertIdentity(){
    const playerId = claimedCid !== null && claimedCid !== undefined ? Number(claimedCid) : null;
    const claimedUnit = getClaimedUnit();
    const playerName = claimedUnit?.name ? String(claimedUnit.name) : "";
    return {
      playerId,
      username: null,
      playerName: playerName || null,
    };
  }

  function formatTurnAlertLabel(identity){
    if (identity?.playerName) return identity.playerName;
    if (identity?.username) return identity.username;
    if (identity?.playerId !== null && identity?.playerId !== undefined){
      return `#${identity.playerId}`;
    }
    return "";
  }

  function persistTurnAlertSubscription(subscription, identity){
    if (!subscription) return;
    const payload = {
      subscription: subscription.toJSON ? subscription.toJSON() : subscription,
      playerId: identity?.playerId ?? null,
      username: identity?.username ?? null,
      label: formatTurnAlertLabel(identity),
      createdAt: new Date().toISOString(),
    };
    try {
      localStorage.setItem(turnAlertStorageKey, JSON.stringify(payload));
    } catch (err){
      console.warn("Unable to store turn alert subscription.", err);
    }
  }

  function loadTurnAlertSubscription(){
    try {
      const raw = localStorage.getItem(turnAlertStorageKey);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (parsed && typeof parsed === "object") return parsed;
    } catch (err){
      console.warn("Unable to read turn alert subscription.", err);
    }
    return null;
  }

  function formatTurnAlertStatus(identity){
    const label = formatTurnAlertLabel(identity);
    return label ? `Subscribed (${label})` : "Subscribed";
  }

  async function syncTurnAlertSubscription(subscription, identity){
    if (!subscription || !identity?.playerId) return;
    const payload = {
      subscription: subscription.toJSON ? subscription.toJSON() : subscription,
      playerId: identity.playerId,
    };
    try {
      await fetch("/api/push/subscribe", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify(payload),
      });
    } catch (err){
      console.warn("Unable to sync turn alert subscription.", err);
    }
  }

  async function refreshTurnAlertStatus(){
    if (!turnAlertStatus) return;
    if (!isStandaloneDisplay()){
      setTurnAlertStatus("Not installed.");
      return;
    }
    if (!("Notification" in window)){
      setTurnAlertStatus("Notifications not supported.");
      return;
    }
    if (Notification.permission === "denied"){
      setTurnAlertStatus("Permission denied.");
      return;
    }
    if (!("serviceWorker" in navigator)){
      setTurnAlertStatus("Service worker unsupported.");
      return;
    }
    if (!("PushManager" in window)){
      setTurnAlertStatus("Push not supported.");
      return;
    }
    setTurnAlertStatus("Not subscribed.");
    try {
      swRegistration = swRegistration || await navigator.serviceWorker.ready;
      const existing = await swRegistration.pushManager.getSubscription();
      if (existing){
        const stored = loadTurnAlertSubscription();
        setTurnAlertStatus(formatTurnAlertStatus(stored || getTurnAlertIdentity()));
      }
    } catch (err){
      console.warn("Unable to check push subscription.", err);
    }
  }

  async function ensurePushSubscribed({vapidPublicKey, playerId}){
    if (!isStandaloneDisplay()){
      throw new Error("Not installed.");
    }
    if (!vapidPublicKey){
      throw new Error("Missing push public key.");
    }
    if (!playerId){
      throw new Error("Claim a character first.");
    }
    if (!("Notification" in window)){
      throw new Error("Notifications are not supported.");
    }
    if (!("serviceWorker" in navigator)){
      throw new Error("Service worker unsupported.");
    }
    if (!("PushManager" in window)){
      throw new Error("Push is not supported.");
    }
    try {
      swRegistration = swRegistration || await navigator.serviceWorker.ready;
    } catch (err){
      throw new Error("Service worker not ready.");
    }
    const permission = await Notification.requestPermission();
    if (permission !== "granted"){
      throw new Error(permission === "denied" ? "Permission denied." : "Permission required.");
    }
    const existing = await swRegistration.pushManager.getSubscription();
    if (existing){
      const identity = getTurnAlertIdentity();
      setTurnAlertStatus(formatTurnAlertStatus(identity));
      await syncTurnAlertSubscription(existing, identity);
      return existing;
    }
    const subscription = await swRegistration.pushManager.subscribe({
      userVisibleOnly: true,
      applicationServerKey: urlBase64ToUint8Array(vapidPublicKey),
    });
    const identity = getTurnAlertIdentity();
    persistTurnAlertSubscription(subscription, identity);
    setTurnAlertStatus(formatTurnAlertStatus(identity));
    await syncTurnAlertSubscription(subscription, identity);
    return subscription;
  }

  function routeDeepLink(url){
    if (!url) return;
    try {
      const target = new URL(url, location.origin);
      if (target.origin === location.origin){
        location.href = target.href;
      } else {
        location.href = url;
      }
    } catch (err){
      location.href = url;
    }
  }

  function urlBase64ToUint8Array(base64String){
    const padding = "=".repeat((4 - (base64String.length % 4)) % 4);
    const base64 = (base64String + padding).replace(/-/g, "+").replace(/_/g, "/");
    const rawData = atob(base64);
    const outputArray = new Uint8Array(rawData.length);
    for (let i = 0; i < rawData.length; ++i){
      outputArray[i] = rawData.charCodeAt(i);
    }
    return outputArray;
  }

  if ("serviceWorker" in navigator){
    navigator.serviceWorker.register("/sw.js")
      .then(() => navigator.serviceWorker.ready)
      .then((registration) => {
        swRegistration = registration;
        navigator.serviceWorker.addEventListener("message", (event) => {
          const data = event.data || {};
          if (data && data.type === "deep-link" && typeof data.url === "string"){
            routeDeepLink(data.url);
          }
        });
      })
      .catch((err) => {
        console.warn("Service worker registration failed.", err);
      });
  }

  const connEl = document.getElementById("conn");
  const connFullTextEl = document.getElementById("connFullText");
  const connCompactLabelEl = document.getElementById("connCompactLabel");
  const connDotEl = document.getElementById("connDot");
  const topbarTitleEl = document.getElementById("topbarTitle");
  const mapViewBar = document.getElementById("mapViewBar");
  const mapViewConnStatus = document.getElementById("mapViewConnStatus");
  const mapViewTurnOrderEl = document.getElementById("mapViewTurnOrder");
  const mapViewTurnOrderStatusEl = document.getElementById("mapViewTurnOrderStatus");
  const mapViewTurnOrderBubbleEl = document.getElementById("mapViewTurnOrderBubble");
  const mapViewSettingsBtn = document.getElementById("mapViewSettingsBtn");
  const mapViewSettingsModal = document.getElementById("mapViewSettingsModal");
  const mapViewSettingsClose = document.getElementById("mapViewSettingsClose");
  const mapViewTextSizeInput = document.getElementById("mapViewTextSize");
  const mapViewBarHeightInput = document.getElementById("mapViewBarHeight");
  const mapViewChipPaddingInput = document.getElementById("mapViewChipPadding");
  const mapViewChipGapInput = document.getElementById("mapViewChipGap");
  const mapViewCornerRadiusInput = document.getElementById("mapViewCornerRadius");
  const mapViewShowTitleInput = document.getElementById("mapViewShowTitle");
  const mapViewShowStatusInput = document.getElementById("mapViewShowStatus");
  const mapViewShowIndexInput = document.getElementById("mapViewShowIndex");
  const connPopoverEl = document.getElementById("connPopover");
  const connPopoverStatusEl = document.getElementById("connPopoverStatus");
  const connReconnectBtn = document.getElementById("connReconnectBtn");
  const connStyleButtons = Array.from(document.querySelectorAll(".conn-style-btn"));
  const meEl = document.getElementById("me");
  const moveEl = document.getElementById("move");
  const actionEl = document.getElementById("action");
  const bonusActionEl = document.getElementById("bonusAction");
  const reactionEl = document.getElementById("reaction");
  const turnEl = document.getElementById("turn");
  const turnOrderEl = document.getElementById("turnOrder");
  const turnOrderStatusEl = document.getElementById("turnOrderStatus");
  const turnOrderBubbleEl = document.getElementById("turnOrderBubble");
  let activeTurnOrderEl = turnOrderEl;
  let activeTurnOrderStatusEl = turnOrderStatusEl;
  let activeTurnOrderBubbleEl = turnOrderBubbleEl;
  if (isMapView && mapViewTurnOrderEl){
    activeTurnOrderEl = mapViewTurnOrderEl;
    activeTurnOrderStatusEl = mapViewTurnOrderStatusEl;
    activeTurnOrderBubbleEl = mapViewTurnOrderBubbleEl;
  }
  const noteEl = document.getElementById("note");
  const colorModal = document.getElementById("colorModal");
  const tokenColorInput = document.getElementById("tokenColorInput");
  const tokenColorSwatch = document.getElementById("tokenColorSwatch");
  const tokenColorConfirm = document.getElementById("tokenColorConfirm");
  const tokenColorCancel = document.getElementById("tokenColorCancel");
  const tokenColorModeBtn = document.getElementById("tokenColorModeBtn");
  const dashModal = document.getElementById("dashModal");
  const dashActionBtn = document.getElementById("dashAction");
  const dashBonusActionBtn = document.getElementById("dashBonusAction");
  const dashCancelBtn = document.getElementById("dashCancel");
  const actionPickerModal = document.getElementById("actionPickerModal");
  const actionPickerTitle = document.getElementById("actionPickerTitle");
  const actionPickerList = document.getElementById("actionPickerList");
  const actionPickerCancelBtn = document.getElementById("actionPickerCancel");
  const battleLogBtn = document.getElementById("battleLog");
  const lockMapBtn = document.getElementById("lockMap");
  const centerMapBtn = document.getElementById("centerMap");
  const zoomInBtn = document.getElementById("zoomIn");
  const zoomOutBtn = document.getElementById("zoomOut");
  const dashBtn = document.getElementById("dash");
  const configBtn = document.getElementById("configBtn");
  const adminMenuBtn = document.getElementById("adminMenuBtn");
  const adminMenuPopover = document.getElementById("adminMenuPopover");
  const adminMenuOpenBtn = document.getElementById("adminMenuOpen");
  const adminMenuRefreshBtn = document.getElementById("adminMenuRefresh");
  const configModal = document.getElementById("configModal");
  const configCloseBtn = document.getElementById("configClose");
  const adminModal = document.getElementById("adminModal");
  const adminLoginModal = document.getElementById("adminLoginModal");
  const adminPasswordInput = document.getElementById("adminPasswordInput");
  const adminLoginStatus = document.getElementById("adminLoginStatus");
  const adminLoginSubmit = document.getElementById("adminLoginSubmit");
  const adminLoginCancel = document.getElementById("adminLoginCancel");
  const adminSessionList = document.getElementById("adminSessionList");
  const adminStatus = document.getElementById("adminStatus");
  const adminRefreshBtn = document.getElementById("adminRefresh");
  const adminCloseBtn = document.getElementById("adminClose");
  const toggleTopbarTitle = document.getElementById("toggleTopbarTitle");
  const toggleConnIndicator = document.getElementById("toggleConnIndicator");
  const toggleLockMap = document.getElementById("toggleLockMap");
  const toggleCenterMap = document.getElementById("toggleCenterMap");
  const toggleMeasure = document.getElementById("toggleMeasure");
  const toggleMeasureClear = document.getElementById("toggleMeasureClear");
  const toggleZoomIn = document.getElementById("toggleZoomIn");
  const toggleZoomOut = document.getElementById("toggleZoomOut");
  const toggleBattleLog = document.getElementById("toggleBattleLog");
  const initiativeStyleSelect = document.getElementById("initiativeStyleSelect");
  const toggleUseAction = document.getElementById("toggleUseAction");
  const toggleUseBonusAction = document.getElementById("toggleUseBonusAction");
  const toggleDash = document.getElementById("toggleDash");
  const toggleStandUp = document.getElementById("toggleStandUp");
  const toggleResetTurn = document.getElementById("toggleResetTurn");
  const toggleSpellMenu = document.getElementById("toggleSpellMenu");
  const toggleLockMenus = document.getElementById("toggleLockMenus");
  const presetSaveBtn = document.getElementById("savePreset");
  const presetLoadBtn = document.getElementById("loadPreset");
  const presetStatus = document.getElementById("presetStatus");
  const enableNotificationsBtn = document.getElementById("enableNotifications");
  const notificationStatus = document.getElementById("notificationStatus");
  const enableTurnAlertsBtn = document.getElementById("enableTurnAlerts");
  const hideTurnAlertsBtn = document.getElementById("hideTurnAlerts");
  const turnAlertsPanel = document.getElementById("turnAlertsPanel");
  const turnAlertStatus = document.getElementById("turnAlertStatus");
  const hotkeyTopbarTitleInput = document.getElementById("hotkeyTopbarTitle");
  const hotkeyConnStyleInput = document.getElementById("hotkeyConnStyle");
  const hotkeyLockMapInput = document.getElementById("hotkeyLockMap");
  const hotkeyCenterMapInput = document.getElementById("hotkeyCenterMap");
  const hotkeyMeasureInput = document.getElementById("hotkeyMeasure");
  const hotkeyMeasureClearInput = document.getElementById("hotkeyMeasureClear");
  const hotkeyZoomInInput = document.getElementById("hotkeyZoomIn");
  const hotkeyZoomOutInput = document.getElementById("hotkeyZoomOut");
  const hotkeyBattleLogInput = document.getElementById("hotkeyBattleLog");
  const hotkeyUseActionInput = document.getElementById("hotkeyUseAction");
  const hotkeyUseBonusActionInput = document.getElementById("hotkeyUseBonusAction");
  const hotkeyDashInput = document.getElementById("hotkeyDash");
  const hotkeyStandUpInput = document.getElementById("hotkeyStandUp");
  const hotkeyResetTurnInput = document.getElementById("hotkeyResetTurn");
  const iosInstallHint = document.getElementById("iosInstallHint");
  const measureToggle = document.getElementById("measureToggle");
  const measureClear = document.getElementById("measureClear");
  const logModal = document.getElementById("logModal");
  const logContent = document.getElementById("logContent");
  const logRefreshBtn = document.getElementById("logRefresh");
  const logCloseBtn = document.getElementById("logClose");
  const waitingOverlay = document.getElementById("waitingOverlay");
  const turnModal = document.getElementById("turnModal");
  const turnModalOk = document.getElementById("turnModalOk");
  const useActionBtn = document.getElementById("useAction");
  const useBonusActionBtn = document.getElementById("useBonusAction");
  const actionSelectEl = document.getElementById("actionSelect");
  const bonusActionSelectEl = document.getElementById("bonusActionSelect");
  const resetTurnBtn = document.getElementById("resetTurn");
  const standUpBtn = document.getElementById("standUp");
  const showAllNamesEl = document.getElementById("showAllNames");
  const castOverlay = document.getElementById("sheetCastView");
  const castOverlayOpenBtn = document.getElementById("castOverlayOpen");
  const castOverlayBackBtn = document.getElementById("castOverlayBack");
  const castMenuTrigger = document.getElementById("castMenuTrigger");
  const castPanel = document.getElementById("castPanel");
  const castForm = document.getElementById("castForm");
  const castFilterLevelInput = document.getElementById("castFilterLevel");
  const castFilterSchoolInput = document.getElementById("castFilterSchool");
  const castFilterTagsInput = document.getElementById("castFilterTags");
  const castFilterCastingTimeInput = document.getElementById("castFilterCastingTime");
  const castFilterRangeInput = document.getElementById("castFilterRange");
  const castFilterRitualInput = document.getElementById("castFilterRitual");
  const castFilterConcentrationInput = document.getElementById("castFilterConcentration");
  const castFilterListInput = document.getElementById("castFilterList");
  const castPresetInput = document.getElementById("castPreset");
  const castManualEntryBadge = document.getElementById("castManualEntryBadge");
  const spellLibraryBtn = document.getElementById("spellLibraryBtn");
  const spellLibraryOverlay = document.getElementById("spellLibraryOverlay");
  const spellLibraryCloseBtn = document.getElementById("spellLibraryClose");
  const spellLibrarySearchInput = document.getElementById("spellLibrarySearch");
  const spellLibrarySortSelect = document.getElementById("spellLibrarySort");
  const spellLibraryStatus = document.getElementById("spellLibraryStatus");
  const spellLibraryList = document.getElementById("spellLibraryList");
  const spellbookOpenBtn = document.getElementById("spellbookOpen");
  const spellbookOverlay = document.getElementById("spellbookOverlay");
  const spellbookBackBtn = document.getElementById("spellbookBack");
  const spellbookBackFloatingBtn = document.getElementById("spellbookBackFloating");
  const spellbookSaveBtn = document.getElementById("spellbookSave");
  const spellbookTabKnown = document.getElementById("spellbookTabKnown");
  const spellbookTabPrepared = document.getElementById("spellbookTabPrepared");
  const spellbookKnownEnabledToggle = document.getElementById("spellbookKnownEnabled");
  const spellbookSearchInput = document.getElementById("spellbookSearch");
  const spellbookSortSelect = document.getElementById("spellbookSort");
  const spellbookLeftTitle = document.getElementById("spellbookLeftTitle");
  const spellbookRightTitle = document.getElementById("spellbookRightTitle");
  const spellbookLeftList = document.getElementById("spellbookLeftList");
  const spellbookRightList = document.getElementById("spellbookRightList");
  const spellbookAddBtn = document.getElementById("spellbookAdd");
  const spellbookRemoveBtn = document.getElementById("spellbookRemove");
  const spellbookStatus = document.getElementById("spellbookStatus");
  const spellbookConfirmModal = document.getElementById("spellbookConfirmModal");
  const spellbookConfirmText = document.getElementById("spellbookConfirmText");
  const spellbookConfirmCancel = document.getElementById("spellbookConfirmCancel");
  const spellbookConfirmYes = document.getElementById("spellbookConfirmYes");
  const spellDetailOverlay = document.getElementById("spellDetailOverlay");
  const spellDetailBackBtn = document.getElementById("spellDetailBack");
  const spellDetailTitle = document.getElementById("spellDetailTitle");
  const spellDetailName = document.getElementById("spellDetailName");
  const spellDetailMeta = document.getElementById("spellDetailMeta");
  const spellDetailGrid = document.getElementById("spellDetailGrid");
  const spellDetailColorInput = document.getElementById("spellDetailColorInput");
  const spellDetailColorSwatch = document.getElementById("spellDetailColorSwatch");
  const spellDetailColorValue = document.getElementById("spellDetailColorValue");
  const spellDetailStatus = document.getElementById("spellDetailStatus");
  const castNameInput = document.getElementById("castName");
  const castShapeInput = document.getElementById("castShape");
  const castRadiusField = document.getElementById("castRadiusField");
  const castSideField = document.getElementById("castSideField");
  const castLengthField = document.getElementById("castLengthField");
  const castWidthField = document.getElementById("castWidthField");
  const castAngleField = document.getElementById("castAngleField");
  const castOrientField = document.getElementById("castOrientField");
  const castThicknessField = document.getElementById("castThicknessField");
  const castHeightField = document.getElementById("castHeightField");
  const castRadiusInput = document.getElementById("castRadius");
  const castSideInput = document.getElementById("castSide");
  const castLengthInput = document.getElementById("castLength");
  const castWidthInput = document.getElementById("castWidth");
  const castAngleInput = document.getElementById("castAngle");
  const castOrientInput = document.getElementById("castOrient");
  const castThicknessInput = document.getElementById("castThickness");
  const castHeightInput = document.getElementById("castHeight");
  const castDcTypeInput = document.getElementById("castDcType");
  const castDcValueInput = document.getElementById("castDcValue");
  const castDefaultDamageInput = document.getElementById("castDefaultDamage");
  const castDiceInput = document.getElementById("castDice");
  const castSlotLevelInput = document.getElementById("castSlotLevel");
  const castDamageTypeInput = document.getElementById("castDamageType");
  const castDamageTypeList = document.getElementById("castDamageTypeList");
  const castAddDamageTypeBtn = document.getElementById("castAddDamageType");
  const castColorInput = document.getElementById("castColor");
  const spellPresetDetails = document.getElementById("spellPresetDetails");
  const sheetWrap = document.getElementById("sheetWrap");
  const sheet = document.getElementById("sheet");
  const sheetHandle = document.getElementById("sheetHandle");
  const tokenTooltip = document.getElementById("tokenTooltip");
  const clientInitPayload = {
    timestamp: new Date().toISOString(),
    userAgent: navigator.userAgent,
    url: location.href,
    message: "LAN client initialized",
    stack: "",
  };
  console.info("LAN client initialized");
  document.documentElement.dataset.lanBoot = "true";
  try {
    fetch("/api/client-log", {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify(clientInitPayload),
    }).catch(() => {});
  } catch (err) {
    console.warn("Failed to report LAN client init:", err);
  }
  const turnAlertAudio = new Audio("/assets/alert.wav");
  turnAlertAudio.preload = "auto";
  const koAlertAudio = new Audio("/assets/ko.wav");
  koAlertAudio.preload = "auto";
  let audioUnlocked = false;
  let pendingTurnAlert = false;
  let pendingVibrate = false;
  let lastVibrateSupported = canVibrate;
  let userHasInteracted = navigator.userActivation?.hasBeenActive ?? false;
  let castOverlayPreviousFocus = null;
  let pendingSpellActionType = null;
  const preparedSpellDefaults = {
    prepared: [],
    max: null,
    maxFormula: "",
    known: [],
    knownLimit: null,
    knownEnabled: true,
    cantrips: [],
    cantripsMax: null,
  };

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  let ws = null;
  let state = null;
  let reconnectTimer = null;
  let reconnecting = false;
  let claimedCid = null;
  let shownNoOwnedToast = false;
  let pendingClaim = null;
  let lastPcList = [];
  let lastActiveCid = null;
  let lastTurnRound = null;
  let selectedTurnCid = null;
  let hoveredTurnCid = null;
  let adminSessions = [];
  let adminPcs = [];
  const adminTokenKey = "inittracker_admin_auth";
  let adminAuthPromise = null;
  let adminAuthResolve = null;
  let adminAuthReject = null;

  // view transform
  let zoom = 32; // px per square
  let panX = 0, panY = 0;
  let dragging = null; // {cid, startX, startY, origCol, origRow}
  let draggingAoe = null; // {aid, cx, cy}
  let aoeMoveModeAid = null;
  let lastAoeTapAid = null;
  let lastAoeTapAt = 0;
  const AOE_DOUBLE_ACTION_MS = 350;
  const aoeDragOverrides = new Map(); // aid -> {cx, cy}
  let selectedAoeId = null;
  let panning = null;  // {x,y, panX, panY}
  let centeredCid = null;
  let initialCenterDone = false;
  let initialCenterFallback = false;
  let lockMap = false;
  let lastGrid = {cols: null, rows: null};
  let lastGridVersion = null;
  let fittedToGrid = false;
  let showAllNames = localStorage.getItem("inittracker_showAllNames") === "1";
  let measurementMode = false;
  let measurement = {start: null, end: null};
  let losPreview = null; // {start:{col,row}, end:{col,row}, blocked, expiresAt}
  const LOS_PREVIEW_MS = 900;
  const sheetHeightKey = "inittracker_sheetHeight";
  const uiToggleKeys = {
    topbarTitle: "inittracker_ui_topbarTitle",
    connIndicator: "inittracker_ui_connIndicator",
    lockMap: "inittracker_ui_lockMap",
    centerMap: "inittracker_ui_centerMap",
    measure: "inittracker_ui_measure",
    measureClear: "inittracker_ui_measureClear",
    zoomIn: "inittracker_ui_zoomIn",
    zoomOut: "inittracker_ui_zoomOut",
    battleLog: "inittracker_ui_battleLog",
    useAction: "inittracker_ui_useAction",
    useBonusAction: "inittracker_ui_useBonusAction",
    dash: "inittracker_ui_dash",
    standUp: "inittracker_ui_standUp",
    resetTurn: "inittracker_ui_resetTurn",
    hideSpellMenu: "inittracker_ui_hideSpellMenu",
    lockMenus: "inittracker_lockMenus",
  };
  const uiSelectKeys = {
    connStyle: "inittracker_ui_connStyle",
    initiativeStyle: "inittracker_ui_initiativeStyle",
  };
  const mapViewSettingsKey = "inittracker_map_view_settings";
  let showTopbarTitle = readToggle(uiToggleKeys.topbarTitle, true);
  let showConnIndicator = readToggle(uiToggleKeys.connIndicator, true);
  let showLockMap = readToggle(uiToggleKeys.lockMap, true);
  let showCenterMap = readToggle(uiToggleKeys.centerMap, true);
  let showMeasure = readToggle(uiToggleKeys.measure, true);
  let showMeasureClear = readToggle(uiToggleKeys.measureClear, true);
  let showZoomIn = readToggle(uiToggleKeys.zoomIn, true);
  let showZoomOut = readToggle(uiToggleKeys.zoomOut, true);
  let showBattleLog = readToggle(uiToggleKeys.battleLog, true);
  let showUseAction = readToggle(uiToggleKeys.useAction, true);
  let showUseBonusAction = readToggle(uiToggleKeys.useBonusAction, true);
  let showDash = readToggle(uiToggleKeys.dash, true);
  let showStandUp = readToggle(uiToggleKeys.standUp, true);
  let showResetTurn = readToggle(uiToggleKeys.resetTurn, true);
  let hideSpellMenu = readToggle(uiToggleKeys.hideSpellMenu, false);
  let menusLocked = readToggle(uiToggleKeys.lockMenus, false);
  let mapViewSettings = null;
  let connStyle = "full";
  let initiativeStyle = "full";
  let sheetHeight = null;
  if (turnAlertStatus){
    refreshTurnAlertStatus();
  }
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
  const isSafariEngine = /AppleWebKit/.test(navigator.userAgent);
  const isAltBrowser = /CriOS|FxiOS|EdgiOS|OPiOS/.test(navigator.userAgent);
  const isStandalone = window.navigator.standalone === true;
  if (document.body){
    document.body.classList.toggle("map-view", isMapView);
    document.body.classList.toggle("map-view-only", isMapView);
  }
  if (iosInstallHint){
    const showHint = isIOS && isSafariEngine && !isAltBrowser && !isStandalone;
    iosInstallHint.classList.toggle("hidden", !showHint);
  }
  if (turnAlertsPanel){
    const hideTurnAlerts = localStorage.getItem(turnAlertHideKey) === "1";
    const shouldHideAlerts = !isIOS || hideTurnAlerts;
    turnAlertsPanel.classList.toggle("hidden", shouldHideAlerts);
  }
  if (isMapView){
    applyMapViewSettings(readMapViewSettings());
  }
  if (showAllNamesEl){
    showAllNamesEl.checked = showAllNames;
    showAllNamesEl.addEventListener("change", (ev) => {
      showAllNames = !!ev.target.checked;
      localStorage.setItem("inittracker_showAllNames", showAllNames ? "1" : "0");
      draw();
    });
  }

  window.addEventListener("resize", () => {
    if (sheetWrap){
      applySheetHeight(sheetHeight);
    }
  });
  updateSpellbookViewportHeight();
  window.addEventListener("resize", updateSpellbookViewportHeight);
  if (window.visualViewport){
    window.visualViewport.addEventListener("resize", updateSpellbookViewportHeight);
    window.visualViewport.addEventListener("scroll", updateSpellbookViewportHeight);
  }

  function updateConnDisplay(){
    if (connFullTextEl) connFullTextEl.textContent = connStatusText;
    if (connEl) connEl.setAttribute("title", connStatusText);
    if (connCompactLabelEl) connCompactLabelEl.textContent = "C";
    if (connDotEl){
      connDotEl.style.background = connStatusOk ? "var(--accent)" : "var(--danger)";
    }
    if (connPopoverStatusEl){
      connPopoverStatusEl.textContent = connStatusText;
    }
  }

  function setConn(ok, txt){
    connStatusOk = !!ok;
    connStatusText = String(txt || "");
    if (connEl){
      connEl.style.borderColor = connStatusOk ? "rgba(106,169,255,0.35)" : "rgba(255,91,91,0.35)";
      connEl.style.background = connStatusOk ? "rgba(106,169,255,0.14)" : "rgba(255,91,91,0.14)";
    }
    if (mapViewConnStatus){
      mapViewConnStatus.textContent = connStatusText;
      mapViewConnStatus.style.color = connStatusOk ? "var(--muted)" : "var(--danger)";
    }
    updateConnDisplay();
  }

  function setConnPopover(open){
    if (!connPopoverEl || !connEl) return;
    connPopoverEl.classList.toggle("show", open);
    connPopoverEl.setAttribute("aria-hidden", open ? "false" : "true");
    connEl.setAttribute("aria-expanded", open ? "true" : "false");
  }

  function closeConnPopover(){
    setConnPopover(false);
  }

  function scheduleReconnect(delayMs){
    if (reconnectTimer){
      clearTimeout(reconnectTimer);
    }
    reconnectTimer = setTimeout(() => {
      reconnectTimer = null;
      connect();
    }, delayMs);
  }

  function softReconnect(){
    reconnecting = true;
    setConn(false, "Reconnecting…");
    closeConnPopover();
    if (ws && ws.readyState === 1){
      ws.close(4001, "reconnect");
    } else {
      scheduleReconnect(200);
    }
  }

  function resize(){
    const r = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.max(1, Math.floor(r.width * dpr));
    canvas.height = Math.max(1, Math.floor(r.height * dpr));
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }
  window.addEventListener("resize", resize);

  function getSheetConstraints(){
    const viewportHeight = window.innerHeight || 0;
    const min = Math.max(180, Math.round(viewportHeight * 0.2));
    const max = Math.max(min + 80, Math.round(viewportHeight * 0.7));
    return {min, max};
  }

  function updateModalOffsets(){
    const topbarHeight = document.querySelector(".topbar")?.getBoundingClientRect().height || 0;
    const sheetHeight = document.getElementById("sheetWrap")?.getBoundingClientRect().height || 0;
    const rootStyle = document.documentElement.style;
    rootStyle.setProperty("--modalTopOffset", `${topbarHeight}px`);
    rootStyle.setProperty("--modalBottomOffset", `${sheetHeight}px`);
    rootStyle.setProperty("--topbar-height", `${topbarHeight}px`);
    rootStyle.setProperty("--bottombar-height", `${sheetHeight}px`);
  }

  function updateSpellbookViewportHeight(){
    const viewportHeight = window.visualViewport?.height || window.innerHeight || 0;
    const vh = Math.max(1, viewportHeight) * 0.01;
    document.documentElement.style.setProperty("--spellbook-vh", `${vh}px`);
  }

  function readMapViewSettings(){
    const defaults = {
      textSize: 14,
      barHeight: 84,
      chipPadding: 6,
      chipGap: 8,
      cornerRadius: 40,
      showTitle: true,
      showStatus: true,
      showIndex: true,
    };
    try {
      const raw = localStorage.getItem(mapViewSettingsKey);
      if (!raw){
        return defaults;
      }
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== "object"){
        return defaults;
      }
      return {
        ...defaults,
        ...parsed,
      };
    } catch (err){
      return defaults;
    }
  }

  function applyMapViewSettings(settings){
    if (!settings){
      return;
    }
    mapViewSettings = settings;
    const rootStyle = document.documentElement.style;
    rootStyle.setProperty("--map-view-order-font-size", `${settings.textSize}px`);
    rootStyle.setProperty("--map-view-bar-height", `${settings.barHeight}px`);
    rootStyle.setProperty("--map-view-order-chip-pad-y", `${settings.chipPadding}px`);
    rootStyle.setProperty("--map-view-order-chip-pad-x", `${Math.max(6, settings.chipPadding + 4)}px`);
    rootStyle.setProperty("--map-view-order-gap", `${settings.chipGap}px`);
    rootStyle.setProperty("--map-view-order-radius", `${settings.cornerRadius}px`);
    if (document.body){
      document.body.classList.toggle("map-view-hide-title", !settings.showTitle);
      document.body.classList.toggle("map-view-hide-status", !settings.showStatus);
      document.body.classList.toggle("map-view-hide-index", !settings.showIndex);
    }
    if (mapViewTextSizeInput){
      mapViewTextSizeInput.value = String(settings.textSize);
    }
    if (mapViewBarHeightInput){
      mapViewBarHeightInput.value = String(settings.barHeight);
    }
    if (mapViewChipPaddingInput){
      mapViewChipPaddingInput.value = String(settings.chipPadding);
    }
    if (mapViewChipGapInput){
      mapViewChipGapInput.value = String(settings.chipGap);
    }
    if (mapViewCornerRadiusInput){
      mapViewCornerRadiusInput.value = String(settings.cornerRadius);
    }
    if (mapViewShowTitleInput){
      mapViewShowTitleInput.checked = !!settings.showTitle;
    }
    if (mapViewShowStatusInput){
      mapViewShowStatusInput.checked = !!settings.showStatus;
    }
    if (mapViewShowIndexInput){
      mapViewShowIndexInput.checked = !!settings.showIndex;
    }
  }

  function persistMapViewSettings(){
    if (!mapViewSettings){
      return;
    }
    try {
      localStorage.setItem(mapViewSettingsKey, JSON.stringify(mapViewSettings));
    } catch (err){
      console.warn("Failed to persist map view settings.", err);
    }
  }

  function applySheetHeight(value){
    if (!sheetWrap) return;
    const {min, max} = getSheetConstraints();
    let target = Number(value);
    if (!Number.isFinite(target)){
      target = Math.round((min + max) / 2);
    }
    target = Math.min(max, Math.max(min, target));
    sheetWrap.style.height = `${target}px`;
    sheetWrap.style.minHeight = `${min}px`;
    sheetWrap.style.maxHeight = `${max}px`;
    sheetHeight = target;
    resize();
    updateModalOffsets();
  }

  function setCastOverlayOpen(open){
    if (!castOverlay) return;
    castOverlay.classList.toggle("show", open);
    castOverlay.classList.toggle("hidden", !open);
    castOverlay.setAttribute("aria-hidden", open ? "false" : "true");
    if (sheet){
      sheet.classList.toggle("hidden", open);
    }
    if (!open){
      pendingSpellActionType = null;
    }
    if (open){
      castOverlayPreviousFocus = document.activeElement instanceof HTMLElement
        ? document.activeElement
        : null;
      requestAnimationFrame(() => {
        castOverlayBackBtn?.focus();
      });
      applyDefaultSpellSaveDc();
    } else if (castOverlayPreviousFocus){
      castOverlayPreviousFocus.focus();
      castOverlayPreviousFocus = null;
    }
    updateModalOffsets();
    resize();
  }

  function getClaimedPlayerName(){
    const claimedUnit = getClaimedUnit();
    if (!claimedUnit?.name) return null;
    return String(claimedUnit.name);
  }

  function getPlayerProfile(name){
    if (!name) return null;
    const profiles = state?.player_profiles;
    if (!profiles || typeof profiles !== "object") return null;
    const profile = profiles[name];
    if (!profile || typeof profile !== "object") return null;
    return profile;
  }

  function normalizePreparedSpellList(list){
    if (!Array.isArray(list)) return [];
    return list.map(normalizeTextValue).filter(Boolean);
  }

  function getPlayerCantripList(name){
    const profile = getPlayerProfile(name);
    const spellcasting = profile?.spellcasting;
    if (!spellcasting || typeof spellcasting !== "object") return [];
    if (Array.isArray(spellcasting.cantrips_list)){
      return normalizePreparedSpellList(spellcasting.cantrips_list);
    }
    const cantrips = spellcasting.cantrips;
    if (Array.isArray(cantrips)){
      return normalizePreparedSpellList(cantrips);
    }
    if (cantrips && typeof cantrips === "object"){
      return normalizePreparedSpellList(cantrips.known);
    }
    return [];
  }

  function evaluatePreparedFormula(formula, variables){
    if (typeof formula !== "string") return null;
    const trimmed = formula.trim();
    if (!trimmed) return null;
    if (!/^[0-9+\-*/(). _a-zA-Z]+$/.test(trimmed)) return null;
    let expr = trimmed;
    Object.entries(variables).forEach(([key, value]) => {
      const safeValue = Number.isFinite(value) ? String(value) : "0";
      const pattern = new RegExp(`\\b${key}\\b`, "g");
      expr = expr.replace(pattern, safeValue);
    });
    if (/[a-zA-Z]/.test(expr)) return null;
    try {
      const result = Function(`"use strict"; return (${expr});`)();
      if (!Number.isFinite(result)) return null;
      return Math.max(0, Math.floor(result));
    } catch (err){
      return null;
    }
  }

  function getAbilityModifier(profile, key){
    const normalizedKey = normalizeAbilityKey(key);
    const abilities = profile?.abilities;
    if (!abilities || typeof abilities !== "object") return 0;
    const modValue = Number(
      abilities[`${normalizedKey}_mod`]
      ?? abilities[`${normalizedKey}_modifier`]
    );
    if (Number.isFinite(modValue)){
      return Math.floor(modValue);
    }
    const scoreValue = Number(
      abilities[normalizedKey]
      ?? abilities[normalizedKey.toUpperCase()]
      ?? abilities[`${normalizedKey}_score`]
    );
    if (Number.isFinite(scoreValue)){
      return Math.floor((scoreValue - 10) / 2);
    }
    return 0;
  }

  function normalizeAbilityKey(key){
    const raw = normalizeLowerValue(key || "");
    if (!raw) return "";
    const abilityMap = {
      strength: "str",
      str: "str",
      dexterity: "dex",
      dex: "dex",
      constitution: "con",
      con: "con",
      intelligence: "int",
      int: "int",
      wisdom: "wis",
      wis: "wis",
      charisma: "cha",
      cha: "cha",
      chr: "cha",
      char: "cha",
    };
    return abilityMap[raw] || raw;
  }

  function getProficiencyBonus(profile){
    const level = getPlayerLevel(profile);
    if (level >= 1){
      if (level >= 17) return 6;
      if (level >= 13) return 5;
      if (level >= 9) return 4;
      if (level >= 5) return 3;
      return 2;
    }
    const prof = Number(profile?.proficiency?.bonus);
    return Number.isFinite(prof) ? Math.floor(prof) : 0;
  }

  function getPreparedSpellLimit(profile, preparedData){
    const maxFormula = preparedData?.maxFormula;
    const maxValue = preparedData?.maxValue;
    const levelRaw = profile?.leveling?.level ?? profile?.leveling?.total_level ?? profile?.leveling?.lvl;
    const level = Number.isFinite(Number(levelRaw)) ? Math.max(0, Math.floor(Number(levelRaw))) : 0;
    const variables = {
      level,
      total_level: level,
      str_mod: getAbilityModifier(profile, "str"),
      dex_mod: getAbilityModifier(profile, "dex"),
      con_mod: getAbilityModifier(profile, "con"),
      int_mod: getAbilityModifier(profile, "int"),
      wis_mod: getAbilityModifier(profile, "wis"),
      cha_mod: getAbilityModifier(profile, "cha"),
    };
    const evaluated = evaluatePreparedFormula(maxFormula, variables);
    if (Number.isFinite(evaluated)){
      return evaluated;
    }
    if (Number.isFinite(maxValue)){
      return Math.max(0, Math.floor(maxValue));
    }
    const fallbackKnown = Number(profile?.spellcasting?.known_spells);
    if (Number.isFinite(fallbackKnown)){
      return Math.max(0, Math.floor(fallbackKnown));
    }
    return null;
  }

  function getPlayerSpellSaveDc(name){
    const profile = getPlayerProfile(name);
    const spellcasting = profile?.spellcasting;
    if (!spellcasting || typeof spellcasting !== "object") return null;
    const rawValue = spellcasting.save_dc ?? spellcasting.saveDC;
    const dcValue = Number(rawValue);
    if (Number.isFinite(dcValue)){
      return Math.floor(dcValue);
    }
    const formula = normalizeTextValue(spellcasting.save_dc_formula);
    if (formula){
      const castingAbility = normalizeAbilityKey(spellcasting.casting_ability || "");
      const castingMod = castingAbility ? getAbilityModifier(profile, castingAbility) : 0;
      const prof = getProficiencyBonus(profile);
      const variables = {
        prof,
        casting_mod: castingMod,
        str_mod: getAbilityModifier(profile, "str"),
        dex_mod: getAbilityModifier(profile, "dex"),
        con_mod: getAbilityModifier(profile, "con"),
        int_mod: getAbilityModifier(profile, "int"),
        wis_mod: getAbilityModifier(profile, "wis"),
        cha_mod: getAbilityModifier(profile, "cha"),
      };
      const evaluated = evaluatePreparedFormula(formula, variables);
      if (Number.isFinite(evaluated)){
        return evaluated;
      }
    }
    return null;
  }

  function applyDefaultSpellSaveDc(){
    if (!castDcValueInput) return;
    if (String(castDcValueInput.value || "").trim()){
      return;
    }
    const playerName = getClaimedPlayerName();
    const dcValue = getPlayerSpellSaveDc(playerName);
    if (Number.isFinite(dcValue)){
      castDcValueInput.value = String(dcValue);
    }
  }

  function getSpellbookConfig(name){
    const defaults = {...preparedSpellDefaults};
    if (!name) return defaults;
    const profile = getPlayerProfile(name);
    const spellcasting = profile?.spellcasting && typeof profile.spellcasting === "object"
      ? profile.spellcasting
      : null;
    if (!spellcasting){
      return defaults;
    }
    const preparedBlock = spellcasting.prepared_spells && typeof spellcasting.prepared_spells === "object"
      ? spellcasting.prepared_spells
      : {};
    const knownBlock = spellcasting.known_spells && typeof spellcasting.known_spells === "object"
      ? spellcasting.known_spells
      : {};
    const cantripsBlock = spellcasting.cantrips && typeof spellcasting.cantrips === "object"
      ? spellcasting.cantrips
      : {};
    const maxFormula = normalizeTextValue(
      spellcasting.prepared_limit_formula
      ?? preparedBlock.max_formula
    );
    const maxValue = Number(preparedBlock.max ?? preparedBlock.max_spells ?? preparedBlock.max_prepared);
    const limit = getPreparedSpellLimit(profile, {maxFormula, maxValue});
    const knownLimitRaw = spellcasting.known_limit ?? knownBlock.max ?? spellcasting.known_spells;
    const knownLimit = Number.isFinite(Number(knownLimitRaw))
      ? Math.max(0, Math.floor(Number(knownLimitRaw)))
      : null;
    const cantripsMaxRaw = cantripsBlock.max;
    const cantripsMax = Number.isFinite(Number(cantripsMaxRaw))
      ? Math.max(0, Math.floor(Number(cantripsMaxRaw)))
      : null;
    return {
      prepared: normalizePreparedSpellList(
        spellcasting.prepared_list ?? preparedBlock.prepared
      ),
      max: limit,
      maxFormula,
      known: normalizePreparedSpellList(
        spellcasting.known_list ?? knownBlock.known ?? spellcasting.known_spell_names
      ),
      knownLimit,
      knownEnabled: spellcasting.known_enabled !== false,
      cantrips: normalizePreparedSpellList(
        spellcasting.cantrips_list ?? cantripsBlock.known ?? spellcasting.cantrips
      ),
      cantripsMax,
    };
  }

  function persistSheetHeight(){
    if (!Number.isFinite(sheetHeight)) return;
    localStorage.setItem(sheetHeightKey, String(Math.round(sheetHeight)));
  }

  function loadSheetHeight(){
    if (!sheetWrap) return;
    const stored = Number(localStorage.getItem(sheetHeightKey));
    applySheetHeight(stored);
  }

  function readToggle(key, defaultValue){
    const stored = localStorage.getItem(key);
    if (stored === null || stored === undefined) return defaultValue;
    return stored === "1";
  }

  function readChoice(key, allowed, defaultValue){
    const stored = localStorage.getItem(key);
    if (stored && allowed.includes(stored)) return stored;
    return defaultValue;
  }

  function persistToggle(key, value){
    localStorage.setItem(key, value ? "1" : "0");
  }

  function persistChoice(key, value){
    if (!value){
      localStorage.removeItem(key);
      return;
    }
    localStorage.setItem(key, value);
  }

  connStyle = readChoice(uiSelectKeys.connStyle, ["full", "compact"], "full");
  initiativeStyle = readChoice(uiSelectKeys.initiativeStyle, ["full", "compact", "hidden"], "full");
  let connStatusText = "Connecting…";
  let connStatusOk = false;

  const hotkeyConfig = {
    toggleTopbarTitle: {
      input: hotkeyTopbarTitleInput,
      conflictEl: document.getElementById("hotkeyConflictTopbarTitle"),
      storageKey: "inittracker_hotkey_toggleTopbarTitle",
      action: () => {
        showTopbarTitle = !showTopbarTitle;
        persistToggle(uiToggleKeys.topbarTitle, showTopbarTitle);
        applyUiConfig();
      },
    },
    toggleConnStyle: {
      input: hotkeyConnStyleInput,
      conflictEl: document.getElementById("hotkeyConflictConnStyle"),
      storageKey: "inittracker_hotkey_toggleConnStyle",
      action: () => {
        connStyle = connStyle === "compact" ? "full" : "compact";
        persistChoice(uiSelectKeys.connStyle, connStyle);
        applyUiConfig();
      },
    },
    lockMap: {
      input: hotkeyLockMapInput,
      conflictEl: document.getElementById("hotkeyConflictLockMap"),
      storageKey: "inittracker_hotkey_lockMap",
      action: () => lockMapBtn && lockMapBtn.click(),
    },
    centerMap: {
      input: hotkeyCenterMapInput,
      conflictEl: document.getElementById("hotkeyConflictCenterMap"),
      storageKey: "inittracker_hotkey_centerMap",
      action: () => centerMapBtn && centerMapBtn.click(),
    },
    measure: {
      input: hotkeyMeasureInput,
      conflictEl: document.getElementById("hotkeyConflictMeasure"),
      storageKey: "inittracker_hotkey_measure",
      action: () => measureToggle && measureToggle.click(),
    },
    measureClear: {
      input: hotkeyMeasureClearInput,
      conflictEl: document.getElementById("hotkeyConflictMeasureClear"),
      storageKey: "inittracker_hotkey_measureClear",
      action: () => measureClear && measureClear.click(),
    },
    zoomIn: {
      input: hotkeyZoomInInput,
      conflictEl: document.getElementById("hotkeyConflictZoomIn"),
      storageKey: "inittracker_hotkey_zoomIn",
      action: () => zoomInBtn && zoomInBtn.click(),
    },
    zoomOut: {
      input: hotkeyZoomOutInput,
      conflictEl: document.getElementById("hotkeyConflictZoomOut"),
      storageKey: "inittracker_hotkey_zoomOut",
      action: () => zoomOutBtn && zoomOutBtn.click(),
    },
    battleLog: {
      input: hotkeyBattleLogInput,
      conflictEl: document.getElementById("hotkeyConflictBattleLog"),
      storageKey: "inittracker_hotkey_battleLog",
      action: () => battleLogBtn && battleLogBtn.click(),
    },
    useAction: {
      input: hotkeyUseActionInput,
      conflictEl: document.getElementById("hotkeyConflictUseAction"),
      storageKey: "inittracker_hotkey_useAction",
      action: () => useActionBtn && useActionBtn.click(),
    },
    useBonusAction: {
      input: hotkeyUseBonusActionInput,
      conflictEl: document.getElementById("hotkeyConflictUseBonusAction"),
      storageKey: "inittracker_hotkey_useBonusAction",
      action: () => useBonusActionBtn && useBonusActionBtn.click(),
    },
    dash: {
      input: hotkeyDashInput,
      conflictEl: document.getElementById("hotkeyConflictDash"),
      storageKey: "inittracker_hotkey_dash",
      action: () => dashBtn && dashBtn.click(),
    },
    standUp: {
      input: hotkeyStandUpInput,
      conflictEl: document.getElementById("hotkeyConflictStandUp"),
      storageKey: "inittracker_hotkey_standUp",
      action: () => standUpBtn && standUpBtn.click(),
    },
    resetTurn: {
      input: hotkeyResetTurnInput,
      conflictEl: document.getElementById("hotkeyConflictResetTurn"),
      storageKey: "inittracker_hotkey_resetTurn",
      action: () => resetTurnBtn && resetTurnBtn.click(),
    },
  };

  let hotkeyBindings = new Map();

  function normalizeHotkeyEvent(event){
    if (!event) return null;
    if (event.key === "Shift" || event.key === "Control" || event.key === "Alt" || event.key === "Meta"){
      return null;
    }
    const parts = [];
    if (event.ctrlKey) parts.push("Ctrl");
    if (event.altKey) parts.push("Alt");
    if (event.metaKey) parts.push("Meta");
    if (event.shiftKey) parts.push("Shift");
    let key = event.key;
    if (key === " ") key = "Space";
    if (key.length === 1) key = key.toUpperCase();
    parts.push(key);
    return parts.join("+");
  }

  function isTypingTarget(target){
    if (!target) return false;
    const tag = target.tagName ? target.tagName.toLowerCase() : "";
    if (tag === "input" || tag === "textarea" || tag === "select") return true;
    if (target.isContentEditable) return true;
    return false;
  }

  function setHotkey(action, value){
    const config = hotkeyConfig[action];
    if (!config) return;
    const stored = value ? String(value) : "";
    if (stored){
      localStorage.setItem(config.storageKey, stored);
    } else {
      localStorage.removeItem(config.storageKey);
    }
    updateHotkeyInputs();
  }

  function updateHotkeyInputs(){
    const usage = {};
    hotkeyBindings = new Map();
    Object.entries(hotkeyConfig).forEach(([action, config]) => {
      if (!config || !config.input) return;
      const stored = localStorage.getItem(config.storageKey) || "";
      const normalized = stored.trim();
      config.input.value = normalized;
      if (normalized){
        if (!usage[normalized]) usage[normalized] = [];
        usage[normalized].push(action);
      }
    });
    Object.entries(hotkeyConfig).forEach(([action, config]) => {
      if (!config || !config.input) return;
      const stored = (localStorage.getItem(config.storageKey) || "").trim();
      const conflicts = stored && usage[stored] && usage[stored].length > 1;
      config.input.classList.toggle("conflict", !!conflicts);
      if (config.conflictEl){
        config.conflictEl.textContent = conflicts ? "Conflict" : "";
      }
      if (stored && !conflicts){
        hotkeyBindings.set(stored, action);
      }
    });
  }

  let presetStatusTimer = null;
  const presetStorageKey = "inittracker_gui_preset";

  function setPresetStatus(text, durationMs=2000){
    if (!presetStatus) return;
    presetStatus.textContent = text || "";
    if (presetStatusTimer){
      clearTimeout(presetStatusTimer);
      presetStatusTimer = null;
    }
    if (text && durationMs > 0){
      presetStatusTimer = setTimeout(() => {
        if (presetStatus) presetStatus.textContent = "";
        presetStatusTimer = null;
      }, durationMs);
    }
  }

  function normalizePresetHotkey(value){
    if (value === null || value === undefined) return "";
    const normalized = String(value).trim();
    return normalized;
  }

  function buildGuiPreset(){
    const hotkeys = {};
    Object.entries(hotkeyConfig).forEach(([action, config]) => {
      if (!config || !config.storageKey) return;
      hotkeys[action] = normalizePresetHotkey(localStorage.getItem(config.storageKey) || "");
    });
    return {
      version: 1,
      toggles: {
        topbarTitle: showTopbarTitle,
        connIndicator: showConnIndicator,
        lockMap: showLockMap,
        centerMap: showCenterMap,
        measure: showMeasure,
        measureClear: showMeasureClear,
        zoomIn: showZoomIn,
        zoomOut: showZoomOut,
        battleLog: showBattleLog,
        useAction: showUseAction,
        useBonusAction: showUseBonusAction,
        dash: showDash,
        standUp: showStandUp,
        resetTurn: showResetTurn,
        hideSpellMenu: hideSpellMenu,
        lockMenus: menusLocked,
      },
      choices: {
        connStyle,
        initiativeStyle,
      },
      showAllNames: showAllNames,
      sheetHeight: Number.isFinite(sheetHeight) ? Math.round(sheetHeight) : null,
      hotkeys,
    };
  }

  function persistLocalPreset(preset){
    try {
      localStorage.setItem(presetStorageKey, JSON.stringify(preset));
    } catch (err){
      console.warn("Failed to persist GUI preset locally.", err);
    }
  }

  function loadLocalPreset(){
    try {
      const raw = localStorage.getItem(presetStorageKey);
      if (!raw) return null;
      const preset = JSON.parse(raw);
      if (preset && typeof preset === "object"){
        return preset;
      }
    } catch (err){
      console.warn("Failed to load GUI preset from storage.", err);
    }
    return null;
  }

  function applyGuiPreset(preset, options = {}){
    if (!preset || typeof preset !== "object") return;
    const persist = options.persist !== false;
    const toggles = preset.toggles && typeof preset.toggles === "object" ? preset.toggles : {};
    const choices = preset.choices && typeof preset.choices === "object" ? preset.choices : {};
    if (typeof toggles.topbarTitle === "boolean") showTopbarTitle = toggles.topbarTitle;
    if (typeof toggles.connIndicator === "boolean") showConnIndicator = toggles.connIndicator;
    if (typeof toggles.lockMap === "boolean") showLockMap = toggles.lockMap;
    if (typeof toggles.centerMap === "boolean") showCenterMap = toggles.centerMap;
    if (typeof toggles.measure === "boolean") showMeasure = toggles.measure;
    if (typeof toggles.measureClear === "boolean") showMeasureClear = toggles.measureClear;
    if (typeof toggles.zoomIn === "boolean") showZoomIn = toggles.zoomIn;
    if (typeof toggles.zoomOut === "boolean") showZoomOut = toggles.zoomOut;
    if (typeof toggles.battleLog === "boolean") showBattleLog = toggles.battleLog;
    if (typeof toggles.useAction === "boolean") showUseAction = toggles.useAction;
    if (typeof toggles.useBonusAction === "boolean") showUseBonusAction = toggles.useBonusAction;
    if (typeof toggles.dash === "boolean") showDash = toggles.dash;
    if (typeof toggles.standUp === "boolean") showStandUp = toggles.standUp;
    if (typeof toggles.resetTurn === "boolean") showResetTurn = toggles.resetTurn;
    if (typeof toggles.hideSpellMenu === "boolean") hideSpellMenu = toggles.hideSpellMenu;
    if (typeof toggles.lockMenus === "boolean") menusLocked = toggles.lockMenus;
    if (persist){
      persistToggle(uiToggleKeys.topbarTitle, showTopbarTitle);
      persistToggle(uiToggleKeys.connIndicator, showConnIndicator);
      persistToggle(uiToggleKeys.lockMap, showLockMap);
      persistToggle(uiToggleKeys.centerMap, showCenterMap);
      persistToggle(uiToggleKeys.measure, showMeasure);
      persistToggle(uiToggleKeys.measureClear, showMeasureClear);
      persistToggle(uiToggleKeys.zoomIn, showZoomIn);
      persistToggle(uiToggleKeys.zoomOut, showZoomOut);
      persistToggle(uiToggleKeys.battleLog, showBattleLog);
      persistToggle(uiToggleKeys.useAction, showUseAction);
      persistToggle(uiToggleKeys.useBonusAction, showUseBonusAction);
      persistToggle(uiToggleKeys.dash, showDash);
      persistToggle(uiToggleKeys.standUp, showStandUp);
      persistToggle(uiToggleKeys.resetTurn, showResetTurn);
      persistToggle(uiToggleKeys.hideSpellMenu, hideSpellMenu);
      persistToggle(uiToggleKeys.lockMenus, menusLocked);
    }
    if (choices.connStyle && ["full", "compact"].includes(choices.connStyle)){
      connStyle = choices.connStyle;
      if (persist){
        persistChoice(uiSelectKeys.connStyle, connStyle);
      }
    }
    if (choices.initiativeStyle && ["full", "compact", "hidden"].includes(choices.initiativeStyle)){
      initiativeStyle = choices.initiativeStyle;
      if (persist){
        persistChoice(uiSelectKeys.initiativeStyle, initiativeStyle);
      }
    }
    if (typeof preset.showAllNames === "boolean"){
      showAllNames = preset.showAllNames;
      if (showAllNamesEl){
        showAllNamesEl.checked = showAllNames;
      }
      if (persist){
        localStorage.setItem("inittracker_showAllNames", showAllNames ? "1" : "0");
      }
    }
    if (Number.isFinite(Number(preset.sheetHeight))){
      applySheetHeight(Number(preset.sheetHeight));
      if (persist){
        persistSheetHeight();
      }
    }
    if (preset.hotkeys && typeof preset.hotkeys === "object"){
      Object.entries(preset.hotkeys).forEach(([action, value]) => {
        const config = hotkeyConfig[action];
        if (!config || !config.storageKey) return;
        const normalized = normalizePresetHotkey(value);
        if (persist){
          if (normalized){
            localStorage.setItem(config.storageKey, normalized);
          } else {
            localStorage.removeItem(config.storageKey);
          }
        }
        if (config.input){
          config.input.value = normalized;
        }
      });
    }
    applyUiConfig();
    updateHotkeyInputs();
  }

  function applyConnStyle(){
    if (!connEl) return;
    connEl.classList.toggle("conn-compact", connStyle === "compact");
    updateConnDisplay();
  }

  function applyUiConfig(){
    document.body.classList.toggle("menus-locked", menusLocked);
    document.body.classList.toggle("initiative-compact", initiativeStyle === "compact");
    document.body.classList.toggle("initiative-hidden", initiativeStyle === "hidden");
    if (topbarTitleEl) topbarTitleEl.classList.toggle("hidden", !showTopbarTitle);
    if (connEl) connEl.classList.toggle("hidden", !showConnIndicator);
    if (!showConnIndicator){
      closeConnPopover();
    }
    if (lockMapBtn) lockMapBtn.classList.toggle("hidden", !showLockMap);
    if (centerMapBtn) centerMapBtn.classList.toggle("hidden", !showCenterMap);
    if (measureToggle) measureToggle.classList.toggle("hidden", !showMeasure);
    if (measureClear) measureClear.classList.toggle("hidden", !showMeasureClear);
    if (zoomInBtn) zoomInBtn.classList.toggle("hidden", !showZoomIn);
    if (zoomOutBtn) zoomOutBtn.classList.toggle("hidden", !showZoomOut);
    if (battleLogBtn) battleLogBtn.classList.toggle("hidden", !showBattleLog);
    if (useActionBtn) useActionBtn.classList.toggle("hidden", !showUseAction);
    if (useBonusActionBtn) useBonusActionBtn.classList.toggle("hidden", !showUseBonusAction);
    if (dashBtn) dashBtn.classList.toggle("hidden", !showDash);
    if (standUpBtn) standUpBtn.classList.toggle("hidden", !showStandUp);
    if (resetTurnBtn) resetTurnBtn.classList.toggle("hidden", !showResetTurn);
    if (toggleTopbarTitle) toggleTopbarTitle.checked = showTopbarTitle;
    if (toggleConnIndicator) toggleConnIndicator.checked = showConnIndicator;
    if (connStyleButtons.length){
      connStyleButtons.forEach((button) => {
        const isActive = button.dataset.connStyle === connStyle;
        button.classList.toggle("active", isActive);
        button.setAttribute("aria-pressed", isActive ? "true" : "false");
      });
    }
    if (toggleLockMap) toggleLockMap.checked = showLockMap;
    if (toggleCenterMap) toggleCenterMap.checked = showCenterMap;
    if (toggleMeasure) toggleMeasure.checked = showMeasure;
    if (toggleMeasureClear) toggleMeasureClear.checked = showMeasureClear;
    if (toggleZoomIn) toggleZoomIn.checked = showZoomIn;
    if (toggleZoomOut) toggleZoomOut.checked = showZoomOut;
    if (toggleBattleLog) toggleBattleLog.checked = showBattleLog;
    if (initiativeStyleSelect) initiativeStyleSelect.value = initiativeStyle;
    if (toggleUseAction) toggleUseAction.checked = showUseAction;
    if (toggleUseBonusAction) toggleUseBonusAction.checked = showUseBonusAction;
    if (toggleDash) toggleDash.checked = showDash;
    if (toggleStandUp) toggleStandUp.checked = showStandUp;
    if (toggleResetTurn) toggleResetTurn.checked = showResetTurn;
    if (toggleSpellMenu) toggleSpellMenu.checked = hideSpellMenu;
    if (toggleLockMenus) toggleLockMenus.checked = menusLocked;
    if (sheetHandle){
      sheetHandle.setAttribute("aria-disabled", menusLocked ? "true" : "false");
    }
    applyConnStyle();
    updateHotkeyInputs();
    updateSpellPanelVisibility();
  }

  const localPreset = loadLocalPreset();
  if (localPreset){
    applyGuiPreset(localPreset, {persist: true});
    if (!Number.isFinite(Number(localPreset.sheetHeight))){
      loadSheetHeight();
    }
  } else {
    applyUiConfig();
    loadSheetHeight();
  }
  if (sheetHandle && sheetWrap){
    let dragState = null;
    sheetHandle.addEventListener("pointerdown", (event) => {
      if (menusLocked) return;
      sheetHandle.setPointerCapture(event.pointerId);
      dragState = {
        startY: event.clientY,
        startHeight: sheetWrap.getBoundingClientRect().height,
      };
      event.preventDefault();
    });
    sheetHandle.addEventListener("pointermove", (event) => {
      if (!dragState) return;
      const delta = dragState.startY - event.clientY;
      applySheetHeight(dragState.startHeight + delta);
    });
    sheetHandle.addEventListener("pointerup", () => {
      if (!dragState) return;
      dragState = null;
      persistSheetHeight();
    });
    sheetHandle.addEventListener("pointercancel", () => {
      if (!dragState) return;
      dragState = null;
      persistSheetHeight();
    });
  }

  function showConfigModal(){
    if (!configModal) return;
    configModal.classList.add("show");
    configModal.setAttribute("aria-hidden", "false");
    if (configBtn){
      configBtn.setAttribute("aria-expanded", "true");
    }
  }

  function hideConfigModal(){
    if (!configModal) return;
    configModal.classList.remove("show");
    configModal.setAttribute("aria-hidden", "true");
    if (configBtn){
      configBtn.setAttribute("aria-expanded", "false");
    }
  }

  function showMapViewSettingsModal(){
    if (!mapViewSettingsModal) return;
    mapViewSettingsModal.classList.add("show");
    mapViewSettingsModal.setAttribute("aria-hidden", "false");
  }

  function hideMapViewSettingsModal(){
    if (!mapViewSettingsModal) return;
    mapViewSettingsModal.classList.remove("show");
    mapViewSettingsModal.setAttribute("aria-hidden", "true");
  }

  function setAdminMenu(open){
    if (!adminMenuPopover || !adminMenuBtn) return;
    adminMenuPopover.classList.toggle("show", open);
    adminMenuPopover.setAttribute("aria-hidden", open ? "false" : "true");
    adminMenuBtn.setAttribute("aria-expanded", open ? "true" : "false");
  }

  function closeAdminMenu(){
    setAdminMenu(false);
  }

  function showAdminModal(){
    if (!adminModal) return;
    adminModal.classList.add("show");
    adminModal.setAttribute("aria-hidden", "false");
  }

  function hideAdminModal(){
    if (!adminModal) return;
    adminModal.classList.remove("show");
    adminModal.setAttribute("aria-hidden", "true");
  }

  function showAdminLoginModal(){
    if (!adminLoginModal) return;
    adminLoginModal.classList.add("show");
    adminLoginModal.setAttribute("aria-hidden", "false");
    if (adminPasswordInput){
      adminPasswordInput.value = "";
      setTimeout(() => adminPasswordInput.focus(), 50);
    }
  }

  function hideAdminLoginModal(){
    if (!adminLoginModal) return;
    adminLoginModal.classList.remove("show");
    adminLoginModal.setAttribute("aria-hidden", "true");
    setAdminLoginStatus("");
  }

  function setAdminStatus(text){
    if (!adminStatus) return;
    adminStatus.textContent = text || "";
  }

  function setAdminLoginStatus(text){
    if (!adminLoginStatus) return;
    adminLoginStatus.textContent = text || "";
  }

  function getAdminAuth(){
    try {
      const raw = sessionStorage.getItem(adminTokenKey);
      if (!raw) return null;
      const data = JSON.parse(raw);
      if (!data || typeof data !== "object") return null;
      if (!data.token) return null;
      if (data.expiresAt && Date.now() > Number(data.expiresAt)){
        sessionStorage.removeItem(adminTokenKey);
        return null;
      }
      return data.token;
    } catch (err){
      sessionStorage.removeItem(adminTokenKey);
      return null;
    }
  }

  function setAdminAuth(token, expiresIn){
    if (!token) return;
    const expiresMs = Math.max(1, Number(expiresIn || 0)) * 1000;
    const payload = {token, expiresAt: Date.now() + expiresMs};
    sessionStorage.setItem(adminTokenKey, JSON.stringify(payload));
  }

  function clearAdminAuth(){
    sessionStorage.removeItem(adminTokenKey);
  }

  function requestAdminLogin(){
    if (getAdminAuth()){
      return Promise.resolve(getAdminAuth());
    }
    if (adminAuthPromise){
      return adminAuthPromise;
    }
    adminAuthPromise = new Promise((resolve, reject) => {
      adminAuthResolve = resolve;
      adminAuthReject = reject;
      showAdminLoginModal();
    });
    return adminAuthPromise;
  }

  function finalizeAdminLogin(success, token){
    if (!adminAuthPromise) return;
    const resolve = adminAuthResolve;
    const reject = adminAuthReject;
    adminAuthPromise = null;
    adminAuthResolve = null;
    adminAuthReject = null;
    if (success && resolve){
      resolve(token);
    } else if (!success && reject){
      reject(new Error("Admin login canceled."));
    }
  }

  async function adminFetch(url, options = {}){
    const token = await requestAdminLogin();
    const headers = new Headers(options.headers || {});
    if (token){
      headers.set("Authorization", `Bearer ${token}`);
    }
    const res = await fetch(url, {...options, headers});
    if ((res.status === 401 || res.status === 403) && !options._retry){
      clearAdminAuth();
      try {
        await requestAdminLogin();
      } catch (err){
        return res;
      }
      return adminFetch(url, {...options, _retry: true});
    }
    return res;
  }

  function buildAdminPcOptions(selectedCid){
    const options = [];
    const blank = document.createElement("option");
    blank.value = "";
    blank.textContent = "(unassigned)";
    options.push(blank);
    adminPcs.forEach((pc) => {
      const opt = document.createElement("option");
      opt.value = String(pc.cid);
      opt.textContent = pc.name || `cid ${pc.cid}`;
      if (selectedCid !== null && selectedCid !== undefined && String(pc.cid) === String(selectedCid)){
        opt.selected = true;
      }
      options.push(opt);
    });
    return options;
  }

  async function submitAdminLogin(){
    const password = adminPasswordInput ? adminPasswordInput.value : "";
    if (!password){
      setAdminLoginStatus("Enter a password to continue.");
      return;
    }
    try {
      setAdminLoginStatus("Signing in…");
      const res = await fetch("/api/admin/login", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({password}),
      });
      if (!res.ok){
        if (res.status === 403){
          setAdminLoginStatus("Admin password is not configured.");
        } else {
          setAdminLoginStatus("Invalid password. Try again.");
        }
        return;
      }
      const payload = await res.json();
      if (!payload || !payload.token){
        setAdminLoginStatus("Login failed.");
        return;
      }
      setAdminAuth(payload.token, payload.expires_in);
      hideAdminLoginModal();
      finalizeAdminLogin(true, payload.token);
    } catch (err){
      console.warn("Admin login failed.", err);
      setAdminLoginStatus("Login failed. Try again.");
    }
  }

  function renderAdminSessions(){
    if (!adminSessionList) return;
    adminSessionList.innerHTML = "";
    if (!adminSessions.length){
      const empty = document.createElement("div");
      empty.className = "hint";
      empty.textContent = "No sessions found yet.";
      adminSessionList.appendChild(empty);
      return;
    }
    adminSessions.forEach((session) => {
      const row = document.createElement("div");
      row.className = "admin-session";
      const top = document.createElement("div");
      top.className = "admin-session-top";
      const ipWrap = document.createElement("div");
      const ipText = document.createElement("div");
      ipText.className = "admin-session-ip";
      ipText.textContent = session.ip || session.host || "(unknown)";
      const metaText = document.createElement("div");
      metaText.className = "admin-session-meta";
      const reverseDns = session.reverse_dns ? `rDNS: ${session.reverse_dns}` : "rDNS: —";
      const lastSeen = session.last_seen ? `Last seen: ${session.last_seen}` : "";
      metaText.textContent = [reverseDns, lastSeen].filter(Boolean).join(" · ");
      ipWrap.appendChild(ipText);
      ipWrap.appendChild(metaText);
      const status = document.createElement("span");
      status.className = "admin-session-status";
      const statusValue = String(session.status || "offline").toLowerCase();
      status.classList.add(statusValue === "connected" ? "connected" : "offline");
      status.textContent = statusValue === "connected" ? "Connected" : "Offline";
      top.appendChild(ipWrap);
      top.appendChild(status);

      const assignRow = document.createElement("div");
      assignRow.className = "admin-session-assign";
      const assignedText = document.createElement("div");
      assignedText.className = "admin-session-meta";
      const assignedLabel = session.assigned_name || "Unassigned";
      const yamlLabel = session.yaml_assigned_name ? `YAML: ${session.yaml_assigned_name}` : "";
      assignedText.textContent = `Assigned: ${assignedLabel}${yamlLabel ? ` · ${yamlLabel}` : ""}`;
      const select = document.createElement("select");
      buildAdminPcOptions(session.assigned_cid).forEach((opt) => select.appendChild(opt));
      const assignBtn = document.createElement("button");
      assignBtn.className = "btn";
      assignBtn.type = "button";
      assignBtn.textContent = "Save";
      assignBtn.addEventListener("click", async () => {
        const value = select.value;
        const cid = value ? Number(value) : null;
        await assignAdminIp(session.ip || session.host || "", cid);
      });
      assignRow.appendChild(assignedText);
      assignRow.appendChild(select);
      assignRow.appendChild(assignBtn);

      row.appendChild(top);
      row.appendChild(assignRow);
      adminSessionList.appendChild(row);
    });
  }

  async function fetchAdminSessions({silent} = {}){
    try {
      if (!silent) setAdminStatus("Loading sessions…");
      const res = await adminFetch("/api/admin/sessions");
      if (!res.ok){
        throw new Error(`HTTP ${res.status}`);
      }
      const payload = await res.json();
      adminSessions = Array.isArray(payload.sessions) ? payload.sessions : [];
      adminPcs = Array.isArray(payload.pcs) ? payload.pcs : [];
      setAdminStatus(`Loaded ${adminSessions.length} session${adminSessions.length === 1 ? "" : "s"}.`);
      renderAdminSessions();
    } catch (err){
      console.warn("Failed to load admin sessions.", err);
      setAdminStatus("Failed to load sessions.");
    }
  }

  async function assignAdminIp(ip, cid){
    const host = String(ip || "").trim();
    if (!host){
      setAdminStatus("Missing IP address.");
      return;
    }
    try {
      setAdminStatus("Saving assignment…");
      const res = await adminFetch("/api/admin/assign_ip", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({ip: host, cid}),
      });
      if (!res.ok){
        throw new Error(`HTTP ${res.status}`);
      }
      await res.json();
      await fetchAdminSessions({silent: true});
      setAdminStatus("Assignment saved.");
    } catch (err){
      console.warn("Failed to assign session.", err);
      setAdminStatus("Failed to save assignment.");
    }
  }

  const mapViewBlockedTypes = new Set([
    "move",
    "dash",
    "perform_action",
    "end_turn",
    "use_action",
    "use_bonus_action",
    "set_color",
    "reset_turn",
    "cast_aoe",
    "aoe_move",
    "aoe_remove",
    "save_preset",
  ]);

  function send(msg){
    if (isMapView && msg && mapViewBlockedTypes.has(msg.type)){
      return;
    }
    if (!ws || ws.readyState !== 1) return;
    ws.send(JSON.stringify(msg));
  }

  function localToast(text){
    if (!noteEl) return;
    noteEl.textContent = text || "…";
    setTimeout(() => noteEl.textContent = "Tip: drag yer token", 2500);
  }

  const DEFAULT_SPELL_COLOR = "#6aa9ff";

  function normalizeHexColor(raw){
    if (!raw) return null;
    const value = String(raw).trim().toLowerCase();
    if (!/^#[0-9a-f]{6}$/.test(value)) return null;
    return value;
  }

  function resolveSpellColor(raw){
    return normalizeHexColor(raw || "") || DEFAULT_SPELL_COLOR;
  }

  function setLocalAoeCenter(aid, cx, cy){
    if (!state || !Array.isArray(state.aoes)) return;
    const target = state.aoes.find(a => Number(a.aid) === Number(aid));
    if (!target) return;
    target.cx = cx;
    target.cy = cy;
  }

  function setLocalAoeMoveRemaining(aid, remaining){
    if (!state || !Array.isArray(state.aoes)) return;
    const target = state.aoes.find(a => Number(a.aid) === Number(aid));
    if (!target) return;
    target.move_remaining_ft = remaining;
  }

  function setSelectedAoe(aid){
    if (aid === null || aid === undefined){
      selectedAoeId = null;
    } else {
      const parsed = Number(aid);
      selectedAoeId = Number.isFinite(parsed) ? parsed : null;
    }
  }

  function clearAoeMoveMode(){
    aoeMoveModeAid = null;
    lastAoeTapAid = null;
    lastAoeTapAt = 0;
  }

  function syncSelectedAoe(){
    if (selectedAoeId === null || selectedAoeId === undefined){
      return;
    }
    const exists = Array.isArray(state?.aoes)
      && state.aoes.some(a => Number(a.aid) === Number(selectedAoeId));
    if (!exists){
      selectedAoeId = null;
      clearAoeMoveMode();
    }
  }

  function hexToRgb(hex){
    const value = normalizeHexColor(hex);
    if (!value) return null;
    return {
      r: parseInt(value.slice(1, 3), 16),
      g: parseInt(value.slice(3, 5), 16),
      b: parseInt(value.slice(5, 7), 16),
    };
  }

  function isForbiddenColor(hex){
    const rgb = hexToRgb(hex);
    if (!rgb) return false;
    if (rgb.r >= 245 && rgb.g >= 245 && rgb.b >= 245) return true;
    if (rgb.r >= 200 && rgb.g <= 80 && rgb.b <= 80) return true;
    return false;
  }

  function rgbaFromHex(hex, alpha){
    const rgb = hexToRgb(hex);
    if (!rgb) return null;
    return `rgba(${rgb.r},${rgb.g},${rgb.b},${alpha})`;
  }

  function updateTokenColorSwatch(color){
    if (!tokenColorSwatch) return;
    tokenColorSwatch.style.background = color || "#6aa9ff";
  }

  function openColorModal(unit){
    if (!colorModal || !tokenColorInput) return;
    const targetUnit = unit || getClaimedUnit();
    if (!targetUnit){
      localToast("Claim a character first, matey.");
      return;
    }
    pendingClaim = targetUnit;
    let preferred = normalizeHexColor(targetUnit?.token_color)
      || normalizeHexColor(localStorage.getItem("inittracker_tokenColor"))
      || "#6aa9ff";
    if (isForbiddenColor(preferred)){
      preferred = "#6aa9ff";
    }
    tokenColorInput.value = preferred;
    updateTokenColorSwatch(preferred);
    colorModal.classList.add("show");
    colorModal.setAttribute("aria-hidden", "false");
  }

  function closeColorModal(){
    if (!colorModal) return;
    colorModal.classList.remove("show");
    colorModal.setAttribute("aria-hidden", "true");
    pendingClaim = null;
  }

  function openClaimedColorModal(){
    openColorModal(getClaimedUnit());
  }

  function validateTokenColor(raw){
    const color = normalizeHexColor(raw);
    if (!color){
      localToast("Pick a valid hex color, matey.");
      return null;
    }
    if (isForbiddenColor(color)){
      localToast("No red or white, matey.");
      return null;
    }
    return color;
  }

  function showNoOwnedPcToast(pcs){
    if (isMapView) return;
    if (shownNoOwnedToast) return;
    if (claimedCid) return;
    const list = Array.isArray(pcs) ? pcs : [];
    if (!list.length) return;
    localToast("No assigned PCs found. Ask the DM to assign yer character.");
    shownNoOwnedToast = true;
  }

  function showDashModal(){
    if (!dashModal) return;
    dashModal.classList.add("show");
    dashModal.setAttribute("aria-hidden", "false");
  }

  function hideDashModal(){
    if (!dashModal) return;
    dashModal.classList.remove("show");
    dashModal.setAttribute("aria-hidden", "true");
  }

  function showLogModal(){
    if (!logModal) return;
    logModal.classList.add("show");
    logModal.setAttribute("aria-hidden", "false");
  }

  function hideLogModal(){
    if (!logModal) return;
    logModal.classList.remove("show");
    logModal.setAttribute("aria-hidden", "true");
  }

  function requestBattleLog(){
    if (logContent){
      logContent.textContent = "Loading…";
    }
    send({type:"log_request"});
  }

  function applyTerrainPayload(terrain){
    if (!state){ state = {}; }
    if (!terrain || typeof terrain !== "object") return;
    if (Array.isArray(terrain.rough_terrain)){
      state.rough_terrain = terrain.rough_terrain;
    } else if (!state.rough_terrain){
      state.rough_terrain = [];
    }
    if (Array.isArray(terrain.obstacles)){
      state.obstacles = terrain.obstacles;
    } else if (!state.obstacles){
      state.obstacles = [];
    }
  }

  function applyTerrainPatch(patch){
    if (!state){ state = {}; }
    if (!patch || typeof patch !== "object") return;
    const roughUpdates = Array.isArray(patch.rough_updates) ? patch.rough_updates : [];
    const roughRemovals = Array.isArray(patch.rough_removals) ? patch.rough_removals : [];
    if (roughUpdates.length || roughRemovals.length){
      const roughMap = new Map();
      (state.rough_terrain || []).forEach((cell) => {
        if (!cell) return;
        const key = `${Number(cell.col)},${Number(cell.row)}`;
        roughMap.set(key, cell);
      });
      roughUpdates.forEach((cell) => {
        if (!cell) return;
        const key = `${Number(cell.col)},${Number(cell.row)}`;
        roughMap.set(key, cell);
      });
      roughRemovals.forEach((cell) => {
        if (!cell) return;
        const key = `${Number(cell.col)},${Number(cell.row)}`;
        roughMap.delete(key);
      });
      state.rough_terrain = Array.from(roughMap.values());
    }

    const obstacleUpdates = Array.isArray(patch.obstacle_updates) ? patch.obstacle_updates : [];
    const obstacleRemovals = Array.isArray(patch.obstacle_removals) ? patch.obstacle_removals : [];
    if (obstacleUpdates.length || obstacleRemovals.length){
      const obstacleSet = new Set((state.obstacles || []).map(o => `${Number(o.col)},${Number(o.row)}`));
      obstacleUpdates.forEach((cell) => {
        if (!cell) return;
        obstacleSet.add(`${Number(cell.col)},${Number(cell.row)}`);
      });
      obstacleRemovals.forEach((cell) => {
        if (!cell) return;
        obstacleSet.delete(`${Number(cell.col)},${Number(cell.row)}`);
      });
      state.obstacles = Array.from(obstacleSet).map((key) => {
        const [col, row] = key.split(",").map(Number);
        return {col, row};
      });
    }
  }

  function applyUnitUpdates(updates){
    if (!state || !Array.isArray(state.units)) return;
    updates.forEach((update) => {
      if (!update || update.cid === undefined || update.cid === null) return;
      const cid = Number(update.cid);
      const idx = state.units.findIndex((unit) => Number(unit.cid) === cid);
      if (idx < 0) return;
      const current = state.units[idx];
      const next = {...current};
      Object.keys(update).forEach((key) => {
        if (key === "cid") return;
        next[key] = update[key];
      });
      state.units[idx] = next;
    });
  }

  function applyAoePatch(patch){
    if (!state){ state = {}; }
    if (!patch || typeof patch !== "object") return;
    const updates = Array.isArray(patch.updates) ? patch.updates : [];
    const removals = Array.isArray(patch.removals) ? patch.removals : [];
    if (!Array.isArray(state.aoes)){
      state.aoes = [];
    }
    const aoeMap = new Map();
    state.aoes.forEach((aoe) => {
      if (!aoe || aoe.aid === undefined || aoe.aid === null) return;
      aoeMap.set(Number(aoe.aid), aoe);
    });
    updates.forEach((aoe) => {
      if (!aoe || aoe.aid === undefined || aoe.aid === null) return;
      aoeMap.set(Number(aoe.aid), aoe);
    });
    removals.forEach((aid) => {
      aoeMap.delete(Number(aid));
    });
    state.aoes = Array.from(aoeMap.values()).sort((a, b) => Number(a.aid) - Number(b.aid));
  }

  function gridToScreen(col,row){
    return {x: panX + col*zoom + zoom/2, y: panY + row*zoom + zoom/2};
  }
  function screenToGrid(x,y){
    return {col: Math.floor((x - panX)/zoom), row: Math.floor((y - panY)/zoom)};
  }
  function screenToGridFloat(x,y){
    const col = (x - panX) / zoom;
    const row = (y - panY) / zoom;
    return {col: Math.round(col * 2) / 2, row: Math.round(row * 2) / 2};
  }

  function hitTestAoe(p){
    if (!state || !state.aoes || !state.aoes.length) return null;
    for (let i = state.aoes.length - 1; i >= 0; i--){
      const a = state.aoes[i];
      if (!a || !a.kind) continue;
      const remainingTurns = Number(a.remaining_turns);
      if (Number.isFinite(remainingTurns) && remainingTurns <= 0){
        continue;
      }
      const cx = Number(a.cx ?? 0);
      const cy = Number(a.cy ?? 0);
      const center = gridToScreen(cx, cy);
      const dx = p.x - center.x;
      const dy = p.y - center.y;
      if (a.kind === "circle" || a.kind === "sphere" || a.kind === "cylinder"){
        const r = Math.max(0, Number(a.radius_sq || 0)) * zoom;
        if (dx * dx + dy * dy <= r * r){
          return a;
        }
      } else if (a.kind === "square" || a.kind === "cube"){
        const half = Math.max(0, Number(a.side_sq || 0)) * zoom / 2;
        if (Math.abs(dx) <= half && Math.abs(dy) <= half){
          return a;
        }
      } else if (a.kind === "line" || a.kind === "wall"){
        const lengthPx = Math.max(0, Number(a.length_sq || 0)) * zoom;
        const widthPx = Math.max(0, Number(a.width_sq || 0)) * zoom;
        const orient = a.orient === "horizontal" ? "horizontal" : "vertical";
        const angleDeg = Number.isFinite(Number(a.angle_deg)) ? Number(a.angle_deg) : (orient === "horizontal" ? 0 : 90);
        const angle = (-angleDeg * Math.PI) / 180;
        const rx = dx * Math.cos(angle) - dy * Math.sin(angle);
        const ry = dx * Math.sin(angle) + dy * Math.cos(angle);
        if (Math.abs(rx) <= lengthPx / 2 && Math.abs(ry) <= widthPx / 2){
          return a;
        }
      } else if (a.kind === "cone"){
        const lengthPx = Math.max(0, Number(a.length_sq || 0)) * zoom;
        const spreadDeg = Number.isFinite(Number(a.angle_deg)) ? Number(a.angle_deg) : 90;
        const headingDeg = a.orient === "horizontal" ? 0 : -90;
        const dist = Math.hypot(dx, dy);
        if (dist <= lengthPx){
          let angle = Math.atan2(dy, dx);
          const heading = (headingDeg * Math.PI) / 180;
          angle -= heading;
          while (angle <= -Math.PI) angle += Math.PI * 2;
          while (angle > Math.PI) angle -= Math.PI * 2;
          const halfSpread = (spreadDeg * Math.PI) / 360;
          if (Math.abs(angle) <= halfSpread){
            return a;
          }
        }
      }
    }
    return null;
  }

  function gridReady(){
    if (!state || !state.grid) return false;
    if (state.grid.ready === false) return false;
    return Number.isFinite(state.grid.cols) && Number.isFinite(state.grid.rows);
  }

  function updateWaitingOverlay(){
    if (!waitingOverlay) return;
    waitingOverlay.classList.toggle("show", !gridReady());
  }

  function formatFeet(feet){
    const rounded = Math.round(feet * 10) / 10;
    const label = Number.isInteger(rounded) ? String(rounded) : rounded.toFixed(1);
    return `${label} ft`;
  }

  function updateMeasurementControls(){
    if (measureToggle){
      measureToggle.textContent = measurementMode ? "Measuring…" : "Measure";
      measureToggle.classList.toggle("accent", measurementMode);
      measureToggle.setAttribute("aria-pressed", measurementMode ? "true" : "false");
    }
    if (measureClear){
      measureClear.disabled = !(measurement.start || measurement.end);
    }
  }

  function getClaimedUnit(){
    if (!state || !state.units || claimedCid === null) return null;
    return state.units.find(u => Number(u.cid) === Number(claimedCid)) || null;
  }

  function isUnitSpellcaster(unit){
    if (!unit) return false;
    if (unit.is_spellcaster !== undefined && unit.is_spellcaster !== null){
      return !!unit.is_spellcaster;
    }
    if (unit.spellcaster !== undefined && unit.spellcaster !== null){
      return !!unit.spellcaster;
    }
    return true;
  }

  function updateSpellPanelVisibility(){
    if (!castPanel) return;
    const claimedUnit = getClaimedUnit();
    const hideForNonCaster = hideSpellMenu && claimedUnit && !isUnitSpellcaster(claimedUnit);
    castPanel.classList.toggle("hidden", hideForNonCaster);
    if (castMenuTrigger){
      castMenuTrigger.classList.toggle("hidden", hideForNonCaster);
    }
    if (castOverlay){
      castOverlay.classList.toggle("hidden", hideForNonCaster);
    }
    if (hideForNonCaster && castOverlay?.classList.contains("show")){
      setCastOverlayOpen(false);
    }
  }

  function defaultAoeCenter(){
    const unit = getClaimedUnit();
    if (unit){
      return {cx: Number(unit.pos.col), cy: Number(unit.pos.row)};
    }
    const cols = state?.grid?.cols ?? 0;
    const rows = state?.grid?.rows ?? 0;
    return {cx: Math.max(0, (cols - 1) / 2), cy: Math.max(0, (rows - 1) / 2)};
  }

  function toGridPoint(point){
    if (!point) return {col: 0, row: 0};
    const colValue = point.col ?? point.cx ?? 0;
    const rowValue = point.row ?? point.cy ?? 0;
    return {col: Math.round(Number(colValue)), row: Math.round(Number(rowValue))};
  }

  function isLineOfSightBlocked(startPoint, endPoint){
    if (!state || !state.obstacles || !state.obstacles.length) return false;
    const start = toGridPoint(startPoint);
    const end = toGridPoint(endPoint);
    const obstacles = new Set(state.obstacles.map(o => `${Number(o.col)},${Number(o.row)}`));
    let x0 = start.col;
    let y0 = start.row;
    const x1 = end.col;
    const y1 = end.row;
    const dx = Math.abs(x1 - x0);
    const dy = Math.abs(y1 - y0);
    const sx = x0 < x1 ? 1 : -1;
    const sy = y0 < y1 ? 1 : -1;
    let err = dx - dy;
    let first = true;
    while (true){
      if (!first && obstacles.has(`${x0},${y0}`)){
        return true;
      }
      if (x0 === x1 && y0 === y1){
        break;
      }
      const e2 = 2 * err;
      if (e2 > -dy){
        err -= dy;
        x0 += sx;
      }
      if (e2 < dx){
        err += dx;
        y0 += sy;
      }
      first = false;
    }
    return false;
  }

  function setLosPreview(startPoint, endPoint, blocked){
    losPreview = {
      start: toGridPoint(startPoint),
      end: toGridPoint(endPoint),
      blocked: !!blocked,
      expiresAt: Date.now() + LOS_PREVIEW_MS,
    };
    setTimeout(() => {
      if (losPreview && Date.now() >= losPreview.expiresAt){
        losPreview = null;
        draw();
      }
    }, LOS_PREVIEW_MS + 25);
    draw();
  }

  function clearMeasurement(){
    measurement = {start: null, end: null};
    updateMeasurementControls();
    draw();
  }

  function setMeasurementPoint(p){
    if (!gridReady()) return;
    const g = screenToGrid(p.x, p.y);
    const point = {col: g.col, row: g.row};
    if (!measurement.start || measurement.end){
      measurement = {start: point, end: null};
    } else {
      measurement.end = point;
    }
    updateMeasurementControls();
    draw();
  }

  function draw(){
    if (!state) return;
    if (!gridReady()){
      updateWaitingOverlay();
      return;
    }
    updateWaitingOverlay();
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;

    ctx.clearRect(0,0,w,h);

    // background
    ctx.fillStyle = "#0a0c12";
    ctx.fillRect(0,0,w,h);

    const cols = state.grid.cols, rows = state.grid.rows;
    if (cols !== lastGrid.cols || rows !== lastGrid.rows){
      fittedToGrid = false;
      lastGrid = {cols, rows};
    }

    // auto-fit on first draw
    if (!fittedToGrid){
      const pad = 24;
      const sx = (w - pad*2) / (cols*zoom);
      const sy = (h - pad*2) / (rows*zoom);
      const s = Math.min(1.0, Math.max(0.35, Math.min(sx, sy)));
      zoom = Math.floor(zoom * s);
      panX = Math.floor((w - cols*zoom)/2);
      panY = Math.floor((h - rows*zoom)/2);
      fittedToGrid = true;
    }

    // grid
    ctx.strokeStyle = "rgba(255,255,255,0.07)";
    ctx.lineWidth = 1;
    for(let c=0;c<=cols;c++){
      const x = panX + c*zoom;
      ctx.beginPath(); ctx.moveTo(x, panY); ctx.lineTo(x, panY + rows*zoom); ctx.stroke();
    }
    for(let r=0;r<=rows;r++){
      const y = panY + r*zoom;
      ctx.beginPath(); ctx.moveTo(panX, y); ctx.lineTo(panX + cols*zoom, y); ctx.stroke();
    }

    // rough terrain
    if (state.rough_terrain && state.rough_terrain.length){
      state.rough_terrain.forEach(cell => {
        const x = panX + cell.col*zoom;
        const y = panY + cell.row*zoom;
        const colorHex = normalizeHexColor(cell.color || "");
        const isSwim = !!cell.is_swim;
        const isRough = !!cell.is_rough;
        let alpha = isSwim ? 0.35 : 0.25;
        if (isRough && !isSwim){
          alpha = 0.3;
        }
        const fallback = isSwim ? "rgba(74,163,223,0.32)" : "rgba(141,110,99,0.25)";
        ctx.fillStyle = colorHex ? rgbaFromHex(colorHex, alpha) : fallback;
        ctx.fillRect(x+1,y+1,zoom-2,zoom-2);
      });
    }

    // movement range (claimed token)
    const isMyTurn = claimedCid != null
      && state.active_cid != null
      && Number(state.active_cid) === Number(claimedCid);
    if (isMyTurn && state.units){
      const me = state.units.find(u => Number(u.cid) === Number(claimedCid));
      if (me){
        const move = Math.max(0, Number(me.move_remaining || 0));
        const feet = Math.max(1, Number(state.grid.feet_per_square || 5));
        const rangeSquares = move / feet;
        if (rangeSquares > 0){
          const {x,y} = gridToScreen(me.pos.col, me.pos.row);
          const radius = rangeSquares * zoom;
          ctx.save();
          ctx.beginPath();
          ctx.arc(x, y, radius, 0, Math.PI * 2);
          ctx.fillStyle = "rgba(106,169,255,0.12)";
          ctx.fill();
          ctx.lineWidth = 2;
          ctx.strokeStyle = "rgba(106,169,255,0.35)";
          ctx.stroke();
          ctx.restore();
        }
      }
    }

    // obstacles
    if (state.obstacles && state.obstacles.length){
      ctx.fillStyle = "rgba(255,255,255,0.10)";
      state.obstacles.forEach(o => {
        const x = panX + o.col*zoom;
        const y = panY + o.row*zoom;
        ctx.fillRect(x+1,y+1,zoom-2,zoom-2);
      });
    }

    // AoE overlays
    if (state.aoes && state.aoes.length){
      state.aoes.forEach(a => {
        if (!a || !a.kind) return;
        const remainingTurnsRaw = a.remaining_turns;
        const remainingTurnsValue = (remainingTurnsRaw === null || remainingTurnsRaw === undefined)
          ? null
          : Number(remainingTurnsRaw);
        if (Number.isFinite(remainingTurnsValue) && remainingTurnsValue <= 0){
          return;
        }
        const preview = (draggingAoe && draggingAoe.aid === a.aid) ? draggingAoe : null;
        const override = aoeDragOverrides.get(Number(a.aid));
        const cx = Number((preview || override) ? (preview || override).cx : a.cx ?? 0);
        const cy = Number((preview || override) ? (preview || override).cy : a.cy ?? 0);
        const {x,y} = gridToScreen(cx, cy);
        const colorHex = normalizeHexColor(a.color || "");
        ctx.save();
        ctx.lineWidth = 2;
        ctx.setLineDash([6,4]);
        if (a.kind === "circle" || a.kind === "sphere" || a.kind === "cylinder"){
          const r = Math.max(0, Number(a.radius_sq || 0)) * zoom;
          ctx.beginPath();
          ctx.arc(x, y, r, 0, Math.PI * 2);
          ctx.fillStyle = colorHex ? rgbaFromHex(colorHex, 0.28) : "rgba(168,197,255,0.32)";
          ctx.strokeStyle = colorHex || "rgba(45,79,138,0.85)";
          ctx.fill();
          ctx.stroke();
        } else if (a.kind === "line" || a.kind === "wall"){
          const lengthPx = Math.max(0, Number(a.length_sq || 0)) * zoom;
          const widthPx = Math.max(0, Number(a.width_sq || 0)) * zoom;
          const angleDeg = Number.isFinite(Number(a.angle_deg)) ? Number(a.angle_deg) : null;
          const orient = a.orient === "horizontal" ? "horizontal" : "vertical";
          const halfW = orient === "horizontal" ? lengthPx / 2 : widthPx / 2;
          const halfH = orient === "horizontal" ? widthPx / 2 : lengthPx / 2;
          ctx.fillStyle = colorHex
            ? rgbaFromHex(colorHex, 0.28)
            : (a.kind === "wall" ? "rgba(255,230,153,0.32)" : "rgba(183,255,224,0.32)");
          ctx.strokeStyle = colorHex || (a.kind === "wall" ? "rgba(181,125,34,0.85)" : "rgba(45,138,87,0.85)");
          if (angleDeg !== null){
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate((angleDeg * Math.PI) / 180);
            ctx.beginPath();
            ctx.rect(-lengthPx / 2, -widthPx / 2, lengthPx, widthPx);
            ctx.fill();
            ctx.stroke();
            ctx.restore();
          } else {
            ctx.beginPath();
            ctx.rect(x - halfW, y - halfH, halfW * 2, halfH * 2);
            ctx.fill();
            ctx.stroke();
          }
        } else if (a.kind === "square" || a.kind === "cube"){
          const sidePx = Math.max(0, Number(a.side_sq || 0)) * zoom;
          const half = sidePx / 2;
          ctx.beginPath();
          ctx.rect(x - half, y - half, sidePx, sidePx);
          ctx.fillStyle = colorHex ? rgbaFromHex(colorHex, 0.28) : "rgba(226,182,255,0.32)";
          ctx.strokeStyle = colorHex || "rgba(107,61,138,0.85)";
          ctx.fill();
          ctx.stroke();
        } else if (a.kind === "cone"){
          const lengthPx = Math.max(0, Number(a.length_sq || 0)) * zoom;
          const spreadDeg = Number.isFinite(Number(a.angle_deg)) ? Number(a.angle_deg) : 90;
          const headingDeg = a.orient === "horizontal" ? 0 : -90;
          const halfSpread = (spreadDeg * Math.PI) / 360;
          const headingRad = (headingDeg * Math.PI) / 180;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.arc(x, y, lengthPx, headingRad - halfSpread, headingRad + halfSpread);
          ctx.closePath();
          ctx.fillStyle = colorHex ? rgbaFromHex(colorHex, 0.28) : "rgba(255,189,110,0.32)";
          ctx.strokeStyle = colorHex || "rgba(181,110,34,0.85)";
          ctx.fill();
          ctx.stroke();
        }
        ctx.setLineDash([]);
        const label = a.name ? String(a.name) : "";
        const labelText = label
          ? (a.pinned && Number.isFinite(remainingTurns) ? `${label} (${remainingTurns}t)` : label)
          : "";
        if (labelText){
          ctx.font = `700 ${Math.max(10, Math.floor(zoom*0.32))}px system-ui`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillStyle = "rgba(20,25,35,0.9)";
          ctx.fillText(labelText, x + 1, y + 1);
          ctx.fillStyle = "rgba(232,238,247,0.95)";
          ctx.fillText(labelText, x, y);
        }
        if (selectedAoeId !== null && Number(a.aid) === Number(selectedAoeId)){
          ctx.save();
          ctx.lineWidth = 3;
          ctx.setLineDash([]);
          ctx.strokeStyle = "rgba(255,214,102,0.95)";
          if (a.kind === "circle" || a.kind === "sphere" || a.kind === "cylinder"){
            const r = Math.max(0, Number(a.radius_sq || 0)) * zoom;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.stroke();
          } else if (a.kind === "line" || a.kind === "wall"){
            const lengthPx = Math.max(0, Number(a.length_sq || 0)) * zoom;
            const widthPx = Math.max(0, Number(a.width_sq || 0)) * zoom;
            const angleDeg = Number.isFinite(Number(a.angle_deg)) ? Number(a.angle_deg) : null;
            if (angleDeg !== null){
              ctx.translate(x, y);
              ctx.rotate((angleDeg * Math.PI) / 180);
              ctx.beginPath();
              ctx.rect(-lengthPx / 2, -widthPx / 2, lengthPx, widthPx);
              ctx.stroke();
            } else {
              const orient = a.orient === "horizontal" ? "horizontal" : "vertical";
              const halfW = orient === "horizontal" ? lengthPx / 2 : widthPx / 2;
              const halfH = orient === "horizontal" ? widthPx / 2 : lengthPx / 2;
              ctx.beginPath();
              ctx.rect(x - halfW, y - halfH, halfW * 2, halfH * 2);
              ctx.stroke();
            }
          } else if (a.kind === "square" || a.kind === "cube"){
            const sidePx = Math.max(0, Number(a.side_sq || 0)) * zoom;
            const half = sidePx / 2;
            ctx.beginPath();
            ctx.rect(x - half, y - half, sidePx, sidePx);
            ctx.stroke();
          } else if (a.kind === "cone"){
            const lengthPx = Math.max(0, Number(a.length_sq || 0)) * zoom;
            const spreadDeg = Number.isFinite(Number(a.angle_deg)) ? Number(a.angle_deg) : 90;
            const headingDeg = a.orient === "horizontal" ? 0 : -90;
            const halfSpread = (spreadDeg * Math.PI) / 360;
            const headingRad = (headingDeg * Math.PI) / 180;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.arc(x, y, lengthPx, headingRad - halfSpread, headingRad + halfSpread);
            ctx.closePath();
            ctx.stroke();
          }
          ctx.restore();
        }
        ctx.restore();
      });
    }

    // measurement line
    if (measurement.start){
      const start = gridToScreen(measurement.start.col, measurement.start.row);
      ctx.save();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(255,233,106,0.9)";
      ctx.fillStyle = "rgba(255,233,106,0.9)";
      ctx.beginPath();
      ctx.arc(start.x, start.y, Math.max(6, zoom * 0.12), 0, Math.PI * 2);
      ctx.fill();
      if (measurement.end){
        const end = gridToScreen(measurement.end.col, measurement.end.row);
        ctx.beginPath();
        ctx.moveTo(start.x, start.y);
        ctx.lineTo(end.x, end.y);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(end.x, end.y, Math.max(6, zoom * 0.12), 0, Math.PI * 2);
        ctx.fill();
        const feetPerSquare = Math.max(1, Number(state.grid.feet_per_square || 5));
        const dx = measurement.end.col - measurement.start.col;
        const dy = measurement.end.row - measurement.start.row;
        const feet = Math.hypot(dx, dy) * feetPerSquare;
        const label = formatFeet(feet);
        const midX = (start.x + end.x) / 2;
        const midY = (start.y + end.y) / 2;
        ctx.font = `700 ${Math.max(11, Math.floor(zoom * 0.32))}px system-ui`;
        ctx.textAlign = "center";
        ctx.textBaseline = "bottom";
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillText(label, midX + 1, midY - 7 + 1);
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.fillText(label, midX, midY - 7);
      }
      ctx.restore();
    }

    if (losPreview && Date.now() <= losPreview.expiresAt){
      const start = gridToScreen(losPreview.start.col, losPreview.start.row);
      const end = gridToScreen(losPreview.end.col, losPreview.end.row);
      ctx.save();
      ctx.lineWidth = 3;
      ctx.setLineDash([8, 6]);
      ctx.strokeStyle = losPreview.blocked ? "rgba(255,120,120,0.95)" : "rgba(123,233,173,0.95)";
      ctx.beginPath();
      ctx.moveTo(start.x, start.y);
      ctx.lineTo(end.x, end.y);
      ctx.stroke();
      ctx.restore();
    }

    // tokens
    const tokens = state.units || [];
    // group labels by cell
    const cellMap = new Map();
    tokens.forEach(u => {
      const key = `${u.pos.col},${u.pos.row}`;
      if (!cellMap.has(key)) cellMap.set(key, []);
      cellMap.get(key).push(u);
    });

    // draw token circles first
    tokens.forEach(u => {
      const {x,y} = gridToScreen(u.pos.col,u.pos.row);
      const r = Math.max(10, zoom*0.35);
      const active = (state.active_cid !== null && Number(state.active_cid) === Number(u.cid));
      const mine = (claimedCid && Number(claimedCid) === Number(u.cid));
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);

      // color
      const customFill = u.token_color ? rgbaFromHex(u.token_color, 0.28) : null;
      if (customFill){
        ctx.fillStyle = customFill;
      } else if (u.role === "enemy") {
        ctx.fillStyle = "rgba(255,91,91,0.28)";
      } else {
        ctx.fillStyle = "rgba(106,255,176,0.18)";
      }
      ctx.fill();

      ctx.lineWidth = active ? 3 : 2;
      ctx.strokeStyle = mine ? "rgba(106,169,255,0.95)" : (active ? "rgba(255,255,255,0.85)" : "rgba(255,255,255,0.25)");
      ctx.stroke();

      // condition markers inside
      const marks = (u.marks || "").trim();
      if (marks){
        ctx.font = `${Math.max(10, Math.floor(zoom*0.33))}px system-ui`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.fillText(marks, x, y);
      }
    });

    // labels above: name or group name
    const labelBoxes = [];
    const labelFontSize = Math.max(11, Math.floor(zoom*0.32));
    const labelOffset = zoom*0.40;
    const labelPad = 2;
    const labelStep = Math.max(6, Math.floor(labelFontSize * 0.7));
    const labelOffsets = [0, -labelStep, labelStep, -2*labelStep, 2*labelStep];
    const labelEntries = [];
    cellMap.forEach((arr, key) => {
      const [col,row] = key.split(",").map(Number);
      const {x,y} = gridToScreen(col,row);
      let label = "";
      if (arr.length >= 2){
        const names = arr.map(a => a.name).join(", ");
        label = `Group (${arr.length}): ${names}`;
      } else {
        label = arr[0].name;
      }
      const isActive = arr.some(a => state.active_cid !== null && Number(state.active_cid) === Number(a.cid));
      labelEntries.push({label, x, y: y - labelOffset, isActive});
    });
    labelEntries.sort((a, b) => Number(a.isActive) - Number(b.isActive));
    ctx.textAlign = "center";
    ctx.textBaseline = "bottom";
    ctx.font = `600 ${labelFontSize}px system-ui`;
    const overlaps = (a, b) => !(a.x2 < b.x1 || a.x1 > b.x2 || a.y2 < b.y1 || a.y1 > b.y2);
    labelEntries.forEach(entry => {
      const width = ctx.measureText(entry.label).width;
      let placed = false;
      for (const offset of labelOffsets){
        const y = entry.y + offset;
        const box = {
          x1: entry.x - width / 2 - labelPad,
          x2: entry.x + width / 2 + labelPad,
          y1: y - labelFontSize - labelPad,
          y2: y + labelPad,
        };
        if (!labelBoxes.some(b => overlaps(b, box))){
          // shadow
          ctx.fillStyle = "rgba(0,0,0,0.55)";
          ctx.fillText(entry.label, entry.x + 1, y + 1);
          ctx.fillStyle = "rgba(232,238,247,0.92)";
          ctx.fillText(entry.label, entry.x, y);
          labelBoxes.push(box);
          placed = true;
          break;
        }
      }
      if (!placed && (showAllNames || entry.isActive)){
        const y = entry.y;
        const box = {
          x1: entry.x - width / 2 - labelPad,
          x2: entry.x + width / 2 + labelPad,
          y1: y - labelFontSize - labelPad,
          y2: y + labelPad,
        };
        ctx.fillStyle = "rgba(0,0,0,0.55)";
        ctx.fillText(entry.label, entry.x + 1, y + 1);
        ctx.fillStyle = "rgba(232,238,247,0.92)";
        ctx.fillText(entry.label, entry.x, y);
        labelBoxes.push(box);
      }
    });

  }

  function centerOnPoint(col, row){
    if (!state || !state.grid) return false;
    if (!gridReady()) return false;
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    const cols = state.grid.cols, rows = state.grid.rows;
    const desiredX = (w / 2) - (Number(col) + 0.5) * zoom;
    const desiredY = (h / 2) - (Number(row) + 0.5) * zoom;
    const gridW = cols * zoom;
    const gridH = rows * zoom;
    if (gridW <= w) {
      panX = Math.floor((w - gridW) / 2);
    } else {
      const minX = w - gridW;
      panX = Math.min(0, Math.max(minX, desiredX));
    }
    if (gridH <= h) {
      panY = Math.floor((h - gridH) / 2);
    } else {
      const minY = h - gridH;
      panY = Math.min(0, Math.max(minY, desiredY));
    }
    return true;
  }

  function centerOnClaimed(){
    if (!state || !state.units || claimedCid === null || claimedCid === undefined) return false;
    if (!gridReady()) return false;
    const me = state.units.find(u => Number(u.cid) === Number(claimedCid));
    if (!me) return false;
    const ok = centerOnPoint(me.pos.col, me.pos.row);
    if (ok){
      centeredCid = String(claimedCid);
      draw();
    }
    return ok;
  }

  function centerOnGridCenter(){
    if (!state || !state.grid) return false;
    if (!gridReady()) return false;
    const cols = Number(state.grid.cols || 0);
    const rows = Number(state.grid.rows || 0);
    const col = Math.max(0, (cols - 1) / 2);
    const row = Math.max(0, (rows - 1) / 2);
    const ok = centerOnPoint(col, row);
    if (ok){
      draw();
    }
    return ok;
  }

  function autoCenterOnJoin(){
    if (!gridReady()) return;
    if (claimedCid !== null && claimedCid !== undefined){
      if (!initialCenterDone || (initialCenterFallback && centeredCid !== String(claimedCid))){
        if (centerOnClaimed()){
          initialCenterDone = true;
          initialCenterFallback = false;
        }
      }
    } else if (!initialCenterDone) {
      if (centerOnGridCenter()){
        initialCenterDone = true;
        initialCenterFallback = true;
      }
    }
  }

  function formatTurnOrderLabel(unit){
    if (!unit) return "";
    const role = String(unit.role || "enemy");
    let label = `${unit.name} (${role})`;
    if ((role === "pc" || role === "ally") && Number.isFinite(Number(unit.hp))){
      label += ` ${Number(unit.hp)} HP`;
    }
    return label;
  }

  function showTurnOrderBubble(chip, unit){
    if (!activeTurnOrderBubbleEl){
      return;
    }
    if (!chip || !unit){
      activeTurnOrderBubbleEl.classList.remove("show");
      return;
    }
    activeTurnOrderBubbleEl.textContent = formatTurnOrderLabel(unit);
    activeTurnOrderBubbleEl.classList.add("show");
    const container = activeTurnOrderBubbleEl.offsetParent || activeTurnOrderEl;
    if (!container){
      return;
    }
    const containerRect = container.getBoundingClientRect();
    const chipRect = chip.getBoundingClientRect();
    const bubbleRect = activeTurnOrderBubbleEl.getBoundingClientRect();
    const left = chipRect.left - containerRect.left + (chipRect.width / 2);
    let top = chipRect.top - containerRect.top - bubbleRect.height - 8;
    if (top < 0){
      top = chipRect.bottom - containerRect.top + 8;
    }
    activeTurnOrderBubbleEl.style.left = `${left}px`;
    activeTurnOrderBubbleEl.style.top = `${top}px`;
  }

  function updateTurnOrder(){
    if (!activeTurnOrderEl){
      return;
    }
    const TURN_CHIP_NAME_MAX = 20;
    const formatTurnChipName = (name) => {
      const fullName = String(name ?? "");
      if (fullName.length <= TURN_CHIP_NAME_MAX){
        return fullName;
      }
      return `${fullName.slice(0, TURN_CHIP_NAME_MAX - 1).trimEnd()}…`;
    };
    const order = Array.isArray(state?.turn_order) ? state.turn_order : [];
    activeTurnOrderEl.innerHTML = "";
    if (!order.length){
      if (activeTurnOrderStatusEl){
        activeTurnOrderStatusEl.textContent = "";
      }
      if (activeTurnOrderBubbleEl){
        activeTurnOrderBubbleEl.classList.remove("show");
      }
      return;
    }
    const activeCid = state?.active_cid;
    const activeIndex = (activeCid === null || activeCid === undefined)
      ? -1
      : order.findIndex(cid => Number(cid) === Number(activeCid));
    const claimedIndex = (claimedCid === null || claimedCid === undefined)
      ? -1
      : order.findIndex(cid => Number(cid) === Number(claimedCid));
    const unitsByCid = new Map();
    if (Array.isArray(state?.units)){
      state.units.forEach((unit) => {
        if (unit && unit.cid !== undefined && unit.cid !== null){
          unitsByCid.set(Number(unit.cid), unit);
        }
      });
    }
    const chipByCid = new Map();
    order.forEach((cid, idx) => {
      const unit = unitsByCid.get(Number(cid));
      const chip = document.createElement("div");
      chip.className = "turn-chip";
      if (idx === claimedIndex){
        chip.classList.add("claimed");
      }
      if (idx === activeIndex){
        chip.classList.add("active");
      }
      chip.setAttribute("role", "button");
      chip.setAttribute("tabindex", "0");
      const unitName = unit?.name ? String(unit.name) : `#${cid}`;
      const truncatedUnitName = formatTurnChipName(unitName);
      chip.setAttribute("aria-label", `Turn ${idx + 1}: ${unitName}`);
      chip.setAttribute("data-full-name", unitName);
      chip.setAttribute("title", unitName);
      if (idx === claimedIndex){
        const claimedMarker = document.createElement("span");
        claimedMarker.className = "turn-chip-marker claimed-marker";
        claimedMarker.setAttribute("aria-hidden", "true");
        chip.appendChild(claimedMarker);
      }
      if (idx === activeIndex){
        const activeMarker = document.createElement("span");
        activeMarker.className = "turn-chip-marker active-marker";
        activeMarker.setAttribute("aria-hidden", "true");
        chip.appendChild(activeMarker);
      }
      const indexEl = document.createElement("span");
      indexEl.className = "turn-chip-index";
      indexEl.textContent = String(idx + 1);
      chip.appendChild(indexEl);
      const nameEl = document.createElement("span");
      nameEl.className = "turn-chip-name";
      nameEl.textContent = truncatedUnitName;
      nameEl.setAttribute("data-full-name", unitName);
      nameEl.setAttribute("title", unitName);
      chip.appendChild(nameEl);
      chip.addEventListener("click", () => {
        setSelectedTurnCid(Number(cid));
      });
      chip.addEventListener("keydown", (ev) => {
        if (ev.key === "Enter" || ev.key === " "){
          ev.preventDefault();
          setSelectedTurnCid(Number(cid));
        }
      });
      chip.addEventListener("mouseenter", () => {
        hoveredTurnCid = Number(cid);
        showTurnOrderBubble(chip, unit);
      });
      chip.addEventListener("mouseleave", () => {
        if (hoveredTurnCid === Number(cid)){
          hoveredTurnCid = null;
        }
        if (selectedTurnCid !== null && chipByCid.has(Number(selectedTurnCid))){
          const selectedChip = chipByCid.get(Number(selectedTurnCid));
          const selectedUnit = unitsByCid.get(Number(selectedTurnCid));
          showTurnOrderBubble(selectedChip, selectedUnit);
        } else {
          showTurnOrderBubble(null, null);
        }
      });
      activeTurnOrderEl.appendChild(chip);
      chipByCid.set(Number(cid), chip);
    });
    const setSelectedTurnCid = (cid) => {
      selectedTurnCid = cid;
      chipByCid.forEach((chip, key) => {
        chip.classList.toggle("selected", Number(key) === Number(cid));
      });
      if (hoveredTurnCid === null){
        showTurnOrderBubble(chipByCid.get(Number(cid)), unitsByCid.get(Number(cid)));
      }
    };
    const claimedUnit = claimedIndex >= 0 ? unitsByCid.get(Number(claimedCid)) : null;
    if (activeTurnOrderStatusEl){
      if (isMapView){
        const activeUnit = activeIndex >= 0 ? unitsByCid.get(Number(order[activeIndex])) : null;
        const roundLabel = Number.isFinite(Number(state?.round_num)) ? `Round ${state.round_num}` : "";
        const activeLabel = activeUnit?.name ? `Active: ${activeUnit.name}` : "Active: —";
        activeTurnOrderStatusEl.textContent = roundLabel ? `${roundLabel} · ${activeLabel}` : activeLabel;
      } else if (claimedIndex >= 0 && claimedUnit){
        activeTurnOrderStatusEl.textContent = `You are #${claimedIndex + 1}: ${claimedUnit.name}`;
      } else {
        activeTurnOrderStatusEl.textContent = "You are not in initiative.";
      }
    }
    let fallbackCid = selectedTurnCid;
    if (fallbackCid === null || !chipByCid.has(Number(fallbackCid))){
      if (claimedIndex >= 0){
        fallbackCid = Number(claimedCid);
      } else if (activeIndex >= 0){
        fallbackCid = Number(order[activeIndex]);
      } else {
        fallbackCid = Number(order[0]);
      }
    }
    setSelectedTurnCid(fallbackCid);
  }

  function normalizeActionEntry(entry, defaultType){
    if (!entry) return null;
    if (typeof entry === "string"){
      const name = String(entry || "").trim();
      if (!name) return null;
      return {name, description: "", type: defaultType};
    }
    if (typeof entry !== "object") return null;
    const name = normalizeTextValue(entry.name);
    if (!name) return null;
    const description = normalizeTextValue(entry.description) || "";
    const type = normalizeLowerValue(entry.type) || defaultType;
    return {name, description, type};
  }

  function normalizeActionList(entries, defaultType){
    const list = Array.isArray(entries) ? entries : [];
    return list
      .map((entry) => normalizeActionEntry(entry, defaultType))
      .filter(Boolean);
  }

  function isSpellActionEntry(entry){
    const name = normalizeLowerValue(entry?.name);
    return name === "magic" || name === "cast a spell" || name === "cast spell" || name === "spellcasting";
  }

  function populateActionSelect(selectEl, options, placeholder){
    if (!selectEl) return;
    const previousValue = selectEl.value;
    selectEl.textContent = "";
    const placeholderOption = document.createElement("option");
    placeholderOption.value = "";
    placeholderOption.textContent = placeholder;
    selectEl.appendChild(placeholderOption);
    const normalized = normalizeActionList(options, "action");
    normalized.forEach((item) => {
      const option = document.createElement("option");
      option.value = item.name;
      option.textContent = item.name;
      selectEl.appendChild(option);
    });
    if (previousValue && normalized.some((item) => item.name === previousValue)){
      selectEl.value = previousValue;
    } else {
      selectEl.value = "";
    }
  }

  function updateHud(){
    if (!state){ return; }
    const active = state.active_cid;
    const round = state.round_num;
    turnEl.textContent = (active === null) ? "Turn: (not started)" : `Round ${round}`;
    const myTurn = claimedCid && active !== null && String(active) === String(claimedCid);
    if (resetTurnBtn){
      resetTurnBtn.disabled = !myTurn;
    }
    if (claimedCid && state.units){
      const me = state.units.find(u => Number(u.cid) === Number(claimedCid));
      if (me){
        meEl.textContent = me.name;
        moveEl.textContent = `Move: ${me.move_remaining}/${me.move_total}`;
        actionEl.textContent = `Action: ${me.action_remaining ?? 0}`;
        bonusActionEl.textContent = `Bonus Action: ${me.bonus_action_remaining ?? 0}`;
        if (reactionEl){
          reactionEl.textContent = `Reaction: ${me.reaction_remaining ?? 0}`;
        }
        useActionBtn.disabled = Number(me.action_remaining || 0) <= 0;
        useBonusActionBtn.disabled = Number(me.bonus_action_remaining || 0) <= 0;
        populateActionSelect(actionSelectEl, me.actions, "None/Custom");
        populateActionSelect(bonusActionSelectEl, me.bonus_actions, "None/Custom");
        if (actionSelectEl){
          actionSelectEl.disabled = false;
        }
        if (bonusActionSelectEl){
          bonusActionSelectEl.disabled = false;
        }
        if (standUpBtn){
          standUpBtn.disabled = !(myTurn && me.is_prone);
        }
      } else {
        actionEl.textContent = "Action: —";
        bonusActionEl.textContent = "Bonus Action: —";
        if (reactionEl){
          reactionEl.textContent = "Reaction: —";
        }
        useActionBtn.disabled = true;
        useBonusActionBtn.disabled = true;
        populateActionSelect(actionSelectEl, [], "None/Custom");
        populateActionSelect(bonusActionSelectEl, [], "None/Custom");
        if (actionSelectEl){
          actionSelectEl.disabled = true;
        }
        if (bonusActionSelectEl){
          bonusActionSelectEl.disabled = true;
        }
        if (standUpBtn){
          standUpBtn.disabled = true;
        }
      }
    } else {
      actionEl.textContent = "Action: —";
      bonusActionEl.textContent = "Bonus Action: —";
      if (reactionEl){
        reactionEl.textContent = "Reaction: —";
      }
      useActionBtn.disabled = true;
      useBonusActionBtn.disabled = true;
      populateActionSelect(actionSelectEl, [], "None/Custom");
      populateActionSelect(bonusActionSelectEl, [], "None/Custom");
      if (actionSelectEl){
        actionSelectEl.disabled = true;
      }
      if (bonusActionSelectEl){
        bonusActionSelectEl.disabled = true;
      }
      if (standUpBtn){
        standUpBtn.disabled = true;
      }
    }
    updateTurnOrder();
    updateSpellPanelVisibility();
  }

  function showActionPicker(){
    if (!actionPickerModal) return;
    actionPickerModal.classList.add("show");
    actionPickerModal.setAttribute("aria-hidden", "false");
  }

  function hideActionPicker(){
    if (!actionPickerModal) return;
    actionPickerModal.classList.remove("show");
    actionPickerModal.setAttribute("aria-hidden", "true");
    if (actionPickerList){
      actionPickerList.textContent = "";
    }
  }

  function buildActionPickerItem(entry){
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "action-picker-item";
    const nameEl = document.createElement("div");
    nameEl.className = "action-picker-name";
    const spendLabel = entry.spend === "bonus" ? "Bonus Action" : "Action";
    nameEl.textContent = `${entry.name} (${spendLabel})`;
    btn.appendChild(nameEl);
    if (entry.description){
      const descEl = document.createElement("div");
      descEl.className = "action-picker-meta";
      descEl.textContent = entry.description;
      btn.appendChild(descEl);
    }
    btn.addEventListener("click", () => {
      hideActionPicker();
      if (isSpellActionEntry(entry)){
        pendingSpellActionType = entry.spend === "bonus" ? "bonus_action" : "action";
        setCastOverlayOpen(true);
        return;
      }
      if (!claimedCid) return;
      send({
        type: "perform_action",
        cid: Number(claimedCid),
        spend: entry.spend,
        action: entry.name,
      });
    });
    return btn;
  }

  function openActionPicker(mode){
    const unit = getClaimedUnit();
    if (!unit){
      localToast("Claim a character first, matey.");
      return;
    }
    if (!actionPickerList || !actionPickerTitle){
      return;
    }
    const actions = normalizeActionList(unit.actions, "action");
    const bonusActions = normalizeActionList(unit.bonus_actions, "bonus_action");
    const items = [];
    if (mode === "action"){
      actionPickerTitle.textContent = "Choose an Action";
      actions.forEach((entry) => items.push({...entry, spend: "action"}));
    } else if (mode === "bonus"){
      actionPickerTitle.textContent = "Choose a Bonus Action";
      bonusActions.forEach((entry) => items.push({...entry, spend: "bonus"}));
    } else {
      actionPickerTitle.textContent = "Choose Dash";
      const dashEntries = (list, spend) => {
        list.forEach((entry) => {
          if (normalizeLowerValue(entry.name) === "dash"){
            items.push({...entry, spend});
          }
        });
      };
      dashEntries(actions, "action");
      dashEntries(bonusActions, "bonus");
    }
    actionPickerList.textContent = "";
    if (!items.length){
      const empty = document.createElement("div");
      empty.className = "action-picker-meta";
      empty.textContent = "No available actions.";
      actionPickerList.appendChild(empty);
    } else {
      items.forEach((entry) => {
        actionPickerList.appendChild(buildActionPickerItem(entry));
      });
    }
    showActionPicker();
  }

  function hideTurnModal(){
    if (!turnModal) return;
    turnModal.classList.remove("show");
    turnModal.setAttribute("aria-hidden", "true");
  }

  function playTurnAlert(){
    turnAlertAudio.currentTime = 0;
    turnAlertAudio.play().catch((err) => {
      console.warn("Turn alert audio failed to play.", err);
    });
  }

  function playKoAlert(){
    koAlertAudio.currentTime = 0;
    koAlertAudio.play().catch((err) => {
      console.warn("KO audio failed to play.", err);
    });
  }

  function fireVibrate(){
    if (!lastVibrateSupported) return false;
    const didVibrate = vibrate([200, 120, 200]);
    if (!didVibrate){
      lastVibrateSupported = false;
      console.debug("Vibration blocked or unsupported.");
    }
    return didVibrate;
  }

  function handleUserGesture(){
    userHasInteracted = true;
    if (!audioUnlocked){
      turnAlertAudio.play().then(() => {
        turnAlertAudio.pause();
        turnAlertAudio.currentTime = 0;
        audioUnlocked = true;
        if (pendingTurnAlert){
          pendingTurnAlert = false;
          playTurnAlert();
        }
        if (pendingVibrate){
          fireVibrate();
          pendingVibrate = false;
        }
      }).catch((err) => {
        console.warn("Turn alert audio unlock failed.", err);
      });
      return;
    }
    if (pendingTurnAlert){
      pendingTurnAlert = false;
      playTurnAlert();
    }
    if (pendingVibrate){
      fireVibrate();
      pendingVibrate = false;
    }
  }

  function showTurnModal(){
    if (!turnModal) return;
    if (document.visibilityState === "hidden") return;
    turnModal.classList.add("show");
    turnModal.setAttribute("aria-hidden", "false");
    if (audioUnlocked){
      playTurnAlert();
    } else {
      pendingTurnAlert = true;
    }
    if (userHasInteracted || navigator.userActivation?.hasBeenActive){
      fireVibrate();
    } else {
      pendingVibrate = true;
    }
  }

  function maybeShowTurnAlert(){
    if (!state || !claimedCid) return;
    const activeCid = state.active_cid;
    const round = state.round_num;
    const isNowMyTurn = (activeCid !== null && String(activeCid) === String(claimedCid));
    const wasMyTurn = (lastActiveCid !== null && String(lastActiveCid) === String(claimedCid));
    const activeChanged = String(activeCid) !== String(lastActiveCid);
    const roundChanged = round !== lastTurnRound;
    if (isNowMyTurn && (!wasMyTurn || activeChanged || roundChanged)){
      showTurnModal();
    }
    lastActiveCid = activeCid;
    lastTurnRound = round;
  }

  function connect(){
    if (!wsUrl){
      setConn(false, "Disconnected");
      scheduleReconnect(1000);
      return;
    }
    try {
      ws = new WebSocket(wsUrl);
    } catch (err){
      console.warn("WebSocket connect failed.", err);
      setConn(false, "Disconnected");
      scheduleReconnect(1000);
      return;
    }
    ws.addEventListener("open", () => {
      reconnecting = false;
      setConn(true, "Connected");
      send({type:"grid_request"});
      send({type:"terrain_request"});
    });
    ws.addEventListener("close", (ev) => {
      const wasReconnect = reconnecting;
      reconnecting = false;
      const serverError = ev && ev.code === 1011;
      if (serverError){
        setConn(false, "Server error while preparing state.");
        scheduleReconnect(1000);
      } else if (wasReconnect){
        setConn(false, "Reconnecting…");
        scheduleReconnect(200);
      } else {
        setConn(false, "Disconnected");
        scheduleReconnect(1000);
      }
    });
    ws.addEventListener("message", (ev) => {
      let msg = null;
      try { msg = JSON.parse(ev.data); } catch(e){ return; }
      if (msg.type === "static_data"){
        // Merge static data into state (sent once on connection)
        if (!state){ state = {}; }
        if (msg.data && typeof msg.data === "object"){
          if (Array.isArray(msg.data.spell_presets)){
            state.spell_presets = msg.data.spell_presets;
            updateSpellPresetOptions(state.spell_presets);
          }
          if (msg.data.player_spells && typeof msg.data.player_spells === "object"){
            state.player_spells = msg.data.player_spells;
          }
          if (msg.data.player_profiles && typeof msg.data.player_profiles === "object"){
            state.player_profiles = msg.data.player_profiles;
          }
        }
      } else if (msg.type === "preset"){
        if (msg.preset && typeof msg.preset === "object"){
          applyGuiPreset(msg.preset, {persist: true});
          persistLocalPreset(msg.preset);
        } else {
          setPresetStatus("No preset saved.", 2500);
        }
      } else if (msg.type === "preset_saved"){
        setPresetStatus("Saved!");
      } else if (msg.type === "preset_error"){
        setPresetStatus(msg.error || "Preset error.", 2500);
      } else if (msg.type === "state"){
        const oldSpellPresets = state?.spell_presets;
        const oldPlayerSpells = state?.player_spells;
        const oldPlayerProfiles = state?.player_profiles;
        const oldGrid = state?.grid;
        const oldTerrain = state?.rough_terrain;
        const oldObstacles = state?.obstacles;
        state = (msg.state && typeof msg.state === "object") ? msg.state : {};
        // Preserve static data from previous state if not in new message
        // Only preserve if old values exist and new values are undefined (not just missing)
        if (!state.spell_presets && Array.isArray(oldSpellPresets)){
          state.spell_presets = oldSpellPresets;
        }
        if (!state.player_spells && oldPlayerSpells && typeof oldPlayerSpells === "object"){
          state.player_spells = oldPlayerSpells;
        }
        if (!state.player_profiles && oldPlayerProfiles && typeof oldPlayerProfiles === "object"){
          state.player_profiles = oldPlayerProfiles;
        }
        if (!state.grid && oldGrid){
          state.grid = oldGrid;
        }
        if (!state.rough_terrain && Array.isArray(oldTerrain)){
          state.rough_terrain = oldTerrain;
        }
        if (!state.obstacles && Array.isArray(oldObstacles)){
          state.obstacles = oldObstacles;
        }
        if (isMapView){
          claimedCid = null;
        }
        if (!Array.isArray(state.spell_presets)){
          state.spell_presets = [];
        }
        updateSpellPresetOptions(state.spell_presets);
        aoeDragOverrides.clear();
        syncSelectedAoe();
        lastPcList = msg.pcs || msg.claimable || [];
        updateWaitingOverlay();
        draw();
        updateHud();
        maybeShowTurnAlert();
        autoCenterOnJoin();
        if (!claimedCid){
          showNoOwnedPcToast(msg.pcs || msg.claimable || []);
        } else {
          const exists = (state.units || []).some(u => Number(u.cid) === Number(claimedCid));
            if (!exists){
              claimedCid = null;
              meEl.textContent = "(unclaimed)";
              shownNoOwnedToast = false;
              showNoOwnedPcToast(msg.pcs || msg.claimable || []);
              refreshSpellPresetOptions();
            }
        }
        refreshTurnAlertStatus();
      } else if (msg.type === "turn_update"){
        if (!state){ state = {}; }
        if ("active_cid" in msg){
          state.active_cid = msg.active_cid;
        }
        if ("round_num" in msg){
          state.round_num = msg.round_num;
        }
        if ("turn_order" in msg){
          state.turn_order = msg.turn_order;
        }
        updateHud();
        maybeShowTurnAlert();
        draw();
      } else if (msg.type === "units_snapshot"){
        if (!state){ state = {}; }
        state.units = Array.isArray(msg.units) ? msg.units : [];
        if (claimedCid){
          const exists = state.units.some(u => Number(u.cid) === Number(claimedCid));
          if (!exists){
            claimedCid = null;
            meEl.textContent = "(unclaimed)";
            shownNoOwnedToast = false;
            showNoOwnedPcToast(lastPcList || []);
            refreshSpellPresetOptions();
          }
        }
        updateHud();
        draw();
      } else if (msg.type === "unit_update"){
        const updates = Array.isArray(msg.updates) ? msg.updates : [];
        if (updates.length){
          applyUnitUpdates(updates);
          updateHud();
          draw();
        }
      } else if (msg.type === "force_claim"){
        if (isMapView) return;
        if (msg.cid !== null && msg.cid !== undefined){
          claimedCid = String(msg.cid);
          shownNoOwnedToast = false;
          autoCenterOnJoin();
          refreshSpellPresetOptions();
        }
        updateHud();
        noteEl.textContent = msg.text || "Assigned by the DM.";
        setTimeout(() => noteEl.textContent = "Tip: drag yer token", 2500);
        refreshTurnAlertStatus();
      } else if (msg.type === "force_unclaim"){
        if (isMapView) return;
        claimedCid = null;
        meEl.textContent = "(unclaimed)";
        shownNoOwnedToast = false;
        showNoOwnedPcToast(msg.pcs || lastPcList || []);
        refreshSpellPresetOptions();
        refreshTurnAlertStatus();
      } else if (msg.type === "toast"){
        noteEl.textContent = msg.text || "…";
        setTimeout(() => noteEl.textContent = "Tip: drag yer token", 2500);
      } else if (msg.type === "battle_log"){
        if (logContent){
          const lines = Array.isArray(msg.lines) ? msg.lines : [];
          logContent.textContent = lines.length ? lines.join("\n") : "No log entries yet.";
        }
        showLogModal();
      } else if (msg.type === "grid_update"){
        if (!state){ state = {}; }
        if ("grid" in msg){
          state.grid = msg.grid;
        }
        if (gridReady()){
          const cols = state.grid.cols;
          const rows = state.grid.rows;
          const gridChanged = cols !== lastGrid.cols || rows !== lastGrid.rows;
          if (gridChanged){
            fittedToGrid = false;
            lastGrid = {cols, rows};
          }
        }
        updateWaitingOverlay();
        lastGridVersion = msg.version ?? lastGridVersion;
        send({type:"grid_ack", version: msg.version});
        draw();
      } else if (msg.type === "terrain_update"){
        applyTerrainPayload(msg.terrain);
        updateWaitingOverlay();
        send({type:"terrain_ack", version: msg.version});
        draw();
      } else if (msg.type === "terrain_patch"){
        applyTerrainPatch(msg);
        updateWaitingOverlay();
        draw();
      } else if (msg.type === "aoe_patch"){
        applyAoePatch(msg);
        syncSelectedAoe();
        draw();
      } else if (msg.type === "play_audio"){
        if (!msg.audio) return;
        if (msg.audio !== "ko") return;
        if (!audioUnlocked) return;
        if (msg.cid !== undefined && msg.cid !== null){
          if (!claimedCid || String(msg.cid) !== String(claimedCid)) return;
        }
        playKoAlert();
      }
    });
  }

  // input
  function pointerPos(ev){
    const r = canvas.getBoundingClientRect();
    return {x: ev.clientX - r.left, y: ev.clientY - r.top};
  }

  function hitTestToken(p){
    if (!state || !state.units) return null;
    for (let i=state.units.length-1; i>=0; i--){
      const u = state.units[i];
      const {x,y} = gridToScreen(u.pos.col,u.pos.row);
      const r = Math.max(12, zoom*0.45);
      const dx = p.x - x, dy = p.y - y;
      if (dx*dx + dy*dy <= r*r){
        return u;
      }
    }
    return null;
  }

  function buildCellMap(tokens){
    const cellMap = new Map();
    tokens.forEach(u => {
      const key = `${u.pos.col},${u.pos.row}`;
      if (!cellMap.has(key)) cellMap.set(key, []);
      cellMap.get(key).push(u);
    });
    return cellMap;
  }

  function groupLabelFromTokens(arr){
    if (!arr || !arr.length) return "";
    const groupName = arr.find(a => a.group_name || a.group_label || a.group)
      ?.group_name
      ?? arr.find(a => a.group_label)?.group_label
      ?? arr.find(a => a.group)?.group;
    if (groupName) return groupName;
    const names = arr.map(a => a.name).filter(Boolean);
    if (!names.length) return `Group (${arr.length})`;
    const first = names[0];
    const allSame = names.every(n => n === first);
    if (allSame){
      return `${arr.length}x ${first}`;
    }
    if (showAllNames){
      return `Group (${arr.length}): ${names.join(", ")}`;
    }
    return `Group (${arr.length})`;
  }

  function setTokenTooltip(text, clientX, clientY){
    if (!tokenTooltip) return;
    if (!text){
      tokenTooltip.classList.remove("show");
      tokenTooltip.setAttribute("aria-hidden", "true");
      return;
    }
    const wrapRect = mapWrap?.getBoundingClientRect();
    if (!wrapRect) return;
    tokenTooltip.textContent = text;
    const pad = 12;
    const left = clientX - wrapRect.left + pad;
    const top = clientY - wrapRect.top + pad;
    tokenTooltip.style.left = `${left}px`;
    tokenTooltip.style.top = `${top}px`;
    tokenTooltip.classList.add("show");
    tokenTooltip.setAttribute("aria-hidden", "false");
  }

  function clampZoom(value){
    return Math.min(90, Math.max(12, value));
  }

  function zoomAt(newZoom, focusX, focusY){
    const preZoom = zoom;
    const nextZoom = clampZoom(newZoom);
    if (Math.abs(nextZoom - preZoom) < 0.01) return;
    const col = (focusX - panX) / preZoom;
    const row = (focusY - panY) / preZoom;
    zoom = nextZoom;
    panX = focusX - col * zoom;
    panY = focusY - row * zoom;
    draw();
  }

  const activePointers = new Map();
  let pinchState = null;

  function enforceLoginGate(){
    return false;
  }

  function startPinch(){
    if (activePointers.size < 2) return;
    const pts = Array.from(activePointers.values());
    const dx = pts[0].x - pts[1].x;
    const dy = pts[0].y - pts[1].y;
    const dist = Math.hypot(dx, dy);
    pinchState = {startDist: dist || 1, startZoom: zoom};
  }

  function updatePinch(){
    if (!pinchState || activePointers.size < 2) return;
    const pts = Array.from(activePointers.values());
    const midX = (pts[0].x + pts[1].x) / 2;
    const midY = (pts[0].y + pts[1].y) / 2;
    const dx = pts[0].x - pts[1].x;
    const dy = pts[0].y - pts[1].y;
    const dist = Math.hypot(dx, dy);
    if (pinchState.startDist <= 0) return;
    const scale = dist / pinchState.startDist;
    zoomAt(pinchState.startZoom * scale, midX, midY);
  }

  canvas.addEventListener("pointerdown", (ev) => {
    if (enforceLoginGate()) return;
    setTokenTooltip(null);
    canvas.setPointerCapture(ev.pointerId);
    const p = pointerPos(ev);
    activePointers.set(ev.pointerId, p);
    if (activePointers.size >= 2){
      dragging = null;
      draggingAoe = null;
      panning = null;
      startPinch();
      return;
    }
    if (measurementMode){
      setMeasurementPoint(p);
      return;
    }
    if (isMapView){
      if (!lockMap){
        panning = {x: p.x, y: p.y, panX, panY};
      }
      return;
    }

    // Try token hit
    const hit = hitTestToken(p);
    if (hit){
      // only drag own token
      if (!claimedCid || Number(hit.cid) !== Number(claimedCid)){
        send({type:"toast", text:"Arrr, that token ain’t yers."});
        return;
      }
      // only on your turn
      if (state.active_cid === null || Number(state.active_cid) !== Number(claimedCid)){
        send({type:"toast", text:"Not yer turn yet, matey."});
        return;
      }
      dragging = {cid: hit.cid, startX: p.x, startY: p.y, origCol: hit.pos.col, origRow: hit.pos.row};
      return;
    }
    const aoeHit = hitTestAoe(p);
    if (aoeHit){
      setSelectedAoe(aoeHit.aid);
      if (!claimedCid){
        clearAoeMoveMode();
        localToast("Claim a character first, matey.");
        return;
      }
      if (aoeHit.owner_cid !== null && aoeHit.owner_cid !== undefined
          && Number(aoeHit.owner_cid) !== Number(claimedCid)){
        clearAoeMoveMode();
        localToast("That spell be not yers.");
        return;
      }
      if (aoeHit.pinned){
        clearAoeMoveMode();
        localToast("That spell be pinned.");
        return;
      }
      if (aoeMoveModeAid !== null && Number(aoeMoveModeAid) !== Number(aoeHit.aid)){
        clearAoeMoveMode();
      }
      const now = Date.now();
      if (lastAoeTapAid !== null && Number(lastAoeTapAid) === Number(aoeHit.aid) && now - lastAoeTapAt <= AOE_DOUBLE_ACTION_MS){
        aoeMoveModeAid = Number(aoeHit.aid);
        lastAoeTapAid = null;
        lastAoeTapAt = 0;
      } else {
        lastAoeTapAid = Number(aoeHit.aid);
        lastAoeTapAt = now;
      }
      if (Number(aoeMoveModeAid) !== Number(aoeHit.aid)){
        localToast("Double-tap to move that spell.");
        return;
      }
      const movePerTurn = Number(aoeHit.move_per_turn_ft);
      const hasMoveLimit = Number.isFinite(movePerTurn) && movePerTurn > 0;
      const moveRemaining = Number.isFinite(Number(aoeHit.move_remaining_ft))
        ? Number(aoeHit.move_remaining_ft)
        : (hasMoveLimit ? movePerTurn : null);
      if (state?.active_cid === null || Number(state.active_cid) !== Number(claimedCid)){
        clearAoeMoveMode();
        localToast("Not yer turn yet, matey.");
        return;
      }
      if (hasMoveLimit){
        if (!Number.isFinite(moveRemaining) || moveRemaining <= 0){
          clearAoeMoveMode();
          localToast("That spell can't move any more this turn.");
          return;
        }
      }
      draggingAoe = {
        aid: aoeHit.aid,
        cx: aoeHit.cx,
        cy: aoeHit.cy,
        startCx: aoeHit.cx,
        startCy: aoeHit.cy,
        moveRemainingFt: moveRemaining,
        movePerTurnFt: hasMoveLimit ? movePerTurn : null,
      };
      return;
    }
    setSelectedAoe(null);
    clearAoeMoveMode();
    // else pan (if map not locked)
    if (!lockMap){
      panning = {x: p.x, y: p.y, panX, panY};
    }
  });

  canvas.addEventListener("pointermove", (ev) => {
    if (enforceLoginGate()) return;
    const p = pointerPos(ev);
    if (activePointers.has(ev.pointerId)){
      activePointers.set(ev.pointerId, p);
    }
    if (pinchState && activePointers.size >= 2){
      updatePinch();
      setTokenTooltip(null);
      return;
    }
    if (ev.pointerType === "touch"){
      setTokenTooltip(null);
      return;
    }
    if (dragging){
      // update local preview by shifting pan temporarily? simplest: draw ghost at pointer
      draw();
      // ghost
      ctx.save();
      ctx.globalAlpha = 0.85;
      ctx.beginPath();
      ctx.arc(p.x, p.y, Math.max(10, zoom*0.35), 0, Math.PI*2);
      ctx.fillStyle = "rgba(106,169,255,0.25)";
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(106,169,255,0.95)";
      ctx.stroke();
      ctx.restore();
      setTokenTooltip(null);
    } else if (draggingAoe){
      const g = screenToGridFloat(p.x, p.y);
      draggingAoe.cx = g.col;
      draggingAoe.cy = g.row;
      aoeDragOverrides.set(Number(draggingAoe.aid), {cx: g.col, cy: g.row});
      draw();
      setTokenTooltip(null);
    } else if (panning){
      panX = panning.panX + (p.x - panning.x);
      panY = panning.panY + (p.y - panning.y);
      draw();
      setTokenTooltip(null);
    } else if (measurementMode){
      setTokenTooltip(null);
    } else {
      const tokens = state?.units || [];
      const hit = hitTestToken(p);
      if (hit){
        const cellMap = buildCellMap(tokens);
        const key = `${hit.pos.col},${hit.pos.row}`;
        const group = cellMap.get(key) || [];
        const label = group.length > 1 ? groupLabelFromTokens(group) : (hit.name || "Unknown");
        setTokenTooltip(label, ev.clientX, ev.clientY);
      } else {
        setTokenTooltip(null);
      }
    }
  });

  canvas.addEventListener("pointerup", (ev) => {
    if (enforceLoginGate()) return;
    const p = pointerPos(ev);
    activePointers.delete(ev.pointerId);
    if (activePointers.size < 2){
      pinchState = null;
    }
    setTokenTooltip(null);
    dragging && (function(){
      const g = screenToGrid(p.x, p.y);
      send({type:"move", cid: Number(dragging.cid), to: {col: g.col, row: g.row}});
      dragging = null;
    })();
    draggingAoe && (function(){
      const g = screenToGridFloat(p.x, p.y);
      const aid = Number(draggingAoe.aid);
      const movePerTurn = Number(draggingAoe.movePerTurnFt);
      if (Number.isFinite(movePerTurn) && movePerTurn > 0){
        const feetPerSquare = Math.max(1, Number(state?.grid?.feet_per_square || 5));
        const dx = Number(g.col) - Number(draggingAoe.startCx);
        const dy = Number(g.row) - Number(draggingAoe.startCy);
        const distFt = Math.hypot(dx, dy) * feetPerSquare;
        const remaining = Number(draggingAoe.moveRemainingFt);
        if (!Number.isFinite(remaining) || distFt > remaining + 0.01){
          localToast(`That spell can only move ${Number.isFinite(remaining) ? remaining.toFixed(1) : 0} ft this turn.`);
          aoeDragOverrides.delete(aid);
          setLocalAoeCenter(aid, draggingAoe.startCx, draggingAoe.startCy);
          draggingAoe = null;
          draw();
          return;
        }
        const nextRemaining = Math.max(0, remaining - distFt);
        setLocalAoeMoveRemaining(aid, nextRemaining);
      }
      aoeDragOverrides.set(aid, {cx: g.col, cy: g.row});
      setLocalAoeCenter(aid, g.col, g.row);
      send({type:"aoe_move", aid: Number(draggingAoe.aid), to: {cx: g.col, cy: g.row}});
      draggingAoe = null;
      clearAoeMoveMode();
      draw();
    })();
    panning = null;
  });

  canvas.addEventListener("pointercancel", (ev) => {
    if (enforceLoginGate()) return;
    activePointers.delete(ev.pointerId);
    if (activePointers.size < 2){
      pinchState = null;
    }
    setTokenTooltip(null);
    if (draggingAoe){
      aoeDragOverrides.delete(Number(draggingAoe.aid));
      draggingAoe = null;
      draw();
    }
  });

  canvas.addEventListener("pointerleave", () => {
    setTokenTooltip(null);
  });

  canvas.addEventListener("wheel", (ev) => {
    if (enforceLoginGate()) return;
    if (pinchState) return;
    ev.preventDefault();
    const p = pointerPos(ev);
    const delta = ev.deltaY || 0;
    const factor = delta > 0 ? 0.9 : 1.1;
    zoomAt(zoom * factor, p.x, p.y);
  }, {passive: false});

  if (zoomInBtn){
    zoomInBtn.addEventListener("click", () => {
      if (enforceLoginGate()) return;
      const r = canvas.getBoundingClientRect();
      zoomAt(zoom + 4, r.width / 2, r.height / 2);
    });
  }
  if (zoomOutBtn){
    zoomOutBtn.addEventListener("click", () => {
      if (enforceLoginGate()) return;
      const r = canvas.getBoundingClientRect();
      zoomAt(zoom - 4, r.width / 2, r.height / 2);
    });
  }
  if (lockMapBtn){
    lockMapBtn.addEventListener("click", (ev) => {
      if (enforceLoginGate()) return;
      lockMap = !lockMap;
      ev.target.textContent = lockMap ? "Unlock Map" : "Lock Map";
    });
  }
  if (centerMapBtn){
    centerMapBtn.addEventListener("click", () => {
      if (enforceLoginGate()) return;
      if (!centerOnClaimed()){
        centerOnGridCenter();
      }
    });
  }
  if (measureToggle){
    measureToggle.addEventListener("click", () => {
      if (enforceLoginGate()) return;
      measurementMode = !measurementMode;
      updateMeasurementControls();
    });
  }
  if (measureClear){
    measureClear.addEventListener("click", () => {
      if (enforceLoginGate()) return;
      clearMeasurement();
    });
  }
  if (tokenColorModeBtn){
    tokenColorModeBtn.addEventListener("click", () => {
      if (enforceLoginGate()) return;
      openClaimedColorModal();
    });
  }

  if (tokenColorInput){
    tokenColorInput.addEventListener("input", (ev) => {
      updateTokenColorSwatch(ev.target.value);
    });
  }
  if (tokenColorConfirm){
    tokenColorConfirm.addEventListener("click", () => {
      const claimedUnit = getClaimedUnit();
      if (!claimedUnit){
        localToast("Claim a character first, matey.");
        closeColorModal();
        return;
      }
      pendingClaim = claimedUnit;
      const color = validateTokenColor(tokenColorInput ? tokenColorInput.value : "");
      if (!color) return;
      localStorage.setItem("inittracker_tokenColor", color);
      if (state?.units){
        const unit = state.units.find(u => Number(u.cid) === Number(pendingClaim.cid));
        if (unit){
          unit.token_color = color;
          draw();
        }
      }
      send({type:"set_color", cid: Number(pendingClaim.cid), color});
      meEl.textContent = pendingClaim.name;
      closeColorModal();
    });
  }
  if (tokenColorCancel){
    tokenColorCancel.addEventListener("click", () => {
      closeColorModal();
      showNoOwnedPcToast(lastPcList || []);
    });
  }

  let lastSpellPresetSignature = "";
  let cachedSpellPresets = [];
  let spellPresetBySlug = new Map();
  const normalizeSpellPresets = (presets) => Array.isArray(presets) ? presets.filter(p => p && typeof p === "object") : [];
  const formatSpellLevelLabel = (level) => {
    const num = Number(level);
    if (!Number.isFinite(num)) return "Unknown";
    if (num === 0) return "Cantrip";
    const suffix = num === 1 ? "st" : num === 2 ? "nd" : num === 3 ? "rd" : "th";
    return `${num}${suffix}`;
  };
  const formatListGroupLabel = (value) => String(value || "")
    .replace(/_/g, " ")
    .replace(/\\b\\w/g, (char) => char.toUpperCase());
  const normalizeTextValue = (value) => String(value || "").trim();
  const normalizeLowerValue = (value) => normalizeTextValue(value).toLowerCase();
  const getSpellKey = (value) => normalizeLowerValue(value);
  const getPresetSlug = (preset) => {
    const slug = normalizeTextValue(preset?.slug);
    if (slug) return slug;
    return normalizeLowerValue(preset?.name).replace(/\\s+/g, "-");
  };
  const AOE_SHAPES = new Set(["circle", "square", "line", "sphere", "cube", "cone", "cylinder", "wall"]);
  const isAoePreset = (preset) => {
    const shape = normalizeLowerValue(preset?.shape);
    return shape && AOE_SHAPES.has(shape);
  };
  const loadPreparedSpellFilterList = () => {
    const name = getClaimedPlayerName();
    if (!name) return null;
    const config = getSpellbookConfig(name);
    const cantrips = config.cantrips || [];
    if (!config.prepared.length && !cantrips.length) return null;
    const merged = new Set([
      ...config.prepared.map(normalizeTextValue),
      ...cantrips.map(normalizeTextValue),
    ]);
    return Array.from(merged).filter(Boolean);
  };
  const getPreparedSpellFilterSet = () => {
    if (!claimedCid) return new Set();
    const list = loadPreparedSpellFilterList();
    if (!list) return new Set();
    return new Set(list.map(getSpellKey));
  };
  const filterPresetsByKnownList = (presets, knownSpellSet) => {
    if (!knownSpellSet) return presets;
    return presets.filter((preset) => {
      const slug = getPresetSlug(preset);
      if (!slug) return false;
      return knownSpellSet.has(getSpellKey(slug));
    });
  };
  const getSpellListEntries = (lists) => {
    if (!lists || typeof lists !== "object") return [];
    const entries = [];
    Object.entries(lists).forEach(([group, values]) => {
      if (!Array.isArray(values)) return;
      values.forEach((value) => {
        const trimmed = normalizeTextValue(value);
        if (!trimmed) return;
        entries.push({group, value: trimmed});
      });
    });
    return entries;
  };
  const getPresetLevelNumber = (preset) => {
    const num = Number(preset?.level);
    return Number.isFinite(num) ? num : null;
  };
  const updateManualEntryBadge = (preset) => {
    if (!castManualEntryBadge) return;
    if (!preset){
      castManualEntryBadge.classList.remove("show");
      castManualEntryBadge.setAttribute("aria-hidden", "true");
      castManualEntryBadge.removeAttribute("title");
      castManualEntryBadge.removeAttribute("aria-label");
      return;
    }
    const reasons = [];
    const automation = normalizeLowerValue(preset.automation);
    if (automation === "partial" || automation === "manual"){
      reasons.push(`automation is ${automation}`);
    }
    if (!preset.shape){
      reasons.push("shape is missing");
    }
    if (preset.incomplete){
      const missing = Array.isArray(preset.incomplete_fields)
        ? preset.incomplete_fields.map((field) => String(field || "").trim()).filter(Boolean)
        : [];
      if (missing.length){
        reasons.push(`missing ${missing.join(", ")}`);
      } else {
        reasons.push("missing dimensions");
      }
    }
    if (reasons.length){
      const tooltip = `Manual entry required: ${reasons.join("; ")}.`;
      castManualEntryBadge.classList.add("show");
      castManualEntryBadge.setAttribute("aria-hidden", "false");
      castManualEntryBadge.title = tooltip;
      castManualEntryBadge.setAttribute("aria-label", tooltip);
    } else {
      castManualEntryBadge.classList.remove("show");
      castManualEntryBadge.setAttribute("aria-hidden", "true");
      castManualEntryBadge.removeAttribute("title");
      castManualEntryBadge.removeAttribute("aria-label");
    }
  };
  function getSelectedSpellPreset(){
    const name = normalizeTextValue(castPresetInput?.value);
    if (!name) return null;
    return cachedSpellPresets.find(preset => normalizeTextValue(preset.name) === name) || null;
  }
  function normalizeSpellActionType(value){
    const raw = normalizeLowerValue(value);
    // Order matters: keep bonus action/reaction checks before generic action.
    if (/\bbonus[\s\-_]*action\b/.test(raw)) return "bonus_action";
    if (/\breaction\b/.test(raw)) return "reaction";
    if (/\baction\b/.test(raw)) return "action";
    return "action";
  }
  function getSpellActionType(preset){
    if (!preset) return "action";
    const castingTime = normalizeTextValue(preset.casting_time || preset.castingTime);
    return normalizeSpellActionType(castingTime);
  }
  function unitHasMagicAction(unit, actionType){
    const actions = normalizeActionList(unit?.actions, "action");
    const bonusActions = normalizeActionList(unit?.bonus_actions, "bonus_action");
    if (actionType === "bonus_action"){
      return [...bonusActions, ...actions].some((entry) => isSpellActionEntry(entry));
    }
    return actions.some((entry) => isSpellActionEntry(entry));
  }
  function canSpendSpellAction(unit, actionType){
    if (!unit) return {ok: false, reason: "Claim a character first, matey."};
    const remaining = Number(unit.spell_cast_remaining || 0);
    if (remaining <= 0){
      return {ok: false, reason: "You already cast a spell this turn."};
    }
    if (actionType === "bonus_action"){
      if (!unitHasMagicAction(unit, actionType)){
        return {ok: false, reason: "No bonus-action spellcasting available."};
      }
      if (Number(unit.bonus_action_remaining || 0) <= 0){
        return {ok: false, reason: "No bonus actions left, matey."};
      }
      return {ok: true};
    }
    if (actionType === "reaction"){
      if (Number(unit.reaction_remaining || 0) <= 0){
        return {ok: false, reason: "No reactions left, matey."};
      }
      return {ok: true};
    }
    if (!unitHasMagicAction(unit, actionType)){
      return {ok: false, reason: "No spellcasting action available."};
    }
    if (Number(unit.action_remaining || 0) <= 0){
      return {ok: false, reason: "No actions left, matey."};
    }
    return {ok: true};
  }

  let spellLibraryRecords = [];
  let spellLibraryLoadPromise = null;
  let spellLibraryLoadError = "";
  let spellLibrarySearchTerm = "";
  let spellLibrarySortMode = "alpha";
  let spellLibraryPreviousFocus = null;
  let spellbookMode = "known";
  let spellbookSearchTerm = "";
  let spellbookSortMode = "alpha";
  let spellbookKnownEnabled = true;
  let spellbookKnownLimit = null;
  let spellbookPreparedLimit = null;
  let spellbookCantripsMax = null;
  let pendingKnownSet = new Set();
  let pendingPreparedSet = new Set();
  let pendingCantripsSet = new Set();
  let spellbookLeftSelection = new Set();
  let spellbookRightSelection = new Set();
  let spellbookPreviousFocus = null;
  let spellDetailPreviousFocus = null;
  let activeSpellDetailSlug = null;

  function getPlayerLevel(profile){
    const raw = profile?.leveling?.level ?? profile?.leveling?.total_level ?? profile?.leveling?.lvl;
    const value = Number(raw);
    return Number.isFinite(value) ? Math.max(0, Math.floor(value)) : 0;
  }

  function maxSpellLevelForCharacter(level){
    if (level >= 17) return 9;
    if (level >= 15) return 8;
    if (level >= 13) return 7;
    if (level >= 11) return 6;
    if (level >= 9) return 5;
    if (level >= 7) return 4;
    if (level >= 5) return 3;
    if (level >= 3) return 2;
    if (level >= 1) return 1;
    return 0;
  }

  function getPresetLevelBySlug(slug){
    const preset = spellPresetBySlug.get(getSpellKey(slug));
    return preset ? getPresetLevelNumber(preset) : null;
  }

  function sortSlugsByName(slugs){
    return slugs.slice().sort((a, b) => {
      const presetA = spellPresetBySlug.get(getSpellKey(a));
      const presetB = spellPresetBySlug.get(getSpellKey(b));
      const nameA = normalizeTextValue(presetA?.name || a);
      const nameB = normalizeTextValue(presetB?.name || b);
      return nameA.localeCompare(nameB);
    });
  }

  function getSpellbookSearchText(slug){
    const preset = spellPresetBySlug.get(getSpellKey(slug));
    const tags = Array.isArray(preset?.tags) ? preset.tags.filter(Boolean).join(" ") : "";
    return [
      preset?.name,
      slug,
      preset?.school,
      preset?.casting_time,
      preset?.range,
      tags,
    ].filter(Boolean).join(" ").toLowerCase();
  }

  function filterSpellbookSlugs(slugs){
    const query = spellbookSearchTerm.trim().toLowerCase();
    if (!query) return slugs.slice();
    return slugs.filter((slug) => getSpellbookSearchText(slug).includes(query));
  }

  function sortSpellbookSlugs(slugs){
    return slugs.slice().sort((a, b) => {
      const presetA = spellPresetBySlug.get(getSpellKey(a));
      const presetB = spellPresetBySlug.get(getSpellKey(b));
      const nameA = normalizeTextValue(presetA?.name || a);
      const nameB = normalizeTextValue(presetB?.name || b);
      if (spellbookSortMode === "level"){
        const levelA = Number.isFinite(getPresetLevelNumber(presetA)) ? getPresetLevelNumber(presetA) : 99;
        const levelB = Number.isFinite(getPresetLevelNumber(presetB)) ? getPresetLevelNumber(presetB) : 99;
        if (levelA !== levelB) return levelA - levelB;
      }
      return nameA.localeCompare(nameB);
    });
  }

  function getEligibleSpellSlugs(profile){
    const allowedLevel = maxSpellLevelForCharacter(getPlayerLevel(profile));
    const slugs = [];
    cachedSpellPresets.forEach((preset) => {
      const level = getPresetLevelNumber(preset);
      if (Number.isFinite(level) && level > allowedLevel){
        return;
      }
      const slug = getPresetSlug(preset);
      if (slug){
        slugs.push(slug);
      }
    });
    return sortSlugsByName(Array.from(new Set(slugs.map(normalizeTextValue).filter(Boolean))));
  }

  function getSpellLibraryDescription(data){
    if (!data || typeof data !== "object") return "";
    const text = data.text && typeof data.text === "object" ? data.text : null;
    const importRaw = data.import && typeof data.import === "object" ? data.import.raw : null;
    const summary = normalizeTextValue(text?.summary);
    if (summary) return summary;
    const rules = normalizeTextValue(text?.rules);
    if (rules) return rules;
    const description = normalizeTextValue(importRaw?.description);
    if (description) return description;
    return "";
  }

  function formatSpellLibraryLevel(level){
    const num = Number(level);
    if (!Number.isFinite(num)) return "Level ?";
    if (num === 0) return "Cantrip";
    return `Level ${num}`;
  }

  function formatSpellLibraryList(values){
    if (!Array.isArray(values) || !values.length) return "";
    return values.map((value) => formatListGroupLabel(value)).join(", ");
  }

  function buildSpellLibrarySearchText(record){
    const parts = [
      record.id,
      record.name,
      record.school,
      record.castingTime,
      record.range,
      record.duration,
      record.components,
      record.classes.join(" "),
      record.tags.join(" "),
      record.description,
    ];
    return parts.filter(Boolean).join(" ").toLowerCase();
  }

  function buildSpellLibraryRecord(entry){
    const parsed = entry && typeof entry === "object" ? entry.parsed : null;
    const data = parsed && typeof parsed === "object" ? parsed : null;
    const id = String(entry?.id || data?.id || "").trim();
    const name = typeof data?.name === "string" ? data.name : (id || "Unknown Spell");
    const level = Number.isFinite(data?.level) ? Number(data.level) : null;
    const classes = Array.isArray(data?.lists?.classes) ? data.lists.classes.filter(Boolean) : [];
    const tags = Array.isArray(data?.tags) ? data.tags.filter(Boolean) : [];
    const record = {
      id,
      name,
      level,
      classes,
      tags,
      school: normalizeTextValue(data?.school),
      castingTime: normalizeTextValue(data?.casting_time),
      range: normalizeTextValue(data?.range),
      duration: normalizeTextValue(data?.duration),
      components: normalizeTextValue(data?.components),
      ritual: data?.ritual,
      concentration: data?.concentration,
      description: getSpellLibraryDescription(data),
      color: normalizeHexColor(data?.color || ""),
      data,
      error: entry?.error,
    };
    record.searchText = buildSpellLibrarySearchText(record);
    return record;
  }

  async function loadSpellLibrary(){
    if (spellLibraryLoadPromise) return spellLibraryLoadPromise;
    spellLibraryLoadPromise = (async () => {
      if (spellLibraryStatus) spellLibraryStatus.textContent = "Loading spells…";
      let ids = [];
      let bulkRecords = null;
      try {
        const response = await fetch("/api/spells?details=true");
        const payload = await response.json();
        if (Array.isArray(payload?.ids)){
          ids = payload.ids;
        }
        if (Array.isArray(payload?.spells)){
          bulkRecords = payload.spells;
        }
        spellLibraryLoadError = "";
      } catch (err){
        spellLibraryLoadError = "Unable to load spells.";
        if (spellLibraryStatus) spellLibraryStatus.textContent = spellLibraryLoadError;
        return [];
      }
      let results = bulkRecords;
      if (!Array.isArray(results) || !results.length){
        results = await Promise.all(
          ids.map(async (spellId) => {
            try {
              const response = await fetch(`/api/spells/${encodeURIComponent(spellId)}`);
              if (!response.ok){
                throw new Error(`HTTP ${response.status}`);
              }
              return await response.json();
            } catch (err){
              return {id: spellId, raw: null, parsed: null, error: String(err)};
            }
          })
        );
      }
      spellLibraryRecords = results.map(buildSpellLibraryRecord);
      return spellLibraryRecords;
    })();
    return spellLibraryLoadPromise;
  }

  function renderSpellLibrary(){
    if (!spellLibraryList) return;
    const query = spellLibrarySearchTerm.trim().toLowerCase();
    let records = spellLibraryRecords;
    if (query){
      records = records.filter((record) => record.searchText.includes(query));
    }
    if (!records.length && spellLibraryLoadError){
      if (spellLibraryStatus) spellLibraryStatus.textContent = spellLibraryLoadError;
      spellLibraryList.innerHTML = "";
      return;
    }
    const sorted = records.slice().sort((a, b) => {
      if (spellLibrarySortMode === "level"){
        const levelA = Number.isFinite(a.level) ? a.level : 999;
        const levelB = Number.isFinite(b.level) ? b.level : 999;
        if (levelA !== levelB) return levelA - levelB;
      }
      return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
    });
    spellLibraryList.innerHTML = "";
    if (spellLibraryStatus){
      spellLibraryStatus.textContent = sorted.length
        ? `${sorted.length} spell${sorted.length === 1 ? "" : "s"}`
        : "No spells match that search.";
    }
    if (!sorted.length) return;
    const fragment = document.createDocumentFragment();
    sorted.forEach((record) => {
      const details = document.createElement("details");
      details.className = "spell-library-card";
      const summary = document.createElement("summary");
      summary.className = "spell-library-summary";
      const title = document.createElement("span");
      title.className = "spell-library-summary-title";
      title.textContent = record.name || record.id || "Unnamed Spell";
      const meta = document.createElement("span");
      meta.className = "spell-library-summary-meta";
      meta.textContent = formatSpellLibraryLevel(record.level);
      summary.appendChild(title);
      summary.appendChild(meta);
      details.appendChild(summary);

      const body = document.createElement("div");
      body.className = "spell-library-detail-body";
      if (record.error && !record.data){
        const errorText = document.createElement("div");
        errorText.className = "spell-library-detail-description";
        errorText.textContent = "Spell data unavailable.";
        body.appendChild(errorText);
        details.appendChild(body);
        fragment.appendChild(details);
        return;
      }

      const grid = document.createElement("div");
      grid.className = "spell-library-detail-grid";
      const addRow = (label, value) => {
        if (!value && value !== 0) return;
        const labelEl = document.createElement("div");
        labelEl.className = "spell-library-detail-label";
        labelEl.textContent = label;
        const valueEl = document.createElement("div");
        valueEl.className = "spell-library-detail-value";
        valueEl.textContent = String(value);
        grid.appendChild(labelEl);
        grid.appendChild(valueEl);
      };

      addRow("Level", formatSpellLevelLabel(record.level));
      addRow("School", record.school);
      addRow("Casting Time", record.castingTime);
      addRow("Range", record.range);
      addRow("Duration", record.duration);
      addRow("Components", record.components);
      addRow("Classes", formatSpellLibraryList(record.classes));
      addRow("Tags", formatSpellLibraryList(record.tags));
      addRow("Ritual", record.ritual === true ? "Yes" : record.ritual === false ? "No" : "");
      addRow("Concentration", record.concentration === true ? "Yes" : record.concentration === false ? "No" : "");
      body.appendChild(grid);

      if (record.description){
        const description = document.createElement("div");
        description.className = "spell-library-detail-description";
        description.textContent = record.description;
        body.appendChild(description);
      }

      const preset = spellPresetBySlug.get(getSpellKey(record.id))
        || cachedSpellPresets.find((entry) => normalizeLowerValue(entry?.name) === normalizeLowerValue(record.name));
      if (preset){
        const colorRow = document.createElement("div");
        colorRow.className = "spell-library-action-row";
        const colorWrap = document.createElement("div");
        colorWrap.className = "spell-library-color-row";
        const swatch = document.createElement("span");
        swatch.className = "spell-color-swatch";
        swatch.style.background = resolveSpellColor(preset.color);
        const colorLabel = document.createElement("span");
        colorLabel.className = "spell-library-detail-value";
        colorLabel.textContent = normalizeHexColor(preset.color || "") || "Default";
        colorWrap.appendChild(swatch);
        colorWrap.appendChild(colorLabel);
        const colorBtn = document.createElement("button");
        colorBtn.className = "btn";
        colorBtn.type = "button";
        colorBtn.textContent = "Edit Color";
        colorBtn.addEventListener("click", (event) => {
          event.stopPropagation();
          openSpellDetailOverlay(preset);
        });
        colorRow.appendChild(colorWrap);
        colorRow.appendChild(colorBtn);
        body.appendChild(colorRow);
      }

      details.appendChild(body);
      fragment.appendChild(details);
    });
    spellLibraryList.appendChild(fragment);
  }

  function openSpellLibraryOverlay(open){
    if (!spellLibraryOverlay) return;
    spellLibraryOverlay.classList.toggle("show", open);
    spellLibraryOverlay.setAttribute("aria-hidden", open ? "false" : "true");
    if (open){
      spellLibraryPreviousFocus = document.activeElement instanceof HTMLElement
        ? document.activeElement
        : null;
      if (spellLibrarySearchInput) spellLibrarySearchInput.value = spellLibrarySearchTerm;
      if (spellLibrarySortSelect) spellLibrarySortSelect.value = spellLibrarySortMode;
      loadSpellLibrary().then(() => renderSpellLibrary());
      if (spellLibrarySearchInput) spellLibrarySearchInput.focus();
    } else if (spellLibraryPreviousFocus){
      spellLibraryPreviousFocus.focus();
      spellLibraryPreviousFocus = null;
    }
  }

  function setSpellbookStatus(text){
    if (!spellbookStatus) return;
    spellbookStatus.textContent = text || "";
  }

  function toggleSpellbookSelection(slug, selectionSet){
    if (selectionSet.has(slug)){
      selectionSet.delete(slug);
    } else {
      selectionSet.add(slug);
    }
  }

  function renderSpellbookList(listEl, slugs, selectionSet, emptyLabel){
    if (!listEl) return;
    listEl.textContent = "";
    if (!slugs.length){
      const empty = document.createElement("div");
      empty.className = "spellbook-item";
      empty.textContent = emptyLabel || "No spells available.";
      empty.style.opacity = "0.6";
      listEl.appendChild(empty);
      return;
    }
    slugs.forEach((slug) => {
      const preset = spellPresetBySlug.get(getSpellKey(slug));
      const label = normalizeTextValue(preset?.name || slug);
      const level = getPresetLevelNumber(preset);
      const displayColor = resolveSpellColor(preset?.color);
      const item = document.createElement("button");
      item.type = "button";
      item.className = "spellbook-item";
      if (selectionSet.has(slug)){
        item.classList.add("selected");
        item.style.borderColor = displayColor;
        const highlight = rgbaFromHex(displayColor, 0.18);
        if (highlight){
          item.style.background = highlight;
        }
      }
      item.addEventListener("click", () => {
        toggleSpellbookSelection(slug, selectionSet);
        renderSpellbook();
      });
      const nameWrap = document.createElement("span");
      nameWrap.className = "spellbook-item-name";
      const colorDot = document.createElement("span");
      colorDot.className = "spellbook-color-dot";
      colorDot.style.background = displayColor;
      nameWrap.appendChild(colorDot);
      const nameSpan = document.createElement("span");
      nameSpan.textContent = label;
      nameWrap.appendChild(nameSpan);
      item.appendChild(nameWrap);
      const meta = document.createElement("small");
      if (Number.isFinite(level)){
        meta.textContent = level === 0 ? "Cantrip" : `Lv ${level}`;
      } else {
        meta.textContent = "Level ?";
      }
      item.appendChild(meta);
      listEl.appendChild(item);
    });
  }

  function resetSpellbookSelections(){
    spellbookLeftSelection = new Set();
    spellbookRightSelection = new Set();
  }

  function renderSpellbook(){
    const playerName = getClaimedPlayerName();
    const profile = playerName ? getPlayerProfile(playerName) : null;
    if (!profile){
      setSpellbookStatus("Claim a character to manage spells.");
      return;
    }
    if (spellbookKnownEnabledToggle){
      spellbookKnownEnabledToggle.checked = spellbookKnownEnabled;
    }
    if (spellbookTabKnown){
      spellbookTabKnown.disabled = !spellbookKnownEnabled;
      spellbookTabKnown.classList.toggle("accent", spellbookMode === "known");
    }
    if (spellbookTabPrepared){
      spellbookTabPrepared.classList.toggle("accent", spellbookMode === "prepared");
    }
    const eligibleSlugs = getEligibleSpellSlugs(profile);
    const rightSlugs = spellbookMode === "prepared"
      ? Array.from(pendingPreparedSet)
      : Array.from(new Set([...pendingKnownSet, ...pendingCantripsSet]));
    const rightSet = new Set(rightSlugs.map(getSpellKey));
    let leftSlugs = [];
    if (spellbookMode === "known"){
      leftSlugs = eligibleSlugs.filter((slug) => !rightSet.has(getSpellKey(slug)));
      if (spellbookLeftTitle) spellbookLeftTitle.textContent = "Eligible Spells";
      if (spellbookRightTitle) spellbookRightTitle.textContent = "Known & Cantrips";
    } else {
      if (spellbookKnownEnabled){
        const knownSlugs = sortSlugsByName(Array.from(new Set([...pendingKnownSet, ...pendingCantripsSet])));
        leftSlugs = knownSlugs.filter((slug) => !rightSet.has(getSpellKey(slug)));
        if (spellbookLeftTitle) spellbookLeftTitle.textContent = "Known & Cantrips";
      } else {
        leftSlugs = eligibleSlugs.filter((slug) => !rightSet.has(getSpellKey(slug)));
        if (spellbookLeftTitle) spellbookLeftTitle.textContent = "Eligible Spells";
      }
      if (spellbookRightTitle) spellbookRightTitle.textContent = "Prepared Spells";
    }
    const emptyLabel = spellbookSearchTerm.trim() ? "No spells match that search." : "No spells available.";
    const filteredLeft = filterSpellbookSlugs(leftSlugs);
    const filteredRight = filterSpellbookSlugs(rightSlugs);
    renderSpellbookList(spellbookLeftList, sortSpellbookSlugs(filteredLeft), spellbookLeftSelection, emptyLabel);
    renderSpellbookList(spellbookRightList, sortSpellbookSlugs(filteredRight), spellbookRightSelection, emptyLabel);
    const preparedCount = pendingPreparedSet.size;
    const preparedLimitLabel = Number.isFinite(spellbookPreparedLimit)
      ? `${preparedCount}/${spellbookPreparedLimit} prepared`
      : `${preparedCount} prepared`;
    const knownCount = pendingKnownSet.size;
    const knownLimitLabel = Number.isFinite(spellbookKnownLimit)
      ? `${knownCount}/${spellbookKnownLimit} known`
      : `${knownCount} known`;
    const cantripCount = pendingCantripsSet.size;
    const cantripLimitLabel = Number.isFinite(spellbookCantripsMax)
      ? `${cantripCount}/${spellbookCantripsMax} cantrips`
      : `${cantripCount} cantrips`;
    setSpellbookStatus(`${knownLimitLabel} · ${cantripLimitLabel} · ${preparedLimitLabel}`);
  }

  function openSpellbookOverlay(open){
    if (!spellbookOverlay) return;
    spellbookOverlay.classList.toggle("show", open);
    spellbookOverlay.setAttribute("aria-hidden", open ? "false" : "true");
    if (open){
      spellbookPreviousFocus = document.activeElement instanceof HTMLElement
        ? document.activeElement
        : null;
      const playerName = getClaimedPlayerName();
      const config = getSpellbookConfig(playerName);
      spellbookKnownEnabled = config.knownEnabled !== false;
      spellbookKnownLimit = config.knownLimit;
      spellbookPreparedLimit = config.max;
      spellbookCantripsMax = config.cantripsMax;
      pendingKnownSet = new Set(config.known.map(normalizeTextValue).filter(Boolean));
      pendingPreparedSet = new Set(config.prepared.map(normalizeTextValue).filter(Boolean));
      pendingCantripsSet = new Set(config.cantrips.map(normalizeTextValue).filter(Boolean));
      spellbookMode = spellbookKnownEnabled ? "known" : "prepared";
      resetSpellbookSelections();
      if (spellbookSearchInput) spellbookSearchInput.value = spellbookSearchTerm;
      if (spellbookSortSelect) spellbookSortSelect.value = spellbookSortMode;
      renderSpellbook();
      requestAnimationFrame(() => {
        spellbookBackBtn?.focus();
      });
    } else if (spellbookPreviousFocus){
      closeSpellDetailOverlay();
      spellbookPreviousFocus.focus();
      spellbookPreviousFocus = null;
    }
    updateModalOffsets();
    resize();
  }

  function applySpellbookAdd(){
    if (!spellbookLeftSelection.size) return;
    const additions = Array.from(spellbookLeftSelection);
    if (spellbookMode === "prepared"){
      additions.forEach((slug) => {
        if (pendingPreparedSet.has(slug)) return;
        const nextCount = pendingPreparedSet.size + 1;
        if (Number.isFinite(spellbookPreparedLimit) && nextCount > spellbookPreparedLimit){
          localToast(`Prepared spells limited to ${spellbookPreparedLimit}.`);
          return;
        }
        pendingPreparedSet.add(slug);
      });
    } else {
      additions.forEach((slug) => {
        const level = getPresetLevelBySlug(slug);
        if (level === 0){
          const nextCount = pendingCantripsSet.size + 1;
          if (Number.isFinite(spellbookCantripsMax) && nextCount > spellbookCantripsMax){
            localToast(`Cantrips limited to ${spellbookCantripsMax}.`);
            return;
          }
          pendingCantripsSet.add(slug);
        } else {
          if (!spellbookKnownEnabled){
            return;
          }
          const nextCount = pendingKnownSet.size + 1;
          if (Number.isFinite(spellbookKnownLimit) && nextCount > spellbookKnownLimit){
            localToast(`Known spells limited to ${spellbookKnownLimit}.`);
            return;
          }
          pendingKnownSet.add(slug);
        }
      });
    }
    resetSpellbookSelections();
    renderSpellbook();
  }

  function applySpellbookRemove(){
    if (!spellbookRightSelection.size) return;
    const removals = Array.from(spellbookRightSelection);
    if (spellbookMode === "prepared"){
      removals.forEach((slug) => {
        pendingPreparedSet.delete(slug);
      });
    } else {
      removals.forEach((slug) => {
        const level = getPresetLevelBySlug(slug);
        if (level === 0){
          pendingCantripsSet.delete(slug);
        } else {
          pendingKnownSet.delete(slug);
        }
      });
    }
    resetSpellbookSelections();
    renderSpellbook();
  }

  function showSpellbookConfirm(){
    if (!spellbookConfirmModal) return;
    const playerName = getClaimedPlayerName() || "player";
    const fileName = playerName.replace(/[^a-z0-9._-]+/gi, "-");
    if (spellbookConfirmText){
      spellbookConfirmText.textContent = `Overwrite players/${fileName}.yaml?`;
    }
    spellbookConfirmModal.classList.add("show");
    spellbookConfirmModal.setAttribute("aria-hidden", "false");
  }

  function hideSpellbookConfirm(){
    if (!spellbookConfirmModal) return;
    spellbookConfirmModal.classList.remove("show");
    spellbookConfirmModal.setAttribute("aria-hidden", "true");
  }

  async function saveSpellbookChanges(){
    const playerName = getClaimedPlayerName();
    if (!playerName){
      localToast("Claim a character first.");
      return;
    }
    const payload = {
      known_enabled: spellbookKnownEnabled,
      known_list: Array.from(pendingKnownSet),
      prepared_list: Array.from(pendingPreparedSet),
      cantrips_list: Array.from(pendingCantripsSet),
    };
    try {
      const response = await fetch(`/api/players/${encodeURIComponent(playerName)}/spellbook`, {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify(payload),
      });
      if (!response.ok){
        throw new Error(`Failed (${response.status})`);
      }
      const data = await response.json();
      if (data?.player && state?.player_profiles){
        state.player_profiles[data.player.name] = data.player;
      }
      localToast("Spellbook saved.");
      hideSpellbookConfirm();
      refreshSpellPresetOptions();
    } catch (err){
      console.warn("Failed to save spellbook.", err);
      localToast("Unable to save spellbook.");
    }
  }

  function setSpellDetailStatus(text){
    if (!spellDetailStatus) return;
    spellDetailStatus.textContent = text || "";
  }

  function updateSpellDetailColorInputs(color){
    const fallback = color || DEFAULT_SPELL_COLOR;
    if (spellDetailColorSwatch){
      spellDetailColorSwatch.style.background = fallback;
    }
    if (spellDetailColorInput){
      spellDetailColorInput.value = fallback;
    }
    if (spellDetailColorValue){
      spellDetailColorValue.value = color ? color.toUpperCase() : fallback.toUpperCase();
    }
  }

  async function saveSpellDetailColor(slug, color){
    if (!slug) return;
    setSpellDetailStatus("Saving color…");
    try {
      const response = await fetch(`/api/spells/${encodeURIComponent(slug)}/color`, {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({color}),
      });
      if (!response.ok){
        throw new Error(`Failed (${response.status})`);
      }
      const data = await response.json();
      const updatedColor = normalizeHexColor(data?.spell?.color || color) || color;
      const preset = spellPresetBySlug.get(getSpellKey(slug));
      if (preset){
        preset.color = updatedColor;
      }
      updateSpellPresetOptions(cachedSpellPresets);
      updateSpellPresetDetails(preset || null);
      if (spellDetailOverlay?.classList.contains("show")){
        renderSpellDetailOverlay(preset || null);
      }
      setSpellDetailStatus("Color saved.");
    } catch (err){
      console.warn("Failed to save spell color.", err);
      setSpellDetailStatus("Unable to save color.");
      localToast("Unable to save spell color.");
    }
  }

  function renderSpellDetailOverlay(preset){
    if (!spellDetailGrid || !spellDetailName || !spellDetailMeta) return;
    if (!preset){
      spellDetailName.textContent = "Spell";
      spellDetailMeta.textContent = "";
      spellDetailGrid.textContent = "";
      updateSpellDetailColorInputs("");
      setSpellDetailStatus("");
      return;
    }
    const name = normalizeTextValue(preset.name) || normalizeTextValue(preset.slug) || "Spell";
    const levelLabel = formatSpellLevelLabel(preset.level);
    const school = normalizeTextValue(preset.school) || "Unknown";
    spellDetailName.textContent = name;
    spellDetailMeta.textContent = `${levelLabel} · ${school}`;
    const color = normalizeHexColor(preset.color || "");
    const displayColor = resolveSpellColor(preset.color);
    updateSpellDetailColorInputs(displayColor || "");
    setSpellDetailStatus("");
    const fields = [
      {label: "Level", value: levelLabel},
      {label: "School", value: school},
    ];
    const optionalFields = buildOptionalSpellDetails(preset);
    spellDetailGrid.textContent = "";
    [...fields, ...optionalFields].forEach((field) => {
      if (!field || (!field.value && field.value !== 0)) return;
      const row = document.createElement("div");
      row.className = "spell-details-row";
      const label = document.createElement("span");
      label.className = "spell-details-label";
      label.textContent = field.label;
      const value = document.createElement("span");
      value.className = "spell-details-value";
      value.textContent = field.value || "—";
      row.appendChild(label);
      row.appendChild(value);
      spellDetailGrid.appendChild(row);
    });
  }

  function openSpellDetailOverlay(preset){
    if (!spellDetailOverlay) return;
    if (!preset){
      return;
    }
    activeSpellDetailSlug = getPresetSlug(preset);
    spellDetailOverlay.classList.add("show");
    spellDetailOverlay.setAttribute("aria-hidden", "false");
    spellDetailPreviousFocus = document.activeElement instanceof HTMLElement ? document.activeElement : null;
    if (spellDetailTitle){
      spellDetailTitle.textContent = normalizeTextValue(preset.name) || "Spell Details";
    }
    renderSpellDetailOverlay(preset);
    if (spellDetailBackBtn){
      spellDetailBackBtn.focus();
    }
  }

  function closeSpellDetailOverlay(){
    if (!spellDetailOverlay) return;
    spellDetailOverlay.classList.remove("show");
    spellDetailOverlay.setAttribute("aria-hidden", "true");
    activeSpellDetailSlug = null;
    if (spellDetailPreviousFocus){
      spellDetailPreviousFocus.focus();
      spellDetailPreviousFocus = null;
    }
  }

  function commitSpellDetailColor(raw){
    const color = normalizeHexColor(raw || "");
    if (!color){
      localToast("Pick a valid hex color, matey.");
      return;
    }
    updateSpellDetailColorInputs(color);
    if (activeSpellDetailSlug){
      saveSpellDetailColor(activeSpellDetailSlug, color);
    }
  }

  const updateSpellPresetDetails = (preset) => {
    if (!spellPresetDetails) return;
    if (!preset){
      spellPresetDetails.textContent = "Select a preset to see spell details.";
      updateManualEntryBadge(null);
      return;
    }
    updateManualEntryBadge(preset);
    const detailsGrid = document.createElement("div");
    detailsGrid.className = "spell-details-grid";
    const levelLabel = formatSpellLevelLabel(preset.level);
    const tags = Array.isArray(preset.tags) ? preset.tags.filter(Boolean) : [];
    const tagLabel = tags.length ? tags.join(", ") : "—";
    const castingTime = normalizeTextValue(preset.casting_time) || "—";
    const range = normalizeTextValue(preset.range) || "—";
    const ritual = preset.ritual === true ? "Yes" : preset.ritual === false ? "No" : "—";
    const concentration = preset.concentration === true ? "Yes" : preset.concentration === false ? "No" : "—";
    const color = normalizeHexColor(preset.color || "");
    const displayColor = resolveSpellColor(preset.color);
    const lists = getSpellListEntries(preset.lists);
    const listLabel = lists.length
      ? lists.map((entry) => `${formatListGroupLabel(entry.group)}: ${entry.value}`).join(" · ")
      : "—";
    const fields = [
      {label: "Level", value: levelLabel},
      {label: "School", value: normalizeTextValue(preset.school) || "—"},
      {label: "Tags", value: tagLabel},
      {label: "Casting", value: castingTime},
      {label: "Range", value: range},
      {label: "Ritual", value: ritual},
      {label: "Concentration", value: concentration},
      {label: "Lists", value: listLabel},
      {label: "Color", value: color || displayColor, color: displayColor},
    ];
    fields.forEach((field) => {
      const row = document.createElement("div");
      row.className = "spell-details-row";
      const label = document.createElement("span");
      label.className = "spell-details-label";
      label.textContent = field.label;
      const value = document.createElement("span");
      value.className = "spell-details-value";
      if (field.color){
        const swatch = document.createElement("span");
        swatch.className = "spell-color-swatch";
        swatch.style.background = field.color;
        value.appendChild(swatch);
        const text = document.createElement("span");
        text.textContent = ` ${field.value}`;
        value.appendChild(text);
      } else {
        value.textContent = field.value;
      }
      row.appendChild(label);
      row.appendChild(value);
      detailsGrid.appendChild(row);
    });
    spellPresetDetails.textContent = "";
    spellPresetDetails.appendChild(detailsGrid);
  };
  function formatSpellDamageLabel(preset){
    const base = preset?.default_damage ?? preset?.dice ?? "";
    const baseLabel = base !== null && base !== undefined && String(base).trim() ? String(base).trim() : "";
    const damageTypes = Array.isArray(preset?.damage_types)
      ? preset.damage_types.map((entry) => String(entry || "").trim()).filter(Boolean)
      : [];
    if (baseLabel && damageTypes.length){
      return `${baseLabel} (${damageTypes.join(", ")})`;
    }
    if (baseLabel) return baseLabel;
    if (damageTypes.length) return damageTypes.join(", ");
    return "";
  }
  function hasAoeShape(preset){
    if (!preset || typeof preset !== "object") return false;
    return Boolean(
      preset.shape ||
      preset.radius_ft ||
      preset.side_ft ||
      preset.length_ft ||
      preset.width_ft ||
      preset.angle_deg ||
      preset.height_ft ||
      preset.thickness_ft
    );
  }
  function buildOptionalSpellDetails(preset){
    if (!preset || typeof preset !== "object") return [];
    const tags = Array.isArray(preset.tags) ? preset.tags.filter(Boolean) : [];
    const lists = getSpellListEntries(preset.lists);
    const listLabel = lists.length
      ? lists.map((entry) => `${formatListGroupLabel(entry.group)}: ${entry.value}`).join(" · ")
      : "";
    const fields = [
      {label: "Casting Time", value: normalizeTextValue(preset.casting_time)},
      {label: "Range", value: normalizeTextValue(preset.range)},
      {label: "Ritual", value: preset.ritual === true ? "Yes" : preset.ritual === false ? "No" : ""},
      {label: "Concentration", value: preset.concentration === true ? "Yes" : preset.concentration === false ? "No" : ""},
      {label: "Tags", value: tags.length ? tags.join(", ") : ""},
      {label: "Lists", value: listLabel},
      {label: "Shape", value: normalizeTextValue(preset.shape)},
      {label: "Radius (ft)", value: Number.isFinite(Number(preset.radius_ft)) ? String(preset.radius_ft) : ""},
      {label: "Side (ft)", value: Number.isFinite(Number(preset.side_ft)) ? String(preset.side_ft) : ""},
      {label: "Length (ft)", value: Number.isFinite(Number(preset.length_ft)) ? String(preset.length_ft) : ""},
      {label: "Width (ft)", value: Number.isFinite(Number(preset.width_ft)) ? String(preset.width_ft) : ""},
      {label: "Angle (deg)", value: Number.isFinite(Number(preset.angle_deg)) ? String(preset.angle_deg) : ""},
      {label: "Height (ft)", value: Number.isFinite(Number(preset.height_ft)) ? String(preset.height_ft) : ""},
      {label: "Duration (turns)", value: Number.isFinite(Number(preset.duration_turns)) ? String(preset.duration_turns) : ""},
      {label: "Save", value: preset.save_type ? String(preset.save_type || "").toUpperCase() : ""},
      {label: "Save DC", value: Number.isFinite(Number(preset.save_dc)) ? String(preset.save_dc) : ""},
      {label: "Damage", value: formatSpellDamageLabel(preset)},
      {label: "Half on Save", value: preset.half_on_pass ? "Yes" : ""},
      {label: "Automation", value: normalizeTextValue(preset.automation)},
    ];
    return fields.filter((field) => field.value);
  }
  const updateSelectOptions = (selectEl, values) => {
    if (!selectEl) return;
    const currentValue = selectEl.value;
    selectEl.textContent = "";
    const placeholder = document.createElement("option");
    placeholder.value = "";
    placeholder.textContent = "Any";
    selectEl.appendChild(placeholder);
    values.forEach((value) => {
      const opt = document.createElement("option");
      opt.value = value;
      opt.textContent = value;
      selectEl.appendChild(opt);
    });
    if (currentValue && values.includes(currentValue)){
      selectEl.value = currentValue;
    } else {
      selectEl.value = "";
    }
  };
  const updateListFilterOptions = (listGroups) => {
    if (!castFilterListInput) return;
    const currentValue = castFilterListInput.value;
    castFilterListInput.textContent = "";
    const placeholder = document.createElement("option");
    placeholder.value = "";
    placeholder.textContent = "Any";
    castFilterListInput.appendChild(placeholder);
    Array.from(listGroups.entries()).forEach(([group, values]) => {
      const optgroup = document.createElement("optgroup");
      optgroup.label = formatListGroupLabel(group);
      Array.from(values).sort((a, b) => a.localeCompare(b)).forEach((value) => {
        const opt = document.createElement("option");
        opt.value = `${group}::${value}`;
        opt.textContent = value;
        optgroup.appendChild(opt);
      });
      castFilterListInput.appendChild(optgroup);
    });
    if (currentValue){
      castFilterListInput.value = currentValue;
      if (castFilterListInput.value !== currentValue){
        castFilterListInput.value = "";
      }
    }
  };
  const updateSpellFilterOptions = () => {
    const schools = new Set();
    const castingTimes = new Set();
    const ranges = new Set();
    const listGroups = new Map();
    cachedSpellPresets.filter(isAoePreset).forEach((preset) => {
      const school = normalizeTextValue(preset.school);
      if (school) schools.add(school);
      const castingTime = normalizeTextValue(preset.casting_time);
      if (castingTime) castingTimes.add(castingTime);
      const range = normalizeTextValue(preset.range);
      if (range) ranges.add(range);
      getSpellListEntries(preset.lists).forEach((entry) => {
        if (!listGroups.has(entry.group)){
          listGroups.set(entry.group, new Set());
        }
        listGroups.get(entry.group).add(entry.value);
      });
    });
    updateSelectOptions(castFilterSchoolInput, Array.from(schools).sort((a, b) => a.localeCompare(b)));
    updateSelectOptions(castFilterCastingTimeInput, Array.from(castingTimes).sort((a, b) => a.localeCompare(b)));
    updateSelectOptions(castFilterRangeInput, Array.from(ranges).sort((a, b) => a.localeCompare(b)));
    updateListFilterOptions(listGroups);
  };
  const getTagFilters = () => {
    if (!castFilterTagsInput) return [];
    const raw = normalizeLowerValue(castFilterTagsInput.value);
    if (!raw) return [];
    return raw.split(",").map(tag => tag.trim()).filter(Boolean);
  };
  const matchesSpellFilters = (preset) => {
    const levelFilter = castFilterLevelInput ? normalizeTextValue(castFilterLevelInput.value) : "";
    if (levelFilter){
      const levelNum = getPresetLevelNumber(preset);
      if (!Number.isFinite(levelNum) || levelNum !== Number(levelFilter)){
        return false;
      }
    }
    const schoolFilter = castFilterSchoolInput ? normalizeLowerValue(castFilterSchoolInput.value) : "";
    if (schoolFilter){
      if (normalizeLowerValue(preset.school) !== schoolFilter){
        return false;
      }
    }
    const castingTimeFilter = castFilterCastingTimeInput ? normalizeLowerValue(castFilterCastingTimeInput.value) : "";
    if (castingTimeFilter){
      if (!normalizeLowerValue(preset.casting_time).includes(castingTimeFilter)){
        return false;
      }
    }
    const rangeFilter = castFilterRangeInput ? normalizeLowerValue(castFilterRangeInput.value) : "";
    if (rangeFilter){
      if (!normalizeLowerValue(preset.range).includes(rangeFilter)){
        return false;
      }
    }
    const ritualFilter = castFilterRitualInput ? normalizeTextValue(castFilterRitualInput.value) : "";
    if (ritualFilter){
      const ritualValue = ritualFilter === "true";
      if (preset.ritual !== ritualValue){
        return false;
      }
    }
    const concentrationFilter = castFilterConcentrationInput ? normalizeTextValue(castFilterConcentrationInput.value) : "";
    if (concentrationFilter){
      const concentrationValue = concentrationFilter === "true";
      if (preset.concentration !== concentrationValue){
        return false;
      }
    }
    const listFilter = castFilterListInput ? normalizeTextValue(castFilterListInput.value) : "";
    if (listFilter){
      const [group, value] = listFilter.split("::");
      const listValues = preset.lists && typeof preset.lists === "object" ? preset.lists[group] : null;
      if (!Array.isArray(listValues) || !listValues.map(normalizeLowerValue).includes(normalizeLowerValue(value))){
        return false;
      }
    }
    const tagFilters = getTagFilters();
    if (tagFilters.length){
      const presetTags = Array.isArray(preset.tags) ? preset.tags.map(normalizeLowerValue) : [];
      const matchesAll = tagFilters.every(tag => presetTags.includes(tag));
      if (!matchesAll) return false;
    }
    return true;
  };
  const refreshSpellPresetOptions = () => {
    if (!castPresetInput) return;
    const currentValue = String(castPresetInput.value || "");
    castPresetInput.textContent = "";
    const aoePresets = cachedSpellPresets.filter(isAoePreset);
    if (!aoePresets.length){
      castPresetInput.disabled = true;
      const placeholder = document.createElement("option");
      placeholder.value = "";
      placeholder.textContent = "Presets unavailable";
      castPresetInput.appendChild(placeholder);
      castPresetInput.value = "";
      updateSpellPresetDetails(null);
      return;
    }
    castPresetInput.disabled = false;
    const blank = document.createElement("option");
    blank.value = "";
    blank.textContent = "Custom";
    castPresetInput.appendChild(blank);
    const preparedSpellSet = getPreparedSpellFilterSet();
    const filtered = filterPresetsByKnownList(aoePresets, preparedSpellSet)
      .filter(matchesSpellFilters);
    if (!filtered.length){
      const empty = document.createElement("option");
      empty.value = "";
      empty.textContent = "No spells match filters";
      empty.disabled = true;
      castPresetInput.appendChild(empty);
      castPresetInput.value = "";
      updateSpellPresetDetails(null);
      return;
    }
    const groups = new Map();
    filtered.forEach((preset) => {
      const level = getPresetLevelNumber(preset);
      const key = level === null ? "unknown" : String(level);
      if (!groups.has(key)){
        groups.set(key, []);
      }
      groups.get(key).push(preset);
    });
    const orderedLevels = [];
    for (let i = 0; i <= 9; i += 1){
      if (groups.has(String(i))){
        orderedLevels.push(String(i));
      }
    }
    if (groups.has("unknown")){
      orderedLevels.push("unknown");
    }
    orderedLevels.forEach((levelKey) => {
      const list = groups.get(levelKey) || [];
      list.sort((a, b) => normalizeTextValue(a.name).localeCompare(normalizeTextValue(b.name)));
      const optgroup = document.createElement("optgroup");
      optgroup.label = levelKey === "unknown"
        ? "Unknown Level"
        : formatSpellLevelLabel(Number(levelKey));
      list.forEach((preset) => {
        const name = normalizeTextValue(preset.name);
        if (!name) return;
        const opt = document.createElement("option");
        opt.value = name;
        opt.textContent = name;
        optgroup.appendChild(opt);
      });
      castPresetInput.appendChild(optgroup);
    });
    if (currentValue && filtered.some(p => normalizeTextValue(p.name) === currentValue)){
      castPresetInput.value = currentValue;
    } else {
      castPresetInput.value = "";
    }
    const selected = filtered.find(p => normalizeTextValue(p.name) === castPresetInput.value);
    updateSpellPresetDetails(selected || null);
  };
  const updateSpellPresetOptions = (presets) => {
    const list = normalizeSpellPresets(presets);
    const signature = JSON.stringify(list.map(p => [
      String(p.slug || ""),
      String(p.name || ""),
      String(p.shape || ""),
      String(p.level || ""),
      String(p.school || ""),
      String(p.casting_time || ""),
      String(p.range || ""),
      String(p.ritual || ""),
      String(p.concentration || ""),
      String(p.color || ""),
      JSON.stringify(p.tags || []),
      JSON.stringify(p.lists || {}),
    ]));
    if (signature === lastSpellPresetSignature){
      return;
    }
    lastSpellPresetSignature = signature;
    cachedSpellPresets = list;
    spellPresetBySlug = new Map();
    list.forEach((preset) => {
      const slug = getPresetSlug(preset);
      if (slug){
        spellPresetBySlug.set(getSpellKey(slug), preset);
      }
    });
    updateSpellFilterOptions();
    refreshSpellPresetOptions();
    if (spellbookOverlay?.classList.contains("show")){
      renderSpellbook();
    }
  };

  const registerSpellFilterListener = (input, useInputEvent = false) => {
    if (!input) return;
    const handler = () => refreshSpellPresetOptions();
    input.addEventListener("change", handler);
    if (useInputEvent){
      input.addEventListener("input", handler);
    }
  };
  registerSpellFilterListener(castFilterLevelInput);
  registerSpellFilterListener(castFilterSchoolInput);
  registerSpellFilterListener(castFilterTagsInput, true);
  registerSpellFilterListener(castFilterCastingTimeInput);
  registerSpellFilterListener(castFilterRangeInput);
  registerSpellFilterListener(castFilterRitualInput);
  registerSpellFilterListener(castFilterConcentrationInput);
  registerSpellFilterListener(castFilterListInput);

  const setCastFieldEnabled = (input, enabled) => {
    if (!input) return;
    input.disabled = !enabled;
    input.readOnly = !enabled;
  };

  const setCastFieldVisible = (field, visible) => {
    if (!field) return;
    field.style.display = visible ? "" : "none";
  };

  const updateCastShapeFields = () => {
    const shape = String(castShapeInput?.value || "").toLowerCase();
    const usesRadius = shape === "circle" || shape === "sphere" || shape === "cylinder";
    const usesSide = shape === "square" || shape === "cube";
    const usesLength = shape === "line" || shape === "cone" || shape === "wall";
    const usesWidth = shape === "line" || shape === "wall";
    const usesAngle = shape === "line" || shape === "cone" || shape === "wall";
    const usesOrient = shape === "line" || shape === "cone" || shape === "wall";
    const usesThickness = shape === "wall";
    const usesHeight = shape === "wall" || shape === "cylinder";
    setCastFieldVisible(castRadiusField, usesRadius);
    setCastFieldVisible(castSideField, usesSide);
    setCastFieldVisible(castLengthField, usesLength);
    setCastFieldVisible(castWidthField, usesWidth);
    setCastFieldVisible(castAngleField, usesAngle);
    setCastFieldVisible(castOrientField, usesOrient);
    setCastFieldVisible(castThicknessField, usesThickness);
    setCastFieldVisible(castHeightField, usesHeight);
    setCastFieldEnabled(castRadiusInput, usesRadius);
    setCastFieldEnabled(castSideInput, usesSide);
    setCastFieldEnabled(castLengthInput, usesLength);
    setCastFieldEnabled(castWidthInput, usesWidth);
    setCastFieldEnabled(castAngleInput, usesAngle);
    setCastFieldEnabled(castOrientInput, usesOrient);
    setCastFieldEnabled(castThicknessInput, usesThickness);
    setCastFieldEnabled(castHeightInput, usesHeight);
  };

  if (castShapeInput){
    castShapeInput.addEventListener("change", updateCastShapeFields);
    updateCastShapeFields();
  }

  const parseDiceSpec = (value) => {
    if (typeof value !== "string") return null;
    const raw = value.trim().toLowerCase();
    const match = raw.match(/^(\\d+)d(4|6|8|10|12)$/);
    if (!match) return null;
    const count = Number(match[1]);
    const sides = Number(match[2]);
    if (!Number.isFinite(count) || count <= 0) return null;
    return {count, sides};
  };

  const formatDiceSpec = (spec) => `${spec.count}d${spec.sides}`;

  const normalizeUpcastConfig = (upcast) => {
    if (!upcast || typeof upcast !== "object") return null;
    const baseLevel = Number(upcast.base_level);
    if (!Number.isFinite(baseLevel) || baseLevel < 0){
      console.warn("Invalid upcast base_level; ignoring upcast config.", upcast);
      return null;
    }
    const rawIncrements = Array.isArray(upcast.increments) ? upcast.increments : [];
    const increments = [];
    const slotAddDice = typeof upcast.add_per_slot_above === "string" ? upcast.add_per_slot_above : "";
    if (slotAddDice && parseDiceSpec(slotAddDice)){
      increments.push({
        levels_per_increment: 1,
        add_dice: slotAddDice,
      });
    }
    rawIncrements.forEach((entry) => {
      if (!entry || typeof entry !== "object"){
        console.warn("Invalid upcast increment entry; skipping.", entry);
        return;
      }
      const addDice = typeof entry.add_dice === "string" ? entry.add_dice : "";
      if (!parseDiceSpec(addDice)){
        console.warn("Invalid upcast add_dice; skipping.", entry);
        return;
      }
      const levelsPer = Number(entry.levels_per_increment);
      if (Number.isFinite(levelsPer) && levelsPer > 0){
        increments.push({
          levels_per_increment: levelsPer,
          add_dice: addDice,
        });
        return;
      }
      const levelThreshold = Number(entry.level);
      if (Number.isFinite(levelThreshold) && levelThreshold > baseLevel){
        increments.push({
          level: levelThreshold,
          add_dice: addDice,
        });
        return;
      }
      console.warn("Invalid upcast increment entry; skipping.", entry);
    });
    if (!increments.length){
      console.warn("Upcast increments contained no valid entries; ignoring upcast config.", upcast);
      return null;
    }
    return {base_level: baseLevel, increments};
  };

  const computeUpcastValues = (baseDice, baseDefaultDamage, upcastConfig, slotLevel) => {
    if (!upcastConfig || !Number.isFinite(slotLevel)) return {dice: baseDice, defaultDamage: baseDefaultDamage};
    const baseLevel = Number(upcastConfig.base_level);
    if (!Number.isFinite(baseLevel)) return {dice: baseDice, defaultDamage: baseDefaultDamage};
    const deltaLevels = Math.floor(slotLevel - baseLevel);
    if (deltaLevels <= 0) return {dice: baseDice, defaultDamage: baseDefaultDamage};
    const baseDiceSpec = parseDiceSpec(baseDice) || parseDiceSpec(baseDefaultDamage);
    let totalDiceSpec = baseDiceSpec ? {count: baseDiceSpec.count, sides: baseDiceSpec.sides} : null;
    let applied = false;
    (upcastConfig.increments || []).forEach((inc) => {
      const addDiceSpec = parseDiceSpec(inc.add_dice);
      if (!addDiceSpec) return;
      let steps = 0;
      const levelsPer = Number(inc.levels_per_increment);
      if (Number.isFinite(levelsPer) && levelsPer > 0){
        steps = Math.floor(deltaLevels / levelsPer);
      } else {
        const levelThreshold = Number(inc.level);
        if (Number.isFinite(levelThreshold) && slotLevel >= levelThreshold){
          steps = 1;
        }
      }
      if (steps <= 0) return;
      const addCount = addDiceSpec.count * steps;
      if (!totalDiceSpec){
        totalDiceSpec = {count: addCount, sides: addDiceSpec.sides};
        applied = true;
        return;
      }
      if (totalDiceSpec.sides !== addDiceSpec.sides){
        console.warn("Upcast dice sides mismatch; skipping increment.", inc);
        return;
      }
      totalDiceSpec.count += addCount;
      applied = true;
    });
    const dice = totalDiceSpec ? formatDiceSpec(totalDiceSpec) : baseDice;
    let defaultDamage = baseDefaultDamage;
    if (applied){
      const defaultDamageDice = parseDiceSpec(baseDefaultDamage);
      if (defaultDamageDice || baseDefaultDamage === null || baseDefaultDamage === ""){
        defaultDamage = dice;
      }
    }
    return {dice, defaultDamage};
  };

  const castDamageTypes = new Set();
  let castDurationTurns = null;
  let castOverTime = null;
  let castMovePerTurnFt = null;
  let castTriggerOnStartOrEnter = null;
  let castPersistent = null;
  let castPinnedDefault = null;
  let castUpcastConfig = null;
  let castBaseDice = null;
  let castBaseDefaultDamage = null;
  const setCastDamageTypes = (types) => {
    castDamageTypes.clear();
    if (Array.isArray(types)){
      types.forEach((entry) => {
        const dtype = String(entry || "").trim();
        if (dtype){
          castDamageTypes.add(dtype);
        }
      });
    }
    renderCastDamageTypes();
  };
  const renderCastDamageTypes = () => {
    if (!castDamageTypeList) return;
    castDamageTypeList.textContent = "";
    for (const dtype of castDamageTypes){
      const chip = document.createElement("span");
      chip.className = "chip damage-type-chip";
      const label = document.createElement("span");
      label.textContent = dtype;
      const removeBtn = document.createElement("button");
      removeBtn.type = "button";
      removeBtn.setAttribute("aria-label", `Remove ${dtype}`);
      removeBtn.textContent = "×";
      removeBtn.addEventListener("click", () => {
        castDamageTypes.delete(dtype);
        renderCastDamageTypes();
      });
      chip.appendChild(label);
      chip.appendChild(removeBtn);
      castDamageTypeList.appendChild(chip);
    }
  };
  const addCastDamageType = (value) => {
    const dtype = String(value || "").trim();
    if (!dtype){
      localToast("Choose a damage type first, matey.");
      return;
    }
    if (castDamageTypes.has(dtype)){
      localToast("That damage type be added already.");
      return;
    }
    castDamageTypes.add(dtype);
    renderCastDamageTypes();
  };

  const applySpellPreset = (preset) => {
    if (!preset || typeof preset !== "object") return;
    if (castNameInput && preset.name){
      castNameInput.value = String(preset.name || "");
    }
    if (castShapeInput){
      castShapeInput.value = preset.shape ? String(preset.shape || "").toLowerCase() : "";
    }
    updateCastShapeFields();
    if (castRadiusInput){
      castRadiusInput.value = Number.isFinite(Number(preset.radius_ft)) ? Number(preset.radius_ft) : "";
    }
    if (castSideInput){
      castSideInput.value = Number.isFinite(Number(preset.side_ft)) ? Number(preset.side_ft) : "";
    }
    if (castLengthInput){
      castLengthInput.value = Number.isFinite(Number(preset.length_ft)) ? Number(preset.length_ft) : "";
    }
    if (castWidthInput){
      castWidthInput.value = Number.isFinite(Number(preset.width_ft)) ? Number(preset.width_ft) : "";
    }
    if (castAngleInput){
      castAngleInput.value = Number.isFinite(Number(preset.angle_deg)) ? Number(preset.angle_deg) : "";
    }
    if (castOrientInput){
      castOrientInput.value = preset.orient ? String(preset.orient || "").toLowerCase() : "vertical";
    }
    if (castThicknessInput){
      castThicknessInput.value = Number.isFinite(Number(preset.thickness_ft)) ? Number(preset.thickness_ft) : "";
    }
    if (castHeightInput){
      castHeightInput.value = Number.isFinite(Number(preset.height_ft)) ? Number(preset.height_ft) : "";
    }
    if (castDcTypeInput){
      castDcTypeInput.value = preset.save_type ? String(preset.save_type || "").toLowerCase() : "";
    }
    if (castDcValueInput){
      const presetDc = Number(preset.save_dc);
      castDcValueInput.value = Number.isFinite(presetDc) ? Number(presetDc) : "";
      if (!Number.isFinite(presetDc)){
        applyDefaultSpellSaveDc();
      }
    }
    if (castDefaultDamageInput){
      const defaultDamage = preset.default_damage;
      castDefaultDamageInput.value = defaultDamage !== undefined && defaultDamage !== null ? String(defaultDamage) : "";
      castBaseDefaultDamage = defaultDamage !== undefined && defaultDamage !== null ? String(defaultDamage) : "";
    }
    if (castDiceInput){
      const dice = preset.dice;
      castDiceInput.value = dice !== undefined && dice !== null ? String(dice) : "";
      castBaseDice = dice !== undefined && dice !== null ? String(dice) : "";
    }
    if (castColorInput){
      castColorInput.value = normalizeHexColor(preset.color || "") || DEFAULT_SPELL_COLOR;
    }
    setCastDamageTypes(preset.damage_types);
    if (Number.isFinite(Number(preset.duration_turns))){
      castDurationTurns = Number(preset.duration_turns);
    } else {
      castDurationTurns = null;
    }
    if (typeof preset.over_time === "boolean"){
      castOverTime = preset.over_time;
    } else {
      castOverTime = null;
    }
    const movePerTurn = Number(preset.move_per_turn_ft);
    if (Number.isFinite(movePerTurn)){
      castMovePerTurnFt = movePerTurn;
    } else {
      castMovePerTurnFt = null;
    }
    if (preset.trigger_on_start_or_enter){
      castTriggerOnStartOrEnter = String(preset.trigger_on_start_or_enter || "").toLowerCase();
    } else {
      castTriggerOnStartOrEnter = null;
    }
    if (typeof preset.persistent === "boolean"){
      castPersistent = preset.persistent;
    } else {
      castPersistent = null;
    }
    if (typeof preset.pinned_default === "boolean"){
      castPinnedDefault = preset.pinned_default;
    } else {
      castPinnedDefault = null;
    }
    castUpcastConfig = normalizeUpcastConfig(preset.upcast);
    if (castSlotLevelInput){
      if (castUpcastConfig){
        castSlotLevelInput.disabled = false;
        castSlotLevelInput.readOnly = false;
        castSlotLevelInput.value = Number.isFinite(Number(castUpcastConfig.base_level))
          ? String(castUpcastConfig.base_level)
          : "";
      } else {
        castSlotLevelInput.value = "";
        castSlotLevelInput.disabled = true;
        castSlotLevelInput.readOnly = true;
      }
    }
    const slotLevelValue = Number(castSlotLevelInput?.value);
    const upcastValues = computeUpcastValues(castBaseDice, castBaseDefaultDamage, castUpcastConfig, slotLevelValue);
    if (castDiceInput && upcastValues.dice !== undefined && upcastValues.dice !== null){
      castDiceInput.value = String(upcastValues.dice || "");
    }
    if (castDefaultDamageInput && upcastValues.defaultDamage !== undefined && upcastValues.defaultDamage !== null){
      castDefaultDamageInput.value = String(upcastValues.defaultDamage || "");
    }
  };

  const updateUpcastFields = () => {
    if (!castUpcastConfig) return;
    const slotLevelValue = Number(castSlotLevelInput?.value);
    const upcastValues = computeUpcastValues(castBaseDice, castBaseDefaultDamage, castUpcastConfig, slotLevelValue);
    if (castDiceInput && upcastValues.dice !== undefined && upcastValues.dice !== null){
      castDiceInput.value = String(upcastValues.dice || "");
    }
    if (castDefaultDamageInput && upcastValues.defaultDamage !== undefined && upcastValues.defaultDamage !== null){
      castDefaultDamageInput.value = String(upcastValues.defaultDamage || "");
    }
  };

  if (castPresetInput){
    castPresetInput.addEventListener("change", () => {
      const name = String(castPresetInput.value || "").trim();
      if (!name){
        castDurationTurns = null;
        castOverTime = null;
        castMovePerTurnFt = null;
        castTriggerOnStartOrEnter = null;
        castPersistent = null;
        castPinnedDefault = null;
        castUpcastConfig = null;
        castBaseDice = null;
        castBaseDefaultDamage = null;
        if (castDefaultDamageInput){
          castDefaultDamageInput.value = "";
        }
        if (castDiceInput){
          castDiceInput.value = "";
        }
        if (castDcValueInput){
          castDcValueInput.value = "";
          applyDefaultSpellSaveDc();
        }
        if (castSlotLevelInput){
          castSlotLevelInput.value = "";
          castSlotLevelInput.disabled = true;
          castSlotLevelInput.readOnly = true;
        }
        updateSpellPresetDetails(null);
        return;
      }
      const preset = cachedSpellPresets.find(p => String(p.name || "") === name);
      updateSpellPresetDetails(preset || null);
      applySpellPreset(preset);
    });
  }

  if (castSlotLevelInput){
    castSlotLevelInput.addEventListener("input", () => {
      updateUpcastFields();
    });
  }

  if (castAddDamageTypeBtn){
    castAddDamageTypeBtn.addEventListener("click", () => {
      addCastDamageType(castDamageTypeInput?.value || "");
    });
  }

  if (castForm){
    castForm.addEventListener("submit", (ev) => {
      ev.preventDefault();
      if (!claimedCid){
        localToast("Claim a character first, matey.");
        return;
      }
      if (!state || !gridReady()){
        localToast("Map not ready yet, matey.");
        return;
      }
      const preset = getSelectedSpellPreset();
      const spellActionType = getSpellActionType(preset);
      const actionType = pendingSpellActionType || spellActionType;
      if (pendingSpellActionType && pendingSpellActionType !== spellActionType){
        const expectedLabel = spellActionType === "bonus_action" ? "bonus action" : spellActionType;
        localToast(`That spell uses a ${expectedLabel}.`);
        return;
      }
      pendingSpellActionType = null;
      const unit = getClaimedUnit();
      const actionCheck = canSpendSpellAction(unit, actionType);
      if (!actionCheck.ok){
        localToast(actionCheck.reason || "You can't cast right now.");
        return;
      }
      const actionLabel = actionType === "bonus_action" ? "bonus action" : actionType;
      const spellName = normalizeTextValue(castNameInput?.value) || "this spell";
      if (!confirm(`Cast ${spellName} using your ${actionLabel}?`)){
        return;
      }
      const shape = String(castShapeInput?.value || "").toLowerCase();
      if (!shape){
        localToast("Pick a spell shape first, matey.");
        return;
      }
      const parsePositive = (value) => {
        const num = parseFloat(value || "");
        return Number.isFinite(num) && num > 0 ? num : null;
      };
      const parseNonnegative = (value) => {
        const num = parseFloat(value || "");
        return Number.isFinite(num) && num >= 0 ? num : null;
      };
      const radiusFt = parsePositive(castRadiusInput?.value);
      const sideFt = parsePositive(castSideInput?.value);
      const lengthFt = parsePositive(castLengthInput?.value);
      const widthFt = parsePositive(castWidthInput?.value);
      const angleRaw = String(castAngleInput?.value || "").trim();
      const angleDeg = angleRaw ? parseNonnegative(castAngleInput?.value) : null;
      const widthRaw = String(castWidthInput?.value || "").trim();
      const thicknessFt = parsePositive(castThicknessInput?.value);
      const thicknessRaw = String(castThicknessInput?.value || "").trim();
      const heightFt = parsePositive(castHeightInput?.value);
      const heightRaw = String(castHeightInput?.value || "").trim();
      const orientValue = String(castOrientInput?.value || "vertical").toLowerCase();
      const orient = orientValue === "horizontal" ? "horizontal" : "vertical";
      if (shape === "circle" && radiusFt === null){
        localToast("Enter a valid radius, matey.");
        return;
      }
      if ((shape === "sphere" || shape === "cylinder") && radiusFt === null){
        localToast("Enter a valid radius, matey.");
        return;
      }
      if (shape === "cylinder" && heightRaw && heightFt === null){
        localToast("Enter a valid height, matey.");
        return;
      }
      if (shape === "square" && sideFt === null){
        localToast("Enter a valid side length, matey.");
        return;
      }
      if (shape === "cube" && sideFt === null){
        localToast("Enter a valid side length, matey.");
        return;
      }
      if (shape === "line" && (lengthFt === null || widthFt === null)){
        localToast("Enter a valid line size, matey.");
        return;
      }
      if (shape === "cone" && lengthFt === null){
        localToast("Enter a valid cone length, matey.");
        return;
      }
      if (shape === "cone" && angleRaw && (angleDeg === null || angleDeg <= 0)){
        localToast("Enter a valid cone angle, matey.");
        return;
      }
      if ((shape === "line" || shape === "wall") && angleRaw && angleDeg === null){
        localToast("Enter a valid angle, matey.");
        return;
      }
      if (shape === "wall" && widthRaw && widthFt === null){
        localToast("Enter a valid wall width, matey.");
        return;
      }
      if (shape === "wall" && thicknessRaw && thicknessFt === null){
        localToast("Enter a valid wall thickness, matey.");
        return;
      }
      if (shape === "wall" && heightRaw && heightFt === null){
        localToast("Enter a valid wall height, matey.");
        return;
      }
      if (shape === "wall"){
        if (lengthFt === null){
          localToast("Enter a valid wall length, matey.");
          return;
        }
        if (widthFt === null && (thicknessFt === null || heightFt === null)){
          localToast("Enter a valid wall thickness and height (or width), matey.");
          return;
        }
      }
      const dcType = String(castDcTypeInput?.value || "").trim().toLowerCase();
      const dcValue = parseInt(castDcValueInput?.value || "", 10);
      const damageTypes = Array.from(castDamageTypes);
      if (!damageTypes.length){
        const fallbackType = String(castDamageTypeInput?.value || "").trim();
        if (fallbackType){
          damageTypes.push(fallbackType);
        }
      }
      const damageType = damageTypes.length === 1 ? damageTypes[0] : "";
      const name = String(castNameInput?.value || "").trim();
      const color = normalizeHexColor(castColorInput?.value || "") || null;
      let defaultDamage = String(castDefaultDamageInput?.value || "").trim();
      let dice = String(castDiceInput?.value || "").trim();
      if (castUpcastConfig){
        const slotLevelValue = Number(castSlotLevelInput?.value);
        const upcastValues = computeUpcastValues(
          castBaseDice || dice,
          castBaseDefaultDamage || defaultDamage,
          castUpcastConfig,
          slotLevelValue
        );
        if (upcastValues.dice !== undefined && upcastValues.dice !== null){
          dice = String(upcastValues.dice || "");
        }
        if (upcastValues.defaultDamage !== undefined && upcastValues.defaultDamage !== null){
          defaultDamage = String(upcastValues.defaultDamage || "");
        }
      }
      const center = defaultAoeCenter();
      if (shape !== "line"){
        const caster = getClaimedUnit();
        if (caster && caster.pos){
          const start = {col: Number(caster.pos.col), row: Number(caster.pos.row)};
          const end = {col: Number(center.cx), row: Number(center.cy)};
          const blocked = isLineOfSightBlocked(start, end);
          setLosPreview(start, end, blocked);
          if (blocked){
            localToast("No line of sight to spell center.");
            return;
          }
        }
      }
      const payload = {
        shape,
        dc: Number.isFinite(dcValue) ? dcValue : null,
        save_type: dcType || null,
        damage_type: damageType || null,
        damage_types: damageTypes,
        name: name || null,
        color,
        cx: center.cx,
        cy: center.cy,
      };
      if (defaultDamage){
        payload.default_damage = defaultDamage;
      }
      if (dice){
        payload.dice = dice;
      }
      if (Number.isFinite(Number(castDurationTurns)) && Number(castDurationTurns) >= 0){
        payload.duration_turns = Number(castDurationTurns);
      }
      if (typeof castOverTime === "boolean"){
        payload.over_time = castOverTime;
      }
      if (Number.isFinite(Number(castMovePerTurnFt)) && Number(castMovePerTurnFt) >= 0){
        payload.move_per_turn_ft = Number(castMovePerTurnFt);
      }
      if (castTriggerOnStartOrEnter){
        payload.trigger_on_start_or_enter = castTriggerOnStartOrEnter;
      }
      if (typeof castPersistent === "boolean"){
        payload.persistent = castPersistent;
      }
      if (typeof castPinnedDefault === "boolean"){
        payload.pinned_default = castPinnedDefault;
      }
      if (shape === "circle"){
        payload.radius_ft = radiusFt;
      } else if (shape === "sphere" || shape === "cylinder"){
        payload.radius_ft = radiusFt;
        if (heightFt !== null){
          payload.height_ft = heightFt;
        }
      } else if (shape === "square" || shape === "cube"){
        payload.side_ft = sideFt;
      } else if (shape === "line"){
        payload.length_ft = lengthFt;
        payload.width_ft = widthFt;
        payload.orient = orient;
        if (angleDeg !== null){
          payload.angle_deg = angleDeg;
        }
      } else if (shape === "cone"){
        payload.length_ft = lengthFt;
        payload.angle_deg = angleDeg !== null ? angleDeg : 90;
        payload.orient = orient;
      } else if (shape === "wall"){
        payload.length_ft = lengthFt;
        payload.orient = orient;
        if (widthFt !== null){
          payload.width_ft = widthFt;
        }
        if (thicknessFt !== null){
          payload.thickness_ft = thicknessFt;
        }
        if (heightFt !== null){
          payload.height_ft = heightFt;
        }
        if (angleDeg !== null){
          payload.angle_deg = angleDeg;
        }
      }
      send({type: "cast_aoe", payload, action_type: actionType});
    });
  }

  if (dashBtn){
    dashBtn.addEventListener("click", () => {
      if (!claimedCid) return;
      openActionPicker("dash");
    });
  }
  if (dashActionBtn){
    dashActionBtn.addEventListener("click", () => {
      if (!claimedCid) return;
      send({type:"dash", cid: Number(claimedCid), spend:"action"});
      hideDashModal();
    });
  }
  if (dashBonusActionBtn){
    dashBonusActionBtn.addEventListener("click", () => {
      if (!claimedCid) return;
      send({type:"dash", cid: Number(claimedCid), spend:"bonus"});
      hideDashModal();
    });
  }
  if (dashCancelBtn){
    dashCancelBtn.addEventListener("click", () => {
      hideDashModal();
    });
  }
  if (actionPickerCancelBtn){
    actionPickerCancelBtn.addEventListener("click", () => {
      hideActionPicker();
    });
  }
  if (battleLogBtn){
    battleLogBtn.addEventListener("click", () => {
      requestBattleLog();
      showLogModal();
    });
  }
  if (logRefreshBtn){
    logRefreshBtn.addEventListener("click", () => {
      requestBattleLog();
    });
  }
  if (logCloseBtn){
    logCloseBtn.addEventListener("click", () => {
      hideLogModal();
    });
  }
  if (configBtn){
    configBtn.addEventListener("click", () => {
      if (!configModal) return;
      if (configModal.classList.contains("show")){
        hideConfigModal();
        return;
      }
      showConfigModal();
    });
  }
  if (configCloseBtn){
    configCloseBtn.addEventListener("click", () => {
      hideConfigModal();
    });
  }
  if (configModal){
    configModal.addEventListener("click", (event) => {
      if (event.target === configModal){
        hideConfigModal();
      }
    });
  }
  if (mapViewSettingsBtn){
    mapViewSettingsBtn.addEventListener("click", () => {
      if (!mapViewSettingsModal) return;
      if (mapViewSettingsModal.classList.contains("show")){
        hideMapViewSettingsModal();
        return;
      }
      showMapViewSettingsModal();
    });
  }
  if (mapViewSettingsClose){
    mapViewSettingsClose.addEventListener("click", () => {
      hideMapViewSettingsModal();
    });
  }
  if (mapViewSettingsModal){
    mapViewSettingsModal.addEventListener("click", (event) => {
      if (event.target === mapViewSettingsModal){
        hideMapViewSettingsModal();
      }
    });
  }
  const mapViewSettingInputs = [
    mapViewTextSizeInput,
    mapViewBarHeightInput,
    mapViewChipPaddingInput,
    mapViewChipGapInput,
    mapViewCornerRadiusInput,
    mapViewShowTitleInput,
    mapViewShowStatusInput,
    mapViewShowIndexInput,
  ].filter(Boolean);
  mapViewSettingInputs.forEach((inputEl) => {
    inputEl.addEventListener("input", () => {
      if (!mapViewSettings){
        mapViewSettings = readMapViewSettings();
      }
      mapViewSettings = {
        ...mapViewSettings,
        textSize: Number(mapViewTextSizeInput?.value || mapViewSettings.textSize),
        barHeight: Number(mapViewBarHeightInput?.value || mapViewSettings.barHeight),
        chipPadding: Number(mapViewChipPaddingInput?.value || mapViewSettings.chipPadding),
        chipGap: Number(mapViewChipGapInput?.value || mapViewSettings.chipGap),
        cornerRadius: Number(mapViewCornerRadiusInput?.value || mapViewSettings.cornerRadius),
        showTitle: !!mapViewShowTitleInput?.checked,
        showStatus: !!mapViewShowStatusInput?.checked,
        showIndex: !!mapViewShowIndexInput?.checked,
      };
      applyMapViewSettings(mapViewSettings);
      persistMapViewSettings();
    });
  });
  if (adminMenuBtn && adminMenuPopover){
    adminMenuBtn.addEventListener("click", (event) => {
      event.stopPropagation();
      const isOpen = adminMenuPopover.classList.contains("show");
      setAdminMenu(!isOpen);
    });
  }
  if (adminMenuOpenBtn){
    adminMenuOpenBtn.addEventListener("click", async () => {
      closeAdminMenu();
      try {
        await requestAdminLogin();
      } catch (err){
        return;
      }
      showAdminModal();
      fetchAdminSessions();
    });
  }
  if (adminMenuRefreshBtn){
    adminMenuRefreshBtn.addEventListener("click", async () => {
      closeAdminMenu();
      try {
        await requestAdminLogin();
      } catch (err){
        return;
      }
      fetchAdminSessions();
    });
  }
  if (adminRefreshBtn){
    adminRefreshBtn.addEventListener("click", () => {
      fetchAdminSessions();
    });
  }
  if (adminCloseBtn){
    adminCloseBtn.addEventListener("click", () => {
      hideAdminModal();
    });
  }
  if (adminModal){
    adminModal.addEventListener("click", (event) => {
      if (event.target === adminModal){
        hideAdminModal();
      }
    });
  }
  if (adminLoginSubmit){
    adminLoginSubmit.addEventListener("click", () => {
      submitAdminLogin();
    });
  }
  if (adminLoginCancel){
    adminLoginCancel.addEventListener("click", () => {
      hideAdminLoginModal();
      finalizeAdminLogin(false);
    });
  }
  if (adminLoginModal){
    adminLoginModal.addEventListener("click", (event) => {
      if (event.target === adminLoginModal){
        hideAdminLoginModal();
        finalizeAdminLogin(false);
      }
    });
  }
  if (adminPasswordInput){
    adminPasswordInput.addEventListener("keydown", (event) => {
      if (event.key === "Enter"){
        event.preventDefault();
        submitAdminLogin();
      }
    });
  }
  if (presetSaveBtn){
    presetSaveBtn.addEventListener("click", () => {
      const preset = buildGuiPreset();
      persistLocalPreset(preset);
      send({type: "save_preset", preset});
    });
  }
  if (presetLoadBtn){
    presetLoadBtn.addEventListener("click", () => {
      send({type: "load_preset"});
    });
  }
  if (enableNotificationsBtn){
    enableNotificationsBtn.addEventListener("click", async () => {
      if (!("Notification" in window)){
        setNotificationStatus("Notifications are not supported.");
        return;
      }
      try {
        if (!swRegistration){
          swRegistration = await navigator.serviceWorker.ready;
        }
      } catch (err){
        console.warn("Service worker not ready.", err);
        setNotificationStatus("Service worker not ready.");
        return;
      }
      const permission = await Notification.requestPermission();
      if (permission !== "granted"){
        setNotificationStatus("Notifications blocked.");
        return;
      }
      if (!("PushManager" in window)){
        setNotificationStatus("Push is not supported.");
        return;
      }
      try {
        const existing = await swRegistration.pushManager.getSubscription();
        if (existing){
          setNotificationStatus("Notifications already enabled.");
          return;
        }
        if (!pushPublicKey){
          setNotificationStatus("Missing push public key.");
          return;
        }
        const subscription = await swRegistration.pushManager.subscribe({
          userVisibleOnly: true,
          applicationServerKey: urlBase64ToUint8Array(pushPublicKey),
        });
        console.log("Push subscription:", JSON.stringify(subscription));
        setNotificationStatus("Notifications enabled.");
      } catch (err){
        console.warn("Push subscription failed.", err);
        setNotificationStatus("Failed to enable notifications.");
      }
    });
  }
  if (enableTurnAlertsBtn){
    enableTurnAlertsBtn.addEventListener("click", async () => {
      try {
        const identity = getTurnAlertIdentity();
        await ensurePushSubscribed({
          vapidPublicKey: pushPublicKey,
          playerId: identity.playerId,
        });
        localToast("Turn alerts enabled.");
      } catch (err){
        const message = err?.message ? String(err.message) : "Failed to enable alerts.";
        setTurnAlertStatus(message);
        localToast(message);
      }
    });
  }
  if (hideTurnAlertsBtn && turnAlertsPanel){
    hideTurnAlertsBtn.addEventListener("click", () => {
      localStorage.setItem(turnAlertHideKey, "1");
      turnAlertsPanel.classList.add("hidden");
    });
  }
  if (castOverlayOpenBtn){
    castOverlayOpenBtn.addEventListener("click", () => {
      setCastOverlayOpen(true);
    });
  }
  if (castOverlayBackBtn){
    castOverlayBackBtn.addEventListener("click", () => {
      setCastOverlayOpen(false);
    });
  }
  if (spellLibraryBtn){
    spellLibraryBtn.addEventListener("click", () => {
      openSpellLibraryOverlay(true);
    });
  }
  if (spellLibraryCloseBtn){
    spellLibraryCloseBtn.addEventListener("click", () => {
      openSpellLibraryOverlay(false);
    });
  }
  if (spellLibrarySearchInput){
    spellLibrarySearchInput.addEventListener("input", (event) => {
      spellLibrarySearchTerm = String(event.target.value || "");
      renderSpellLibrary();
    });
  }
  if (spellLibrarySortSelect){
    spellLibrarySortSelect.addEventListener("change", (event) => {
      spellLibrarySortMode = String(event.target.value || "alpha");
      renderSpellLibrary();
    });
  }
  if (spellbookOpenBtn){
    spellbookOpenBtn.addEventListener("click", () => {
      openSpellbookOverlay(true);
    });
  }
  if (spellbookBackBtn){
    spellbookBackBtn.addEventListener("click", () => {
      openSpellbookOverlay(false);
    });
  }
  if (spellbookBackFloatingBtn){
    spellbookBackFloatingBtn.addEventListener("click", () => {
      openSpellbookOverlay(false);
    });
  }
  if (spellDetailBackBtn){
    spellDetailBackBtn.addEventListener("click", () => {
      closeSpellDetailOverlay();
    });
  }
  if (spellDetailColorInput){
    spellDetailColorInput.addEventListener("input", (event) => {
      const value = String(event.target.value || "");
      updateSpellDetailColorInputs(normalizeHexColor(value) || value);
    });
    spellDetailColorInput.addEventListener("change", (event) => {
      commitSpellDetailColor(event.target.value || "");
    });
  }
  if (spellDetailColorValue){
    spellDetailColorValue.addEventListener("change", (event) => {
      commitSpellDetailColor(event.target.value || "");
    });
  }
  if (spellbookTabKnown){
    spellbookTabKnown.addEventListener("click", () => {
      spellbookMode = "known";
      resetSpellbookSelections();
      renderSpellbook();
    });
  }
  if (spellbookTabPrepared){
    spellbookTabPrepared.addEventListener("click", () => {
      spellbookMode = "prepared";
      resetSpellbookSelections();
      renderSpellbook();
    });
  }
  if (spellbookKnownEnabledToggle){
    spellbookKnownEnabledToggle.addEventListener("change", (event) => {
      spellbookKnownEnabled = !!event.target.checked;
      if (!spellbookKnownEnabled){
        spellbookMode = "prepared";
      }
      resetSpellbookSelections();
      renderSpellbook();
    });
  }
  if (spellbookSearchInput){
    spellbookSearchInput.addEventListener("input", (event) => {
      spellbookSearchTerm = String(event.target.value || "");
      renderSpellbook();
    });
  }
  if (spellbookSortSelect){
    spellbookSortSelect.addEventListener("change", (event) => {
      spellbookSortMode = String(event.target.value || "alpha");
      renderSpellbook();
    });
  }
  if (spellbookAddBtn){
    spellbookAddBtn.addEventListener("click", () => {
      applySpellbookAdd();
    });
  }
  if (spellbookRemoveBtn){
    spellbookRemoveBtn.addEventListener("click", () => {
      applySpellbookRemove();
    });
  }
  if (spellbookSaveBtn){
    spellbookSaveBtn.addEventListener("click", () => {
      showSpellbookConfirm();
    });
  }
  if (spellbookConfirmCancel){
    spellbookConfirmCancel.addEventListener("click", () => {
      hideSpellbookConfirm();
    });
  }
  if (spellbookConfirmYes){
    spellbookConfirmYes.addEventListener("click", () => {
      saveSpellbookChanges();
    });
  }
  if (spellbookConfirmModal){
    spellbookConfirmModal.addEventListener("click", (event) => {
      if (event.target === spellbookConfirmModal){
        hideSpellbookConfirm();
      }
    });
  }
  if (connEl && connPopoverEl){
    connEl.addEventListener("click", (event) => {
      event.stopPropagation();
      const isOpen = connPopoverEl.classList.contains("show");
      setConnPopover(!isOpen);
    });
  }
  if (connReconnectBtn){
    connReconnectBtn.addEventListener("click", () => {
      softReconnect();
    });
  }
  document.addEventListener("click", (event) => {
    if (!connPopoverEl || !connEl) return;
    if (connPopoverEl.contains(event.target) || connEl.contains(event.target)) return;
    closeConnPopover();
  });
  document.addEventListener("click", (event) => {
    if (!adminMenuPopover || !adminMenuBtn) return;
    if (adminMenuPopover.contains(event.target) || adminMenuBtn.contains(event.target)) return;
    closeAdminMenu();
  });
  document.addEventListener("keydown", (event) => {
    if (event.key === "Escape"){
      if (spellbookConfirmModal?.classList.contains("show")){
        hideSpellbookConfirm();
        return;
      }
      if (spellLibraryOverlay?.classList.contains("show")){
        openSpellLibraryOverlay(false);
        return;
      }
      if (spellDetailOverlay?.classList.contains("show")){
        closeSpellDetailOverlay();
        return;
      }
      if (spellbookOverlay?.classList.contains("show")){
        openSpellbookOverlay(false);
        return;
      }
      if (castOverlay?.classList.contains("show")){
        setCastOverlayOpen(false);
        return;
      }
      closeConnPopover();
      closeAdminMenu();
      hideAdminModal();
    }
  });
  if (toggleTopbarTitle){
    toggleTopbarTitle.addEventListener("change", (event) => {
      showTopbarTitle = !!event.target.checked;
      persistToggle(uiToggleKeys.topbarTitle, showTopbarTitle);
      applyUiConfig();
    });
  }
  if (toggleConnIndicator){
    toggleConnIndicator.addEventListener("change", (event) => {
      showConnIndicator = !!event.target.checked;
      persistToggle(uiToggleKeys.connIndicator, showConnIndicator);
      applyUiConfig();
    });
  }
  if (connStyleButtons.length){
    connStyleButtons.forEach((button) => {
      button.addEventListener("click", () => {
        const nextStyle = button.dataset.connStyle === "compact" ? "compact" : "full";
        if (connStyle === nextStyle) return;
        connStyle = nextStyle;
        persistChoice(uiSelectKeys.connStyle, connStyle);
        applyUiConfig();
      });
    });
  }
  if (toggleLockMap){
    toggleLockMap.addEventListener("change", (event) => {
      showLockMap = !!event.target.checked;
      persistToggle(uiToggleKeys.lockMap, showLockMap);
      applyUiConfig();
    });
  }
  if (toggleCenterMap){
    toggleCenterMap.addEventListener("change", (event) => {
      showCenterMap = !!event.target.checked;
      persistToggle(uiToggleKeys.centerMap, showCenterMap);
      applyUiConfig();
    });
  }
  if (toggleMeasure){
    toggleMeasure.addEventListener("change", (event) => {
      showMeasure = !!event.target.checked;
      persistToggle(uiToggleKeys.measure, showMeasure);
      applyUiConfig();
    });
  }
  if (toggleMeasureClear){
    toggleMeasureClear.addEventListener("change", (event) => {
      showMeasureClear = !!event.target.checked;
      persistToggle(uiToggleKeys.measureClear, showMeasureClear);
      applyUiConfig();
    });
  }
  if (toggleZoomIn){
    toggleZoomIn.addEventListener("change", (event) => {
      showZoomIn = !!event.target.checked;
      persistToggle(uiToggleKeys.zoomIn, showZoomIn);
      applyUiConfig();
    });
  }
  if (toggleZoomOut){
    toggleZoomOut.addEventListener("change", (event) => {
      showZoomOut = !!event.target.checked;
      persistToggle(uiToggleKeys.zoomOut, showZoomOut);
      applyUiConfig();
    });
  }
  if (toggleBattleLog){
    toggleBattleLog.addEventListener("change", (event) => {
      showBattleLog = !!event.target.checked;
      persistToggle(uiToggleKeys.battleLog, showBattleLog);
      applyUiConfig();
    });
  }
  if (initiativeStyleSelect){
    initiativeStyleSelect.addEventListener("change", (event) => {
      const value = event.target.value;
      initiativeStyle = ["full", "compact", "hidden"].includes(value) ? value : "full";
      persistChoice(uiSelectKeys.initiativeStyle, initiativeStyle);
      applyUiConfig();
    });
  }
  if (toggleUseAction){
    toggleUseAction.addEventListener("change", (event) => {
      showUseAction = !!event.target.checked;
      persistToggle(uiToggleKeys.useAction, showUseAction);
      applyUiConfig();
    });
  }
  if (toggleUseBonusAction){
    toggleUseBonusAction.addEventListener("change", (event) => {
      showUseBonusAction = !!event.target.checked;
      persistToggle(uiToggleKeys.useBonusAction, showUseBonusAction);
      applyUiConfig();
    });
  }
  if (toggleDash){
    toggleDash.addEventListener("change", (event) => {
      showDash = !!event.target.checked;
      persistToggle(uiToggleKeys.dash, showDash);
      applyUiConfig();
    });
  }
  if (toggleStandUp){
    toggleStandUp.addEventListener("change", (event) => {
      showStandUp = !!event.target.checked;
      persistToggle(uiToggleKeys.standUp, showStandUp);
      applyUiConfig();
    });
  }
  if (toggleResetTurn){
    toggleResetTurn.addEventListener("change", (event) => {
      showResetTurn = !!event.target.checked;
      persistToggle(uiToggleKeys.resetTurn, showResetTurn);
      applyUiConfig();
    });
  }
  if (toggleSpellMenu){
    toggleSpellMenu.addEventListener("change", (event) => {
      hideSpellMenu = !!event.target.checked;
      persistToggle(uiToggleKeys.hideSpellMenu, hideSpellMenu);
      applyUiConfig();
    });
  }
  if (toggleLockMenus){
    toggleLockMenus.addEventListener("change", (event) => {
      menusLocked = !!event.target.checked;
      persistToggle(uiToggleKeys.lockMenus, menusLocked);
      applyUiConfig();
    });
  }
  Object.entries(hotkeyConfig).forEach(([action, config]) => {
    if (!config || !config.input) return;
    config.input.addEventListener("keydown", (event) => {
      event.preventDefault();
      if (event.key === "Escape"){
        config.input.blur();
        return;
      }
      if (event.key === "Backspace" || event.key === "Delete"){
        setHotkey(action, "");
        return;
      }
      const combo = normalizeHotkeyEvent(event);
      if (!combo) return;
      setHotkey(action, combo);
    });
    config.input.addEventListener("focus", () => {
      config.input.select();
    });
  });
  useActionBtn.addEventListener("click", () => {
    if (!claimedCid) return;
    openActionPicker("action");
  });
  useBonusActionBtn.addEventListener("click", () => {
    if (!claimedCid) return;
    openActionPicker("bonus");
  });
  if (standUpBtn){
    standUpBtn.addEventListener("click", () => {
      if (!claimedCid) return;
      send({type:"stand_up", cid: Number(claimedCid)});
    });
  }
  if (resetTurnBtn){
    resetTurnBtn.addEventListener("click", () => {
      if (!claimedCid) return;
      send({type:"reset_turn", cid: Number(claimedCid)});
    });
  }
  document.getElementById("endTurn").addEventListener("click", () => {
    if (!claimedCid) return;
    send({type:"end_turn", cid: Number(claimedCid)});
  });
  if (turnModalOk){
    turnModalOk.addEventListener("click", () => {
      handleUserGesture();
      hideTurnModal();
    });
  }

  document.addEventListener("keydown", (event) => {
    if (event.defaultPrevented) return;
    if (isTypingTarget(event.target)) return;
    const combo = normalizeHotkeyEvent(event);
    if (!combo) return;
    const action = hotkeyBindings.get(combo);
    if (!action) return;
    event.preventDefault();
    const config = hotkeyConfig[action];
    if (config && typeof config.action === "function"){
      config.action();
    }
  });
  document.addEventListener("pointerdown", handleUserGesture, {passive: true});
  document.addEventListener("keydown", handleUserGesture);

  const mapWrap = document.querySelector(".mapWrap");
  if (mapWrap && isMapView && document.body){
    mapWrap.addEventListener("contextmenu", (event) => {
      event.preventDefault();
      document.body.classList.toggle("map-view-show-bar");
    });
  }
  if (mapWrap && window.ResizeObserver){
    const ro = new ResizeObserver(() => resize());
    ro.observe(mapWrap);
  }
  resize();
  updateMeasurementControls();
  updateWaitingOverlay();
  connect();
})();
</script>
</body>
</html>
"""
