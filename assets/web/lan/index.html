<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <meta name="apple-mobile-web-app-title" content="InitTracker LAN" />
  <link rel="apple-touch-icon" href="/assets/graphic.png" />
  <link rel="manifest" href="/assets/manifest.webmanifest" />
  <title>InitTracker LAN</title>
  <script>window.PUSH_PUBLIC_KEY=__PUSH_PUBLIC_KEY__;</script>
  <script>window.LAN_BASE_URL=__LAN_BASE_URL__;</script>
  <style>
    :root{
      --bg:#0b0d10;
      --panel:#141923;
      --panel2:#0f1320;
      --text:#e8eef7;
      --muted:#93a2b8;
      --accent:#6aa9ff;
      --danger:#ff5b5b;
      --safeInsetTop: env(safe-area-inset-top, 0px);
      --safeInsetBottom: env(safe-area-inset-bottom, 0px);
      --modalTopOffset: 0px;
      --modalBottomOffset: 0px;
      --topbar-height: 0px;
      --bottombar-height: 0px;
    }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--text); font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif; overflow:hidden;}
    .app{height:100dvh; display:flex; flex-direction:column; min-height:0;}
    .topbar{
      padding: calc(10px + var(--safeInsetTop)) 12px 10px 12px;
      background: linear-gradient(180deg, rgba(22,24,30,0.96), rgba(12,14,20,0.88));
      border-bottom: 1px solid rgba(214,186,126,0.28);
      display:flex;
      flex-direction:column;
      align-items:stretch;
      gap:10px;
      position:sticky;
      top:0;
      z-index:24;
      backdrop-filter: blur(12px);
      box-shadow: 0 8px 20px rgba(0,0,0,0.38);
    }
    .map-view{
      --map-view-bar-height: 84px;
      --map-view-order-font-size: 14px;
      --map-view-order-gap: 8px;
      --map-view-order-chip-pad-y: 6px;
      --map-view-order-chip-pad-x: 10px;
      --map-view-order-radius: 999px;
      --map-view-bar-bg: rgba(14,18,26,0.92);
      --map-view-bar-border: rgba(255,255,255,0.1);
    }
    .map-view-only .topbar,
    .map-view-only .sheet-wrap,
    .map-view-only .cast-overlay,
    .map-view-only .menu-popover,
    .map-view-only .conn-popover,
    .map-view-only .spell-library-overlay,
    .map-view-only .spell-detail-overlay,
    .map-view-only .spellbook-overlay,
    .map-view-only .turn-modal,
    .map-view-only .modal{
      display:none !important;
    }
    .map-view .mapWrap{
      flex:1 1 auto;
    }
    .topbar-main-row,
    .topbar-initiative-row{
      display:flex;
      align-items:center;
      gap:12px;
      flex-wrap:wrap;
      position:relative;
    }
    .topbar-main-row{
      width:100%;
    }
    .topbar-initiative{
      display:flex;
      flex-direction:column;
      gap:8px;
      min-height: var(--map-view-bar-height);
      transition: max-height 0.22s ease, opacity 0.22s ease, margin 0.22s ease;
      max-height: 300px;
      opacity: 1;
      overflow: hidden;
    }
    .initiative-hidden .topbar-initiative{
      max-height: 0;
      opacity: 0;
      margin-top: -4px;
      pointer-events:none;
    }
    .map-view-title{
      font-size: 14px;
      font-weight: 700;
      color: var(--text);
      letter-spacing: 0.2px;
    }
    .map-view-readonly{
      font-size: 12px;
      color: var(--muted);
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px dashed rgba(255,255,255,0.18);
      background: rgba(15,19,32,0.6);
      letter-spacing: 0.2px;
      display:none;
    }
    .map-view .map-view-readonly{
      display:inline-flex;
    }
    .map-view-turn-order{
      display:flex;
      gap: var(--map-view-order-gap);
      overflow-x:auto;
      overflow-y:hidden;
      align-items:center;
      padding-bottom: 2px;
      flex-wrap: nowrap;
      max-width: 100%;
      flex: 1 1 100%;
      scrollbar-width: thin;
    }
    .map-view-turn-order::-webkit-scrollbar{
      height: 6px;
    }
    .map-view-turn-order::-webkit-scrollbar-thumb{
      border-radius: 999px;
      background: rgba(255,255,255,0.22);
    }
    .map-view .turn-chip{
      font-size: var(--map-view-order-font-size);
      padding: var(--map-view-order-chip-pad-y) var(--map-view-order-chip-pad-x);
      border-radius: var(--map-view-order-radius);
    }
    .map-view .turn-chip.friendly{
      background: rgba(106,255,176,0.18);
      border-color: rgba(106,255,176,0.45);
    }
    .map-view .turn-chip.enemy{
      background: rgba(255,91,91,0.16);
      border-color: rgba(255,91,91,0.4);
    }
    .map-view .turn-chip.friendly.active{
      border-color: rgba(106,255,176,0.75);
      box-shadow: 0 0 0 1px rgba(106,255,176,0.45);
    }
    .map-view .turn-chip.enemy.active{
      border-color: rgba(255,91,91,0.75);
      box-shadow: 0 0 0 1px rgba(255,91,91,0.45);
    }
    .map-view .turn-chip-index{
      font-size: calc(var(--map-view-order-font-size) * 0.7);
    }
    .map-view .turn-order-status{
      font-size: 12px;
      color: var(--muted);
    }
    .map-view-active-row{
      gap:8px;
    }
    .map-view-active-label{
      font-size: 12px;
      color: var(--muted);
    }
    .map-view-active-select{
      background: rgba(15,19,32,0.82);
      border:1px solid rgba(255,255,255,0.18);
      color: var(--text);
      border-radius: 10px;
      padding: 6px 28px 6px 10px;
      font-size: 13px;
      flex: 1 1 200px;
      min-width: 160px;
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .map-view-active-select.friendly{
      background: rgba(106,255,176,0.18);
      border-color: rgba(106,255,176,0.5);
    }
    .map-view-active-select.enemy{
      background: rgba(255,91,91,0.16);
      border-color: rgba(255,91,91,0.5);
    }
    .map-view-hide-index .turn-chip-index{
      display:none;
    }
    .map-view-hide-status #mapViewTurnOrderStatus{
      display:none;
    }
    .map-view-hide-title .map-view-title{
      display:none;
    }
    .topbar h1{font-size:14px; margin:0; font-weight:650;}
    .pill{font-size:12px; color:var(--muted); padding:6px 10px; border:1px solid rgba(255,255,255,0.10); border-radius:999px;}
    .conn-wrap{
      position:relative;
      display:inline-flex;
      align-items:center;
    }
    .conn-pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      cursor:pointer;
      background: transparent;
      font: inherit;
    }
    .conn-full-text{display:inline;}
    .conn-compact-label,
    .conn-compact-dot{display:none;}
    .conn-compact .conn-full-text{display:none;}
    .conn-compact .conn-compact-label,
    .conn-compact .conn-compact-dot{display:inline-flex;}
    .conn-compact-label{font-weight:700; letter-spacing:0.5px;}
    .conn-compact-dot{
      width:8px;
      height:8px;
      border-radius:50%;
      background: var(--accent);
    }
    .conn-popover{
      position:absolute;
      top: calc(100% + 10px);
      left: 0;
      min-width: 160px;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(15,19,32,0.98);
      box-shadow: 0 12px 30px rgba(0,0,0,0.45);
      display:flex;
      flex-direction:column;
      gap:10px;
      opacity:0;
      transform: translateY(-4px);
      pointer-events:none;
      transition: opacity 0.15s ease, transform 0.15s ease;
      z-index: 30;
    }
    .conn-popover::before{
      content:"";
      position:absolute;
      top: -6px;
      left: 16px;
      width: 12px;
      height: 12px;
      background: rgba(15,19,32,0.98);
      border-left: 1px solid rgba(255,255,255,0.12);
      border-top: 1px solid rgba(255,255,255,0.12);
      transform: rotate(45deg);
    }
    .conn-popover.show{
      opacity:1;
      transform: translateY(0);
      pointer-events:auto;
    }
    .conn-popover-status{
      font-size:12px;
      color: var(--muted);
    }
    .conn-style-toggle{
      display:inline-flex;
      gap:6px;
      flex-wrap:wrap;
    }
    .conn-style-btn{
      padding:6px 10px;
      font-size:12px;
    }
    .conn-style-btn.active{
      border-color: rgba(106,169,255,0.65);
      background: rgba(106,169,255,0.2);
      color: var(--text);
    }
    .menu-wrap{
      position:relative;
      display:inline-flex;
      align-items:center;
    }
    .menu-btn{
      display:inline-flex;
      align-items:center;
      gap:6px;
    }
    .menu-popover{
      position:absolute;
      top: calc(100% + 10px);
      left: 0;
      min-width: 190px;
      padding: 6px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(15,19,32,0.98);
      box-shadow: 0 12px 30px rgba(0,0,0,0.45);
      display:flex;
      flex-direction:column;
      gap:6px;
      opacity:0;
      transform: translateY(-4px);
      pointer-events:none;
      transition: opacity 0.15s ease, transform 0.15s ease;
      z-index: 30;
    }
    .menu-popover.show{
      opacity:1;
      transform: translateY(0);
      pointer-events:auto;
    }
    .menu-item{
      border:none;
      background: transparent;
      color: var(--text);
      font-size: 13px;
      font-weight: 600;
      text-align: left;
      padding: 8px 10px;
      border-radius: 10px;
      cursor:pointer;
    }
    .menu-item:hover,
    .menu-item:focus{
      background: rgba(255,255,255,0.08);
      outline:none;
    }
    .hidden{display:none !important;}

    .monster-detail-overlay{
      position: fixed;
      inset: 0;
      background: rgba(7, 10, 16, 0.82);
      backdrop-filter: blur(4px);
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 24px;
      z-index: 110;
    }
    .monster-detail-content{
      width: min(90vw, 980px);
      max-width: 90vw;
      max-height: 90vh;
      overflow-y: auto;
      background: rgba(15, 19, 32, 0.98);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 14px;
      box-shadow: 0 18px 38px rgba(0,0,0,0.45);
      padding: 20px;
      line-height: 1.45;
    }
    .monster-detail-content h2,
    .monster-detail-content h3{
      margin: 0 0 10px;
    }
    .monster-detail-content p{
      margin: 0 0 8px;
      color: var(--text);
    }
    .monster-detail-content ul{
      margin: 0 0 12px;
      padding-left: 18px;
    }
    .monster-detail-content .ability-grid{
      display:grid;
      grid-template-columns: repeat(6, minmax(56px, 1fr));
      gap: 8px;
      margin: 8px 0 14px;
    }
    .monster-detail-content .ability-cell{
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 10px;
      padding: 8px 6px;
      text-align:center;
      background: rgba(255,255,255,0.05);
      font-size: 12px;
    }
    .monster-detail-content .ability-cell strong{
      display:block;
      font-size: 15px;
      margin-top: 2px;
    }
    .close-btn{
      position: fixed;
      top: 18px;
      right: 18px;
      z-index: 111;
      width: 42px;
      height: 42px;
      border-radius: 50%;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(11,15,24,0.95);
      color: #fff;
      font-size: 28px;
      line-height: 1;
      cursor: pointer;
    }
    @media (max-width: 760px){
      .monster-detail-overlay{padding: 12px;}
      .monster-detail-content{padding: 14px;}
      .monster-detail-content .ability-grid{grid-template-columns: repeat(3, minmax(56px, 1fr));}
      .close-btn{top: 10px; right: 10px;}
    }
    .spacer{flex:1;}
    .btn{
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 13px;
      font-weight: 650;
      touch-action: manipulation;
    }
    .btn:active{transform: translateY(1px);}
    .btn.danger{background: rgba(255,91,91,0.14); border-color: rgba(255,91,91,0.35);}
    .btn.accent{background: rgba(106,169,255,0.14); border-color: rgba(106,169,255,0.35);}
    .topbar-controls{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
    }

    .mapWrap{flex:1 1 auto; min-height:0; position:relative; overflow:hidden; background:#0a0c12;}
    canvas{position:absolute; inset:0; width:100%; height:100%; touch-action:none;}
    .map-tooltip{
      position:absolute;
      z-index:4;
      pointer-events:none;
      max-width:240px;
      padding:4px 8px;
      border-radius:6px;
      background:rgba(16,18,24,0.92);
      color:#eef2f7;
      font-size:12px;
      font-weight:600;
      box-shadow:0 2px 8px rgba(0,0,0,0.35);
      opacity:0;
      transition:opacity 0.08s ease;
      white-space:nowrap;
    }
    .map-tooltip.show{opacity:1;}
    .waiting{
      position:absolute; inset:0; display:none; align-items:center; justify-content:center;
      background: rgba(10,12,18,0.82); color: var(--muted); font-size: 16px; letter-spacing: 0.4px;
      text-transform: lowercase;
    }
    .waiting.show{display:flex;}
    .summon-placement-banner{
      position:absolute;
      top:12px;
      left:50%;
      transform:translateX(-50%);
      z-index:6;
      padding:8px 12px;
      border-radius:10px;
      background:rgba(15,19,32,0.92);
      border:1px solid rgba(106,169,255,0.55);
      color:#e8eef7;
      font-size:12px;
      font-weight:600;
      box-shadow:0 6px 18px rgba(0,0,0,0.35);
      pointer-events:none;
    }

    .sheet-wrap{
      position:sticky; bottom:0; z-index:20;
      display:flex; flex-direction:column;
      background: rgba(20,25,35,0.92);
      border-top: 1px solid rgba(255,255,255,0.08);
      backdrop-filter: blur(10px);
      min-height: 180px;
      max-height: 75vh;
    }
    .sheet-handle{
      height: 18px;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor: ns-resize;
      touch-action: none;
      flex:0 0 auto;
    }
    .menus-locked .sheet-handle{
      cursor: not-allowed;
      opacity: 0.45;
      pointer-events: none;
    }
    .sheet-handle::before{
      content:"";
      width: 44px;
      height: 4px;
      border-radius: 999px;
      background: rgba(255,255,255,0.25);
    }
    .sheet{
      padding: 10px 12px calc(12px + var(--safeInsetBottom)) 12px;
      display:flex;
      flex-direction:column;
      flex:1 1 auto;
      min-height:0;
    }
    .sheet-content{
      display:flex;
      flex-direction:column;
      flex:1 1 auto;
      min-height:0;
    }
    .cast-panel{
      margin-top: 10px;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.1);
      background: rgba(10,14,22,0.55);
    }
    .turn-alerts-panel{
      margin-top: 10px;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.1);
      background: rgba(10,14,22,0.55);
    }
    .turn-alerts-panel legend{
      padding: 0 6px;
      font-weight: 700;
    }
    .turn-alerts-row{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .turn-alerts-status{
      font-size: 12px;
      color: var(--muted);
    }
    .turn-alerts-note{
      margin-top: 6px;
      font-size: 11px;
      color: var(--muted);
    }
    .btn.mount.glow{
      box-shadow: 0 0 0.8rem rgba(106,169,255,0.95);
      border-color: rgba(106,169,255,0.95);
    }
    .cast-panel summary{
      cursor:pointer;
      font-weight:700;
      list-style:none;
    }
    .cast-panel summary::-webkit-details-marker{display:none;}
    .cast-panel[open] summary{margin-bottom:8px;}
    .cast-menu-trigger{
      margin-top: 10px;
      display:flex;
    }
    .cast-menu-trigger .btn{
      flex:1;
    }
    .cast-overlay{
      background: var(--bg);
      display:none;
      flex-direction:column;
      padding: 10px 12px calc(12px + var(--safeInsetBottom)) 12px;
      z-index:40;
      height:100%;
      overflow:auto;
      flex:1 1 auto;
      min-height: 0;
    }
    .cast-overlay.show{
      display:flex;
    }
    .cast-overlay-header{
      display:flex;
      align-items:center;
      gap:12px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
    }
    .cast-overlay-header .btn{
      white-space: nowrap;
    }
    .cast-overlay-title{
      font-size: 14px;
      font-weight: 700;
    }
    .cast-overlay-spacer{
      flex:1;
    }
    .cast-overlay-body{
      margin-top: 10px;
      overflow:auto;
      flex:1 1 auto;
      min-height:0;
    }
    .cast-overlay .cast-panel{
      margin-top: 0;
      padding: 0;
      border: none;
      background: transparent;
    }
    .spell-select-overlay{
      position:fixed;
      inset: 0;
      top: var(--topbar-height);
      bottom: var(--bottombar-height);
      background: var(--bg);
      display:none;
      flex-direction:column;
      padding: 10px 12px calc(12px + var(--safeInsetBottom)) 12px;
      z-index:45;
      min-height:0;
    }
    .spell-select-overlay.show{
      display:flex;
    }
    .spell-select-header{
      display:flex;
      align-items:center;
      gap:12px;
      padding-bottom:8px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      flex-wrap:wrap;
    }
    .spell-select-title{
      font-size: 14px;
      font-weight: 700;
    }
    .spell-select-spacer{
      flex:1;
    }
    .spell-select-body{
      margin-top: 10px;
      display:flex;
      flex-direction:column;
      gap:10px;
      flex:1 1 auto;
      min-height:0;
    }
    .spell-select-summary{
      font-size: 12px;
      color: var(--muted);
    }
    .spell-select-table-wrap{
      overflow:auto;
      max-height: calc(100dvh - var(--topbar-height) - var(--bottombar-height) - 170px);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(8,12,20,0.6);
    }
    .spell-select-table{
      width:100%;
      border-collapse: collapse;
      font-size: 12px;
    }
    .spell-select-table th,
    .spell-select-table td{
      padding: 8px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.06);
      text-align:left;
      vertical-align:top;
    }
    .spell-select-check-col,
    .spell-select-check-cell{
      width: 38px;
      text-align:center;
    }
    .spell-select-overlay:not(.selecting) .spell-select-check-col,
    .spell-select-overlay:not(.selecting) .spell-select-check-cell{
      display:none;
    }
    .spell-select-table th{
      position: sticky;
      top: 0;
      background: rgba(12,16,26,0.98);
      z-index: 2;
      font-size: 11px;
      letter-spacing: 0.3px;
      text-transform: uppercase;
      color: var(--muted);
    }
    .spell-select-table tr:last-child td{
      border-bottom:none;
    }
    .spell-select-name-btn{
      background: none;
      border: none;
      padding: 0;
      color: var(--accent);
      cursor:pointer;
      font-weight: 600;
      text-align:left;
    }
    .spell-select-link{
      color: var(--accent);
      text-decoration: none;
      font-weight: 600;
    }
    .spell-select-link:hover{
      text-decoration: underline;
    }
    .spell-select-details-row td{
      padding-top: 0;
      background: rgba(10,14,22,0.45);
    }
    .spell-select-details-row details{
      padding: 6px 0 10px 0;
    }
    .spell-select-details-row summary{
      cursor:pointer;
      list-style:none;
      font-weight: 700;
      color: var(--text);
    }
    .spell-select-details-row summary::-webkit-details-marker{display:none;}
    .spell-select-details-grid{
      margin-top: 8px;
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 6px;
      font-size: 11px;
      color: var(--muted);
    }
    .spell-select-actions{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .spell-select-overlay:not(.selecting) .spell-select-save-btn{
      display:none;
    }
    .spell-select-details-item strong{
      color: var(--text);
      font-weight: 600;
      display:block;
      margin-bottom: 2px;
    }
    .spell-select-controls{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .spell-select-controls select{
      flex:1;
    }
    .form-grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap:8px;
    }
    .spell-filter-toolbar{
      margin-bottom: 10px;
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .spell-filter-toolbar .form-field{
      flex:1 1 220px;
      min-width: 160px;
    }
    .spell-filter-summary{
      font-size: 12px;
      color: var(--muted);
      flex: 1 1 100%;
    }
    .spell-filter-modal{
      position: fixed;
      inset: 0;
      display:none;
      background: rgba(8,10,14,0.8);
      backdrop-filter: blur(4px);
      z-index: 70;
      padding: 12px;
      align-items:flex-end;
    }
    .spell-filter-modal.show{display:flex;}
    .spell-filter-drawer{
      width: min(620px, 100%);
      max-height: calc(100dvh - 24px);
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(13,18,28,0.98);
      display:flex;
      flex-direction:column;
      overflow:hidden;
      margin: 0 auto;
    }
    .spell-filter-drawer-header{
      display:flex;
      align-items:center;
      gap:10px;
      padding: 12px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
    }
    .spell-filter-drawer-body{
      padding: 12px;
      overflow:auto;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .spell-filter-drawer-actions{
      padding: 12px;
      border-top: 1px solid rgba(255,255,255,0.08);
      display:flex;
      justify-content:flex-end;
      gap:8px;
    }
    .multi-select{
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 10px;
      background: rgba(8,12,20,0.6);
      padding: 8px;
    }
    .multi-select summary{
      cursor:pointer;
      list-style:none;
      font-size: 12px;
      color: var(--text);
    }
    .multi-select summary::-webkit-details-marker{display:none;}
    .multi-select-options{
      margin-top: 8px;
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap:6px;
    }
    .multi-select-options label{
      display:flex;
      align-items:center;
      gap:6px;
      font-size: 12px;
      color: var(--muted);
    }
    .advanced-filter-toggle{
      margin:0;
      padding: 8px;
      border: 1px dashed rgba(255,255,255,0.2);
      border-radius: 10px;
      background: rgba(8,12,20,0.35);
    }
    .advanced-filter-toggle summary{
      cursor:pointer;
      font-size: 12px;
      font-weight: 600;
      color: var(--text);
    }
    .spell-details{
      margin-top: 10px;
      padding: 8px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.1);
      background: rgba(8,12,20,0.6);
      font-size: 12px;
      color: var(--muted);
    }
    .spell-details-grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 6px;
    }
    .spell-details-row{
      display:flex;
      gap:6px;
      align-items:baseline;
    }
    .spell-details-label{
      font-size: 11px;
      color: var(--muted);
      min-width: 64px;
    }
    .spell-details-value{
      font-size: 12px;
      color: var(--text);
      font-weight: 600;
    }
    .spellbook-overlay{
      position: fixed;
      inset: 0;
      height: calc(var(--spellbook-vh, 1vh) * 100);
      max-height: 100dvh;
      background: rgba(10, 12, 16, 0.9);
      backdrop-filter: blur(8px);
      display: none;
      flex-direction: column;
      z-index: 60;
    }
    .spellbook-overlay.show{display:flex;}
    .spell-detail-overlay{
      position: fixed;
      inset: 0;
      height: calc(var(--spellbook-vh, 1vh) * 100);
      max-height: 100dvh;
      background: rgba(10, 12, 16, 0.95);
      backdrop-filter: blur(10px);
      display: none;
      flex-direction: column;
      z-index: 95;
    }
    .spell-detail-overlay.show{display:flex;}
    .spell-detail-header{
      padding: calc(12px + var(--safeInsetTop)) 14px 12px 14px;
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border-bottom: 1px solid rgba(255,255,255,0.08);
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .spell-detail-title{
      font-size: 15px;
      font-weight: 700;
    }
    .spell-detail-spacer{flex:1;}
    .spell-detail-body{
      padding: 14px;
      padding-bottom: calc(14px + var(--safeInsetBottom));
      overflow:auto;
      flex: 1 1 auto;
      min-height: 0;
      display:flex;
      flex-direction:column;
      gap: 14px;
    }
    .spell-detail-card{
      background: rgba(20,25,35,0.92);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      padding: 12px 14px;
      display:flex;
      flex-direction:column;
      gap: 12px;
    }
    .spell-detail-heading{
      font-size: 14px;
      font-weight: 700;
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .spell-detail-meta{
      font-size: 12px;
      color: var(--muted);
    }
    .spell-detail-color-row{
      display:flex;
      align-items:center;
      gap:12px;
      flex-wrap:wrap;
    }
    .spell-detail-color-value{
      width: 96px;
      text-transform: uppercase;
    }
    .spell-color-swatch{
      width: 18px;
      height: 18px;
      border-radius: 50%;
      border: 1px solid rgba(255,255,255,0.4);
      background: rgba(255,255,255,0.2);
      display:inline-block;
      flex: 0 0 auto;
    }
    .spellbook-color-dot{
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: 1px solid rgba(255,255,255,0.4);
      background: rgba(255,255,255,0.2);
      flex: 0 0 auto;
      margin-right: 6px;
    }
    .spell-library-overlay{
      position: fixed;
      inset: 0;
      background: rgba(10, 12, 16, 0.95);
      backdrop-filter: blur(6px);
      display: none;
      flex-direction: column;
      z-index: 80;
    }
    .spell-library-overlay.show{display:flex;}
    .spell-library-header{
      padding: calc(12px + var(--safeInsetTop)) 14px 12px 14px;
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border-bottom: 1px solid rgba(255,255,255,0.08);
      display:flex;
      align-items:center;
      gap:12px;
      flex-wrap:wrap;
    }
    .spell-library-title{
      font-size: 15px;
      font-weight: 700;
    }
    .spell-library-spacer{flex:1;}
    .spell-library-controls{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .spell-library-controls input,
    .spell-library-controls select{
      background: rgba(15,19,32,0.75);
      border: 1px solid rgba(255,255,255,0.15);
      color: var(--text);
      padding: 6px 10px;
      border-radius: 8px;
      font-size: 12px;
    }
    .spell-library-body{
      padding: 12px 14px calc(14px + var(--safeInsetBottom)) 14px;
      overflow:auto;
      flex: 1 1 auto;
      min-height: 0;
    }
    .spell-library-status{
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 10px;
    }
    .spell-library-list{
      display:flex;
      flex-direction: column;
      gap: 12px;
    }
    .spell-library-card{
      background: rgba(20,25,35,0.92);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      display:flex;
      flex-direction: column;
    }
    .spell-library-card summary{
      list-style: none;
      cursor: pointer;
      padding: 12px 14px;
    }
    .spell-library-card summary::-webkit-details-marker{display:none;}
    .spell-library-summary{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }
    .spell-library-summary-title{
      font-size: 14px;
      font-weight: 700;
    }
    .spell-library-summary-meta{
      font-size: 12px;
      color: var(--muted);
    }
    .spell-library-detail-body{
      border-top: 1px solid rgba(255,255,255,0.08);
      padding: 10px 14px 12px 14px;
      display:flex;
      flex-direction: column;
      gap: 10px;
    }
    .spell-library-detail-grid{
      display:grid;
      grid-template-columns: minmax(120px, 180px) minmax(0, 1fr);
      gap: 6px 12px;
    }
    .spell-library-detail-label{
      font-size: 12px;
      color: var(--muted);
      font-weight: 600;
    }
    .spell-library-detail-value{
      font-size: 12px;
      color: var(--text);
      white-space: pre-wrap;
      word-break: break-word;
    }
    .spell-library-detail-description{
      font-size: 12px;
      color: var(--text);
      white-space: pre-wrap;
      line-height: 1.4;
    }
    .spell-library-action-row{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
    }
    .spell-library-color-row{
      display:flex;
      align-items:center;
      gap: 8px;
    }
    .spell-library-color-row .spell-color-swatch{
      width: 16px;
      height: 16px;
    }
    .spellbook-header{
      padding: calc(12px + var(--safeInsetTop)) 14px 12px 14px;
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border-bottom: 1px solid rgba(255,255,255,0.08);
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .spellbook-title{font-size:14px; font-weight:650;}
    .spellbook-spacer{flex:1;}
    .spellbook-body{
      display:flex;
      flex-direction:column;
      gap:12px;
      padding:12px;
      padding-bottom: calc(12px + var(--safeInsetBottom) + 56px);
      overflow:hidden;
      flex:1;
      min-height: 0;
    }
    .spellbook-tabs{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-items:center;
    }
    .spellbook-controls{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-items:center;
    }
    .spellbook-controls input,
    .spellbook-controls select{
      background: rgba(15,19,32,0.75);
      border: 1px solid rgba(255,255,255,0.15);
      color: var(--text);
      padding: 6px 10px;
      border-radius: 8px;
      font-size: 12px;
    }
    .spellbook-columns{
      display:grid;
      grid-template-columns: 1fr auto 1fr;
      gap:12px;
      flex:1;
      min-height:0;
    }
    .spellbook-column{
      background: var(--panel);
      border:1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      padding:10px;
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    .spellbook-column-title{
      font-size:12px;
      color: var(--muted);
      margin-bottom:8px;
      text-transform: uppercase;
      letter-spacing:0.8px;
    }
    .spellbook-list{
      display:flex;
      flex-direction:column;
      gap:6px;
      overflow:auto;
      flex:1;
      padding-right:4px;
    }
    .spellbook-item{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:8px;
      background: rgba(255,255,255,0.05);
      border:1px solid transparent;
      border-radius:8px;
      padding:8px 10px;
      color: var(--text);
      cursor:pointer;
      font-size:13px;
    }
    .spellbook-item-name{
      display:flex;
      align-items:center;
      gap:6px;
      flex:1;
      min-width:0;
    }
    .spellbook-item-name span{
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .spellbook-item.selected{
      border-color: var(--accent);
      background: rgba(106,169,255,0.18);
    }
    .spellbook-item small{
      color: var(--muted);
      font-size:11px;
    }
    .spellbook-actions{
      display:flex;
      flex-direction:column;
      gap:8px;
      justify-content:center;
    }
    .spellbook-status{
      font-size:12px;
      color: var(--muted);
      min-height:16px;
    }
    .spellbook-confirm-text{
      font-size:14px;
      margin:0 0 10px 0;
    }
    .spellbook-back-fab{
      position: fixed;
      left: 16px;
      bottom: calc(16px + var(--safeInsetBottom));
      z-index: 1;
      box-shadow: 0 10px 24px rgba(0,0,0,0.35);
    }
    .manual-entry-badge{
      display: none;
      align-items: center;
      gap: 4px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(255,180,90,0.6);
      background: rgba(255,140,60,0.2);
      color: #ffcc9b;
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.4px;
    }
    .manual-entry-badge.show{
      display: inline-flex;
    }
    .form-field{display:flex; flex-direction:column; gap:4px;}
    .form-field label{font-size:11px; color:var(--muted);}
    .form-field input,
    .form-field select{
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      border-radius: 8px;
      padding: 6px 8px;
      font-size: 12px;
    }
    .form-field select{
      background: var(--panel2);
      color: var(--text);
    }
    .form-field select option{
      background: var(--panel2);
      color: var(--text);
    }
    .form-field input[type="color"]{
      padding:0;
      height:36px;
      width:100%;
      border:none;
      background:none;
    }
    .damage-type-controls{
      display:flex;
      gap:6px;
      align-items:center;
    }
    .damage-type-controls select{flex:1;}
    .damage-type-list{
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      min-height:24px;
    }
    .damage-type-chip{
      display:inline-flex;
      align-items:center;
      gap:6px;
    }
    .chip button{
      border:none;
      background:none;
      color: var(--text);
      font-size: 14px;
      cursor:pointer;
      padding:0;
      line-height:1;
    }
    .form-actions{margin-top:10px; display:flex; gap:8px; flex-wrap:wrap;}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .row + .row{margin-top:10px;}
    .sheet-actions{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .initiative-compact .turn-order{max-height: 60px; overflow:auto;}
    .initiative-compact .turn-order-status{display:none;}
    .label{font-size:12px; color:var(--muted);}
    .value{font-size:14px; font-weight:700;}
    .chip{font-size:12px; padding:6px 10px; border-radius:999px; border:1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.05);}
    .chip input{margin-right:6px;}
    .turn-order{display:flex; flex-wrap:wrap; gap:6px; align-items:center;}
    .turn-chip{
      min-width: 26px;
      font-size:12px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.04);
      color: var(--text);
      display:inline-flex;
      align-items:center;
      gap:6px;
    }
    .turn-chip-index{font-weight:700;}
    .turn-chip-name{
      max-width: 140px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .turn-chip-marker{
      display:none;
      width:8px;
      height:8px;
      border-radius:50%;
      background: rgba(255,255,255,0.3);
      flex:0 0 auto;
    }
    .turn-chip-marker.active-marker{
      background: var(--accent);
      box-shadow: 0 0 6px rgba(106,169,255,0.6);
    }
    .turn-chip-marker.claimed-marker{
      background: rgba(106,169,255,0.55);
      border: 1px solid rgba(106,169,255,0.85);
    }
    .initiative-compact .turn-chip-name{display:none;}
    .initiative-compact .turn-chip-marker{display:inline-block;}
    .initiative-compact .turn-chip.active{
      background: rgba(106,169,255,0.2);
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(106,169,255,0.5);
    }
    .turn-chip.claimed{
      border-color: rgba(106,169,255,0.45);
      box-shadow: inset 0 0 0 1px rgba(106,169,255,0.18);
    }
    .turn-chip.active{
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(106,169,255,0.35);
    }
    .modal{
      position:fixed; inset:0; background: rgba(0,0,0,0.55);
      display:none; align-items:center; justify-content:center;
      padding: calc(var(--modalTopOffset) + 12px) 14px calc(var(--modalBottomOffset) + 12px);
      z-index: 80;
    }
    .modal.show{display:flex;}
    .card{
      width:min(520px, 100%);
      background: var(--panel);
      border:1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 12px 40px rgba(0,0,0,0.5);
      display:flex;
      flex-direction:column;
      overflow:auto;
      max-height: calc(100dvh - var(--safeInsetTop) - var(--safeInsetBottom) - var(--modalTopOffset) - var(--modalBottomOffset) - 24px);
    }
    .config-card{overflow:hidden;}
    .card-scroll{
      max-height: calc(100dvh - var(--safeInsetTop) - var(--safeInsetBottom) - var(--modalTopOffset) - var(--modalBottomOffset) - 24px);
      overflow:auto;
    }
    .modal-body{
      flex: 1 1 auto;
      min-height: 0;
      overflow: auto;
    }
    .card h2{margin:0 0 8px 0; font-size:16px;}
    .list{max-height: 50vh; overflow:auto; border:1px solid rgba(255,255,255,0.10); border-radius:12px;}
    .item{
      padding: 12px;
      border-bottom:1px solid rgba(255,255,255,0.08);
      display:flex; align-items:center; gap:10px;
      touch-action: manipulation;
    }
    .item:last-child{border-bottom:none;}
    .item .name{font-weight:750;}
    .item .meta{font-size:12px; color:var(--muted);}
    .item:active{background: rgba(255,255,255,0.04);}
    .claim-item{
      width:100%;
      text-align:left;
      background: transparent;
      color: var(--text);
      border: none;
      cursor:pointer;
    }
    .claim-item.selected{
      background: rgba(106,169,255,0.12);
      box-shadow: inset 0 0 0 1px rgba(106,169,255,0.35);
    }
    .claim-item input{
      pointer-events:none;
    }
    .hint{font-size:12px; color:var(--muted); margin-top:10px; line-height:1.4;}
    .hint.hidden{display:none;}
    .modal-actions{display:flex; gap:10px; flex-wrap:wrap; margin-top:12px;}
    .modal-actions .btn{flex:1; min-width:120px;}
    .action-picker-list{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-top:4px;
    }
    .action-picker-item{
      border:1px solid rgba(255,255,255,0.12);
      border-radius:12px;
      padding:10px;
      background: rgba(15,20,30,0.6);
      text-align:left;
      color: var(--text);
      cursor:pointer;
    }
    .action-picker-item .action-picker-name{
      font-weight:650;
      margin-bottom:4px;
    }
    .action-picker-item .action-picker-meta{
      font-size:12px;
      color: var(--muted);
      line-height:1.4;
    }
    .admin-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:8px;
    }
    .admin-status{
      font-size:12px;
      color: var(--muted);
      margin-bottom:8px;
    }
    .admin-session-list{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-top:6px;
    }
    .admin-session{
      border:1px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      padding: 10px;
      background: rgba(10,14,22,0.55);
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .admin-session-top{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      flex-wrap:wrap;
    }
    .admin-session-ip{
      font-weight:700;
      font-size:13px;
    }
    .admin-session-meta{
      font-size:12px;
      color: var(--muted);
    }
    .admin-session-status{
      font-size:11px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.16);
    }
    .admin-session-status.connected{
      border-color: rgba(106,169,255,0.55);
      color: var(--accent);
    }
    .admin-session-status.offline{
      border-color: rgba(255,255,255,0.2);
      color: var(--muted);
    }
    .admin-session-assign{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }
    .admin-session-assign select{
      flex:1 1 200px;
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      border-radius: 8px;
      padding: 6px 8px;
      font-size: 12px;
    }
    .admin-login-fields{
      display:flex;
      flex-direction:column;
      gap:12px;
      margin-top: 10px;
    }
    .admin-login-fields label{
      font-size: 12px;
      color: var(--muted);
    }
    .admin-login-input{
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.12);
      background: #0f1422;
      color: var(--text);
      font-size: 14px;
    }
    .config-section{margin-top:8px;}
    .config-section summary{
      cursor:pointer;
      list-style:none;
      font-weight:700;
      font-size:14px;
      padding: 6px 4px;
    }
    .config-section summary::-webkit-details-marker{display:none;}
    .config-list{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-top:8px;
    }
    .config-item{
      display:flex;
      flex-direction:column;
      gap:8px;
      padding: 10px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,0.1);
      background: rgba(10,14,22,0.55);
    }
    .config-item-title{font-size:13px; font-weight:650;}
    .config-controls{display:flex; align-items:center; gap:8px; flex-wrap:wrap;}
    .preset-actions{display:flex; align-items:center; gap:8px; flex-wrap:wrap;}
    .preset-status{font-size:12px; color:var(--accent); min-height:16px;}
    .config-toggle{
      display:flex;
      align-items:center;
      gap:6px;
      font-size:12px;
      color: var(--muted);
    }
    .config-toggle input{transform: scale(1.05);}
    .hotkey-input{
      width:120px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      padding:6px 8px;
      font-size:12px;
    }
    .hotkey-input.conflict{
      border-color: rgba(255,91,91,0.55);
      box-shadow: 0 0 0 1px rgba(255,91,91,0.3);
    }
    .hotkey-conflict{
      min-height:14px;
      font-size:11px;
      color: var(--danger);
    }
    .hotkey-hint{font-size:11px; color: var(--muted);}
    .color-row{display:flex; align-items:center; gap:12px; flex-wrap:wrap;}
    .color-swatch{width:36px; height:36px; border-radius:50%; border:2px solid rgba(255,255,255,0.2); background:#6aa9ff;}
    .color-input{width:64px; height:44px; border:none; background:none; padding:0;}
    .turn-modal{
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 20px 14px;
      background: rgba(0,0,0,0.6);
      opacity:0;
      pointer-events:none;
      transition: opacity 0.2s ease;
    }
    .turn-modal.show{
      opacity:1;
      pointer-events:auto;
    }
    .turn-card{
      width:min(380px, 100%);
      background: var(--panel);
      border:1px solid rgba(255,255,255,0.16);
      border-radius: 16px;
      padding: 18px 16px;
      text-align:center;
      box-shadow: 0 16px 40px rgba(0,0,0,0.5);
      display:flex;
      flex-direction:column;
      max-height: calc(100vh - var(--safeInsetTop) - var(--safeInsetBottom) - 40px);
    }
    .turn-card h2{margin:0 0 12px 0; font-size:18px;}
    .dm-side-layout{
      position:absolute;
      top:10px;
      bottom:10px;
      left:10px;
      right:10px;
      pointer-events:none;
      display:flex;
      justify-content:space-between;
      gap:10px;
      z-index:5;
    }
    .dm-log-panel,.dm-map-preview{
      pointer-events:auto;
      background: rgba(11,14,21,0.72);
      border:1px solid rgba(255,255,255,0.16);
      border-radius:12px;
      backdrop-filter: blur(6px);
    }
    .dm-log-panel{
      width:min(430px,42vw);
      display:none;
      flex-direction:column;
      overflow:hidden;
    }
    .dm-log-panel.show{display:flex;}
    .dm-log-header{display:flex;justify-content:space-between;gap:8px;padding:8px;border-bottom:1px solid rgba(255,255,255,0.1);}
    .dm-log-list{overflow:auto; padding:6px 8px; font-size:12px; display:flex; flex-direction:column; gap:4px;}
    .dm-log-entry{display:grid; grid-template-columns: 72px 1fr; gap:8px; padding:4px 6px; border-radius:6px; cursor:pointer;}
    .dm-log-entry:hover{background:rgba(255,255,255,0.08);}
    .dm-log-time{color:var(--muted); font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;}
    .dm-log-entry.attack .dm-log-msg{color:#ffdbb0;}
    .dm-log-entry.damage .dm-log-msg{color:#ffbcbc;}
    .dm-log-entry.heal .dm-log-msg{color:#bcffd9;}
    .dm-log-entry.save .dm-log-msg{color:#b8d3ff;}
    .dm-map-preview{width:min(300px,28vw); display:none; flex-direction:column; padding:8px; opacity:0.55;}
    .dm-map-preview.show{display:flex;}
    .dm-map-preview canvas{width:100%; aspect-ratio:1/1; background:rgba(5,8,14,0.78); border-radius:8px;}

    .log-content{
      overflow:auto;
      flex:1;
      min-height:0;
      padding: 10px;
      border:1px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      background: rgba(8,10,16,0.65);
      font-size: 12px;
      white-space: pre-wrap;
      line-height: 1.4;
    }
    .spell-slot-monitor-row{
      align-items:center;
    }
    .spell-slot-monitor{
      display:flex;
      flex-wrap:wrap;
      gap:10px 14px;
      align-items:center;
      min-height: 18px;
      padding: 4px 2px;
    }
    .spell-slot-monitor.is-empty{
      display:none;
    }
    .spell-slot-level{
      display:inline-flex;
      align-items:center;
      gap:6px;
      font-size: 11px;
      letter-spacing: 0.5px;
      color: var(--muted);
      text-transform: uppercase;
    }
    .spell-slot-squares{
      display:inline-flex;
      gap:4px;
    }
    .spell-slot-square{
      width:10px;
      height:10px;
      border-radius:3px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.14);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.35);
    }
    .spell-slot-square.is-active{
      background: linear-gradient(135deg, rgba(106,169,255,0.9), rgba(106,255,176,0.55));
      border-color: rgba(106,169,255,0.9);
      box-shadow: 0 0 6px rgba(106,169,255,0.55), inset 0 0 0 1px rgba(255,255,255,0.25);
    }
    .spell-slot-square.is-spent{
      background: rgba(255,255,255,0.05);
      border-color: rgba(255,255,255,0.08);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.4);
    }
    .turn-order-status{
      margin-top: 6px;
      font-size: 12px;
      color: var(--muted);
    }
    .turn-order-bubble{
      position:absolute;
      left:0;
      top:0;
      transform: translate(-50%, 0);
      background: rgba(16,20,28,0.95);
      border: 1px solid rgba(255,255,255,0.16);
      border-radius: 999px;
      padding: 6px 12px;
      font-size: 12px;
      color: var(--text);
      box-shadow: 0 10px 24px rgba(0,0,0,0.4);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s ease;
      z-index: 2;
      max-width: calc(100% - 16px);
      box-sizing: border-box;
      text-align: center;
    }
    .turn-order-bubble.show{
      opacity: 1;
    }
    .turn-chip.selected{
      border-color: rgba(255,255,255,0.5);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.18);
    }
    .topbar-initiative .turn-chip{
      min-width: 44px;
      border-radius: 999px;
      border-color: rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.07);
      box-shadow: 0 4px 10px rgba(0,0,0,0.32);
      padding: 7px 12px;
      flex: 0 0 auto;
    }
    .topbar-initiative .turn-chip.active{
      border-color: rgba(214,186,126,0.95);
      box-shadow: 0 0 0 1px rgba(214,186,126,0.7), 0 0 12px rgba(214,186,126,0.35);
    }
    .topbar-initiative .turn-chip.friendly{
      background: rgba(106,255,176,0.16);
      border-color: rgba(106,255,176,0.42);
    }
    .topbar-initiative .turn-chip.enemy{
      background: rgba(255,91,91,0.15);
      border-color: rgba(255,91,91,0.35);
    }
    .topbar-initiative .turn-chip-name{
      max-width: 120px;
    }
    @media (max-width: 720px), (max-height: 720px){
      .btn{padding: 6px 8px; font-size: 12px;}
      .topbar{gap:8px; padding: calc(8px + var(--safeInsetTop)) 10px 8px 10px;}
      .sheet{padding: 8px 10px calc(10px + var(--safeInsetBottom)) 10px;}
    }
  </style>
</head>
<body>
<div class="app">
  <div class="topbar">
    <div class="topbar-main-row">
      <h1 class="map-view-title" id="topbarTitle">Initiative Tracker</h1>
      <div class="conn-wrap">
        <button class="pill conn-pill" id="conn" type="button" title="Connecting…" aria-haspopup="dialog" aria-expanded="false">
          <span class="conn-full-text" id="connFullText">Connecting…</span>
          <span class="conn-compact-label" id="connCompactLabel" aria-hidden="true">C</span>
          <span class="conn-compact-dot" id="connDot" aria-hidden="true"></span>
        </button>
        <div class="conn-popover" id="connPopover" role="dialog" aria-hidden="true">
          <div class="conn-popover-status" id="connPopoverStatus">Connecting…</div>
          <button class="btn" id="connReconnectBtn" type="button">Reconnect</button>
        </div>
      </div>
      <div class="spacer"></div>
      <button class="btn" id="planningBtn" type="button">Planning Mode</button>
      <button class="btn" id="spellLibraryBtn" type="button">Spellbook</button>
      <button class="btn" id="configBtn" aria-controls="configModal" aria-expanded="false">Config</button>
      <button class="btn" id="initiativeToggleBtn" type="button" aria-pressed="true" title="Show or hide initiative bar">⚔️ Initiative</button>
      <div class="topbar-controls">
        <button class="btn" id="lockMap">Lock Map</button>
        <button class="btn" id="lockAoeToggle" type="button" aria-pressed="true">Unlock my AOEs</button>
        <button class="btn" id="centerMap">Center on Me</button>
        <button class="btn" id="tokenColorModeBtn">Token Color</button>
        <button class="btn" id="measureToggle" aria-pressed="false">Measure</button>
        <button class="btn" id="measureClear">Clear Measure</button>
        <button class="btn accent" id="zoomIn">Zoom +</button>
        <button class="btn accent" id="zoomOut">Zoom −</button>
        <button class="btn" id="battleLog">Battle Log</button>
      </div>
    </div>
    <div class="topbar-initiative" id="initiativeBarWrap" aria-label="Initiative bar">
      <div class="topbar-initiative-row">
        <div class="map-view-readonly" id="mapViewReadOnly" role="note">View-only: actions and movement are disabled.</div>
      </div>
      <div class="topbar-initiative-row">
        <div class="turn-order map-view-turn-order" id="mapViewTurnOrder" aria-label="Initiative order"></div>
        <div class="turn-order-bubble" id="mapViewTurnOrderBubble" role="status" aria-live="polite"></div>
      </div>
      <div class="topbar-initiative-row map-view-active-row">
        <div class="map-view-active-label">Current turn</div>
        <select class="map-view-active-select" id="mapViewActiveSelect" aria-label="Current turn selection"></select>
      </div>
      <div class="topbar-initiative-row">
        <div class="turn-order-status" id="mapViewTurnOrderStatus"></div>
      </div>
    </div>
  </div>

  <div class="mapWrap">
    <canvas id="c"></canvas>
    <div class="waiting" id="waitingOverlay">(waiting for combat...)</div>
    <div class="summon-placement-banner hidden" id="summonPlacementBanner" role="status" aria-live="polite"></div>
    <div class="map-tooltip" id="tokenTooltip" role="tooltip" aria-hidden="true"></div>
    <div class="dm-side-layout" id="dmSideLayout">
      <aside class="dm-log-panel" id="dmLogPanel">
        <div class="dm-log-header">
          <strong>Battle Log</strong>
          <label><input type="checkbox" id="dmLogAutoScroll" checked /> Auto-scroll</label>
        </div>
        <div class="dm-log-header">
          <label><input type="checkbox" data-log-filter="attack" checked />🎲</label>
          <label><input type="checkbox" data-log-filter="damage" checked />💥</label>
          <label><input type="checkbox" data-log-filter="save" checked />🛡</label>
          <label><input type="checkbox" data-log-filter="heal" checked />❤️</label>
          <label><input type="checkbox" data-log-filter="spell" checked />🔮</label>
        </div>
        <div class="dm-log-list" id="dmLogList"></div>
      </aside>
      <aside class="dm-map-preview" id="dmMapPreview">
        <strong>Map Preview</strong>
        <canvas id="dmPreviewCanvas" width="240" height="240"></canvas>
      </aside>
    </div>

    <div class="modal" id="claimModal" aria-hidden="true">
      <div class="card">
        <h2>Claim yer character</h2>
        <div class="modal-body">
          <div class="list" id="claimList"></div>
          <div class="hint hidden" id="claimEmptyHint">No claimable PCs yet. Ask the DM to add one.</div>
          <div class="hint" id="claimHint">Pick a character to control. The DM can reassign ye later.</div>
        </div>
        <div class="modal-actions">
          <button class="btn accent" id="claimConfirm" type="button">Confirm</button>
          <button class="btn" id="claimSpectator" type="button">Spectator / View only</button>
          <button class="btn" id="claimContinue" type="button">Continue unclaimed</button>
        </div>
      </div>
    </div>

    <div class="modal" id="colorModal" aria-hidden="true">
      <div class="card">
        <h2>Pick yer token color</h2>
        <div class="row color-row">
          <div class="color-swatch" id="tokenColorSwatch"></div>
          <input class="color-input" type="color" id="tokenColorInput" value="#6aa9ff" />
          <div class="label">No red or white, matey.</div>
        </div>
        <div class="modal-actions">
          <button class="btn accent" id="tokenColorConfirm">Confirm</button>
          <button class="btn" id="tokenColorCancel">Cancel</button>
        </div>
      </div>
    </div>
    <div class="modal" id="actionPickerModal" aria-hidden="true">
      <div class="card card-scroll">
        <h2 id="actionPickerTitle">Choose an Action</h2>
        <div class="action-picker-list" id="actionPickerList"></div>
        <div class="modal-actions">
          <button class="btn" id="actionPickerCancel">Cancel</button>
        </div>
      </div>
    </div>
    <div class="modal" id="dashModal" aria-hidden="true">
      <div class="card">
        <h2>Use Action or Bonus Action?</h2>
        <div class="modal-actions">
          <button class="btn accent" id="dashAction">Use Action</button>
          <button class="btn accent" id="dashBonusAction">Use Bonus Action</button>
          <button class="btn" id="dashCancel">Cancel</button>
        </div>
      </div>
    </div>
    <div class="modal" id="logModal" aria-hidden="true">
      <div class="card card-scroll">
        <h2>Battle Log</h2>
        <div class="log-content" id="logContent">Loading…</div>
        <div class="modal-actions">
          <button class="btn accent" id="logRefresh">Refresh</button>
          <button class="btn" id="logClose">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="configModal" aria-hidden="true">
      <div class="card config-card">
        <h2>Config</h2>
        <div class="modal-body">
          <details class="config-section">
            <summary>Top Bar</summary>
            <div class="config-list">
              <div class="config-item">
                <div class="config-item-title">InitTracker LAN title</div>
                <div class="config-controls">
                  <label class="config-toggle"><input type="checkbox" id="toggleTopbarTitle" />Show</label>
                  <input class="hotkey-input" id="hotkeyTopbarTitle" data-hotkey-action="toggleTopbarTitle" placeholder="Hotkey" readonly />
                </div>
                <div class="hotkey-conflict" id="hotkeyConflictTopbarTitle"></div>
              </div>
              <div class="config-item">
                <div class="config-item-title">Connection indicator</div>
                <div class="config-controls">
                  <label class="config-toggle"><input type="checkbox" id="toggleConnIndicator" />Show</label>
                  <div class="conn-style-toggle" role="group" aria-label="Connection indicator style">
                    <button class="btn conn-style-btn" type="button" data-conn-style="full">Full</button>
                    <button class="btn conn-style-btn" type="button" data-conn-style="compact">Compact</button>
                  </div>
                  <input class="hotkey-input" id="hotkeyConnStyle" data-hotkey-action="toggleConnStyle" placeholder="Hotkey" readonly />
                </div>
                <div class="hotkey-conflict" id="hotkeyConflictConnStyle"></div>
              </div>
              <div class="config-item">
                <div class="config-item-title">Lock Map</div>
                <div class="config-controls">
                  <label class="config-toggle"><input type="checkbox" id="toggleLockMap" />Show</label>
                  <input class="hotkey-input" id="hotkeyLockMap" data-hotkey-action="lockMap" placeholder="Hotkey" readonly />
                </div>
                <div class="hotkey-conflict" id="hotkeyConflictLockMap"></div>
              </div>
              <div class="config-item">
                <div class="config-item-title">Center on Me</div>
                <div class="config-controls">
                  <label class="config-toggle"><input type="checkbox" id="toggleCenterMap" />Show</label>
                  <input class="hotkey-input" id="hotkeyCenterMap" data-hotkey-action="centerMap" placeholder="Hotkey" readonly />
                </div>
                <div class="hotkey-conflict" id="hotkeyConflictCenterMap"></div>
              </div>
              <div class="config-item">
                <div class="config-item-title">Measure</div>
                <div class="config-controls">
                  <label class="config-toggle"><input type="checkbox" id="toggleMeasure" />Show</label>
                  <input class="hotkey-input" id="hotkeyMeasure" data-hotkey-action="measure" placeholder="Hotkey" readonly />
                </div>
                <div class="hotkey-conflict" id="hotkeyConflictMeasure"></div>
              </div>
              <div class="config-item">
                <div class="config-item-title">Clear Measure</div>
                <div class="config-controls">
                  <label class="config-toggle"><input type="checkbox" id="toggleMeasureClear" />Show</label>
                  <input class="hotkey-input" id="hotkeyMeasureClear" data-hotkey-action="measureClear" placeholder="Hotkey" readonly />
                </div>
                <div class="hotkey-conflict" id="hotkeyConflictMeasureClear"></div>
              </div>
              <div class="config-item">
                <div class="config-item-title">Zoom +</div>
                <div class="config-controls">
                  <label class="config-toggle"><input type="checkbox" id="toggleZoomIn" />Show</label>
                  <input class="hotkey-input" id="hotkeyZoomIn" data-hotkey-action="zoomIn" placeholder="Hotkey" readonly />
                </div>
                <div class="hotkey-conflict" id="hotkeyConflictZoomIn"></div>
              </div>
              <div class="config-item">
                <div class="config-item-title">Zoom -</div>
                <div class="config-controls">
                  <label class="config-toggle"><input type="checkbox" id="toggleZoomOut" />Show</label>
                  <input class="hotkey-input" id="hotkeyZoomOut" data-hotkey-action="zoomOut" placeholder="Hotkey" readonly />
                </div>
                <div class="hotkey-conflict" id="hotkeyConflictZoomOut"></div>
              </div>
              <div class="config-item">
              <div class="config-item-title">Battle Log</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="toggleBattleLog" />Show</label>
                <input class="hotkey-input" id="hotkeyBattleLog" data-hotkey-action="battleLog" placeholder="Hotkey" readonly />
              </div>
              <div class="hotkey-conflict" id="hotkeyConflictBattleLog"></div>
            </div>
            <div class="config-item">
              <div class="config-item-title">DM side log panel</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="toggleDmLogPanel" />Show</label>
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">DM map preview</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="toggleDmMapPreview" />Show</label>
              </div>
            </div>
          </div>
        </details>
        <details class="config-section">
          <summary>Bottom Bar</summary>
          <div class="config-list">
            <div class="config-item">
              <div class="config-item-title">Initiative strip</div>
              <div class="config-controls">
                <select id="initiativeStyleSelect">
                  <option value="full">Full</option>
                  <option value="compact">Compact</option>
                  <option value="hidden">Hidden</option>
                </select>
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Action</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="toggleUseAction" />Show</label>
                <input class="hotkey-input" id="hotkeyUseAction" data-hotkey-action="useAction" placeholder="Hotkey" readonly />
              </div>
              <div class="hotkey-conflict" id="hotkeyConflictUseAction"></div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Bonus Action</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="toggleUseBonusAction" />Show</label>
                <input class="hotkey-input" id="hotkeyUseBonusAction" data-hotkey-action="useBonusAction" placeholder="Hotkey" readonly />
              </div>
              <div class="hotkey-conflict" id="hotkeyConflictUseBonusAction"></div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Dash</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="toggleDash" />Show</label>
                <input class="hotkey-input" id="hotkeyDash" data-hotkey-action="dash" placeholder="Hotkey" readonly />
              </div>
              <div class="hotkey-conflict" id="hotkeyConflictDash"></div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Stand</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="toggleStandUp" />Show</label>
                <input class="hotkey-input" id="hotkeyStandUp" data-hotkey-action="standUp" placeholder="Hotkey" readonly />
              </div>
              <div class="hotkey-conflict" id="hotkeyConflictStandUp"></div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Reset</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="toggleResetTurn" />Show</label>
                <input class="hotkey-input" id="hotkeyResetTurn" data-hotkey-action="resetTurn" placeholder="Hotkey" readonly />
              </div>
              <div class="hotkey-conflict" id="hotkeyConflictResetTurn"></div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Hide spell menu for non spell casters</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="toggleSpellMenu" />Hide</label>
              </div>
            </div>
          </div>
        </details>
        <details class="config-section">
          <summary>Initiative Display</summary>
          <div class="config-list">
            <div class="config-item">
              <div class="config-item-title">Text size</div>
              <div class="config-controls">
                <input id="mapViewTextSize" type="range" min="10" max="28" step="1" />
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Bar height</div>
              <div class="config-controls">
                <input id="mapViewBarHeight" type="range" min="56" max="140" step="2" />
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Chip padding</div>
              <div class="config-controls">
                <input id="mapViewChipPadding" type="range" min="4" max="18" step="1" />
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Chip gap</div>
              <div class="config-controls">
                <input id="mapViewChipGap" type="range" min="2" max="20" step="1" />
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Chip radius</div>
              <div class="config-controls">
                <input id="mapViewCornerRadius" type="range" min="6" max="40" step="2" />
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Show tracker title</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="mapViewShowTitle" />Show</label>
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Show status</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="mapViewShowStatus" />Show</label>
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Show turn index</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="mapViewShowIndex" />Show</label>
              </div>
            </div>
          </div>
        </details>
        <details class="config-section">
          <summary>Notifications</summary>
          <div class="config-list">
            <div class="config-item">
              <div class="config-item-title">Push notifications</div>
              <div class="config-controls">
                <button class="btn" id="enableNotifications" type="button">Enable</button>
                <div class="preset-status" id="notificationStatus" aria-live="polite"></div>
              </div>
            </div>
            <div class="config-item">
              <div class="config-item-title">Focus tab on my turn</div>
              <div class="config-controls">
                <label class="config-toggle"><input type="checkbox" id="focusTabOnTurn" />Focus</label>
              </div>
            </div>
          </div>
        </details>
        <div class="hint hidden" id="iosInstallHint">
          Open Safari → Share → Add to Home Screen.
          <a href="https://support.apple.com/en-us/HT201366" target="_blank" rel="noopener">Learn more</a>
        </div>
        </div>
        <div class="modal-actions">
          <button class="btn" id="configClose">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="adminModal" aria-hidden="true">
      <div class="card card-scroll">
        <div class="admin-header">
          <h2>Admin Sessions</h2>
          <button class="btn" id="adminRefresh" type="button">Refresh</button>
        </div>
        <div class="admin-status" id="adminStatus">Loading…</div>
        <div class="form-grid" id="adminPreSummonControls">
          <div class="form-field"><label for="preSummonTarget">Target</label><select id="preSummonTarget"></select></div>
          <div class="form-field"><label for="preSummonSpell">Spell</label><select id="preSummonSpell"></select></div>
          <div class="form-field"><label for="preSummonMonster">Monster</label><select id="preSummonMonster"></select></div>
          <div class="form-field"><label for="preSummonVariant">Variant</label><input id="preSummonVariant" type="text" placeholder="Celestial" /></div>
          <div class="form-field"><label for="preSummonSlotLevel">Slot Level</label><input id="preSummonSlotLevel" type="number" min="1" max="9" value="2" /></div>
          <div class="form-field"><label>&nbsp;</label><button class="btn" id="assignPreSummon" type="button">Assign Pre-Summon</button></div>
        </div>
        <div class="admin-session-list" id="adminSessionList"></div>
        <div class="modal-actions">
          <button class="btn" id="adminClose">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="adminLoginModal" aria-hidden="true">
      <div class="card">
        <h2>Admin Login</h2>
        <div class="hint">Enter the DM password to manage LAN sessions.</div>
        <div class="admin-login-fields">
          <label for="adminPasswordInput">Admin password</label>
          <input class="admin-login-input" id="adminPasswordInput" type="password" autocomplete="current-password" />
        </div>
        <div class="admin-status" id="adminLoginStatus"></div>
        <div class="modal-actions">
          <button class="btn" id="adminLoginSubmit" type="button">Login</button>
          <button class="btn" id="adminLoginCancel" type="button">Cancel</button>
        </div>
      </div>
    </div>
  </div>

  <div class="sheet-wrap" id="sheetWrap">
    <div class="sheet-handle" id="sheetHandle" role="separator" aria-orientation="horizontal" aria-label="Resize sheet"></div>
    <div class="sheet" id="sheet">
      <div class="sheet-content">
      <div class="row">
        <div class="label">Ye be:</div>
        <div class="value" id="me">(unclaimed)</div>
        <button class="btn" id="switchCharacter" type="button">Switch character</button>
        <div class="spacer"></div>
        <div class="sheet-actions">
          <button class="btn" id="useAction">Use Action</button>
          <button class="btn" id="useBonusAction">Use Bonus Action</button>
          <button class="btn" id="dash">Dash</button>
          <button class="btn" id="standUp">Stand Up</button>
          <button class="btn" id="resetTurn">Reset Turn</button>
          <button class="btn" id="dismissSummons">Dismiss Summons</button>
          <button class="btn mount hidden" id="mountBtn">Mount</button>
          <button class="btn hidden" id="dismountBtn">Dismount</button>
          <button class="btn danger" id="endTurn">End Turn</button>
        </div>
      </div>
      <div class="row">
        <div class="form-field">
          <label for="actionSelect">Action</label>
          <select id="actionSelect">
            <option value="">None/Custom</option>
          </select>
        </div>
        <div class="form-field">
          <label for="bonusActionSelect">Bonus Action</label>
          <select id="bonusActionSelect">
            <option value="">None/Custom</option>
          </select>
        </div>
      </div>
      <div class="row">
        <div class="chip" id="move">Move: —</div>
        <div class="chip" id="action">Action: —</div>
        <div class="chip" id="bonusAction">Bonus Action: —</div>
        <div class="chip" id="reaction">Reaction: —</div>
        <div class="chip" id="turn">Turn: —</div>
        <div class="chip" id="note">Tip: drag yer token · hold Shift to drag AoE (touch-hold ok)</div>
        <label class="chip"><input type="checkbox" id="showAllNames">Show All Names</label>
      </div>
      <fieldset class="turn-alerts-panel" id="turnAlertsPanel">
        <legend>Turn Alerts</legend>
        <div class="turn-alerts-row">
          <div class="turn-alerts-status" id="turnAlertStatus" aria-live="polite">Not installed.</div>
          <button class="btn" id="unlockAudio" type="button">Enable sounds</button>
          <button class="btn" id="enableTurnAlerts" type="button">Enable Turn Alerts</button>
          <button class="btn" id="hideTurnAlerts" type="button">Hide</button>
        </div>
        <div class="turn-alerts-note">Only works when installed as an app.</div>
      </fieldset>
      <div class="row spell-slot-monitor-row">
        <div class="spell-slot-monitor" id="spellSlotMonitor" aria-label="Spell slot monitor"></div>
      </div>
      <div class="cast-menu-trigger" id="castMenuTrigger">
        <button class="btn" id="castOverlayOpen" type="button">Cast Spell</button>
      </div>
      </div>
    </div>
    <div class="cast-overlay hidden" id="sheetCastView" aria-hidden="true">
      <div class="cast-overlay-header">
        <button class="btn" id="castOverlayBack" type="button">Back</button>
        <div class="cast-overlay-title" id="castOverlayTitle">Cast Spell</div>
        <div class="cast-overlay-spacer"></div>
        <button class="btn" id="spellbookOpen" type="button">Manage Spells</button>
      </div>
      <div class="cast-overlay-body" role="dialog" aria-modal="true" aria-labelledby="castOverlayTitle">
        <div class="cast-panel" id="castPanel">
          <form id="castForm">
            <div class="spell-filter-toolbar">
              <div class="form-field">
                <label for="castSearch">Search</label>
                <input id="castSearch" type="search" placeholder="Search name, tags, description" />
              </div>
              <button class="btn" id="openSpellFilters" type="button">Filters</button>
              <div class="spell-filter-summary" id="spellFilterSummary">No filters active.</div>
            </div>
            <div class="spell-filter-modal" id="spellFilterModal" aria-hidden="true">
              <div class="spell-filter-drawer" role="dialog" aria-modal="true" aria-labelledby="spellFilterModalTitle">
                <div class="spell-filter-drawer-header">
                  <strong id="spellFilterModalTitle">Spell Filters</strong>
                  <div class="spell-select-spacer"></div>
                  <button class="btn" id="closeSpellFilters" type="button">Close</button>
                </div>
                <div class="spell-filter-drawer-body">
                  <div class="form-grid">
                    <div class="form-field">
                      <label for="castFilterLevelMin">Level Min</label>
                      <select id="castFilterLevelMin">
                        <option value="" selected>Any</option>
                        <option value="0">Cantrip</option>
                        <option value="1">1st</option>
                        <option value="2">2nd</option>
                        <option value="3">3rd</option>
                        <option value="4">4th</option>
                        <option value="5">5th</option>
                        <option value="6">6th</option>
                        <option value="7">7th</option>
                        <option value="8">8th</option>
                        <option value="9">9th</option>
                      </select>
                    </div>
                    <div class="form-field">
                      <label for="castFilterLevelMax">Level Max</label>
                      <select id="castFilterLevelMax">
                        <option value="" selected>Any</option>
                        <option value="0">Cantrip</option>
                        <option value="1">1st</option>
                        <option value="2">2nd</option>
                        <option value="3">3rd</option>
                        <option value="4">4th</option>
                        <option value="5">5th</option>
                        <option value="6">6th</option>
                        <option value="7">7th</option>
                        <option value="8">8th</option>
                        <option value="9">9th</option>
                      </select>
                    </div>
                    <div class="form-field">
                      <label for="castFilterCastingTime">Casting Time</label>
                      <select id="castFilterCastingTime"><option value="" selected>Any</option></select>
                    </div>
                    <div class="form-field">
                      <label for="castFilterRange">Range</label>
                      <select id="castFilterRange"><option value="" selected>Any</option></select>
                    </div>
                  </div>
                  <details class="multi-select" id="castFilterSchoolMulti">
                    <summary>Schools: Any</summary>
                    <div class="multi-select-options" id="castFilterSchoolOptions"></div>
                  </details>
                  <details class="multi-select" id="castFilterTagMulti">
                    <summary>Tags: Any</summary>
                    <div class="multi-select-options" id="castFilterTagOptions"></div>
                  </details>
                  <details class="multi-select" id="castFilterListMulti">
                    <summary>Lists: Any</summary>
                    <div class="multi-select-options" id="castFilterListOptions"></div>
                  </details>
                  <details class="advanced-filter-toggle" id="advancedSpellFilters">
                    <summary>Advanced Filters</summary>
                    <div class="form-grid" style="margin-top:8px;">
                      <label class="chip"><input type="checkbox" id="castFilterRitual"> Ritual only</label>
                      <label class="chip"><input type="checkbox" id="castFilterConcentration"> Concentration only</label>
                    </div>
                  </details>
                </div>
                <div class="spell-filter-drawer-actions">
                  <button class="btn" id="clearSpellFilters" type="button">Clear</button>
                  <button class="btn" id="applySpellFilters" type="button">Apply</button>
                </div>
              </div>
            </div>
          <div class="form-grid">
            <div class="form-field">
              <label for="castPreset">Preset <span class="manual-entry-badge" id="castManualEntryBadge" title="Manual entry required.">Manual entry required</span></label>
              <div class="spell-select-controls">
                <select id="castPreset">
                  <option value="" selected>Custom</option>
                </select>
              </div>
            </div>
            <div class="form-field">
              <label for="castName">Name</label>
              <input id="castName" type="text" placeholder="Fireball" />
            </div>
            <div class="form-field">
              <label for="castSlotLevel">Slot Level</label>
              <input id="castSlotLevel" type="number" min="0" step="1" placeholder="1" disabled />
            </div>
          </div>
          <div class="form-grid" id="aoeOptions">
            <div class="form-field">
              <label for="castShape">Shape</label>
              <select id="castShape">
                <option value="" selected>Choose shape</option>
                <option value="circle">Circle</option>
                <option value="square">Square</option>
                <option value="line">Line</option>
                <option value="sphere">Sphere</option>
                <option value="cube">Cube</option>
                <option value="cone">Cone</option>
                <option value="cylinder">Cylinder</option>
                <option value="wall">Wall</option>
              </select>
            </div>
            <div class="form-field cast-size-field" id="castRadiusField">
              <label for="castRadius">Radius (ft)</label>
              <input id="castRadius" type="number" min="5" step="5" value="10" readonly disabled />
            </div>
            <div class="form-field cast-size-field" id="castSideField">
              <label for="castSide">Side (ft)</label>
              <input id="castSide" type="number" min="5" step="5" value="10" readonly disabled />
            </div>
            <div class="form-field cast-size-field" id="castLengthField">
              <label for="castLength">Length (ft)</label>
              <input id="castLength" type="number" min="5" step="5" value="30" readonly disabled />
            </div>
            <div class="form-field cast-size-field" id="castWidthField">
              <label for="castWidth">Width (ft)</label>
              <input id="castWidth" type="number" min="5" step="5" value="5" readonly disabled />
            </div>
            <div class="form-field cast-size-field" id="castAngleField">
              <label for="castAngle">Angle (deg)</label>
              <input id="castAngle" type="number" min="0" step="5" value="90" readonly disabled />
            </div>
            <div class="form-field cast-size-field" id="castOrientField">
              <label for="castOrient">Orientation</label>
              <select id="castOrient" disabled>
                <option value="vertical" selected>Vertical</option>
                <option value="horizontal">Horizontal</option>
              </select>
            </div>
            <div class="form-field cast-size-field" id="castThicknessField">
              <label for="castThickness">Thickness (ft)</label>
              <input id="castThickness" type="number" min="1" step="1" value="5" readonly disabled />
            </div>
            <div class="form-field cast-size-field" id="castHeightField">
              <label for="castHeight">Height (ft)</label>
              <input id="castHeight" type="number" min="1" step="1" value="10" readonly disabled />
            </div>
            <div class="form-field">
              <label for="castDcType">DC Type</label>
              <select id="castDcType">
                <option value="">None</option>
                <option value="str">STR</option>
                <option value="dex">DEX</option>
                <option value="con">CON</option>
                <option value="int">INT</option>
                <option value="wis">WIS</option>
                <option value="cha">CHA</option>
              </select>
            </div>
            <div class="form-field">
              <label for="castDcValue">Save DC</label>
              <input id="castDcValue" type="number" min="0" step="1" placeholder="15" />
            </div>
            <div class="form-field">
              <label for="castDefaultDamage">Default Damage</label>
              <input id="castDefaultDamage" type="text" placeholder="28" />
            </div>
            <div class="form-field">
              <label for="castDice">Damage Dice</label>
              <input id="castDice" type="text" placeholder="8d6" />
            </div>
            <div class="form-field">
              <label for="castDamageType">Damage Types</label>
              <div class="damage-type-controls">
                <select id="castDamageType">
                  <option value="" selected>Select a type</option>
__DAMAGE_TYPE_OPTIONS__
                </select>
                <button class="btn" type="button" id="castAddDamageType">Add</button>
              </div>
              <div class="damage-type-list" id="castDamageTypeList" aria-live="polite"></div>
            </div>
            <div class="form-field">
              <label for="castColor">Color</label>
              <input id="castColor" type="color" value="#6aa9ff" />
            </div>
          </div>
          <div id="summonOptions" class="hidden">
            <div class="form-grid">
              <div class="form-field">
                <label for="castSummonChoice">Summon</label>
                <select id="castSummonChoice"></select>
              </div>
              <div class="form-field">
                <label for="castSummonVariant">Variant</label>
                <select id="castSummonVariant"></select>
              </div>
              <div class="form-field">
                <label for="castSummonQuantity">Quantity</label>
                <input id="castSummonQuantity" type="number" min="1" step="1" value="1" />
              </div>
            </div>
            <div class="spell-details" id="castSummonMeta" aria-live="polite"></div>
          </div>
          <div class="spell-details" id="spellPresetDetails" aria-live="polite">
            Select a preset to see spell details.
          </div>
          <div class="form-actions">
            <button class="btn accent" id="castSubmit" type="submit">Cast</button>
          </div>
        </form>
      </div>
    </div>
    <div class="modal" id="rosterPickerModal" aria-hidden="true">
      <div class="panel">
        <h3 style="margin-top:0;">Add Players to Encounter</h3>
        <div class="hint">Select player characters from the current YAML roster.</div>
        <div class="modal-body">
          <div id="rosterPickerStatus" class="hint">Loading roster…</div>
          <div id="rosterPickerList" class="roster-picker-list"></div>
        </div>
        <div class="modal-actions">
          <button class="btn" id="rosterPickerRefresh" type="button">Refresh</button>
          <button class="btn" id="rosterPickerAdd" type="button">Add Selected</button>
          <button class="btn" id="rosterPickerClose" type="button">Close</button>
        </div>
      </div>
    </div>

    <div class="modal" id="mountPromptModal" aria-hidden="true">
      <div class="card">
        <h2>Mount Request</h2>
        <div class="hint" id="mountPromptBody">Someone wants to mount you. OK?</div>
        <div class="modal-actions">
          <button class="btn accent" id="mountPromptYes">Yes</button>
          <button class="btn" id="mountPromptNo">No</button>
        </div>
      </div>
    </div>
  </div>
  </div>
</div>
<div class="spellbook-overlay" id="spellbookOverlay" aria-hidden="true">
  <div class="spellbook-header">
    <button class="btn" id="spellbookBack" type="button">Back</button>
    <div class="spellbook-title" id="spellbookTitle">Manage Spells</div>
    <div class="spellbook-spacer"></div>
    <button class="btn accent" id="spellbookSave" type="button">Save</button>
  </div>
  <div class="spellbook-body">
    <div class="spellbook-tabs">
      <button class="btn" id="spellbookTabKnown" type="button">Known Spells</button>
      <button class="btn" id="spellbookTabPrepared" type="button">Prepared Spells</button>
      <label class="chip spellbook-toggle"><input type="checkbox" id="spellbookKnownEnabled" />Known spells enabled</label>
    </div>
    <div class="spellbook-controls">
      <input id="spellbookSearch" type="search" placeholder="Search spells..." />
      <select id="spellbookSort">
        <option value="alpha" selected>Name</option>
        <option value="level">Level</option>
      </select>
    </div>
    <div class="spellbook-columns">
      <div class="spellbook-column">
        <div class="spellbook-column-title" id="spellbookLeftTitle">All Spells</div>
        <div class="spellbook-list" id="spellbookLeftList"></div>
      </div>
      <div class="spellbook-column spellbook-actions">
        <button class="btn" id="spellbookAdd" type="button">Add →</button>
        <button class="btn" id="spellbookRemove" type="button">← Remove</button>
      </div>
      <div class="spellbook-column">
        <div class="spellbook-column-title" id="spellbookRightTitle">Known Spells</div>
        <div class="spellbook-list" id="spellbookRightList"></div>
      </div>
    </div>
    <div class="spellbook-status" id="spellbookStatus"></div>
  </div>
  <button class="btn spellbook-back-fab" id="spellbookBackFloating" type="button" aria-label="Close spellbook">Close</button>
</div>
<div class="spell-detail-overlay" id="spellDetailOverlay" aria-hidden="true">
  <div class="spell-detail-header">
    <button class="btn" id="spellDetailBack" type="button">Back</button>
    <div class="spell-detail-title" id="spellDetailTitle">Spell Details</div>
    <div class="spell-detail-spacer"></div>
  </div>
  <div class="spell-detail-body">
    <div class="spell-detail-card">
      <div class="spell-detail-heading">
        <span id="spellDetailName">Spell</span>
        <span class="spell-detail-meta" id="spellDetailMeta"></span>
      </div>
      <div class="form-field">
        <label for="spellDetailColorInput">Spell Color</label>
        <div class="spell-detail-color-row">
          <span class="spell-color-swatch" id="spellDetailColorSwatch"></span>
          <input class="color-input" type="color" id="spellDetailColorInput" value="#6aa9ff" />
          <input class="spell-detail-color-value" id="spellDetailColorValue" type="text" inputmode="text" autocomplete="off" />
        </div>
      </div>
      <div class="spell-detail-meta" id="spellDetailStatus"></div>
    </div>
    <div class="spell-detail-card">
      <div class="spell-detail-heading">Spell Details</div>
      <div class="spell-details-grid" id="spellDetailGrid"></div>
    </div>
  </div>
</div>
<div class="modal" id="spellbookConfirmModal" aria-hidden="true">
  <div class="card">
    <h2>Confirm Spellbook</h2>
    <p class="spellbook-confirm-text" id="spellbookConfirmText">Overwrite player file?</p>
    <div class="modal-actions">
      <button class="btn" id="spellbookConfirmCancel" type="button">Cancel</button>
      <button class="btn accent" id="spellbookConfirmYes" type="button">Overwrite</button>
    </div>
  </div>
</div>
<div class="spell-library-overlay" id="spellLibraryOverlay" aria-hidden="true">
  <div class="spell-library-header">
    <button class="btn" id="spellLibraryClose" type="button">Back</button>
    <div class="spell-library-title">Spellbook</div>
    <div class="spell-library-spacer"></div>
    <div class="spell-library-controls">
      <input id="spellLibrarySearch" type="search" placeholder="Search spells..." />
      <select id="spellLibrarySort">
        <option value="alpha" selected>Name</option>
        <option value="level">Level</option>
      </select>
    </div>
  </div>
  <div class="spell-library-body">
    <div class="spell-library-status" id="spellLibraryStatus">Loading spells…</div>
    <div class="spell-library-list" id="spellLibraryList"></div>
  </div>
</div>
<div class="turn-modal" id="turnModal" aria-hidden="true">
  <div class="turn-card" role="dialog" aria-live="assertive">
    <h2>It’s your turn!</h2>
    <button class="btn accent" id="turnModalOk">OK</button>
  </div>
</div>

<div id="monsterDetailOverlay" class="monster-detail-overlay hidden" role="dialog" aria-modal="true" aria-hidden="true">
  <button id="monsterDetailCloseBtn" class="close-btn" aria-label="Close" type="button">×</button>
  <div id="monsterDetailContent" class="monster-detail-content"></div>
</div>

<script>
(() => {
  const logClientError = (payload) => {
    try {
      console.error("Client error:", payload);
      fetch("/api/client-log", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify(payload),
      }).catch(() => {});
    } catch (err) {
      console.error("Failed to report client error:", err);
    }
  };

  window.onerror = (message, source, line, column, error) => {
    const stack = error?.stack ? String(error.stack) : "";
    logClientError({
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      url: location.href,
      stack: stack || `${message} at ${source}:${line}:${column}`,
    });
  };

  window.onunhandledrejection = (event) => {
    const reason = event?.reason;
    const stack = reason?.stack ? String(reason.stack) : "";
    const message = reason?.message ? String(reason.message) : String(reason || "");
    logClientError({
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      url: location.href,
      stack: stack || message || "Unhandled promise rejection",
    });
  };
})();

(() => {
  document.addEventListener("contextmenu", (e) => e.preventDefault());
  const canVibrate = "vibrate" in navigator;
  function vibrate(pattern){
    if (!canVibrate) return false;
    return navigator.vibrate(pattern);
  }

  const qs = new URLSearchParams(location.search);
  const normalizedPath = location.pathname.replace(/\/+$/, "") || "/";
  const isMapView = normalizedPath === "/map_view";
  const isPlanning = normalizedPath === "/planning";
  const supportsMapView = !isPlanning;
  const wsPath = isMapView ? "/ws_view" : "/ws";
  const wsProto = (location.protocol === "https:") ? "wss" : "ws";
  const wsOrigin = (() => {
    const origin = (location.origin && location.origin !== "null") ? location.origin : "";
    if (origin){
      return origin.replace(/^http/, "ws");
    }
    const host = location.host || location.hostname;
    return host ? `${wsProto}://${host}` : "";
  })();
  const wsUrl = wsOrigin ? `${wsOrigin}${wsPath}` : "";
  const pushPublicKey = (window.PUSH_PUBLIC_KEY || "").trim();
  const turnAlertStorageKey = "inittracker_turnAlertSubscription";
  const turnAlertHideKey = "inittracker_hideTurnAlerts";
  const spellFilterStorageKey = "inittracker_spellFilters_v2";
  const focusTabOnTurnStorageKey = "inittracker_focus_tab_on_turn";
  const clientIdStorageKey = "inittracker_client_id";
  let swRegistration = null;
  const cidWarningCache = new Set();
  const warnCid = (context, value, reason) => {
    const key = `${context}:${reason}`;
    if (cidWarningCache.has(key)) return;
    cidWarningCache.add(key);
    console.warn(`[CID normalize] ${context}: ${reason}`, {value});
  };
  const normalizeCid = (value, context = "cid") => {
    if (value === null || value === undefined || value === "") return null;
    if (typeof value === "number"){
      if (!Number.isFinite(value)){
        warnCid(context, value, "non-finite number");
        return null;
      }
      if (!Number.isInteger(value)){
        warnCid(context, value, "non-integer number");
        return null;
      }
      return value;
    }
    if (typeof value === "string"){
      const trimmed = value.trim();
      if (!trimmed) return null;
      const parsed = Number(trimmed);
      if (!Number.isFinite(parsed) || !Number.isInteger(parsed)){
        warnCid(context, value, "unusable string");
        return null;
      }
      warnCid(context, value, "coerced string to number");
      return parsed;
    }
    warnCid(context, value, `unsupported ${typeof value}`);
    return null;
  };
  const cidMatches = (left, right, context = "cidMatch") => {
    const leftCid = normalizeCid(left, `${context}.left`);
    const rightCid = normalizeCid(right, `${context}.right`);
    return leftCid !== null && rightCid !== null && leftCid === rightCid;
  };

  function setNotificationStatus(message){
    if (!notificationStatus) return;
    notificationStatus.textContent = message;
  }

  function setTurnAlertStatus(message){
    if (!turnAlertStatus) return;
    turnAlertStatus.textContent = message;
  }

  function isStandaloneDisplay(){
    return window.matchMedia("(display-mode: standalone)").matches || window.navigator.standalone;
  }

  function getTurnAlertIdentity(){
    const playerId = normalizeCid(claimedCid, "turnAlert.playerId");
    const claimedUnit = getClaimedUnit();
    const playerName = claimedUnit?.name ? String(claimedUnit.name) : "";
    return {
      playerId,
      username: null,
      playerName: playerName || null,
    };
  }

  function formatTurnAlertLabel(identity){
    if (identity?.playerName) return identity.playerName;
    if (identity?.username) return identity.username;
    if (identity?.playerId !== null && identity?.playerId !== undefined){
      return `#${identity.playerId}`;
    }
    return "";
  }

  function persistTurnAlertSubscription(subscription, identity){
    if (!subscription) return;
    const payload = {
      subscription: subscription.toJSON ? subscription.toJSON() : subscription,
      playerId: identity?.playerId ?? null,
      username: identity?.username ?? null,
      label: formatTurnAlertLabel(identity),
      createdAt: new Date().toISOString(),
    };
    try {
      localStorage.setItem(turnAlertStorageKey, JSON.stringify(payload));
    } catch (err){
      console.warn("Unable to store turn alert subscription.", err);
    }
  }

  function loadTurnAlertSubscription(){
    try {
      const raw = localStorage.getItem(turnAlertStorageKey);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (parsed && typeof parsed === "object") return parsed;
    } catch (err){
      console.warn("Unable to read turn alert subscription.", err);
    }
    return null;
  }

  function formatTurnAlertStatus(identity){
    const label = formatTurnAlertLabel(identity);
    return label ? `Subscribed (${label})` : "Subscribed";
  }

  async function syncTurnAlertSubscription(subscription, identity){
    if (!subscription || !identity?.playerId) return;
    const payload = {
      subscription: subscription.toJSON ? subscription.toJSON() : subscription,
      playerId: identity.playerId,
    };
    try {
      await fetch("/api/push/subscribe", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify(payload),
      });
    } catch (err){
      console.warn("Unable to sync turn alert subscription.", err);
    }
  }

  async function refreshTurnAlertStatus(){
    if (!turnAlertStatus) return;
    if (!isStandaloneDisplay()){
      setTurnAlertStatus("Not installed.");
      return;
    }
    if (!("Notification" in window)){
      setTurnAlertStatus("Notifications not supported.");
      return;
    }
    if (Notification.permission === "denied"){
      setTurnAlertStatus("Permission denied.");
      return;
    }
    if (!("serviceWorker" in navigator)){
      setTurnAlertStatus("Service worker unsupported.");
      return;
    }
    if (!("PushManager" in window)){
      setTurnAlertStatus("Push not supported.");
      return;
    }
    setTurnAlertStatus("Not subscribed.");
    try {
      swRegistration = swRegistration || await navigator.serviceWorker.ready;
      const existing = await swRegistration.pushManager.getSubscription();
      if (existing){
        const stored = loadTurnAlertSubscription();
        setTurnAlertStatus(formatTurnAlertStatus(stored || getTurnAlertIdentity()));
      }
    } catch (err){
      console.warn("Unable to check push subscription.", err);
    }
  }

  async function ensurePushSubscribed({vapidPublicKey, playerId}){
    if (!isStandaloneDisplay()){
      throw new Error("Not installed.");
    }
    if (!vapidPublicKey){
      throw new Error("Missing push public key.");
    }
    if (!playerId){
      throw new Error("Claim a character first.");
    }
    if (!("Notification" in window)){
      throw new Error("Notifications are not supported.");
    }
    if (!("serviceWorker" in navigator)){
      throw new Error("Service worker unsupported.");
    }
    if (!("PushManager" in window)){
      throw new Error("Push is not supported.");
    }
    try {
      swRegistration = swRegistration || await navigator.serviceWorker.ready;
    } catch (err){
      throw new Error("Service worker not ready.");
    }
    const permission = await Notification.requestPermission();
    if (permission !== "granted"){
      throw new Error(permission === "denied" ? "Permission denied." : "Permission required.");
    }
    const existing = await swRegistration.pushManager.getSubscription();
    if (existing){
      const identity = getTurnAlertIdentity();
      setTurnAlertStatus(formatTurnAlertStatus(identity));
      await syncTurnAlertSubscription(existing, identity);
      return existing;
    }
    const subscription = await swRegistration.pushManager.subscribe({
      userVisibleOnly: true,
      applicationServerKey: urlBase64ToUint8Array(vapidPublicKey),
    });
    const identity = getTurnAlertIdentity();
    persistTurnAlertSubscription(subscription, identity);
    setTurnAlertStatus(formatTurnAlertStatus(identity));
    await syncTurnAlertSubscription(subscription, identity);
    return subscription;
  }

  function routeDeepLink(url){
    if (!url) return;
    try {
      const target = new URL(url, location.origin);
      if (target.origin === location.origin){
        location.href = target.href;
      } else {
        location.href = url;
      }
    } catch (err){
      location.href = url;
    }
  }

  function urlBase64ToUint8Array(base64String){
    const padding = "=".repeat((4 - (base64String.length % 4)) % 4);
    const base64 = (base64String + padding).replace(/-/g, "+").replace(/_/g, "/");
    const rawData = atob(base64);
    const outputArray = new Uint8Array(rawData.length);
    for (let i = 0; i < rawData.length; ++i){
      outputArray[i] = rawData.charCodeAt(i);
    }
    return outputArray;
  }

  function generateClientId(){
    try {
      if (window.crypto && typeof window.crypto.randomUUID === "function"){
        return window.crypto.randomUUID();
      }
    } catch (err){
      console.warn("Unable to use crypto.randomUUID.", err);
    }
    try {
      if (window.crypto && typeof window.crypto.getRandomValues === "function"){
        const data = new Uint8Array(16);
        window.crypto.getRandomValues(data);
        return Array.from(data).map((byte) => byte.toString(16).padStart(2, "0")).join("");
      }
    } catch (err){
      console.warn("Unable to use crypto.getRandomValues.", err);
    }
    return `client_${Date.now().toString(36)}_${Math.random().toString(36).slice(2)}`;
  }

  function getClientId(){
    let existing = "";
    try {
      existing = String(localStorage.getItem(clientIdStorageKey) || "").trim();
    } catch (err){
      console.warn("Unable to read client id storage.", err);
    }
    if (existing){
      return existing;
    }
    const fresh = generateClientId();
    try {
      localStorage.setItem(clientIdStorageKey, fresh);
    } catch (err){
      console.warn("Unable to persist client id storage.", err);
    }
    return fresh;
  }

  const clientId = getClientId();

  if ("serviceWorker" in navigator){
    navigator.serviceWorker.register("/sw.js")
      .then(() => navigator.serviceWorker.ready)
      .then((registration) => {
        swRegistration = registration;
        navigator.serviceWorker.addEventListener("message", (event) => {
          const data = event.data || {};
          if (data && data.type === "deep-link" && typeof data.url === "string"){
            routeDeepLink(data.url);
          }
        });
      })
      .catch((err) => {
        console.warn("Service worker registration failed.", err);
      });
  }

  const connEl = document.getElementById("conn");
  const connFullTextEl = document.getElementById("connFullText");
  const connCompactLabelEl = document.getElementById("connCompactLabel");
  const connDotEl = document.getElementById("connDot");
  const topbarTitleEl = document.getElementById("topbarTitle");
  const mapViewTurnOrderEl = document.getElementById("mapViewTurnOrder");
  const mapViewTurnOrderStatusEl = document.getElementById("mapViewTurnOrderStatus");
  const mapViewTurnOrderBubbleEl = document.getElementById("mapViewTurnOrderBubble");
  const mapViewActiveSelectEl = document.getElementById("mapViewActiveSelect");
  const mapViewTextSizeInput = document.getElementById("mapViewTextSize");
  const mapViewBarHeightInput = document.getElementById("mapViewBarHeight");
  const mapViewChipPaddingInput = document.getElementById("mapViewChipPadding");
  const mapViewChipGapInput = document.getElementById("mapViewChipGap");
  const mapViewCornerRadiusInput = document.getElementById("mapViewCornerRadius");
  const mapViewShowTitleInput = document.getElementById("mapViewShowTitle");
  const mapViewShowStatusInput = document.getElementById("mapViewShowStatus");
  const mapViewShowIndexInput = document.getElementById("mapViewShowIndex");
  const connPopoverEl = document.getElementById("connPopover");
  const connPopoverStatusEl = document.getElementById("connPopoverStatus");
  const connReconnectBtn = document.getElementById("connReconnectBtn");
  const connStyleButtons = Array.from(document.querySelectorAll(".conn-style-btn"));
  const meEl = document.getElementById("me");
  const moveEl = document.getElementById("move");
  const actionEl = document.getElementById("action");
  const bonusActionEl = document.getElementById("bonusAction");
  const reactionEl = document.getElementById("reaction");
  const turnEl = document.getElementById("turn");
  const spellSlotMonitorEl = document.getElementById("spellSlotMonitor");
  const activeTurnOrderEl = mapViewTurnOrderEl;
  const activeTurnOrderStatusEl = mapViewTurnOrderStatusEl;
  const activeTurnOrderBubbleEl = mapViewTurnOrderBubbleEl;
  if (activeTurnOrderEl){
    activeTurnOrderEl.addEventListener("mouseleave", () => {
      hoveredTurnCid = null;
      hideTurnOrderBubble();
    });
  }
  const noteEl = document.getElementById("note");
  const colorModal = document.getElementById("colorModal");
  const tokenColorInput = document.getElementById("tokenColorInput");
  const tokenColorSwatch = document.getElementById("tokenColorSwatch");
  const tokenColorConfirm = document.getElementById("tokenColorConfirm");
  const tokenColorCancel = document.getElementById("tokenColorCancel");
  const tokenColorModeBtn = document.getElementById("tokenColorModeBtn");
  const dashModal = document.getElementById("dashModal");
  const dashActionBtn = document.getElementById("dashAction");
  const dashBonusActionBtn = document.getElementById("dashBonusAction");
  const dashCancelBtn = document.getElementById("dashCancel");
  const actionPickerModal = document.getElementById("actionPickerModal");
  const actionPickerTitle = document.getElementById("actionPickerTitle");
  const actionPickerList = document.getElementById("actionPickerList");
  const actionPickerCancelBtn = document.getElementById("actionPickerCancel");
  const battleLogBtn = document.getElementById("battleLog");
  const lockMapBtn = document.getElementById("lockMap");
  const lockAoeBtn = document.getElementById("lockAoeToggle");
  const centerMapBtn = document.getElementById("centerMap");
  const zoomInBtn = document.getElementById("zoomIn");
  const zoomOutBtn = document.getElementById("zoomOut");
  const dashBtn = document.getElementById("dash");
  const configBtn = document.getElementById("configBtn");
  const initiativeToggleBtn = document.getElementById("initiativeToggleBtn");
  const adminMenuBtn = document.getElementById("adminMenuBtn");
  const adminMenuPopover = document.getElementById("adminMenuPopover");
  const adminMenuOpenBtn = document.getElementById("adminMenuOpen");
  const adminMenuRefreshBtn = document.getElementById("adminMenuRefresh");
  const adminMenuResetPcsBtn = document.getElementById("adminMenuResetPcs");
  const configModal = document.getElementById("configModal");
  const configCloseBtn = document.getElementById("configClose");
  const adminModal = document.getElementById("adminModal");
  const adminLoginModal = document.getElementById("adminLoginModal");
  const adminPasswordInput = document.getElementById("adminPasswordInput");
  const adminLoginStatus = document.getElementById("adminLoginStatus");
  const adminLoginSubmit = document.getElementById("adminLoginSubmit");
  const adminLoginCancel = document.getElementById("adminLoginCancel");
  const adminSessionList = document.getElementById("adminSessionList");
  const adminStatus = document.getElementById("adminStatus");
  const adminRefreshBtn = document.getElementById("adminRefresh");
  const adminCloseBtn = document.getElementById("adminClose");
  const rosterPickerModal = document.getElementById("rosterPickerModal");
  const rosterPickerList = document.getElementById("rosterPickerList");
  const rosterPickerStatus = document.getElementById("rosterPickerStatus");
  const rosterPickerRefreshBtn = document.getElementById("rosterPickerRefresh");
  const rosterPickerAddBtn = document.getElementById("rosterPickerAdd");
  const rosterPickerCloseBtn = document.getElementById("rosterPickerClose");
  const preSummonTargetInput = document.getElementById("preSummonTarget");
  const preSummonSpellInput = document.getElementById("preSummonSpell");
  const preSummonMonsterInput = document.getElementById("preSummonMonster");
  const preSummonVariantInput = document.getElementById("preSummonVariant");
  const preSummonSlotLevelInput = document.getElementById("preSummonSlotLevel");
  const assignPreSummonBtn = document.getElementById("assignPreSummon");
  const toggleTopbarTitle = document.getElementById("toggleTopbarTitle");
  const toggleConnIndicator = document.getElementById("toggleConnIndicator");
  const toggleLockMap = document.getElementById("toggleLockMap");
  const toggleCenterMap = document.getElementById("toggleCenterMap");
  const toggleMeasure = document.getElementById("toggleMeasure");
  const toggleMeasureClear = document.getElementById("toggleMeasureClear");
  const toggleZoomIn = document.getElementById("toggleZoomIn");
  const toggleZoomOut = document.getElementById("toggleZoomOut");
  const toggleBattleLog = document.getElementById("toggleBattleLog");
  const initiativeStyleSelect = document.getElementById("initiativeStyleSelect");
  const toggleUseAction = document.getElementById("toggleUseAction");
  const toggleUseBonusAction = document.getElementById("toggleUseBonusAction");
  const toggleDash = document.getElementById("toggleDash");
  const toggleStandUp = document.getElementById("toggleStandUp");
  const toggleResetTurn = document.getElementById("toggleResetTurn");
  const toggleSpellMenu = document.getElementById("toggleSpellMenu");
  const toggleLockMenus = document.getElementById("toggleLockMenus");
  const presetSaveBtn = document.getElementById("savePreset");
  const presetLoadBtn = document.getElementById("loadPreset");
  const presetStatus = document.getElementById("presetStatus");
  const enableNotificationsBtn = document.getElementById("enableNotifications");
  const notificationStatus = document.getElementById("notificationStatus");
  const focusTabOnTurnInput = document.getElementById("focusTabOnTurn");
  const unlockAudioBtn = document.getElementById("unlockAudio");
  const enableTurnAlertsBtn = document.getElementById("enableTurnAlerts");
  const hideTurnAlertsBtn = document.getElementById("hideTurnAlerts");
  const turnAlertsPanel = document.getElementById("turnAlertsPanel");
  const turnAlertStatus = document.getElementById("turnAlertStatus");
  const hotkeyTopbarTitleInput = document.getElementById("hotkeyTopbarTitle");
  const hotkeyConnStyleInput = document.getElementById("hotkeyConnStyle");
  const hotkeyLockMapInput = document.getElementById("hotkeyLockMap");
  const hotkeyCenterMapInput = document.getElementById("hotkeyCenterMap");
  const hotkeyMeasureInput = document.getElementById("hotkeyMeasure");
  const hotkeyMeasureClearInput = document.getElementById("hotkeyMeasureClear");
  const hotkeyZoomInInput = document.getElementById("hotkeyZoomIn");
  const hotkeyZoomOutInput = document.getElementById("hotkeyZoomOut");
  const hotkeyBattleLogInput = document.getElementById("hotkeyBattleLog");
  const hotkeyUseActionInput = document.getElementById("hotkeyUseAction");
  const toggleDmLogPanelInput = document.getElementById("toggleDmLogPanel");
  const toggleDmMapPreviewInput = document.getElementById("toggleDmMapPreview");
  const hotkeyUseBonusActionInput = document.getElementById("hotkeyUseBonusAction");
  const hotkeyDashInput = document.getElementById("hotkeyDash");
  const hotkeyStandUpInput = document.getElementById("hotkeyStandUp");
  const hotkeyResetTurnInput = document.getElementById("hotkeyResetTurn");
  const iosInstallHint = document.getElementById("iosInstallHint");
  const measureToggle = document.getElementById("measureToggle");
  const measureClear = document.getElementById("measureClear");
  const logModal = document.getElementById("logModal");
  const logContent = document.getElementById("logContent");
  const logRefreshBtn = document.getElementById("logRefresh");
  const logCloseBtn = document.getElementById("logClose");
  const dmSideLayout = document.getElementById("dmSideLayout");
  const dmLogPanel = document.getElementById("dmLogPanel");
  const dmLogList = document.getElementById("dmLogList");
  const dmMapPreview = document.getElementById("dmMapPreview");
  const dmPreviewCanvas = document.getElementById("dmPreviewCanvas");
  const dmLogAutoScrollInput = document.getElementById("dmLogAutoScroll");
  const dmLogFilterInputs = Array.from(document.querySelectorAll("input[data-log-filter]"));
  const waitingOverlay = document.getElementById("waitingOverlay");
  const claimModal = document.getElementById("claimModal");
  const claimListEl = document.getElementById("claimList");
  const claimEmptyHint = document.getElementById("claimEmptyHint");
  const claimConfirmBtn = document.getElementById("claimConfirm");
  const claimSpectatorBtn = document.getElementById("claimSpectator");
  const claimContinueBtn = document.getElementById("claimContinue");
  const turnModal = document.getElementById("turnModal");
  const turnModalOk = document.getElementById("turnModalOk");
  const switchCharacterBtn = document.getElementById("switchCharacter");
  const useActionBtn = document.getElementById("useAction");
  const useBonusActionBtn = document.getElementById("useBonusAction");
  const actionSelectEl = document.getElementById("actionSelect");
  const bonusActionSelectEl = document.getElementById("bonusActionSelect");
  const resetTurnBtn = document.getElementById("resetTurn");
  const standUpBtn = document.getElementById("standUp");
  const dismissSummonsBtn = document.getElementById("dismissSummons");
  const endTurnBtn = document.getElementById("endTurn");
  const mountBtn = document.getElementById("mountBtn");
  const dismountBtn = document.getElementById("dismountBtn");
  const mountPromptModal = document.getElementById("mountPromptModal");
  const mountPromptBody = document.getElementById("mountPromptBody");
  const mountPromptYes = document.getElementById("mountPromptYes");
  const mountPromptNo = document.getElementById("mountPromptNo");
  const showAllNamesEl = document.getElementById("showAllNames");
  const castOverlay = document.getElementById("sheetCastView");
  const castOverlayOpenBtn = document.getElementById("castOverlayOpen");
  const castOverlayBackBtn = document.getElementById("castOverlayBack");
  const castMenuTrigger = document.getElementById("castMenuTrigger");
  const castPanel = document.getElementById("castPanel");
  const castForm = document.getElementById("castForm");
  const castSearchInput = document.getElementById("castSearch");
  const openSpellFiltersBtn = document.getElementById("openSpellFilters");
  const closeSpellFiltersBtn = document.getElementById("closeSpellFilters");
  const applySpellFiltersBtn = document.getElementById("applySpellFilters");
  const clearSpellFiltersBtn = document.getElementById("clearSpellFilters");
  const spellFilterModal = document.getElementById("spellFilterModal");
  const spellFilterSummary = document.getElementById("spellFilterSummary");
  const castFilterLevelMinInput = document.getElementById("castFilterLevelMin");
  const castFilterLevelMaxInput = document.getElementById("castFilterLevelMax");
  const castFilterSchoolOptions = document.getElementById("castFilterSchoolOptions");
  const castFilterTagOptions = document.getElementById("castFilterTagOptions");
  const castFilterListOptions = document.getElementById("castFilterListOptions");
  const castFilterSchoolMulti = document.getElementById("castFilterSchoolMulti");
  const castFilterTagMulti = document.getElementById("castFilterTagMulti");
  const castFilterListMulti = document.getElementById("castFilterListMulti");
  const castFilterCastingTimeInput = document.getElementById("castFilterCastingTime");
  const castFilterRangeInput = document.getElementById("castFilterRange");
  const castFilterRitualInput = document.getElementById("castFilterRitual");
  const castFilterConcentrationInput = document.getElementById("castFilterConcentration");
  const castPresetInput = document.getElementById("castPreset");
  const castManualEntryBadge = document.getElementById("castManualEntryBadge");
  const planningBtn = document.getElementById("planningBtn");
  const spellLibraryBtn = document.getElementById("spellLibraryBtn");
  const spellLibraryOverlay = document.getElementById("spellLibraryOverlay");
  const spellLibraryCloseBtn = document.getElementById("spellLibraryClose");
  const spellLibrarySearchInput = document.getElementById("spellLibrarySearch");
  const spellLibrarySortSelect = document.getElementById("spellLibrarySort");
  const spellLibraryStatus = document.getElementById("spellLibraryStatus");
  const spellLibraryList = document.getElementById("spellLibraryList");
  const spellbookOpenBtn = document.getElementById("spellbookOpen");
  const spellbookOverlay = document.getElementById("spellbookOverlay");
  const spellbookBackBtn = document.getElementById("spellbookBack");
  const spellbookBackFloatingBtn = document.getElementById("spellbookBackFloating");
  const spellbookSaveBtn = document.getElementById("spellbookSave");
  const spellbookTabKnown = document.getElementById("spellbookTabKnown");
  const spellbookTabPrepared = document.getElementById("spellbookTabPrepared");
  const spellbookKnownEnabledToggle = document.getElementById("spellbookKnownEnabled");
  const spellbookSearchInput = document.getElementById("spellbookSearch");
  const spellbookSortSelect = document.getElementById("spellbookSort");
  const spellbookLeftTitle = document.getElementById("spellbookLeftTitle");
  const spellbookRightTitle = document.getElementById("spellbookRightTitle");
  const spellbookLeftList = document.getElementById("spellbookLeftList");
  const spellbookRightList = document.getElementById("spellbookRightList");
  const spellbookAddBtn = document.getElementById("spellbookAdd");
  const spellbookRemoveBtn = document.getElementById("spellbookRemove");
  const spellbookStatus = document.getElementById("spellbookStatus");
  const spellbookConfirmModal = document.getElementById("spellbookConfirmModal");
  const spellbookConfirmText = document.getElementById("spellbookConfirmText");
  const spellbookConfirmCancel = document.getElementById("spellbookConfirmCancel");
  const spellbookConfirmYes = document.getElementById("spellbookConfirmYes");
  const spellDetailOverlay = document.getElementById("spellDetailOverlay");
  const spellDetailBackBtn = document.getElementById("spellDetailBack");
  const spellDetailTitle = document.getElementById("spellDetailTitle");
  const spellDetailName = document.getElementById("spellDetailName");
  const spellDetailMeta = document.getElementById("spellDetailMeta");
  const spellDetailGrid = document.getElementById("spellDetailGrid");
  const spellDetailColorInput = document.getElementById("spellDetailColorInput");
  const spellDetailColorSwatch = document.getElementById("spellDetailColorSwatch");
  const spellDetailColorValue = document.getElementById("spellDetailColorValue");
  const spellDetailStatus = document.getElementById("spellDetailStatus");
  const monsterDetailOverlay = document.getElementById("monsterDetailOverlay");
  const monsterDetailCloseBtn = document.getElementById("monsterDetailCloseBtn");
  const monsterDetailContent = document.getElementById("monsterDetailContent");
  const castNameInput = document.getElementById("castName");
  const castSubmitBtn = document.getElementById("castSubmit");
  const aoeOptions = document.getElementById("aoeOptions");
  const summonOptions = document.getElementById("summonOptions");
  const castSummonChoiceInput = document.getElementById("castSummonChoice");
  const castSummonVariantInput = document.getElementById("castSummonVariant");
  const castSummonQuantityInput = document.getElementById("castSummonQuantity");
  const castSummonMeta = document.getElementById("castSummonMeta");
  const castShapeInput = document.getElementById("castShape");
  const castRadiusField = document.getElementById("castRadiusField");
  const castSideField = document.getElementById("castSideField");
  const castLengthField = document.getElementById("castLengthField");
  const castWidthField = document.getElementById("castWidthField");
  const castAngleField = document.getElementById("castAngleField");
  const castOrientField = document.getElementById("castOrientField");
  const castThicknessField = document.getElementById("castThicknessField");
  const castHeightField = document.getElementById("castHeightField");
  const castRadiusInput = document.getElementById("castRadius");
  const castSideInput = document.getElementById("castSide");
  const castLengthInput = document.getElementById("castLength");
  const castWidthInput = document.getElementById("castWidth");
  const castAngleInput = document.getElementById("castAngle");
  const castOrientInput = document.getElementById("castOrient");
  const castThicknessInput = document.getElementById("castThickness");
  const castHeightInput = document.getElementById("castHeight");
  const castDcTypeInput = document.getElementById("castDcType");
  const castDcValueInput = document.getElementById("castDcValue");
  const castDefaultDamageInput = document.getElementById("castDefaultDamage");
  const castDiceInput = document.getElementById("castDice");
  const castSlotLevelInput = document.getElementById("castSlotLevel");
  const castDamageTypeInput = document.getElementById("castDamageType");
  const castDamageTypeList = document.getElementById("castDamageTypeList");
  const castAddDamageTypeBtn = document.getElementById("castAddDamageType");
  const castColorInput = document.getElementById("castColor");
  const spellPresetDetails = document.getElementById("spellPresetDetails");
  const sheetWrap = document.getElementById("sheetWrap");
  const sheet = document.getElementById("sheet");
  const sheetHandle = document.getElementById("sheetHandle");
  const tokenTooltip = document.getElementById("tokenTooltip");
  const summonPlacementBanner = document.getElementById("summonPlacementBanner");
  const clientInitPayload = {
    timestamp: new Date().toISOString(),
    userAgent: navigator.userAgent,
    url: location.href,
    message: "LAN client initialized",
    stack: "",
  };
  console.info("LAN client initialized");
  document.documentElement.dataset.lanBoot = "true";
  try {
    fetch("/api/client-log", {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify(clientInitPayload),
    }).catch(() => {});
  } catch (err) {
    console.warn("Failed to report LAN client init:", err);
  }
  const turnAlertAudio = new Audio("/assets/alert.wav");
  turnAlertAudio.preload = "auto";
  const koAlertAudio = new Audio("/assets/ko.wav");
  koAlertAudio.preload = "auto";
  let audioUnlocked = false;
  let focusTabOnTurn = localStorage.getItem(focusTabOnTurnStorageKey) === "1";
  let pendingTurnAlert = false;
  let pendingVibrate = false;
  let lastVibrateSupported = canVibrate;
  let userHasInteracted = navigator.userActivation?.hasBeenActive ?? false;
  let castOverlayPreviousFocus = null;
  let pendingSpellActionType = null;
  let pendingSummonPlacement = null;
  let summonValidCells = new Set();
  const preparedSpellDefaults = {
    prepared: [],
    max: null,
    maxFormula: "",
    known: [],
    knownLimit: null,
    knownEnabled: true,
    cantrips: [],
    cantripsMax: null,
  };

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  let ws = null;
  let state = null;
  let planningSnapshotLocked = false;
  let reconnectTimer = null;
  let reconnecting = false;
  let claimedCid = null;
  let rosterShownOnStart = false;
  claimedCid = normalizeCid(claimedCid, "init.claimedCid");
  let shownNoOwnedToast = false;
  let pendingClaim = null;
  let lastPcList = [];
  let claimStaticDataSeen = false;
  let claimStateSeen = false;
  let claimDataReady = false;
  let claimRenderRetryTimer = null;
  const claimRenderRetryDelayMs = 500;
  let allowUnclaimed = false;
  let selectedClaimCid = null;
  const lanSelectedCidKey = "lan_selected_cid";
  const lanSelectedNameKey = "lan_selected_name";
  const autoClaimTimeoutMs = 1500;
  let autoClaimPending = null;
  let autoClaimChecked = false;
  let claimInFlight = false;
  let claimInFlightCid = null;
  let claimInFlightTimeoutId = null;
  const claimInFlightTimeoutMs = 8000;
  let claimStatus = "unclaimed";
  let claimRev = 0;
  let stateUpdateCounter = 0;
  let lastActiveCid = null;
  let lastTurnRound = null;
  let selectedTurnCid = null;
  let pendingMountRequestId = null;
  let pendingMountPair = null;
  let hoveredTurnCid = null;
  let adminSessions = [];
  const adminTokenKey = "inittracker_admin_auth";
  let adminAuthPromise = null;
  let adminAuthResolve = null;
  let adminAuthReject = null;
  const claimDebugLoggingEnabled = window.location.hostname === "localhost"
    || window.location.hostname === "127.0.0.1";

  // view transform
  let zoom = 32; // px per square
  let panX = 0, panY = 0;
  let dragging = null; // {cid, startX, startY, origCol, origRow}
  let aoeDragging = null; // {aid, offsetCol, offsetRow, isRotating}
  let aoeDragPreview = null; // {aid, cx, cy, angle_deg, ax, ay, spread_deg}
  let aoeDragPending = null; // {pointerId, aid, offsetCol, offsetRow, centerCol, centerRow, startX, startY, timerId}
  let panning = null;  // {x,y, panX, panY}
  let shiftMoveMode = false;
  const isShiftKey = (event) => (
    event?.key === "Shift"
    || event?.code === "ShiftLeft"
    || event?.code === "ShiftRight"
  );
  let centeredCid = null;
  let initialCenterDone = false;
  let initialCenterFallback = false;
  let lockMap = false;
  let lastGrid = {cols: null, rows: null};
  let lastGridVersion = null;
  let fittedToGrid = false;
  let showAllNames = localStorage.getItem("inittracker_showAllNames") === "1";
  let measurementMode = false;
  let measurement = {start: null, end: null};
  let losPreview = null; // {start:{col,row}, end:{col,row}, blocked, expiresAt}
  const LOS_PREVIEW_MS = 900;
  const sheetHeightKey = "inittracker_sheetHeight";
  const lockMyAoesKey = "inittracker_lock_my_aoes";
  const uiToggleKeys = {
    topbarTitle: "inittracker_ui_topbarTitle",
    connIndicator: "inittracker_ui_connIndicator",
    lockMap: "inittracker_ui_lockMap",
    centerMap: "inittracker_ui_centerMap",
    measure: "inittracker_ui_measure",
    measureClear: "inittracker_ui_measureClear",
    zoomIn: "inittracker_ui_zoomIn",
    zoomOut: "inittracker_ui_zoomOut",
    battleLog: "inittracker_ui_battleLog",
    useAction: "inittracker_ui_useAction",
    useBonusAction: "inittracker_ui_useBonusAction",
    dash: "inittracker_ui_dash",
    standUp: "inittracker_ui_standUp",
    resetTurn: "inittracker_ui_resetTurn",
    hideSpellMenu: "inittracker_ui_hideSpellMenu",
    lockMenus: "inittracker_lockMenus",
  };
  const uiSelectKeys = {
    connStyle: "inittracker_ui_connStyle",
    initiativeStyle: "inittracker_ui_initiativeStyle",
  };
  const mapViewSettingsKey = "inittracker_map_view_settings";
  const dmUiPrefsKey = "inittracker_dm_ui_prefs";
  let dmLogLines = [];
  let dmHighlightUntil = new Map();
  let dmUiPrefs = {showMapPreview:false, showLogPanel:false, autoScroll:true, filters:{attack:true,damage:true,save:true,heal:true,spell:true}};
  try { dmUiPrefs = {...dmUiPrefs, ...(JSON.parse(localStorage.getItem(dmUiPrefsKey)||"{}")||{})}; } catch(_) {}

  let showTopbarTitle = readToggle(uiToggleKeys.topbarTitle, true);
  let showConnIndicator = readToggle(uiToggleKeys.connIndicator, true);
  let showLockMap = readToggle(uiToggleKeys.lockMap, true);
  let showCenterMap = readToggle(uiToggleKeys.centerMap, true);
  let showMeasure = readToggle(uiToggleKeys.measure, true);
  let showMeasureClear = readToggle(uiToggleKeys.measureClear, true);
  let showZoomIn = readToggle(uiToggleKeys.zoomIn, true);
  let showZoomOut = readToggle(uiToggleKeys.zoomOut, true);
  let showBattleLog = readToggle(uiToggleKeys.battleLog, true);
  let showUseAction = readToggle(uiToggleKeys.useAction, true);
  let showUseBonusAction = readToggle(uiToggleKeys.useBonusAction, true);
  let showDash = readToggle(uiToggleKeys.dash, true);
  let showStandUp = readToggle(uiToggleKeys.standUp, true);
  let showResetTurn = readToggle(uiToggleKeys.resetTurn, true);
  let hideSpellMenu = readToggle(uiToggleKeys.hideSpellMenu, false);
  let menusLocked = readToggle(uiToggleKeys.lockMenus, false);
  let lockMyAoes = readToggle(lockMyAoesKey, true);
  let mapViewSettings = null;
  let connStyle = "full";
  let initiativeStyle = "full";
  let sheetHeight = null;
  if (turnAlertStatus){
    refreshTurnAlertStatus();
  }
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
  const isSafariEngine = /AppleWebKit/.test(navigator.userAgent);
  const isAltBrowser = /CriOS|FxiOS|EdgiOS|OPiOS/.test(navigator.userAgent);
  const isStandalone = window.navigator.standalone === true;
  if (document.body){
    document.body.classList.toggle("map-view", isMapView);
    document.body.classList.toggle("map-view-only", isMapView);
    document.body.classList.toggle("planning-view", isPlanning);
  }
  if (iosInstallHint){
    const showHint = isIOS && isSafariEngine && !isAltBrowser && !isStandalone;
    iosInstallHint.classList.toggle("hidden", !showHint);
  }
  if (turnAlertsPanel){
    const hideTurnAlerts = localStorage.getItem(turnAlertHideKey) === "1";
    const shouldHideAlerts = !isIOS || hideTurnAlerts;
    turnAlertsPanel.classList.toggle("hidden", shouldHideAlerts);
  }
  applyMapViewSettings(readMapViewSettings());
  if (isMapView){ dmUiPrefs.showLogPanel = dmUiPrefs.showLogPanel === true; dmUiPrefs.showMapPreview = dmUiPrefs.showMapPreview === true; renderDmLogPanel(); }
  function applyMapViewReadOnlyControls(){
    if (!isMapView) return;
    const controls = [
      useActionBtn,
      useBonusActionBtn,
      dashBtn,
      standUpBtn,
      resetTurnBtn,
      endTurnBtn,
      actionSelectEl,
      bonusActionSelectEl,
    ];
    controls.forEach((control) => {
      if (!control) return;
      control.disabled = true;
      control.setAttribute("aria-disabled", "true");
    });
  }
  function updateEndTurnState(){
    if (!endTurnBtn) return;
    const needsClaim = claimedCid === null || claimedCid === undefined;
    const shouldDisable = isMapView || needsClaim;
    endTurnBtn.disabled = shouldDisable;
    endTurnBtn.setAttribute("aria-disabled", shouldDisable ? "true" : "false");
    let titleText = "";
    if (needsClaim){
      titleText = "Claim a character first, matey.";
    } else if (isMapView){
      titleText = "Map view is read-only.";
    }
    if (titleText){
      endTurnBtn.setAttribute("title", titleText);
    } else {
      endTurnBtn.removeAttribute("title");
    }
  }
  applyMapViewReadOnlyControls();
  updateEndTurnState();
  if (showAllNamesEl){
    showAllNamesEl.checked = showAllNames;
    showAllNamesEl.addEventListener("change", (ev) => {
      showAllNames = !!ev.target.checked;
      localStorage.setItem("inittracker_showAllNames", showAllNames ? "1" : "0");
      draw();
    });
  }

  window.addEventListener("resize", () => {
    if (sheetWrap){
      applySheetHeight(sheetHeight);
    }
  });
  updateSpellbookViewportHeight();
  window.addEventListener("resize", updateSpellbookViewportHeight);
  if (window.visualViewport){
    window.visualViewport.addEventListener("resize", updateSpellbookViewportHeight);
    window.visualViewport.addEventListener("scroll", updateSpellbookViewportHeight);
  }

  function updateConnDisplay(){
    if (connFullTextEl) connFullTextEl.textContent = connStatusText;
    if (connEl) connEl.setAttribute("title", connStatusText);
    if (connCompactLabelEl) connCompactLabelEl.textContent = "C";
    if (connDotEl){
      connDotEl.style.background = connStatusOk ? "var(--accent)" : "var(--danger)";
    }
    if (connPopoverStatusEl){
      connPopoverStatusEl.textContent = connStatusText;
    }
  }

  function setConn(ok, txt){
    connStatusOk = !!ok;
    connStatusText = String(txt || "");
    if (connEl){
      connEl.style.borderColor = connStatusOk ? "rgba(106,169,255,0.35)" : "rgba(255,91,91,0.35)";
      connEl.style.background = connStatusOk ? "rgba(106,169,255,0.14)" : "rgba(255,91,91,0.14)";
    }
    updateConnDisplay();
  }

  function setConnPopover(open){
    if (!connPopoverEl || !connEl) return;
    connPopoverEl.classList.toggle("show", open);
    connPopoverEl.setAttribute("aria-hidden", open ? "false" : "true");
    connEl.setAttribute("aria-expanded", open ? "true" : "false");
  }

  function closeConnPopover(){
    setConnPopover(false);
  }

  function scheduleReconnect(delayMs){
    if (reconnectTimer){
      clearTimeout(reconnectTimer);
    }
    reconnectTimer = setTimeout(() => {
      reconnectTimer = null;
      connect();
    }, delayMs);
  }

  function softReconnect(){
    reconnecting = true;
    setConn(false, "Reconnecting…");
    closeConnPopover();
    if (ws && ws.readyState === 1){
      ws.close(4001, "reconnect");
    } else {
      scheduleReconnect(200);
    }
  }

  function resize(){
    const r = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.max(1, Math.floor(r.width * dpr));
    canvas.height = Math.max(1, Math.floor(r.height * dpr));
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }
  window.addEventListener("resize", resize);

  function getSheetConstraints(){
    const viewportHeight = window.innerHeight || 0;
    const min = Math.max(180, Math.round(viewportHeight * 0.2));
    const max = Math.max(min + 80, Math.round(viewportHeight * 0.7));
    return {min, max};
  }

  function updateModalOffsets(){
    const topbarHeight = document.querySelector(".topbar")?.getBoundingClientRect().height || 0;
    const sheetHeight = document.getElementById("sheetWrap")?.getBoundingClientRect().height || 0;
    const rootStyle = document.documentElement.style;
    rootStyle.setProperty("--modalTopOffset", `${topbarHeight}px`);
    rootStyle.setProperty("--modalBottomOffset", `${sheetHeight}px`);
    rootStyle.setProperty("--topbar-height", `${topbarHeight}px`);
    rootStyle.setProperty("--bottombar-height", `${sheetHeight}px`);
  }

  function updateSpellbookViewportHeight(){
    const viewportHeight = window.visualViewport?.height || window.innerHeight || 0;
    const vh = Math.max(1, viewportHeight) * 0.01;
    document.documentElement.style.setProperty("--spellbook-vh", `${vh}px`);
  }

  function readMapViewSettings(){
    const defaults = {
      textSize: 14,
      barHeight: 84,
      chipPadding: 6,
      chipGap: 8,
      cornerRadius: 40,
      showTitle: true,
      showStatus: true,
      showIndex: true,
    };
    try {
      const raw = localStorage.getItem(mapViewSettingsKey);
      if (!raw){
        return defaults;
      }
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== "object"){
        return defaults;
      }
      return {
        ...defaults,
        ...parsed,
      };
    } catch (err){
      return defaults;
    }
  }

  function applyMapViewSettings(settings){
    if (!settings){
      return;
    }
    mapViewSettings = settings;
    const rootStyle = document.documentElement.style;
    rootStyle.setProperty("--map-view-order-font-size", `${settings.textSize}px`);
    rootStyle.setProperty("--map-view-bar-height", `${settings.barHeight}px`);
    rootStyle.setProperty("--map-view-order-chip-pad-y", `${settings.chipPadding}px`);
    rootStyle.setProperty("--map-view-order-chip-pad-x", `${Math.max(6, settings.chipPadding + 4)}px`);
    rootStyle.setProperty("--map-view-order-gap", `${settings.chipGap}px`);
    rootStyle.setProperty("--map-view-order-radius", `${settings.cornerRadius}px`);
    if (document.body){
      document.body.classList.toggle("map-view-hide-title", !settings.showTitle);
      document.body.classList.toggle("map-view-hide-status", !settings.showStatus);
      document.body.classList.toggle("map-view-hide-index", !settings.showIndex);
    }
    if (mapViewTextSizeInput){
      mapViewTextSizeInput.value = String(settings.textSize);
    }
    if (mapViewBarHeightInput){
      mapViewBarHeightInput.value = String(settings.barHeight);
    }
    if (mapViewChipPaddingInput){
      mapViewChipPaddingInput.value = String(settings.chipPadding);
    }
    if (mapViewChipGapInput){
      mapViewChipGapInput.value = String(settings.chipGap);
    }
    if (mapViewCornerRadiusInput){
      mapViewCornerRadiusInput.value = String(settings.cornerRadius);
    }
    if (mapViewShowTitleInput){
      mapViewShowTitleInput.checked = !!settings.showTitle;
    }
    if (mapViewShowStatusInput){
      mapViewShowStatusInput.checked = !!settings.showStatus;
    }
    if (mapViewShowIndexInput){
      mapViewShowIndexInput.checked = !!settings.showIndex;
    }
  }

  function persistMapViewSettings(){
    if (!mapViewSettings){
      return;
    }
    try {
      localStorage.setItem(mapViewSettingsKey, JSON.stringify(mapViewSettings));
    } catch (err){
      console.warn("Failed to persist map view settings.", err);
    }
  }

  function applySheetHeight(value){
    if (!sheetWrap) return;
    const {min, max} = getSheetConstraints();
    let target = Number(value);
    if (!Number.isFinite(target)){
      target = Math.round((min + max) / 2);
    }
    target = Math.min(max, Math.max(min, target));
    sheetWrap.style.height = `${target}px`;
    sheetWrap.style.minHeight = `${min}px`;
    sheetWrap.style.maxHeight = `${max}px`;
    sheetHeight = target;
    resize();
    updateModalOffsets();
  }

  function setCastOverlayOpen(open){
    if (!castOverlay) return;
    castOverlay.classList.toggle("show", open);
    castOverlay.classList.toggle("hidden", !open);
    castOverlay.setAttribute("aria-hidden", open ? "false" : "true");
    if (sheet){
      sheet.classList.toggle("hidden", open);
    }
    if (!open){
      pendingSpellActionType = null;
    }
    if (open){
      castOverlayPreviousFocus = document.activeElement instanceof HTMLElement
        ? document.activeElement
        : null;
      requestAnimationFrame(() => {
        castOverlayBackBtn?.focus();
      });
      applyDefaultSpellSaveDc();
    } else if (castOverlayPreviousFocus){
      castOverlayPreviousFocus.focus();
      castOverlayPreviousFocus = null;
    }
    updateModalOffsets();
    resize();
  }

  function getClaimedPlayerName(){
    const claimedUnit = getClaimedUnit();
    if (!claimedUnit?.name) return null;
    return String(claimedUnit.name);
  }

  function getPlayerProfile(name){
    if (!name) return null;
    const profiles = state?.player_profiles;
    if (!profiles || typeof profiles !== "object") return null;
    const profile = profiles[name];
    if (!profile || typeof profile !== "object") return null;
    return profile;
  }

  const spellSlotNumerals = ["I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];

  function getSpellSlotLevels(profile){
    const slots = profile?.spellcasting?.spell_slots;
    if (!slots || typeof slots !== "object") return [];
    const levels = [];
    for (let level = 1; level <= 9; level += 1){
      const entry = Array.isArray(slots)
        ? slots[level - 1]
        : (slots[String(level)] ?? slots[level]);
      let maxValue = 0;
      let currentValue = 0;
      if (entry && typeof entry === "object"){
        maxValue = Number(entry.max ?? entry.total ?? entry.slots ?? 0);
        currentValue = Number(entry.current ?? entry.remaining ?? entry.max ?? maxValue);
      } else {
        maxValue = Number(entry ?? 0);
        currentValue = maxValue;
      }
      if (!Number.isFinite(maxValue)) maxValue = 0;
      if (!Number.isFinite(currentValue)) currentValue = maxValue;
      maxValue = Math.max(0, Math.floor(maxValue));
      currentValue = Math.max(0, Math.min(Math.floor(currentValue), maxValue));
      levels.push({level, max: maxValue, current: currentValue});
    }
    return levels;
  }

  function getAvailableSlotCountAtOrAbove(profile, minLevel){
    const levelFloor = Number.isFinite(Number(minLevel)) ? Math.max(1, Math.floor(Number(minLevel))) : 1;
    return getSpellSlotLevels(profile)
      .filter((entry) => entry.level >= levelFloor)
      .reduce((sum, entry) => sum + Math.max(0, Number(entry.current) || 0), 0);
  }

  function renderSpellSlotMonitor(){
    if (!spellSlotMonitorEl) return;
    const playerName = getClaimedPlayerName();
    const profile = getPlayerProfile(playerName);
    const levels = getSpellSlotLevels(profile).filter((entry) => entry.max > 0);
    spellSlotMonitorEl.textContent = "";
    if (!levels.length){
      spellSlotMonitorEl.classList.add("is-empty");
      return;
    }
    spellSlotMonitorEl.classList.remove("is-empty");
    levels.forEach((entry) => {
      const levelWrap = document.createElement("div");
      levelWrap.className = "spell-slot-level";
      const label = document.createElement("span");
      label.textContent = spellSlotNumerals[entry.level - 1] || String(entry.level);
      levelWrap.appendChild(label);
      const squaresWrap = document.createElement("div");
      squaresWrap.className = "spell-slot-squares";
      for (let i = 0; i < entry.max; i += 1){
        const square = document.createElement("span");
        square.className = `spell-slot-square ${i < entry.current ? "is-active" : "is-spent"}`;
        squaresWrap.appendChild(square);
      }
      levelWrap.appendChild(squaresWrap);
      spellSlotMonitorEl.appendChild(levelWrap);
    });
  }

  function normalizePreparedSpellList(list){
    if (!Array.isArray(list)) return [];
    return list.map(normalizeTextValue).filter(Boolean);
  }

  function getPlayerCantripList(name){
    const profile = getPlayerProfile(name);
    const spellcasting = profile?.spellcasting;
    if (!spellcasting || typeof spellcasting !== "object") return [];
    if (Array.isArray(spellcasting.cantrips_list)){
      return normalizePreparedSpellList(spellcasting.cantrips_list);
    }
    const cantrips = spellcasting.cantrips;
    if (Array.isArray(cantrips)){
      return normalizePreparedSpellList(cantrips);
    }
    if (cantrips && typeof cantrips === "object"){
      return normalizePreparedSpellList(cantrips.known);
    }
    return [];
  }

  function evaluatePreparedFormula(formula, variables){
    if (typeof formula !== "string") return null;
    const trimmed = formula.trim();
    if (!trimmed) return null;
    if (!/^[0-9+\-*/(). _a-zA-Z]+$/.test(trimmed)) return null;
    let expr = trimmed;
    Object.entries(variables).forEach(([key, value]) => {
      const safeValue = Number.isFinite(value) ? String(value) : "0";
      const pattern = new RegExp(`\\b${key}\\b`, "g");
      expr = expr.replace(pattern, safeValue);
    });
    if (/[a-zA-Z]/.test(expr)) return null;
    try {
      const result = Function(`"use strict"; return (${expr});`)();
      if (!Number.isFinite(result)) return null;
      return Math.max(0, Math.floor(result));
    } catch (err){
      return null;
    }
  }

  function getAbilityModifier(profile, key){
    const normalizedKey = normalizeAbilityKey(key);
    const abilities = profile?.abilities;
    if (!abilities || typeof abilities !== "object") return 0;
    const modValue = Number(
      abilities[`${normalizedKey}_mod`]
      ?? abilities[`${normalizedKey}_modifier`]
    );
    if (Number.isFinite(modValue)){
      return Math.floor(modValue);
    }
    const scoreValue = Number(
      abilities[normalizedKey]
      ?? abilities[normalizedKey.toUpperCase()]
      ?? abilities[`${normalizedKey}_score`]
    );
    if (Number.isFinite(scoreValue)){
      return Math.floor((scoreValue - 10) / 2);
    }
    return 0;
  }

  function normalizeAbilityKey(key){
    const raw = normalizeLowerValue(key || "");
    if (!raw) return "";
    const abilityMap = {
      strength: "str",
      str: "str",
      dexterity: "dex",
      dex: "dex",
      constitution: "con",
      con: "con",
      intelligence: "int",
      int: "int",
      wisdom: "wis",
      wis: "wis",
      charisma: "cha",
      cha: "cha",
      chr: "cha",
      char: "cha",
    };
    return abilityMap[raw] || raw;
  }

  function getProficiencyBonus(profile){
    const level = getPlayerLevel(profile);
    if (level >= 1){
      if (level >= 17) return 6;
      if (level >= 13) return 5;
      if (level >= 9) return 4;
      if (level >= 5) return 3;
      return 2;
    }
    const prof = Number(profile?.proficiency?.bonus);
    return Number.isFinite(prof) ? Math.floor(prof) : 0;
  }

  function getPreparedSpellLimit(profile, preparedData){
    const maxFormula = preparedData?.maxFormula;
    const maxValue = preparedData?.maxValue;
    const levelRaw = profile?.leveling?.level ?? profile?.leveling?.total_level ?? profile?.leveling?.lvl;
    const level = Number.isFinite(Number(levelRaw)) ? Math.max(0, Math.floor(Number(levelRaw))) : 0;
    const variables = {
      level,
      total_level: level,
      str_mod: getAbilityModifier(profile, "str"),
      dex_mod: getAbilityModifier(profile, "dex"),
      con_mod: getAbilityModifier(profile, "con"),
      int_mod: getAbilityModifier(profile, "int"),
      wis_mod: getAbilityModifier(profile, "wis"),
      cha_mod: getAbilityModifier(profile, "cha"),
    };
    const evaluated = evaluatePreparedFormula(maxFormula, variables);
    if (Number.isFinite(evaluated)){
      return evaluated;
    }
    if (Number.isFinite(maxValue)){
      return Math.max(0, Math.floor(maxValue));
    }
    const fallbackKnown = Number(profile?.spellcasting?.known_spells);
    if (Number.isFinite(fallbackKnown)){
      return Math.max(0, Math.floor(fallbackKnown));
    }
    return null;
  }

  function getPlayerSpellSaveDc(name){
    const profile = getPlayerProfile(name);
    const spellcasting = profile?.spellcasting;
    if (!spellcasting || typeof spellcasting !== "object") return null;
    const rawValue = spellcasting.save_dc ?? spellcasting.saveDC;
    const dcValue = Number(rawValue);
    if (Number.isFinite(dcValue)){
      return Math.floor(dcValue);
    }
    const formula = normalizeTextValue(spellcasting.save_dc_formula);
    if (formula){
      const castingAbility = normalizeAbilityKey(spellcasting.casting_ability || "");
      const castingMod = castingAbility ? getAbilityModifier(profile, castingAbility) : 0;
      const prof = getProficiencyBonus(profile);
      const variables = {
        prof,
        casting_mod: castingMod,
        str_mod: getAbilityModifier(profile, "str"),
        dex_mod: getAbilityModifier(profile, "dex"),
        con_mod: getAbilityModifier(profile, "con"),
        int_mod: getAbilityModifier(profile, "int"),
        wis_mod: getAbilityModifier(profile, "wis"),
        cha_mod: getAbilityModifier(profile, "cha"),
      };
      const evaluated = evaluatePreparedFormula(formula, variables);
      if (Number.isFinite(evaluated)){
        return evaluated;
      }
    }
    return null;
  }

  function applyDefaultSpellSaveDc(){
    if (!castDcValueInput) return;
    if (String(castDcValueInput.value || "").trim()){
      return;
    }
    const playerName = getClaimedPlayerName();
    const dcValue = getPlayerSpellSaveDc(playerName);
    if (Number.isFinite(dcValue)){
      castDcValueInput.value = String(dcValue);
    }
  }

  function getSpellbookConfig(name){
    const defaults = {...preparedSpellDefaults};
    if (!name) return defaults;
    const profile = getPlayerProfile(name);
    const spellcasting = profile?.spellcasting && typeof profile.spellcasting === "object"
      ? profile.spellcasting
      : null;
    if (!spellcasting){
      return defaults;
    }
    const preparedBlock = spellcasting.prepared_spells && typeof spellcasting.prepared_spells === "object"
      ? spellcasting.prepared_spells
      : {};
    const knownBlock = spellcasting.known_spells && typeof spellcasting.known_spells === "object"
      ? spellcasting.known_spells
      : {};
    const cantripsBlock = spellcasting.cantrips && typeof spellcasting.cantrips === "object"
      ? spellcasting.cantrips
      : {};
    const maxFormula = normalizeTextValue(
      spellcasting.prepared_limit_formula
      ?? preparedBlock.max_formula
    );
    const maxValue = Number(preparedBlock.max ?? preparedBlock.max_spells ?? preparedBlock.max_prepared);
    const limit = getPreparedSpellLimit(profile, {maxFormula, maxValue});
    const knownLimitRaw = spellcasting.known_limit ?? knownBlock.max ?? spellcasting.known_spells;
    const knownLimit = Number.isFinite(Number(knownLimitRaw))
      ? Math.max(0, Math.floor(Number(knownLimitRaw)))
      : null;
    const cantripsMaxRaw = cantripsBlock.max;
    const cantripsMax = Number.isFinite(Number(cantripsMaxRaw))
      ? Math.max(0, Math.floor(Number(cantripsMaxRaw)))
      : null;
    return {
      prepared: normalizePreparedSpellList(
        spellcasting.prepared_list ?? preparedBlock.prepared
      ),
      max: limit,
      maxFormula,
      known: normalizePreparedSpellList(
        spellcasting.known_list ?? knownBlock.known ?? spellcasting.known_spell_names
      ),
      knownLimit,
      knownEnabled: spellcasting.known_enabled !== false,
      cantrips: normalizePreparedSpellList(
        spellcasting.cantrips_list ?? cantripsBlock.known ?? spellcasting.cantrips
      ),
      cantripsMax,
    };
  }

  function persistSheetHeight(){
    if (!Number.isFinite(sheetHeight)) return;
    localStorage.setItem(sheetHeightKey, String(Math.round(sheetHeight)));
  }

  function loadSheetHeight(){
    if (!sheetWrap) return;
    const stored = Number(localStorage.getItem(sheetHeightKey));
    applySheetHeight(stored);
  }

  function readToggle(key, defaultValue){
    const stored = localStorage.getItem(key);
    if (stored === null || stored === undefined) return defaultValue;
    return stored === "1";
  }

  function readChoice(key, allowed, defaultValue){
    const stored = localStorage.getItem(key);
    if (stored && allowed.includes(stored)) return stored;
    return defaultValue;
  }

  function persistToggle(key, value){
    localStorage.setItem(key, value ? "1" : "0");
  }

  function persistChoice(key, value){
    if (!value){
      localStorage.removeItem(key);
      return;
    }
    localStorage.setItem(key, value);
  }

  connStyle = readChoice(uiSelectKeys.connStyle, ["full", "compact"], "full");
  initiativeStyle = readChoice(uiSelectKeys.initiativeStyle, ["full", "compact", "hidden"], "full");
  let connStatusText = "Connecting…";
  let connStatusOk = false;

  const hotkeyConfig = {
    toggleTopbarTitle: {
      input: hotkeyTopbarTitleInput,
      conflictEl: document.getElementById("hotkeyConflictTopbarTitle"),
      storageKey: "inittracker_hotkey_toggleTopbarTitle",
      action: () => {
        showTopbarTitle = !showTopbarTitle;
        persistToggle(uiToggleKeys.topbarTitle, showTopbarTitle);
        applyUiConfig();
      },
    },
    toggleConnStyle: {
      input: hotkeyConnStyleInput,
      conflictEl: document.getElementById("hotkeyConflictConnStyle"),
      storageKey: "inittracker_hotkey_toggleConnStyle",
      action: () => {
        connStyle = connStyle === "compact" ? "full" : "compact";
        persistChoice(uiSelectKeys.connStyle, connStyle);
        applyUiConfig();
      },
    },
    lockMap: {
      input: hotkeyLockMapInput,
      conflictEl: document.getElementById("hotkeyConflictLockMap"),
      storageKey: "inittracker_hotkey_lockMap",
      action: () => lockMapBtn && lockMapBtn.click(),
    },
    centerMap: {
      input: hotkeyCenterMapInput,
      conflictEl: document.getElementById("hotkeyConflictCenterMap"),
      storageKey: "inittracker_hotkey_centerMap",
      action: () => centerMapBtn && centerMapBtn.click(),
    },
    measure: {
      input: hotkeyMeasureInput,
      conflictEl: document.getElementById("hotkeyConflictMeasure"),
      storageKey: "inittracker_hotkey_measure",
      action: () => measureToggle && measureToggle.click(),
    },
    measureClear: {
      input: hotkeyMeasureClearInput,
      conflictEl: document.getElementById("hotkeyConflictMeasureClear"),
      storageKey: "inittracker_hotkey_measureClear",
      action: () => measureClear && measureClear.click(),
    },
    zoomIn: {
      input: hotkeyZoomInInput,
      conflictEl: document.getElementById("hotkeyConflictZoomIn"),
      storageKey: "inittracker_hotkey_zoomIn",
      action: () => zoomInBtn && zoomInBtn.click(),
    },
    zoomOut: {
      input: hotkeyZoomOutInput,
      conflictEl: document.getElementById("hotkeyConflictZoomOut"),
      storageKey: "inittracker_hotkey_zoomOut",
      action: () => zoomOutBtn && zoomOutBtn.click(),
    },
    battleLog: {
      input: hotkeyBattleLogInput,
      conflictEl: document.getElementById("hotkeyConflictBattleLog"),
      storageKey: "inittracker_hotkey_battleLog",
      action: () => battleLogBtn && battleLogBtn.click(),
    },
    useAction: {
      input: hotkeyUseActionInput,
      conflictEl: document.getElementById("hotkeyConflictUseAction"),
      storageKey: "inittracker_hotkey_useAction",
      action: () => useActionBtn && useActionBtn.click(),
    },
    useBonusAction: {
      input: hotkeyUseBonusActionInput,
      conflictEl: document.getElementById("hotkeyConflictUseBonusAction"),
      storageKey: "inittracker_hotkey_useBonusAction",
      action: () => useBonusActionBtn && useBonusActionBtn.click(),
    },
    dash: {
      input: hotkeyDashInput,
      conflictEl: document.getElementById("hotkeyConflictDash"),
      storageKey: "inittracker_hotkey_dash",
      action: () => dashBtn && dashBtn.click(),
    },
    standUp: {
      input: hotkeyStandUpInput,
      conflictEl: document.getElementById("hotkeyConflictStandUp"),
      storageKey: "inittracker_hotkey_standUp",
      action: () => standUpBtn && standUpBtn.click(),
    },
    resetTurn: {
      input: hotkeyResetTurnInput,
      conflictEl: document.getElementById("hotkeyConflictResetTurn"),
      storageKey: "inittracker_hotkey_resetTurn",
      action: () => resetTurnBtn && resetTurnBtn.click(),
    },
  };

  let hotkeyBindings = new Map();

  function normalizeHotkeyEvent(event){
    if (!event) return null;
    if (event.key === "Shift" || event.key === "Control" || event.key === "Alt" || event.key === "Meta"){
      return null;
    }
    const parts = [];
    if (event.ctrlKey) parts.push("Ctrl");
    if (event.altKey) parts.push("Alt");
    if (event.metaKey) parts.push("Meta");
    if (event.shiftKey) parts.push("Shift");
    let key = event.key;
    if (key === " ") key = "Space";
    if (key.length === 1) key = key.toUpperCase();
    parts.push(key);
    return parts.join("+");
  }

  function isTypingTarget(target){
    if (!target) return false;
    const tag = target.tagName ? target.tagName.toLowerCase() : "";
    if (tag === "input" || tag === "textarea" || tag === "select") return true;
    if (target.isContentEditable) return true;
    return false;
  }

  function setHotkey(action, value){
    const config = hotkeyConfig[action];
    if (!config) return;
    const stored = value ? String(value) : "";
    if (stored){
      localStorage.setItem(config.storageKey, stored);
    } else {
      localStorage.removeItem(config.storageKey);
    }
    updateHotkeyInputs();
  }

  function updateHotkeyInputs(){
    const usage = {};
    hotkeyBindings = new Map();
    Object.entries(hotkeyConfig).forEach(([action, config]) => {
      if (!config || !config.input) return;
      const stored = localStorage.getItem(config.storageKey) || "";
      const normalized = stored.trim();
      config.input.value = normalized;
      if (normalized){
        if (!usage[normalized]) usage[normalized] = [];
        usage[normalized].push(action);
      }
    });
    Object.entries(hotkeyConfig).forEach(([action, config]) => {
      if (!config || !config.input) return;
      const stored = (localStorage.getItem(config.storageKey) || "").trim();
      const conflicts = stored && usage[stored] && usage[stored].length > 1;
      config.input.classList.toggle("conflict", !!conflicts);
      if (config.conflictEl){
        config.conflictEl.textContent = conflicts ? "Conflict" : "";
      }
      if (stored && !conflicts){
        hotkeyBindings.set(stored, action);
      }
    });
  }

  let presetStatusTimer = null;
  const presetStorageKey = "inittracker_gui_preset";

  function setPresetStatus(text, durationMs=2000){
    if (!presetStatus) return;
    presetStatus.textContent = text || "";
    if (presetStatusTimer){
      clearTimeout(presetStatusTimer);
      presetStatusTimer = null;
    }
    if (text && durationMs > 0){
      presetStatusTimer = setTimeout(() => {
        if (presetStatus) presetStatus.textContent = "";
        presetStatusTimer = null;
      }, durationMs);
    }
  }

  function normalizePresetHotkey(value){
    if (value === null || value === undefined) return "";
    const normalized = String(value).trim();
    return normalized;
  }

  function buildGuiPreset(){
    const hotkeys = {};
    Object.entries(hotkeyConfig).forEach(([action, config]) => {
      if (!config || !config.storageKey) return;
      hotkeys[action] = normalizePresetHotkey(localStorage.getItem(config.storageKey) || "");
    });
    return {
      version: 1,
      toggles: {
        topbarTitle: showTopbarTitle,
        connIndicator: showConnIndicator,
        lockMap: showLockMap,
        centerMap: showCenterMap,
        measure: showMeasure,
        measureClear: showMeasureClear,
        zoomIn: showZoomIn,
        zoomOut: showZoomOut,
        battleLog: showBattleLog,
        useAction: showUseAction,
        useBonusAction: showUseBonusAction,
        dash: showDash,
        standUp: showStandUp,
        resetTurn: showResetTurn,
        hideSpellMenu: hideSpellMenu,
        lockMenus: menusLocked,
      },
      choices: {
        connStyle,
        initiativeStyle,
      },
      showAllNames: showAllNames,
      sheetHeight: Number.isFinite(sheetHeight) ? Math.round(sheetHeight) : null,
      hotkeys,
    };
  }

  function persistLocalPreset(preset){
    try {
      localStorage.setItem(presetStorageKey, JSON.stringify(preset));
    } catch (err){
      console.warn("Failed to persist GUI preset locally.", err);
    }
  }

  function loadLocalPreset(){
    try {
      const raw = localStorage.getItem(presetStorageKey);
      if (!raw) return null;
      const preset = JSON.parse(raw);
      if (preset && typeof preset === "object"){
        return preset;
      }
    } catch (err){
      console.warn("Failed to load GUI preset from storage.", err);
    }
    return null;
  }

  function applyGuiPreset(preset, options = {}){
    if (!preset || typeof preset !== "object") return;
    const persist = options.persist !== false;
    const toggles = preset.toggles && typeof preset.toggles === "object" ? preset.toggles : {};
    const choices = preset.choices && typeof preset.choices === "object" ? preset.choices : {};
    if (typeof toggles.topbarTitle === "boolean") showTopbarTitle = toggles.topbarTitle;
    if (typeof toggles.connIndicator === "boolean") showConnIndicator = toggles.connIndicator;
    if (typeof toggles.lockMap === "boolean") showLockMap = toggles.lockMap;
    if (typeof toggles.centerMap === "boolean") showCenterMap = toggles.centerMap;
    if (typeof toggles.measure === "boolean") showMeasure = toggles.measure;
    if (typeof toggles.measureClear === "boolean") showMeasureClear = toggles.measureClear;
    if (typeof toggles.zoomIn === "boolean") showZoomIn = toggles.zoomIn;
    if (typeof toggles.zoomOut === "boolean") showZoomOut = toggles.zoomOut;
    if (typeof toggles.battleLog === "boolean") showBattleLog = toggles.battleLog;
    if (typeof toggles.useAction === "boolean") showUseAction = toggles.useAction;
    if (typeof toggles.useBonusAction === "boolean") showUseBonusAction = toggles.useBonusAction;
    if (typeof toggles.dash === "boolean") showDash = toggles.dash;
    if (typeof toggles.standUp === "boolean") showStandUp = toggles.standUp;
    if (typeof toggles.resetTurn === "boolean") showResetTurn = toggles.resetTurn;
    if (typeof toggles.hideSpellMenu === "boolean") hideSpellMenu = toggles.hideSpellMenu;
    if (typeof toggles.lockMenus === "boolean") menusLocked = toggles.lockMenus;
    if (persist){
      persistToggle(uiToggleKeys.topbarTitle, showTopbarTitle);
      persistToggle(uiToggleKeys.connIndicator, showConnIndicator);
      persistToggle(uiToggleKeys.lockMap, showLockMap);
      persistToggle(uiToggleKeys.centerMap, showCenterMap);
      persistToggle(uiToggleKeys.measure, showMeasure);
      persistToggle(uiToggleKeys.measureClear, showMeasureClear);
      persistToggle(uiToggleKeys.zoomIn, showZoomIn);
      persistToggle(uiToggleKeys.zoomOut, showZoomOut);
      persistToggle(uiToggleKeys.battleLog, showBattleLog);
      persistToggle(uiToggleKeys.useAction, showUseAction);
      persistToggle(uiToggleKeys.useBonusAction, showUseBonusAction);
      persistToggle(uiToggleKeys.dash, showDash);
      persistToggle(uiToggleKeys.standUp, showStandUp);
      persistToggle(uiToggleKeys.resetTurn, showResetTurn);
      persistToggle(uiToggleKeys.hideSpellMenu, hideSpellMenu);
      persistToggle(uiToggleKeys.lockMenus, menusLocked);
    }
    if (choices.connStyle && ["full", "compact"].includes(choices.connStyle)){
      connStyle = choices.connStyle;
      if (persist){
        persistChoice(uiSelectKeys.connStyle, connStyle);
      }
    }
    if (choices.initiativeStyle && ["full", "compact", "hidden"].includes(choices.initiativeStyle)){
      initiativeStyle = choices.initiativeStyle;
      if (persist){
        persistChoice(uiSelectKeys.initiativeStyle, initiativeStyle);
      }
    }
    if (typeof preset.showAllNames === "boolean"){
      showAllNames = preset.showAllNames;
      if (showAllNamesEl){
        showAllNamesEl.checked = showAllNames;
      }
      if (persist){
        localStorage.setItem("inittracker_showAllNames", showAllNames ? "1" : "0");
      }
    }
    if (Number.isFinite(Number(preset.sheetHeight))){
      applySheetHeight(Number(preset.sheetHeight));
      if (persist){
        persistSheetHeight();
      }
    }
    if (preset.hotkeys && typeof preset.hotkeys === "object"){
      Object.entries(preset.hotkeys).forEach(([action, value]) => {
        const config = hotkeyConfig[action];
        if (!config || !config.storageKey) return;
        const normalized = normalizePresetHotkey(value);
        if (persist){
          if (normalized){
            localStorage.setItem(config.storageKey, normalized);
          } else {
            localStorage.removeItem(config.storageKey);
          }
        }
        if (config.input){
          config.input.value = normalized;
        }
      });
    }
    applyUiConfig();
    updateHotkeyInputs();
  }

  function applyConnStyle(){
    if (!connEl) return;
    connEl.classList.toggle("conn-compact", connStyle === "compact");
    updateConnDisplay();
  }

  function toggleInitiativeBar(forceVisible){
    const shouldShow = typeof forceVisible === "boolean"
      ? forceVisible
      : document.body.classList.contains("initiative-hidden");
    document.body.classList.toggle("initiative-hidden", !shouldShow);
    initiativeStyle = shouldShow ? "full" : "hidden";
    persistChoice(uiSelectKeys.initiativeStyle, initiativeStyle);
    if (initiativeStyleSelect){
      initiativeStyleSelect.value = initiativeStyle;
    }
    if (initiativeToggleBtn){
      initiativeToggleBtn.setAttribute("aria-pressed", shouldShow ? "true" : "false");
    }
    updateModalOffsets();
    updateTurnOrder();
    resize();
  }

  function applyUiConfig(){
    document.body.classList.toggle("menus-locked", menusLocked);
    document.body.classList.toggle("initiative-compact", initiativeStyle === "compact");
    document.body.classList.toggle("initiative-hidden", initiativeStyle === "hidden");
    if (initiativeToggleBtn) initiativeToggleBtn.setAttribute("aria-pressed", initiativeStyle === "hidden" ? "false" : "true");
    if (topbarTitleEl) topbarTitleEl.classList.toggle("hidden", !showTopbarTitle);
    if (connEl) connEl.classList.toggle("hidden", !showConnIndicator);
    if (!showConnIndicator){
      closeConnPopover();
    }
    if (lockMapBtn) lockMapBtn.classList.toggle("hidden", !showLockMap);
    if (centerMapBtn) centerMapBtn.classList.toggle("hidden", !showCenterMap);
    if (measureToggle) measureToggle.classList.toggle("hidden", !showMeasure);
    if (measureClear) measureClear.classList.toggle("hidden", !showMeasureClear);
    if (zoomInBtn) zoomInBtn.classList.toggle("hidden", !showZoomIn);
    if (zoomOutBtn) zoomOutBtn.classList.toggle("hidden", !showZoomOut);
    if (battleLogBtn) battleLogBtn.classList.toggle("hidden", !showBattleLog);
    if (useActionBtn) useActionBtn.classList.toggle("hidden", !showUseAction);
    if (useBonusActionBtn) useBonusActionBtn.classList.toggle("hidden", !showUseBonusAction);
    if (dashBtn) dashBtn.classList.toggle("hidden", !showDash);
    if (standUpBtn) standUpBtn.classList.toggle("hidden", !showStandUp);
    if (resetTurnBtn) resetTurnBtn.classList.toggle("hidden", !showResetTurn);
    if (toggleTopbarTitle) toggleTopbarTitle.checked = showTopbarTitle;
    if (toggleConnIndicator) toggleConnIndicator.checked = showConnIndicator;
    if (connStyleButtons.length){
      connStyleButtons.forEach((button) => {
        const isActive = button.dataset.connStyle === connStyle;
        button.classList.toggle("active", isActive);
        button.setAttribute("aria-pressed", isActive ? "true" : "false");
      });
    }
    if (toggleLockMap) toggleLockMap.checked = showLockMap;
    if (toggleCenterMap) toggleCenterMap.checked = showCenterMap;
    if (toggleMeasure) toggleMeasure.checked = showMeasure;
    if (toggleMeasureClear) toggleMeasureClear.checked = showMeasureClear;
    if (toggleZoomIn) toggleZoomIn.checked = showZoomIn;
    if (toggleZoomOut) toggleZoomOut.checked = showZoomOut;
    if (toggleBattleLog) toggleBattleLog.checked = showBattleLog;
    if (initiativeStyleSelect) initiativeStyleSelect.value = initiativeStyle;
    if (toggleUseAction) toggleUseAction.checked = showUseAction;
    if (toggleUseBonusAction) toggleUseBonusAction.checked = showUseBonusAction;
    if (toggleDash) toggleDash.checked = showDash;
    if (toggleStandUp) toggleStandUp.checked = showStandUp;
    if (toggleResetTurn) toggleResetTurn.checked = showResetTurn;
    if (toggleSpellMenu) toggleSpellMenu.checked = hideSpellMenu;
    if (toggleLockMenus) toggleLockMenus.checked = menusLocked;
    if (sheetHandle){
      sheetHandle.setAttribute("aria-disabled", menusLocked ? "true" : "false");
    }
    applyConnStyle();
    updateHotkeyInputs();
    updateSpellPanelVisibility();
    updateMountControls();
    updateAoeLockButton();
  }

  const localPreset = loadLocalPreset();
  if (localPreset){
    applyGuiPreset(localPreset, {persist: true});
    if (!Number.isFinite(Number(localPreset.sheetHeight))){
      loadSheetHeight();
    }
  } else {
    applyUiConfig();
    loadSheetHeight();
  }
  if (sheetHandle && sheetWrap){
    let dragState = null;
    sheetHandle.addEventListener("pointerdown", (event) => {
      if (menusLocked) return;
      sheetHandle.setPointerCapture(event.pointerId);
      dragState = {
        startY: event.clientY,
        startHeight: sheetWrap.getBoundingClientRect().height,
      };
      event.preventDefault();
    });
    sheetHandle.addEventListener("pointermove", (event) => {
      if (!dragState) return;
      const delta = dragState.startY - event.clientY;
      applySheetHeight(dragState.startHeight + delta);
    });
    sheetHandle.addEventListener("pointerup", () => {
      if (!dragState) return;
      dragState = null;
      persistSheetHeight();
    });
    sheetHandle.addEventListener("pointercancel", () => {
      if (!dragState) return;
      dragState = null;
      persistSheetHeight();
    });
  }

  function showConfigModal(){
    if (!configModal) return;
    configModal.classList.add("show");
    configModal.setAttribute("aria-hidden", "false");
    if (configBtn){
      configBtn.setAttribute("aria-expanded", "true");
    }
  }

  function hideConfigModal(){
    if (!configModal) return;
    configModal.classList.remove("show");
    configModal.setAttribute("aria-hidden", "true");
    if (configBtn){
      configBtn.setAttribute("aria-expanded", "false");
    }
  }

  function setAdminMenu(open){
    if (!adminMenuPopover || !adminMenuBtn) return;
    adminMenuPopover.classList.toggle("show", open);
    adminMenuPopover.setAttribute("aria-hidden", open ? "false" : "true");
    adminMenuBtn.setAttribute("aria-expanded", open ? "true" : "false");
  }

  function closeAdminMenu(){
    setAdminMenu(false);
  }

  function showAdminModal(){
    if (!adminModal) return;
    adminModal.classList.add("show");
    adminModal.setAttribute("aria-hidden", "false");
  }

  function hideAdminModal(){
    if (!adminModal) return;
    adminModal.classList.remove("show");
    adminModal.setAttribute("aria-hidden", "true");
  }

  function showAdminLoginModal(){
    if (!adminLoginModal) return;
    adminLoginModal.classList.add("show");
    adminLoginModal.setAttribute("aria-hidden", "false");
    if (adminPasswordInput){
      adminPasswordInput.value = "";
      setTimeout(() => adminPasswordInput.focus(), 50);
    }
  }

  function hideAdminLoginModal(){
    if (!adminLoginModal) return;
    adminLoginModal.classList.remove("show");
    adminLoginModal.setAttribute("aria-hidden", "true");
    setAdminLoginStatus("");
  }

  function setAdminStatus(text){
    if (!adminStatus) return;
    adminStatus.textContent = text || "";
  }

  function setAdminLoginStatus(text){
    if (!adminLoginStatus) return;
    adminLoginStatus.textContent = text || "";
  }

  function getAdminAuth(){
    try {
      const raw = sessionStorage.getItem(adminTokenKey);
      if (!raw) return null;
      const data = JSON.parse(raw);
      if (!data || typeof data !== "object") return null;
      if (!data.token) return null;
      if (data.expiresAt && Date.now() > Number(data.expiresAt)){
        sessionStorage.removeItem(adminTokenKey);
        return null;
      }
      return data.token;
    } catch (err){
      sessionStorage.removeItem(adminTokenKey);
      return null;
    }
  }

  function setAdminAuth(token, expiresIn){
    if (!token) return;
    const expiresMs = Math.max(1, Number(expiresIn || 0)) * 1000;
    const payload = {token, expiresAt: Date.now() + expiresMs};
    sessionStorage.setItem(adminTokenKey, JSON.stringify(payload));
  }

  function clearAdminAuth(){
    sessionStorage.removeItem(adminTokenKey);
  }

  function requestAdminLogin(){
    if (getAdminAuth()){
      return Promise.resolve(getAdminAuth());
    }
    if (adminAuthPromise){
      return adminAuthPromise;
    }
    adminAuthPromise = new Promise((resolve, reject) => {
      adminAuthResolve = resolve;
      adminAuthReject = reject;
      showAdminLoginModal();
    });
    return adminAuthPromise;
  }

  function finalizeAdminLogin(success, token){
    if (!adminAuthPromise) return;
    const resolve = adminAuthResolve;
    const reject = adminAuthReject;
    adminAuthPromise = null;
    adminAuthResolve = null;
    adminAuthReject = null;
    if (success && resolve){
      resolve(token);
    } else if (!success && reject){
      reject(new Error("Admin login canceled."));
    }
  }

  async function adminFetch(url, options = {}){
    const token = await requestAdminLogin();
    const headers = new Headers(options.headers || {});
    if (token){
      headers.set("Authorization", `Bearer ${token}`);
    }
    const res = await fetch(url, {...options, headers});
    if ((res.status === 401 || res.status === 403) && !options._retry){
      clearAdminAuth();
      try {
        await requestAdminLogin();
      } catch (err){
        return res;
      }
      return adminFetch(url, {...options, _retry: true});
    }
    return res;
  }

  async function sendAdminAction(type){
    closeAdminMenu();
    try {
      const token = await requestAdminLogin();
      send({type, admin_token: token});
      localToast("Player characters reset.");
    } catch (err){
      console.warn("Admin action canceled.", err);
      localToast("Admin action canceled.");
    }
  }

  async function submitAdminLogin(){
    const password = adminPasswordInput ? adminPasswordInput.value : "";
    if (!password){
      setAdminLoginStatus("Enter a password to continue.");
      return;
    }
    try {
      setAdminLoginStatus("Signing in…");
      const res = await fetch("/api/admin/login", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({password}),
      });
      if (!res.ok){
        if (res.status === 403){
          setAdminLoginStatus("Admin password is not configured.");
        } else {
          setAdminLoginStatus("Invalid password. Try again.");
        }
        return;
      }
      const payload = await res.json();
      if (!payload || !payload.token){
        setAdminLoginStatus("Login failed.");
        return;
      }
      setAdminAuth(payload.token, payload.expires_in);
      hideAdminLoginModal();
      finalizeAdminLogin(true, payload.token);
    } catch (err){
      console.warn("Admin login failed.", err);
      setAdminLoginStatus("Login failed. Try again.");
    }
  }

  function renderAdminSessions(){
    if (!adminSessionList) return;
    adminSessionList.innerHTML = "";
    if (!adminSessions.length){
      const empty = document.createElement("div");
      empty.className = "hint";
      empty.textContent = "No sessions found yet.";
      adminSessionList.appendChild(empty);
      return;
    }
    adminSessions.forEach((session) => {
      const row = document.createElement("div");
      row.className = "admin-session";
      const top = document.createElement("div");
      top.className = "admin-session-top";
      const ipWrap = document.createElement("div");
      const ipText = document.createElement("div");
      ipText.className = "admin-session-ip";
      ipText.textContent = session.ip || session.host || "(unknown)";
      const metaText = document.createElement("div");
      metaText.className = "admin-session-meta";
      const reverseDns = session.reverse_dns ? `rDNS: ${session.reverse_dns}` : "rDNS: —";
      const lastSeen = session.last_seen ? `Last seen: ${session.last_seen}` : "";
      metaText.textContent = [reverseDns, lastSeen].filter(Boolean).join(" · ");
      ipWrap.appendChild(ipText);
      ipWrap.appendChild(metaText);
      const status = document.createElement("span");
      status.className = "admin-session-status";
      const statusValue = String(session.status || "offline").toLowerCase();
      status.classList.add(statusValue === "connected" ? "connected" : "offline");
      status.textContent = statusValue === "connected" ? "Connected" : "Offline";
      top.appendChild(ipWrap);
      top.appendChild(status);

      const claimedRow = document.createElement("div");
      claimedRow.className = "admin-session-assign";
      const claimedText = document.createElement("div");
      claimedText.className = "admin-session-meta";
      const claimedLabel = session.claimed_name
        || (session.cid !== null && session.cid !== undefined ? `cid ${session.cid}` : "Unclaimed");
      claimedText.textContent = `Claimed: ${claimedLabel}`;
      claimedRow.appendChild(claimedText);

      row.appendChild(top);
      row.appendChild(claimedRow);
      adminSessionList.appendChild(row);
    });
  }

  async function fetchAdminSessions({silent} = {}){
    try {
      if (!silent) setAdminStatus("Loading sessions…");
      const res = await adminFetch("/api/admin/sessions");
      if (!res.ok){
        throw new Error(`HTTP ${res.status}`);
      }
      const payload = await res.json();
      adminSessions = Array.isArray(payload.sessions) ? payload.sessions : [];
      setAdminStatus(`Loaded ${adminSessions.length} session${adminSessions.length === 1 ? "" : "s"}.`);
      renderAdminSessions();
      refreshPreSummonControls();
    } catch (err){
      console.warn("Failed to load admin sessions.", err);
      setAdminStatus("Failed to load sessions.");
    }
  }

  function refreshPreSummonControls(){
    if (!preSummonTargetInput || !preSummonSpellInput || !preSummonMonsterInput) return;
    const units = Array.isArray(state?.units) ? state.units : [];
    const pcs = units.filter((u) => String(u?.role || "") !== "enemy");
    preSummonTargetInput.textContent = "";
    pcs.forEach((u) => {
      const opt = document.createElement("option");
      opt.value = String(u.cid);
      opt.textContent = `${u.name || `#${u.cid}`}`;
      preSummonTargetInput.appendChild(opt);
    });

    preSummonSpellInput.textContent = "";
    (cachedSpellPresets || []).filter((preset) => preset?.summon?.mount).forEach((preset) => {
      const opt = document.createElement("option");
      opt.value = normalizeTextValue(preset.slug || preset.id || "");
      opt.textContent = preset.name || opt.value;
      preSummonSpellInput.appendChild(opt);
    });

    preSummonMonsterInput.textContent = "";
    const monsters = Array.isArray(state?.monster_choices) ? state.monster_choices : [];
    monsters.forEach((entry) => {
      const opt = document.createElement("option");
      opt.value = normalizeTextValue(entry?.slug || "");
      opt.textContent = entry?.name || opt.value;
      preSummonMonsterInput.appendChild(opt);
    });
  }

  function showRosterPickerModal(){
    if (!rosterPickerModal) return;
    rosterPickerModal.classList.add("show");
    rosterPickerModal.setAttribute("aria-hidden", "false");
  }

  function hideRosterPickerModal(){
    if (!rosterPickerModal) return;
    rosterPickerModal.classList.remove("show");
    rosterPickerModal.setAttribute("aria-hidden", "true");
  }

  function renderRosterPicker(players){
    if (!rosterPickerList) return;
    rosterPickerList.textContent = "";
    const pool = Array.isArray(players) ? players : [];
    const unassigned = pool.filter((p) => !p?.assigned);
    if (!unassigned.length){
      const empty = document.createElement("div");
      empty.className = "hint";
      empty.textContent = "All players are already in this encounter.";
      rosterPickerList.appendChild(empty);
      return;
    }
    unassigned.forEach((player) => {
      const row = document.createElement("label");
      row.className = "roster-picker-item";
      const cb = document.createElement("input");
      cb.type = "checkbox";
      cb.value = String(player.name || "");
      const name = document.createElement("span");
      name.textContent = String(player.name || "Unnamed");
      row.appendChild(cb);
      row.appendChild(name);
      rosterPickerList.appendChild(row);
    });
  }

  async function fetchRosterPickerPlayers(options = {}){
    const forceRefresh = Boolean(options && options.forceRefresh);
    if (rosterPickerStatus) rosterPickerStatus.textContent = forceRefresh ? "Refreshing roster…" : "Loading roster…";
    if (forceRefresh){
      await fetch("/api/players/cache/refresh", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({clear_only: false}),
      });
    }
    const res = await fetch("/api/players/list");
    if (!res.ok){
      throw new Error(`HTTP ${res.status}`);
    }
    const payload = await res.json();
    const players = Array.isArray(payload?.players) ? payload.players : [];
    renderRosterPicker(players);
    if (rosterPickerStatus) rosterPickerStatus.textContent = `Roster loaded (${players.length}).`;
    return players;
  }

  async function openRosterPickerIfNeeded(force = false){
    const units = Array.isArray(state?.units) ? state.units : [];
    if (!force && units.length) return;
    showRosterPickerModal();
    try {
      await fetchRosterPickerPlayers({forceRefresh: false});
    } catch (err){
      console.warn("Failed to load roster picker", err);
      if (rosterPickerStatus) rosterPickerStatus.textContent = "Failed to load roster.";
    }
  }

  const mapViewBlockedTypes = new Set([
    "move",
    "dash",
    "perform_action",
    "end_turn",
    "use_action",
    "use_bonus_action",
    "set_color",
    "reset_turn",
    "cast_aoe",
    "cast_spell",
    "aoe_move",
    "aoe_remove",
    "save_preset",
  ]);

  function send(msg){
    if (isPlanning) return;
    if (isMapView && msg && mapViewBlockedTypes.has(msg.type)){
      return;
    }
    if (!ws || ws.readyState !== 1) return;
    ws.send(JSON.stringify(msg));
  }

  function localToast(text){
    if (!noteEl) return;
    noteEl.textContent = text || "…";
    setTimeout(() => noteEl.textContent = "Tip: drag yer token · unlock “Unlock my AOEs” to move AoEs (touch-hold ok)", 2500);
  }

  const DEFAULT_SPELL_COLOR = "#6aa9ff";

  function normalizeHexColor(raw){
    if (!raw) return null;
    const value = String(raw).trim().toLowerCase();
    if (!/^#[0-9a-f]{6}$/.test(value)) return null;
    return value;
  }

  function normalizeMovementMode(value){
    if (typeof value !== "string") return "normal";
    const lowered = value.trim().toLowerCase();
    if (["normal", "swim", "burrow", "fly"].includes(lowered)) return lowered;
    if (lowered === "land") return "normal";
    if (lowered === "water") return "swim";
    return "normal";
  }

  function normalizeMovementType(value, isSwim){
    if (typeof value === "string"){
      const lowered = value.trim().toLowerCase();
      if (["water", "ground"].includes(lowered)) return lowered;
      if (["swim", "waterborne"].includes(lowered)) return "water";
      if (["land", "normal", "burrow", "earth"].includes(lowered)) return "ground";
    }
    return isSwim ? "water" : "ground";
  }

  function cellMovementType(cell){
    return normalizeMovementType(cell?.movement_type, !!cell?.is_swim);
  }

  function movementModeLabel(mode){
    const key = normalizeMovementMode(mode);
    if (key === "swim") return "Swim";
    if (key === "burrow") return "Burrow";
    if (key === "fly") return "Fly";
    return "Normal";
  }

  function resolveSpellColor(raw){
    return normalizeHexColor(raw || "") || DEFAULT_SPELL_COLOR;
  }

  function hexToRgb(hex){
    const value = normalizeHexColor(hex);
    if (!value) return null;
    return {
      r: parseInt(value.slice(1, 3), 16),
      g: parseInt(value.slice(3, 5), 16),
      b: parseInt(value.slice(5, 7), 16),
    };
  }


  function applyServerClaim(claimedCidValue, claimedName, incomingRev){
    const revValue = Number.isFinite(Number(incomingRev)) ? Number(incomingRev) : claimRev;
    if (Number.isFinite(revValue) && revValue < claimRev){
      return false;
    }
    claimRev = Number.isFinite(revValue) ? revValue : claimRev;
    claimedCid = normalizeCid(claimedCidValue, "claim.server.claimedCid");
    claimStatus = (claimedCid !== null && claimedCid !== undefined) ? "claimed" : "unclaimed";
    clearClaimInFlight();
    if (meEl){
      if (claimedCid !== null && claimedCid !== undefined){
        const name = claimedName || getClaimablePcName(claimedCid, lastPcList || []) || `#${claimedCid}`;
        meEl.textContent = name;
      } else {
        meEl.textContent = "(unclaimed)";
      }
    }
    if (claimedCid !== null && claimedCid !== undefined){
      shownNoOwnedToast = false;
    }
    refreshSpellPresetOptions();
    updateClaimOverlay();
    return true;
  }

  function isForbiddenColor(hex){
    const rgb = hexToRgb(hex);
    if (!rgb) return false;
    if (rgb.r >= 245 && rgb.g >= 245 && rgb.b >= 245) return true;
    if (rgb.r >= 200 && rgb.g <= 80 && rgb.b <= 80) return true;
    return false;
  }

  function rgbaFromHex(hex, alpha){
    const rgb = hexToRgb(hex);
    if (!rgb) return null;
    return `rgba(${rgb.r},${rgb.g},${rgb.b},${alpha})`;
  }

  function updateTokenColorSwatch(color){
    if (!tokenColorSwatch) return;
    tokenColorSwatch.style.background = color || "#6aa9ff";
  }

  function openColorModal(unit){
    if (!colorModal || !tokenColorInput) return;
    const targetUnit = unit || getClaimedUnit();
    if (!targetUnit){
      localToast("Claim a character first, matey.");
      return;
    }
    pendingClaim = targetUnit;
    let preferred = normalizeHexColor(targetUnit?.token_color)
      || normalizeHexColor(localStorage.getItem("inittracker_tokenColor"))
      || "#6aa9ff";
    if (isForbiddenColor(preferred)){
      preferred = "#6aa9ff";
    }
    tokenColorInput.value = preferred;
    updateTokenColorSwatch(preferred);
    colorModal.classList.add("show");
    colorModal.setAttribute("aria-hidden", "false");
  }

  function closeColorModal(){
    if (!colorModal) return;
    colorModal.classList.remove("show");
    colorModal.setAttribute("aria-hidden", "true");
    pendingClaim = null;
  }

  function openClaimedColorModal(){
    openColorModal(getClaimedUnit());
  }

  function validateTokenColor(raw){
    const color = normalizeHexColor(raw);
    if (!color){
      localToast("Pick a valid hex color, matey.");
      return null;
    }
    if (isForbiddenColor(color)){
      localToast("No red or white, matey.");
      return null;
    }
    return color;
  }

  function showNoOwnedPcToast(pcs){
    if (isMapView) return;
    if (shownNoOwnedToast) return;
    if (claimStatus !== "unclaimed") return;
    if (claimedCid) return;
    const list = Array.isArray(pcs) ? pcs : [];
    if (!list.length) return;
    localToast("No assigned PCs found. Ask the DM to assign yer character.");
    shownNoOwnedToast = true;
  }

  function getClaimablePcName(cid, pcs){
    const list = Array.isArray(pcs) ? pcs : [];
    const match = list.find((pc) => pc && cidMatches(pc.cid, cid, "claimList.nameMatch"));
    if (match?.name) return String(match.name);
    const unit = getUnitByCid(cid);
    if (unit?.name) return String(unit.name);
    return null;
  }

  function storeLanSelection(cid, pcs){
    const cidValue = normalizeCid(cid, "lan.storeCid");
    if (cidValue === null) return;
    localStorage.setItem(lanSelectedCidKey, String(cidValue));
    const name = getClaimablePcName(cidValue, pcs);
    if (name){
      localStorage.setItem(lanSelectedNameKey, name);
    } else {
      localStorage.removeItem(lanSelectedNameKey);
    }
  }

  function clearLanSelection(){
    localStorage.removeItem(lanSelectedCidKey);
    localStorage.removeItem(lanSelectedNameKey);
  }

  function loadLanSelection(){
    const storedCid = Number(localStorage.getItem(lanSelectedCidKey));
    const cidValue = normalizeCid(storedCid, "lan.loadCid");
    if (cidValue === null) return null;
    const nameValue = localStorage.getItem(lanSelectedNameKey);
    return {
      cid: cidValue,
      name: nameValue ? String(nameValue) : null,
    };
  }

  function clearAutoClaimPending(){
    if (autoClaimPending?.timeoutId){
      clearTimeout(autoClaimPending.timeoutId);
    }
    autoClaimPending = null;
  }

  function setClaimInFlight(cid){
    if (claimInFlightTimeoutId){
      clearTimeout(claimInFlightTimeoutId);
      claimInFlightTimeoutId = null;
    }
    claimInFlight = true;
    claimInFlightCid = normalizeCid(cid, "claim.inFlightCid");
    claimStatus = "claiming";
    claimInFlightTimeoutId = setTimeout(() => {
      claimInFlightTimeoutId = null;
      if (!claimInFlight) return;
      const pendingCid = claimInFlightCid;
      clearClaimInFlight();
      if (claimStatus !== "claimed"){
        claimStatus = "unclaimed";
      }
      if (pendingCid !== null && pendingCid !== undefined){
        const displayName = getClaimablePcName(pendingCid, lastPcList || []) || `#${pendingCid}`;
        localToast(`Claim for ${displayName} timed out. Please try again.`);
      } else {
        localToast("Claim request timed out. Please try again.");
      }
      updateClaimOverlay();
    }, claimInFlightTimeoutMs);
    if (claimConfirmBtn){
      claimConfirmBtn.disabled = true;
    }
  }

  function clearClaimInFlight(){
    if (claimInFlightTimeoutId){
      clearTimeout(claimInFlightTimeoutId);
      claimInFlightTimeoutId = null;
    }
    claimInFlight = false;
    claimInFlightCid = null;
    if (claimStatus === "claiming"){
      claimStatus = (claimedCid !== null && claimedCid !== undefined) ? "claimed" : "unclaimed";
    }
    updateClaimSelection();
  }

  function handleAutoClaimFailure(){
    if (!autoClaimPending) return;
    const cid = autoClaimPending.cid;
    const displayName = autoClaimPending.name || `#${cid}`;
    clearAutoClaimPending();
    clearClaimInFlight();
    clearLanSelection();
    allowUnclaimed = false;
    localToast(`Could not claim ${displayName}. Please choose again.`);
    updateClaimOverlay();
  }

  function checkAutoClaimResolved(){
    if (!autoClaimPending) return;
    if (claimedCid !== null && claimedCid !== undefined){
      if (cidMatches(claimedCid, autoClaimPending.cid, "lan.autoClaimMatch")){
        clearAutoClaimPending();
      } else {
        handleAutoClaimFailure();
      }
    }
  }

  function maybeAutoClaimFromState(msg, pcs){
    if (autoClaimChecked) return;
    const hasPcInfo = Object.prototype.hasOwnProperty.call(msg || {}, "pcs")
      || Object.prototype.hasOwnProperty.call(msg || {}, "claimable");
    if (!hasPcInfo) return;
    autoClaimChecked = true;
    if (claimedCid !== null && claimedCid !== undefined) return;
    const selection = loadLanSelection();
    if (!selection) return;
    const list = Array.isArray(pcs) ? pcs : [];
    if (list.length){
      const inList = list.some((pc) => pc && cidMatches(pc.cid, selection.cid, "lan.autoClaimList"));
      if (!inList){
        autoClaimPending = {cid: selection.cid, name: selection.name || `#${selection.cid}`};
        handleAutoClaimFailure();
        return;
      }
    }
    const pendingName = selection.name || getClaimablePcName(selection.cid, list) || `#${selection.cid}`;
    autoClaimPending = {
      cid: selection.cid,
      name: pendingName,
      timeoutId: setTimeout(() => {
        if (!autoClaimPending) return;
        if (!claimedCid || !cidMatches(claimedCid, selection.cid, "lan.autoClaimTimeout")){
          handleAutoClaimFailure();
        }
      }, autoClaimTimeoutMs),
      startedAt: stateUpdateCounter,
    };
    setClaimInFlight(selection.cid);
    send({type:"claim", cid: selection.cid, client_id: clientId});
  }

  function handleAutoClaimStateUpdate(){
    if (!autoClaimPending) return;
    if (autoClaimPending.startedAt === undefined) return;
    if (stateUpdateCounter > autoClaimPending.startedAt){
      if (!claimedCid || !cidMatches(claimedCid, autoClaimPending.cid, "lan.autoClaimStateCheck")){
        handleAutoClaimFailure();
      } else {
        clearAutoClaimPending();
      }
    }
  }

  function setSelectedClaimCid(cid){
    selectedClaimCid = normalizeCid(cid, "claimModal.selectedCid");
    updateClaimSelection();
  }

  function updateClaimSelection(){
    if (!claimListEl) return;
    const items = Array.from(claimListEl.querySelectorAll("[data-claim-cid]"));
    items.forEach((item) => {
      const cidValue = normalizeCid(item.dataset.claimCid, "claimModal.itemCid");
      const isSelected = cidValue !== null && selectedClaimCid !== null
        && cidMatches(cidValue, selectedClaimCid, "claimModal.selectedMatch");
      item.classList.toggle("selected", isSelected);
      const radio = item.querySelector("input[type=\"radio\"]");
      if (radio){
        radio.checked = isSelected;
      }
    });
    if (claimConfirmBtn){
      claimConfirmBtn.disabled = claimInFlight || selectedClaimCid === null || selectedClaimCid === undefined;
    }
  }

  function logClaimMessage(type, pcs){
    if (!claimDebugLoggingEnabled) return;
    console.debug(`[claim] ${type} received`, {
      ready: claimDataReady,
      static_data_seen: claimStaticDataSeen,
      state_seen: claimStateSeen,
      claimable_count: Array.isArray(pcs) ? pcs.length : 0,
      claimable_pcs: Array.isArray(pcs) ? pcs : [],
    });
  }

  function markClaimMessageSeen(type){
    if (type === "static_data"){
      claimStaticDataSeen = true;
    } else if (type === "state"){
      claimStateSeen = true;
    }
    claimDataReady = claimStaticDataSeen && claimStateSeen;
  }

  function clearClaimRenderRetry(){
    if (claimRenderRetryTimer){
      clearTimeout(claimRenderRetryTimer);
      claimRenderRetryTimer = null;
    }
  }

  function scheduleClaimRenderRetry(){
    clearClaimRenderRetry();
    claimRenderRetryTimer = setTimeout(() => {
      claimRenderRetryTimer = null;
      if (!claimDataReady) return;
      if (claimedCid !== null && claimedCid !== undefined) return;
      renderClaimList(lastPcList || []);
      updateClaimOverlay();
    }, claimRenderRetryDelayMs);
  }

  function renderClaimList(pcs){
    if (!claimListEl) return;
    const list = Array.isArray(pcs) ? pcs : [];
    if (!claimDataReady){
      clearClaimRenderRetry();
      claimListEl.textContent = "";
      selectedClaimCid = null;
      if (claimEmptyHint){
        claimEmptyHint.textContent = "Loading characters…";
        claimEmptyHint.classList.remove("hidden");
      }
      updateClaimSelection();
      return;
    }
    claimListEl.textContent = "";
    let fallbackCid = null;
    list.forEach((pc) => {
      if (!pc || typeof pc !== "object") return;
      const cidValue = normalizeCid(pc.cid, "claimModal.renderCid");
      if (cidValue === null) return;
      if (fallbackCid === null){
        fallbackCid = cidValue;
      }
      const item = document.createElement("button");
      item.type = "button";
      item.className = "item claim-item";
      item.dataset.claimCid = String(cidValue);
      const radio = document.createElement("input");
      radio.type = "radio";
      radio.name = "claimChoice";
      radio.tabIndex = -1;
      const nameEl = document.createElement("div");
      nameEl.className = "name";
      nameEl.textContent = pc.name ? String(pc.name) : `#${cidValue}`;
      const metaEl = document.createElement("div");
      metaEl.className = "meta";
      metaEl.textContent = `CID ${cidValue}`;
      item.appendChild(radio);
      item.appendChild(nameEl);
      item.appendChild(metaEl);
      item.addEventListener("click", () => {
        allowUnclaimed = false;
        setSelectedClaimCid(cidValue);
      });
      claimListEl.appendChild(item);
    });
    if (!list.length){
      selectedClaimCid = null;
    } else if (selectedClaimCid === null || selectedClaimCid === undefined){
      setSelectedClaimCid(fallbackCid);
    }
    if (claimEmptyHint){
      claimEmptyHint.textContent = "No claimable PCs yet. Ask the DM to add one.";
      claimEmptyHint.classList.toggle("hidden", list.length > 0);
    }
    if (!list.length){
      scheduleClaimRenderRetry();
    } else {
      clearClaimRenderRetry();
    }
    updateClaimSelection();
  }

  function updateClaimOverlay(){
    if (!claimModal) return;
    if (isMapView){
      claimModal.classList.remove("show");
      claimModal.setAttribute("aria-hidden", "true");
      return;
    }
    const needsClaim = claimedCid === null || claimedCid === undefined;
    const requiresClaim = !isPlanning;
    if (requiresClaim){
      allowUnclaimed = false;
    }
    const shouldShow = claimStatus === "unclaimed" && needsClaim && (requiresClaim || !allowUnclaimed);
    claimModal.classList.toggle("show", shouldShow);
    claimModal.setAttribute("aria-hidden", shouldShow ? "false" : "true");
    if (claimSpectatorBtn){
      claimSpectatorBtn.classList.toggle("hidden", !supportsMapView);
    }
    if (claimContinueBtn){
      claimContinueBtn.classList.toggle("hidden", requiresClaim || supportsMapView);
    }
    if (shouldShow){
      if (!claimDataReady && claimEmptyHint){
        claimEmptyHint.textContent = "Loading characters…";
        claimEmptyHint.classList.remove("hidden");
      }
      renderClaimList(lastPcList || []);
    } else {
      clearClaimRenderRetry();
    }
  }

  function requestCharacterSwitch(){
    allowUnclaimed = false;
    clearAutoClaimPending();
    clearClaimInFlight();
    clearLanSelection();
    if (claimedCid !== null && claimedCid !== undefined){
      claimStatus = "unclaiming";
      send({type:"unclaim", client_id: clientId});
    }
    claimedCid = null;
    selectedClaimCid = null;
    if (meEl){
      meEl.textContent = "(unclaimed)";
    }
    updateEndTurnState();
    updateClaimOverlay();
  }

  function showDashModal(){
    if (!dashModal) return;
    dashModal.classList.add("show");
    dashModal.setAttribute("aria-hidden", "false");
  }

  function hideDashModal(){
    if (!dashModal) return;
    dashModal.classList.remove("show");
    dashModal.setAttribute("aria-hidden", "true");
  }

  function showLogModal(){
    if (!logModal) return;
    logModal.classList.add("show");
    logModal.setAttribute("aria-hidden", "false");
  }

  function hideLogModal(){
    if (!logModal) return;
    logModal.classList.remove("show");
    logModal.setAttribute("aria-hidden", "true");
  }

  function requestBattleLog(){
    if (logContent){
      logContent.textContent = "Loading…";
    }
    send({type:"log_request"});
  }

  function applyTerrainPayload(terrain){
    if (!state){ state = {}; }
    if (!terrain || typeof terrain !== "object") return;
    if (Array.isArray(terrain.rough_terrain)){
      state.rough_terrain = terrain.rough_terrain;
    } else if (!state.rough_terrain){
      state.rough_terrain = [];
    }
    if (Array.isArray(terrain.obstacles)){
      state.obstacles = terrain.obstacles;
    } else if (!state.obstacles){
      state.obstacles = [];
    }
  }

  function applyTerrainPatch(patch){
    if (!state){ state = {}; }
    if (!patch || typeof patch !== "object") return;
    const roughUpdates = Array.isArray(patch.rough_updates) ? patch.rough_updates : [];
    const roughRemovals = Array.isArray(patch.rough_removals) ? patch.rough_removals : [];
    if (roughUpdates.length || roughRemovals.length){
      const roughMap = new Map();
      (state.rough_terrain || []).forEach((cell) => {
        if (!cell) return;
        const key = `${Number(cell.col)},${Number(cell.row)}`;
        roughMap.set(key, cell);
      });
      roughUpdates.forEach((cell) => {
        if (!cell) return;
        const key = `${Number(cell.col)},${Number(cell.row)}`;
        roughMap.set(key, cell);
      });
      roughRemovals.forEach((cell) => {
        if (!cell) return;
        const key = `${Number(cell.col)},${Number(cell.row)}`;
        roughMap.delete(key);
      });
      state.rough_terrain = Array.from(roughMap.values());
    }

    const obstacleUpdates = Array.isArray(patch.obstacle_updates) ? patch.obstacle_updates : [];
    const obstacleRemovals = Array.isArray(patch.obstacle_removals) ? patch.obstacle_removals : [];
    if (obstacleUpdates.length || obstacleRemovals.length){
      const obstacleSet = new Set((state.obstacles || []).map(o => `${Number(o.col)},${Number(o.row)}`));
      obstacleUpdates.forEach((cell) => {
        if (!cell) return;
        obstacleSet.add(`${Number(cell.col)},${Number(cell.row)}`);
      });
      obstacleRemovals.forEach((cell) => {
        if (!cell) return;
        obstacleSet.delete(`${Number(cell.col)},${Number(cell.row)}`);
      });
      state.obstacles = Array.from(obstacleSet).map((key) => {
        const [col, row] = key.split(",").map(Number);
        return {col, row};
      });
    }
  }

  function applyUnitUpdates(updates){
    if (!state || !Array.isArray(state.units)) return;
    updates.forEach((update) => {
      if (!update || update.cid === undefined || update.cid === null) return;
      const cid = Number(update.cid);
      const idx = state.units.findIndex((unit) => Number(unit.cid) === cid);
      if (idx < 0) return;
      const current = state.units[idx];
      const next = {...current};
      Object.keys(update).forEach((key) => {
        if (key === "cid") return;
        next[key] = update[key];
      });
      state.units[idx] = next;
    });
  }

  function applyAoePatch(patch){
    if (!state){ state = {}; }
    if (!patch || typeof patch !== "object") return;
    const updates = Array.isArray(patch.updates) ? patch.updates : [];
    const removals = Array.isArray(patch.removals) ? patch.removals : [];
    if (!Array.isArray(state.aoes)){
      state.aoes = [];
    }
    const aoeMap = new Map();
    state.aoes.forEach((aoe) => {
      if (!aoe || aoe.aid === undefined || aoe.aid === null) return;
      aoeMap.set(Number(aoe.aid), aoe);
    });
    updates.forEach((aoe) => {
      if (!aoe || aoe.aid === undefined || aoe.aid === null) return;
      aoeMap.set(Number(aoe.aid), aoe);
    });
    removals.forEach((aid) => {
      aoeMap.delete(Number(aid));
    });
    state.aoes = Array.from(aoeMap.values()).sort((a, b) => Number(a.aid) - Number(b.aid));
  }

  function planningModeSpeed(unit){
    if (!unit) return 30;
    const mode = normalizeMovementMode(unit?.movement_mode);
    if (mode === "swim"){
      const swimSpeed = Number(unit?.swim_speed || 0);
      if (Number.isFinite(swimSpeed) && swimSpeed > 0) return swimSpeed;
    }
    if (mode === "fly"){
      const flySpeed = Number(unit?.fly_speed || 0);
      if (Number.isFinite(flySpeed) && flySpeed > 0) return flySpeed;
    }
    if (mode === "burrow"){
      const burrowSpeed = Number(unit?.burrow_speed || 0);
      if (Number.isFinite(burrowSpeed) && burrowSpeed > 0) return burrowSpeed;
    }
    const speed = Number(unit?.speed || 30);
    if (!Number.isFinite(speed) || speed <= 0) return 30;
    return speed;
  }

  function nextPlanningAoeId(){
    const list = Array.isArray(state?.aoes) ? state.aoes : [];
    let maxAid = 0;
    list.forEach((aoe) => {
      const aid = Number(aoe?.aid);
      if (Number.isFinite(aid) && aid > maxAid){
        maxAid = aid;
      }
    });
    return maxAid + 1;
  }

  function buildPlanningAoe(payload){
    if (!payload || typeof payload !== "object") return null;
    const shape = String(payload.shape || payload.kind || "").toLowerCase();
    if (!shape) return null;
    const feetPerSquare = Math.max(1, Number(state?.grid?.feet_per_square || 5));
    const aoe = {
      aid: nextPlanningAoeId(),
      kind: shape,
      cx: Number(payload.cx ?? 0),
      cy: Number(payload.cy ?? 0),
    };
    if (payload.name){
      aoe.name = payload.name;
    }
    if (payload.color){
      aoe.color = payload.color;
    }
    if (payload.damage_type){
      aoe.damage_type = payload.damage_type;
    }
    if (Array.isArray(payload.damage_types) && payload.damage_types.length){
      aoe.damage_types = payload.damage_types.slice();
    }
    if (payload.save_type){
      aoe.save_type = payload.save_type;
    }
    if (payload.dc !== undefined && payload.dc !== null){
      aoe.dc = Number(payload.dc);
    }
    if (payload.default_damage){
      aoe.default_damage = payload.default_damage;
    }
    if (payload.dice){
      aoe.dice = payload.dice;
    }
    if (payload.duration_turns !== undefined && payload.duration_turns !== null){
      const duration = Number(payload.duration_turns);
      if (Number.isFinite(duration)){
        aoe.duration_turns = duration;
        aoe.remaining_turns = duration > 0 ? duration : null;
      }
    }
    if (payload.over_time){
      aoe.over_time = true;
    }
    if (payload.persistent){
      aoe.persistent = true;
    }
    if (payload.trigger_on_start_or_enter){
      aoe.trigger_on_start_or_enter = payload.trigger_on_start_or_enter;
    }
    if (payload.move_per_turn_ft !== undefined && payload.move_per_turn_ft !== null){
      aoe.move_per_turn_ft = Number(payload.move_per_turn_ft);
      aoe.move_remaining_ft = Number(payload.move_per_turn_ft);
    }
    if (payload.pinned_default){
      aoe.pinned = true;
    }
    const radiusFt = Number(payload.radius_ft);
    const sideFt = Number(payload.side_ft);
    const lengthFt = Number(payload.length_ft);
    const widthFt = Number(payload.width_ft);
    const thicknessFt = Number(payload.thickness_ft);
    const heightFt = Number(payload.height_ft);
    const angleDeg = payload.angle_deg !== undefined && payload.angle_deg !== null
      ? Number(payload.angle_deg)
      : null;
    if (shape === "circle" || shape === "sphere" || shape === "cylinder"){
      if (Number.isFinite(radiusFt)){
        aoe.radius_sq = Math.max(0.5, radiusFt / feetPerSquare);
        aoe.radius_ft = radiusFt;
      }
      if ((shape === "sphere" || shape === "cylinder") && Number.isFinite(heightFt)){
        aoe.height_ft = heightFt;
      }
    } else if (shape === "square" || shape === "cube"){
      if (Number.isFinite(sideFt)){
        aoe.side_sq = Math.max(1.0, sideFt / feetPerSquare);
        aoe.side_ft = sideFt;
      }
    } else if (shape === "cone"){
      if (Number.isFinite(lengthFt)){
        aoe.length_sq = Math.max(1.0, lengthFt / feetPerSquare);
        aoe.length_ft = lengthFt;
      }
      if (Number.isFinite(angleDeg)){
        aoe.angle_deg = angleDeg;
      }
      aoe.orient = String(payload.orient || "vertical");
    } else if (shape === "wall"){
      if (Number.isFinite(lengthFt)){
        aoe.length_sq = Math.max(1.0, lengthFt / feetPerSquare);
        aoe.length_ft = lengthFt;
      }
      if (Number.isFinite(widthFt)){
        aoe.width_sq = Math.max(1.0, widthFt / feetPerSquare);
        aoe.width_ft = widthFt;
        if (Number.isFinite(heightFt)){
          aoe.height_ft = heightFt;
        }
      } else if (Number.isFinite(thicknessFt)){
        aoe.width_sq = Math.max(1.0, thicknessFt / feetPerSquare);
        aoe.thickness_ft = thicknessFt;
        if (Number.isFinite(heightFt)){
          aoe.height_ft = heightFt;
        }
      }
      if (Number.isFinite(angleDeg)){
        aoe.angle_deg = angleDeg;
      }
      aoe.orient = String(payload.orient || "vertical");
    } else if (shape === "line"){
      if (Number.isFinite(lengthFt)){
        aoe.length_sq = Math.max(1.0, lengthFt / feetPerSquare);
        aoe.length_ft = lengthFt;
      }
      if (Number.isFinite(widthFt)){
        aoe.width_sq = Math.max(1.0, widthFt / feetPerSquare);
        aoe.width_ft = widthFt;
      } else {
        aoe.width_sq = 1.0;
      }
      if (Number.isFinite(angleDeg)){
        aoe.angle_deg = angleDeg;
      }
      aoe.orient = String(payload.orient || "vertical");
    }
    return aoe;
  }

  function planningMutate(msg){
    if (!msg || typeof msg !== "object") return;
    const type = String(msg.type || "");
    if (type === "move"){
      const unit = getUnitByCid(msg.cid);
      const to = msg.to || {};
      if (!unit) return;
      const update = {
        cid: unit.cid,
        pos: {col: Number(to.col ?? unit.pos.col), row: Number(to.row ?? unit.pos.row)},
      };
      if (gridReady()){
        const moveRemaining = Number(unit.move_remaining || 0);
        if (Number.isFinite(moveRemaining) && moveRemaining > 0){
          const feetPerSquare = Math.max(1, Number(state?.grid?.feet_per_square || 5));
          const roughMap = buildRoughTerrainMap(state.rough_terrain);
          const obstacleSet = buildObstacleSet(state.obstacles);
          const costMap = movementCostMap(
            Number(unit.pos.col),
            Number(unit.pos.row),
            moveRemaining,
            unit,
            roughMap,
            obstacleSet,
            state.grid.cols,
            state.grid.rows,
            feetPerSquare,
          );
          const cost = costMap.get(cellKey(update.pos.col, update.pos.row));
          if (Number.isFinite(cost)){
            update.move_remaining = Math.max(0, moveRemaining - cost);
          }
        }
      }
      applyUnitUpdates([update]);
      return;
    }
    if (["dash", "perform_action", "use_action", "use_bonus_action"].includes(type)){
      const unit = getUnitByCid(msg.cid);
      if (!unit) return;
      const update = {cid: unit.cid};
      const spendRaw = String(msg.spend || "").toLowerCase();
      const spend = spendRaw.includes("bonus") ? "bonus" : "action";
      const useAction = () => {
        const current = Number(unit.action_remaining || 0);
        update.action_remaining = Math.max(0, current - 1);
      };
      const useBonus = () => {
        const current = Number(unit.bonus_action_remaining || 0);
        update.bonus_action_remaining = Math.max(0, current - 1);
      };
      if (type === "use_action"){
        useAction();
      } else if (type === "use_bonus_action"){
        useBonus();
      } else if (spend === "bonus"){
        useBonus();
      } else {
        useAction();
      }
      const actionName = String(msg.action || msg.name || "");
      const actionKey = normalizeLowerValue(actionName);
      if (type === "dash" || actionKey === "dash"){
        const baseSpeed = planningModeSpeed(unit);
        const total = Number(unit.move_total || 0);
        const remaining = Number(unit.move_remaining || 0);
        update.move_total = total + baseSpeed;
        update.move_remaining = remaining + baseSpeed;
      }
      applyUnitUpdates([update]);
      return;
    }
    if (type === "cast_aoe"){
      const aoe = buildPlanningAoe(msg.payload || {});
      if (!aoe) return;
      applyAoePatch({updates: [aoe], removals: []});
      return;
    }
    if (type === "aoe_move"){
      const aid = Number(msg.aid);
      if (!Number.isFinite(aid)) return;
      const target = msg.to || {};
      const current = Array.isArray(state?.aoes)
        ? state.aoes.find(a => Number(a?.aid) === aid)
        : null;
      if (!current) return;
      const update = {
        ...current,
        cx: Number(target.cx ?? current.cx),
        cy: Number(target.cy ?? current.cy),
      };
      if (target.angle_deg !== undefined){
        update.angle_deg = Number(target.angle_deg);
      }
      if (target.ax !== undefined){
        update.ax = Number(target.ax);
      }
      if (target.ay !== undefined){
        update.ay = Number(target.ay);
      }
      if (target.spread_deg !== undefined){
        update.spread_deg = Number(target.spread_deg);
      }
      applyAoePatch({
        updates: [update],
        removals: [],
      });
      return;
    }
    if (type === "aoe_remove"){
      const aid = Number(msg.aid);
      if (!Number.isFinite(aid)) return;
      applyAoePatch({updates: [], removals: [aid]});
    }
  }

  function gridToScreen(col,row){
    return {x: panX + col*zoom + zoom/2, y: panY + row*zoom + zoom/2};
  }
  function screenToGrid(x,y){
    return {col: Math.floor((x - panX)/zoom), row: Math.floor((y - panY)/zoom)};
  }
  function screenToGridFloat(x,y){
    return {col: (x - panX - zoom / 2) / zoom, row: (y - panY - zoom / 2) / zoom};
  }

  function coneSpreadDeg(aoe){
    const spread = Number(aoe?.spread_deg);
    if (Number.isFinite(spread)) return spread;
    const angle = Number(aoe?.angle_deg);
    if (Number.isFinite(angle)) return angle;
    return 90;
  }

  function coneHeadingDeg(aoe){
    const hasSpread = Number.isFinite(Number(aoe?.spread_deg));
    const angle = Number(aoe?.angle_deg);
    if (hasSpread && Number.isFinite(angle)) return angle;
    return aoe?.orient === "horizontal" ? 0 : -90;
  }

  function normalizeAngleDeg(angle){
    let next = angle % 360;
    if (next > 180) next -= 360;
    if (next < -180) next += 360;
    return next;
  }

  function angularDiffDeg(a, b){
    return Math.abs(normalizeAngleDeg(a - b));
  }

  function renderAoeOverlay(aoe, options = {}){
    if (!aoe || !aoe.kind) return;
    const renderAoe = options.override ? {...aoe, ...options.override} : aoe;
    const remainingTurnsRaw = renderAoe.remaining_turns;
    const remainingTurnsValue = (remainingTurnsRaw === null || remainingTurnsRaw === undefined)
      ? null
      : Number(remainingTurnsRaw);
    const cx = Number(options.cx ?? renderAoe.cx ?? 0);
    const cy = Number(options.cy ?? renderAoe.cy ?? 0);
    const {x,y} = gridToScreen(cx, cy);
    const colorHex = normalizeHexColor(renderAoe.color || "");
    const isPreview = !!options.preview;
    const alphaScale = isPreview ? 0.65 : 1;
    ctx.save();
    ctx.lineWidth = 2;
    ctx.setLineDash([6,4]);
    if (renderAoe.kind === "circle" || renderAoe.kind === "sphere" || renderAoe.kind === "cylinder"){
      const r = Math.max(0, Number(renderAoe.radius_sq || 0)) * zoom;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fillStyle = colorHex
        ? rgbaFromHex(colorHex, 0.28 * alphaScale)
        : `rgba(168,197,255,${0.32 * alphaScale})`;
      ctx.strokeStyle = colorHex || `rgba(45,79,138,${0.85 * alphaScale})`;
      ctx.fill();
      ctx.stroke();
    } else if (renderAoe.kind === "line" || renderAoe.kind === "wall"){
      const lengthPx = Math.max(0, Number(renderAoe.length_sq || 0)) * zoom;
      const widthPx = Math.max(0, Number(renderAoe.width_sq || 0)) * zoom;
      const angleDeg = Number.isFinite(Number(renderAoe.angle_deg)) ? Number(renderAoe.angle_deg) : null;
      const orient = renderAoe.orient === "horizontal" ? "horizontal" : "vertical";
      const halfW = orient === "horizontal" ? lengthPx / 2 : widthPx / 2;
      const halfH = orient === "horizontal" ? widthPx / 2 : lengthPx / 2;
      ctx.fillStyle = colorHex
        ? rgbaFromHex(colorHex, 0.28 * alphaScale)
        : (renderAoe.kind === "wall"
          ? `rgba(255,230,153,${0.32 * alphaScale})`
          : `rgba(183,255,224,${0.32 * alphaScale})`);
      ctx.strokeStyle = colorHex || (renderAoe.kind === "wall"
        ? `rgba(181,125,34,${0.85 * alphaScale})`
        : `rgba(45,138,87,${0.85 * alphaScale})`);
      if (angleDeg !== null){
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate((angleDeg * Math.PI) / 180);
        ctx.beginPath();
        ctx.rect(-lengthPx / 2, -widthPx / 2, lengthPx, widthPx);
        ctx.fill();
        ctx.stroke();
        ctx.restore();
      } else {
        ctx.beginPath();
        ctx.rect(x - halfW, y - halfH, halfW * 2, halfH * 2);
        ctx.fill();
        ctx.stroke();
      }
    } else if (renderAoe.kind === "square" || renderAoe.kind === "cube"){
      const sidePx = Math.max(0, Number(renderAoe.side_sq || 0)) * zoom;
      const half = sidePx / 2;
      const angleDeg = Number.isFinite(Number(renderAoe.angle_deg)) ? Number(renderAoe.angle_deg) : null;
      if (angleDeg !== null){
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate((angleDeg * Math.PI) / 180);
        ctx.beginPath();
        ctx.rect(-half, -half, sidePx, sidePx);
        ctx.fillStyle = colorHex
          ? rgbaFromHex(colorHex, 0.28 * alphaScale)
          : `rgba(226,182,255,${0.32 * alphaScale})`;
        ctx.strokeStyle = colorHex || `rgba(107,61,138,${0.85 * alphaScale})`;
        ctx.fill();
        ctx.stroke();
        ctx.restore();
      } else {
        ctx.beginPath();
        ctx.rect(x - half, y - half, sidePx, sidePx);
        ctx.fillStyle = colorHex
          ? rgbaFromHex(colorHex, 0.28 * alphaScale)
          : `rgba(226,182,255,${0.32 * alphaScale})`;
        ctx.strokeStyle = colorHex || `rgba(107,61,138,${0.85 * alphaScale})`;
        ctx.fill();
        ctx.stroke();
      }
    } else if (renderAoe.kind === "cone"){
      const lengthPx = Math.max(0, Number(renderAoe.length_sq || 0)) * zoom;
      const spreadDeg = coneSpreadDeg(renderAoe);
      const headingDeg = coneHeadingDeg(renderAoe);
      const halfSpread = (spreadDeg * Math.PI) / 360;
      const headingRad = (headingDeg * Math.PI) / 180;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.arc(x, y, lengthPx, headingRad - halfSpread, headingRad + halfSpread);
      ctx.closePath();
      ctx.fillStyle = colorHex
        ? rgbaFromHex(colorHex, 0.28 * alphaScale)
        : `rgba(255,189,110,${0.32 * alphaScale})`;
      ctx.strokeStyle = colorHex || `rgba(181,110,34,${0.85 * alphaScale})`;
      ctx.fill();
      ctx.stroke();
    }
    ctx.setLineDash([]);
    const label = aoe.name ? String(aoe.name) : "";
    const labelText = label
      ? (aoe.pinned && Number.isFinite(remainingTurnsValue) ? `${label} (${remainingTurnsValue}t)` : label)
      : "";
    if (labelText && !isPreview){
      ctx.font = `700 ${Math.max(10, Math.floor(zoom*0.32))}px system-ui`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = "rgba(20,25,35,0.9)";
      ctx.fillText(labelText, x + 1, y + 1);
      ctx.fillStyle = "rgba(232,238,247,0.95)";
      ctx.fillText(labelText, x, y);
    }
    ctx.restore();
  }

  function hitTestAoe(p){
    if (!state || !state.aoes || !state.aoes.length) return null;
    const gridPos = screenToGridFloat(p.x, p.y);
    for (let i = state.aoes.length - 1; i >= 0; i--){
      const aoe = state.aoes[i];
      if (!aoe || !aoe.kind) continue;
      if (!canInteractWithAoe(aoe)) continue;
      const cx = Number(aoe.cx ?? 0);
      const cy = Number(aoe.cy ?? 0);
      const dx = gridPos.col - cx;
      const dy = gridPos.row - cy;
      const kind = String(aoe.kind);
      if (kind === "circle" || kind === "sphere" || kind === "cylinder"){
        const radius = Math.max(0, Number(aoe.radius_sq || 0));
        if (dx * dx + dy * dy <= radius * radius) return aoe;
      } else if (kind === "square" || kind === "cube"){
        const side = Math.max(0, Number(aoe.side_sq || 0));
        const half = side / 2;
        const angleDeg = Number.isFinite(Number(aoe.angle_deg)) ? Number(aoe.angle_deg) : null;
        if (angleDeg !== null){
          const rad = (-angleDeg * Math.PI) / 180;
          const rx = dx * Math.cos(rad) - dy * Math.sin(rad);
          const ry = dx * Math.sin(rad) + dy * Math.cos(rad);
          if (Math.abs(rx) <= half && Math.abs(ry) <= half) return aoe;
        } else if (Math.abs(dx) <= half && Math.abs(dy) <= half) return aoe;
      } else if (kind === "line" || kind === "wall"){
        const length = Math.max(0, Number(aoe.length_sq || 0));
        const width = Math.max(0, Number(aoe.width_sq || 0));
        const angleDeg = Number.isFinite(Number(aoe.angle_deg)) ? Number(aoe.angle_deg) : null;
        const orient = aoe.orient === "horizontal" ? "horizontal" : "vertical";
        const halfW = orient === "horizontal" ? length / 2 : width / 2;
        const halfH = orient === "horizontal" ? width / 2 : length / 2;
        if (angleDeg !== null){
          const rad = (-angleDeg * Math.PI) / 180;
          const rx = dx * Math.cos(rad) - dy * Math.sin(rad);
          const ry = dx * Math.sin(rad) + dy * Math.cos(rad);
          if (Math.abs(rx) <= length / 2 && Math.abs(ry) <= width / 2) return aoe;
        } else {
          if (Math.abs(dx) <= halfW && Math.abs(dy) <= halfH) return aoe;
        }
      } else if (kind === "cone"){
        const length = Math.max(0, Number(aoe.length_sq || 0));
        const dist = Math.hypot(dx, dy);
        if (dist > length) continue;
        const angleToPoint = (Math.atan2(dy, dx) * 180) / Math.PI;
        const headingDeg = coneHeadingDeg(aoe);
        const spreadDeg = coneSpreadDeg(aoe);
        const diff = angularDiffDeg(angleToPoint, headingDeg);
        if (diff <= spreadDeg / 2) return aoe;
      }
    }
    return null;
  }


  function gridReady(){
    if (!state || !state.grid) return false;
    if (state.grid.ready === false) return false;
    return Number.isFinite(state.grid.cols) && Number.isFinite(state.grid.rows);
  }

  function updateWaitingOverlay(){
    if (!waitingOverlay) return;
    waitingOverlay.classList.toggle("show", !gridReady());
  }

  function formatFeet(feet){
    const rounded = Math.round(feet * 10) / 10;
    const label = Number.isInteger(rounded) ? String(rounded) : rounded.toFixed(1);
    return `${label} ft`;
  }

  function parseSpellRangeFeet(rangeValue){
    const text = String(rangeValue || "").toLowerCase();
    const match = text.match(/(\d+(?:\.\d+)?)\s*(?:ft|feet)/);
    if (!match) return null;
    const value = Number(match[1]);
    return Number.isFinite(value) && value >= 0 ? value : null;
  }

  function distanceFeetBetweenCells(a, b){
    const feetPerSquare = Math.max(1, Number(state?.grid?.feet_per_square || 5));
    const dx = Number(a?.col || 0) - Number(b?.col || 0);
    const dy = Number(a?.row || 0) - Number(b?.row || 0);
    return Math.hypot(dx, dy) * feetPerSquare;
  }

  function summonCellKey(col, row){
    return `${Number(col)},${Number(row)}`;
  }

  function isSummonPlacementCellValid(cell){
    if (!pendingSummonPlacement || !cell) return false;
    return summonValidCells.has(summonCellKey(cell.col, cell.row));
  }

  function clearSummonPlacementState(){
    pendingSummonPlacement = null;
    summonValidCells = new Set();
    if (summonPlacementBanner){
      summonPlacementBanner.classList.add("hidden");
      summonPlacementBanner.textContent = "";
    }
  }

  function updateSummonPlacementBanner(){
    if (!summonPlacementBanner) return;
    if (!pendingSummonPlacement){
      summonPlacementBanner.classList.add("hidden");
      summonPlacementBanner.textContent = "";
      return;
    }
    const total = Math.max(1, Number(pendingSummonPlacement.summonQuantity || 1));
    const placed = pendingSummonPlacement.positions.length;
    const remaining = Math.max(0, total - placed);
    const hasRange = Number.isFinite(Number(pendingSummonPlacement.maxRangeFt));
    const rangeLabel = hasRange ? `${Math.round(Number(pendingSummonPlacement.maxRangeFt))} ft` : "any range";
    summonPlacementBanner.textContent = `You're placing a summon. Click up to ${remaining} square(s) within ${rangeLabel} of your caster to choose spawn locations.`;
    summonPlacementBanner.classList.remove("hidden");
  }

  function rebuildSummonValidCells(){
    summonValidCells = new Set();
    if (!pendingSummonPlacement || !gridReady()) return;
    const cols = Number(state?.grid?.cols || 0);
    const rows = Number(state?.grid?.rows || 0);
    const blocked = new Set((state?.obstacles || []).map((o) => summonCellKey(o.col, o.row)));
    const maxRangeFt = Number(pendingSummonPlacement.maxRangeFt);
    for (let col = 0; col < cols; col += 1){
      for (let row = 0; row < rows; row += 1){
        const key = summonCellKey(col, row);
        if (blocked.has(key)) continue;
        if (Number.isFinite(maxRangeFt)){
          const distFt = distanceFeetBetweenCells(pendingSummonPlacement.casterPos, {col, row});
          if (distFt > maxRangeFt + 1e-6) continue;
        }
        summonValidCells.add(key);
      }
    }
  }

  function updateMeasurementControls(){
    if (measureToggle){
      measureToggle.textContent = measurementMode ? "Measuring…" : "Measure";
      measureToggle.classList.toggle("accent", measurementMode);
      measureToggle.setAttribute("aria-pressed", measurementMode ? "true" : "false");
    }
    if (measureClear){
      measureClear.disabled = !(measurement.start || measurement.end);
    }
  }

  function updateAoeLockButton(){
    if (!lockAoeBtn) return;
    lockAoeBtn.classList.toggle("accent", !lockMyAoes);
    lockAoeBtn.setAttribute("aria-pressed", lockMyAoes ? "true" : "false");
    lockAoeBtn.textContent = "Unlock my AOEs";
    lockAoeBtn.setAttribute(
      "title",
      lockMyAoes ? "AOEs locked (click to unlock)." : "AOEs unlocked (click to lock)."
    );
  }

  function isAdminClient(){
    return !!getAdminAuth();
  }

  function canInteractWithAoe(aoe){
    if (!aoe) return false;
    if (isMapView) return isAdminClient();
    if (isAdminClient()) return true;
    if (!claimedCid) return false;
    if (!cidMatches(aoe.owner_cid, claimedCid, "aoe.ownerCid")) return false;
    if (lockMyAoes) return false;
    return true;
  }

  function getClaimedUnit(){
    if (!state || !state.units || claimedCid === null) return null;
    return state.units.find(u => cidMatches(u.cid, claimedCid, "claimedUnit")) || null;
  }

  function getUnitByCid(cid){
    if (!state || !state.units) return null;
    const cidValue = normalizeCid(cid, "getUnitByCid.cid");
    if (cidValue === null) return null;
    return state.units.find(u => cidMatches(u.cid, cidValue, "getUnitByCid.unitCid")) || null;
  }

  function canControlSummonUnit(unit){
    if (!unit || claimedCid === null || claimedCid === undefined) return false;
    if (!cidMatches(unit.summoned_by_cid, claimedCid, "summonControl.owner")) return false;
    const mode = normalizeTextValue(unit.summon_controller_mode);
    return mode === "summoner" || !!unit.summon_shared_turn;
  }

  function activeControlledUnitCid(){
    const activeCid = normalizeCid(state?.active_cid, "activeControlled.activeCid");
    if (activeCid === null) return null;
    if (claimedCid !== null && claimedCid !== undefined && activeCid === claimedCid){
      return claimedCid;
    }
    const activeUnit = getUnitByCid(activeCid);
    if (canControlSummonUnit(activeUnit)){
      return activeCid;
    }
    return null;
  }

  function isUnitConcentrationLinked(unit){
    if (!unit) return false;
    if (unit.concentrating === true) return true;
    const ownerCid = normalizeCid(unit.summoned_by_cid, "concentration.ownerCid");
    if (ownerCid === null) return false;
    const owner = getUnitByCid(ownerCid);
    if (!owner || owner.concentrating !== true) return false;
    const ownerSpell = normalizeTextValue(owner.concentration_spell);
    const sourceSpell = normalizeTextValue(unit.summon_source_spell);
    return !!ownerSpell && !!sourceSpell && ownerSpell === sourceSpell;
  }

  function isUnitSpellcaster(unit){
    if (!unit) return false;
    if (unit.is_spellcaster !== undefined && unit.is_spellcaster !== null){
      return !!unit.is_spellcaster;
    }
    if (unit.spellcaster !== undefined && unit.spellcaster !== null){
      return !!unit.spellcaster;
    }
    return true;
  }

  function updateSpellPanelVisibility(){
    if (!castPanel) return;
    const claimedUnit = getClaimedUnit();
    const hideForNonCaster = hideSpellMenu && claimedUnit && !isUnitSpellcaster(claimedUnit);
    castPanel.classList.toggle("hidden", hideForNonCaster);
    if (castMenuTrigger){
      castMenuTrigger.classList.toggle("hidden", hideForNonCaster);
    }
    if (castOverlay){
      castOverlay.classList.toggle("hidden", hideForNonCaster);
    }
    if (hideForNonCaster && castOverlay?.classList.contains("show")){
      setCastOverlayOpen(false);
    }
  }

  function defaultAoeCenter(){
    const unit = getClaimedUnit();
    if (unit){
      return {cx: Number(unit.pos.col), cy: Number(unit.pos.row)};
    }
    const cols = state?.grid?.cols ?? 0;
    const rows = state?.grid?.rows ?? 0;
    return {cx: Math.max(0, (cols - 1) / 2), cy: Math.max(0, (rows - 1) / 2)};
  }

  function toGridPoint(point){
    if (!point) return {col: 0, row: 0};
    const colValue = point.col ?? point.cx ?? 0;
    const rowValue = point.row ?? point.cy ?? 0;
    return {col: Math.round(Number(colValue)), row: Math.round(Number(rowValue))};
  }

  function isLineOfSightBlocked(startPoint, endPoint){
    if (!state || !state.obstacles || !state.obstacles.length) return false;
    const start = toGridPoint(startPoint);
    const end = toGridPoint(endPoint);
    const obstacles = new Set(state.obstacles.map(o => `${Number(o.col)},${Number(o.row)}`));
    let x0 = start.col;
    let y0 = start.row;
    const x1 = end.col;
    const y1 = end.row;
    const dx = Math.abs(x1 - x0);
    const dy = Math.abs(y1 - y0);
    const sx = x0 < x1 ? 1 : -1;
    const sy = y0 < y1 ? 1 : -1;
    let err = dx - dy;
    let first = true;
    while (true){
      if (!first && obstacles.has(`${x0},${y0}`)){
        return true;
      }
      if (x0 === x1 && y0 === y1){
        break;
      }
      const e2 = 2 * err;
      if (e2 > -dy){
        err -= dy;
        x0 += sx;
      }
      if (e2 < dx){
        err += dx;
        y0 += sy;
      }
      first = false;
    }
    return false;
  }

  function setLosPreview(startPoint, endPoint, blocked){
    losPreview = {
      start: toGridPoint(startPoint),
      end: toGridPoint(endPoint),
      blocked: !!blocked,
      expiresAt: Date.now() + LOS_PREVIEW_MS,
    };
    setTimeout(() => {
      if (losPreview && Date.now() >= losPreview.expiresAt){
        losPreview = null;
        draw();
      }
    }, LOS_PREVIEW_MS + 25);
    draw();
  }

  function clearMeasurement(){
    measurement = {start: null, end: null};
    updateMeasurementControls();
    draw();
  }

  function setMeasurementPoint(p){
    if (!gridReady()) return;
    const g = screenToGrid(p.x, p.y);
    const point = {col: g.col, row: g.row};
    if (!measurement.start || measurement.end){
      measurement = {start: point, end: null};
    } else {
      measurement.end = point;
    }
    updateMeasurementControls();
    draw();
  }

  function cellKey(col, row){
    return `${col},${row}`;
  }

  function buildRoughTerrainMap(list){
    const map = new Map();
    if (Array.isArray(list)){
      list.forEach(cell => {
        map.set(cellKey(Number(cell.col), Number(cell.row)), cell || {});
      });
    }
    return map;
  }

  function buildObstacleSet(list){
    const set = new Set();
    if (Array.isArray(list)){
      list.forEach(cell => {
        set.add(cellKey(Number(cell.col), Number(cell.row)));
      });
    }
    return set;
  }

  function movementCostMap(startCol, startRow, maxFt, unit, roughMap, obstacles, cols, rows, feetPerSquare){
    const step = Number(feetPerSquare) || 5;
    const diag5 = step;
    const diag10 = step * 2;
    const mode = normalizeMovementMode(unit?.movement_mode);
    const landSpeed = Math.max(0, Number(unit?.speed || 0));
    let swimSpeed = Math.max(0, Number(unit?.swim_speed || 0));
    if (swimSpeed <= 0){
      swimSpeed = Math.max(1, Math.floor(landSpeed / 2));
    }
    let waterMultiplier = 1;
    if (mode === "normal" && landSpeed > 0 && swimSpeed > 0){
      waterMultiplier = landSpeed / swimSpeed;
    }

    function inBounds(col, row){
      return col >= 0 && row >= 0 && col < cols && row < rows;
    }

    const best = new Map();
    const bestSq = new Map();
    const heap = [];

    function heapPush(item){
      heap.push(item);
      let i = heap.length - 1;
      while (i > 0){
        const p = Math.floor((i - 1) / 2);
        if (heap[p].cost <= heap[i].cost) break;
        [heap[p], heap[i]] = [heap[i], heap[p]];
        i = p;
      }
    }

    function heapPop(){
      if (!heap.length) return null;
      const top = heap[0];
      const last = heap.pop();
      if (heap.length && last){
        heap[0] = last;
        let i = 0;
        while (true){
          const l = i * 2 + 1;
          const r = i * 2 + 2;
          let smallest = i;
          if (l < heap.length && heap[l].cost < heap[smallest].cost) smallest = l;
          if (r < heap.length && heap[r].cost < heap[smallest].cost) smallest = r;
          if (smallest === i) break;
          [heap[i], heap[smallest]] = [heap[smallest], heap[i]];
          i = smallest;
        }
      }
      return top;
    }

    const startKey = `${startCol},${startRow},0`;
    best.set(startKey, 0);
    heapPush({cost: 0, col: startCol, row: startRow, parity: 0});

    while (heap.length){
      const item = heapPop();
      if (!item) break;
      const {cost, col, row, parity} = item;
      const stateKey = `${col},${row},${parity}`;
      if (cost !== best.get(stateKey)) continue;
      if (cost > maxFt) continue;
      const sqKey = cellKey(col, row);
      const prev = bestSq.get(sqKey);
      if (prev === undefined || cost < prev){
        bestSq.set(sqKey, cost);
      }

      const neighbors = [
        [-1, 0, false], [1, 0, false], [0, -1, false], [0, 1, false],
        [-1, -1, true], [1, -1, true], [-1, 1, true], [1, 1, true],
      ];
      for (const [dc, dr, isDiag] of neighbors){
        const nc = col + dc;
        const nr = row + dr;
        if (!inBounds(nc, nr)) continue;
        if (obstacles.has(cellKey(nc, nr))) continue;
        if (isDiag){
          if (obstacles.has(cellKey(col + dc, row)) || obstacles.has(cellKey(col, row + dr))){
            continue;
          }
        }
        let stepCost;
        let npar;
        if (isDiag){
          stepCost = parity === 0 ? diag5 : diag10;
          npar = 1 - parity;
        } else {
          stepCost = step;
          npar = parity;
        }

        const currentCell = roughMap.get(cellKey(col, row)) || {};
        const targetCell = roughMap.get(cellKey(nc, nr)) || {};
        const currentType = cellMovementType(currentCell);
        const targetType = cellMovementType(targetCell);
        if (mode === "swim" && targetType !== "water") continue;
        if (mode === "burrow" && targetType === "water") continue;
        if (mode !== "fly"){
          if (currentType === "water" || targetType === "water"){
            stepCost = Math.ceil(stepCost * waterMultiplier);
          }
          if (targetCell.is_rough){
            stepCost *= 2;
          }
        }

        const newCost = cost + stepCost;
        if (newCost > maxFt) continue;
        const nextKey = `${nc},${nr},${npar}`;
        if (newCost < (best.get(nextKey) ?? 1e9)){
          best.set(nextKey, newCost);
          heapPush({cost: newCost, col: nc, row: nr, parity: npar});
        }
      }
    }

    return bestSq;
  }

  
  function saveDmUiPrefs(){ try { localStorage.setItem(dmUiPrefsKey, JSON.stringify(dmUiPrefs)); } catch(_) {} }
  function classifyLogLine(text){ const t=(text||"").toLowerCase(); if (t.includes("heal")) return "heal"; if (t.includes("save")||t.includes("concentration")) return "save"; if (t.includes("hits")||t.includes("miss")) return "attack"; if (t.includes("damage")||t.includes("takes")) return "damage"; if (t.includes("spell")||t.includes("🔮")) return "spell"; return "spell"; }
  function parseBattleLine(line){ const m=String(line||"").match(/^\[([^\]]+)\]\s*\t?\s*(.*)$/); return {time:m?m[1]:"", msg:m?m[2]:String(line||"")}; }
  function renderDmLogPanel(){
    if (!dmLogPanel || !dmLogList) return;
    const isAdmin = isAdminClient();
    dmLogPanel.classList.toggle('show', !!(isAdmin && dmUiPrefs.showLogPanel));
    dmMapPreview?.classList.toggle('show', !!(isAdmin && dmUiPrefs.showMapPreview));
    if (!isAdmin) return;
    dmLogList.textContent = "";
    const atBottom = dmLogList.scrollTop + dmLogList.clientHeight >= dmLogList.scrollHeight - 12;
    dmLogLines.forEach((line)=>{
      const parsed = parseBattleLine(line);
      const kind = classifyLogLine(parsed.msg);
      if (dmUiPrefs.filters && dmUiPrefs.filters[kind] === false) return;
      const row = document.createElement('div');
      row.className = `dm-log-entry ${kind}`;
      row.innerHTML = `<div class="dm-log-time">${parsed.time ? parsed.time.slice(11,19) : ''}</div><div class="dm-log-msg">${parsed.msg}</div>`;
      row.addEventListener('click', ()=>{
        const unit=(state?.units||[]).find(u => parsed.msg.includes(u.name));
        if (unit){ centerOn(unit.cid); dmHighlightUntil.set(String(unit.cid), Date.now()+2200); }
      });
      dmLogList.appendChild(row);
    });
    if (dmUiPrefs.autoScroll && (atBottom || dmLogAutoScrollInput?.checked)) dmLogList.scrollTop = dmLogList.scrollHeight;
  }
  function renderDmPreview(){
    if (!dmPreviewCanvas || !state?.grid || !dmUiPrefs.showMapPreview || !isAdminClient()) return;
    const pctx = dmPreviewCanvas.getContext('2d');
    const w = dmPreviewCanvas.width, h = dmPreviewCanvas.height;
    pctx.clearRect(0,0,w,h); pctx.fillStyle='#0a0c12'; pctx.fillRect(0,0,w,h);
    const cols=Number(state.grid.cols||1), rows=Number(state.grid.rows||1);
    const cell=Math.max(2, Math.min((w-8)/cols,(h-8)/rows));
    const ox=(w-cols*cell)/2, oy=(h-rows*cell)/2;
    pctx.strokeStyle='rgba(255,255,255,0.08)'; pctx.lineWidth=1;
    for(let c=0;c<=cols;c++){const x=ox+c*cell; pctx.beginPath(); pctx.moveTo(x,oy); pctx.lineTo(x,oy+rows*cell); pctx.stroke();}
    for(let r=0;r<=rows;r++){const y=oy+r*cell; pctx.beginPath(); pctx.moveTo(ox,y); pctx.lineTo(ox+cols*cell,y); pctx.stroke();}
    (state.aoes||[]).forEach(a=>{ pctx.fillStyle='rgba(120,160,255,0.18)'; const cx=ox+(Number(a.cx||0)+0.5)*cell; const cy=oy+(Number(a.cy||0)+0.5)*cell; const rr=Math.max(2, Number(a.radius_sq||1)*cell); pctx.beginPath(); pctx.arc(cx,cy,rr,0,Math.PI*2); pctx.fill(); });
    (state.units||[]).forEach(u=>{ const x=ox+(Number(u.pos.col)+0.5)*cell; const y=oy+(Number(u.pos.row)+0.5)*cell; pctx.fillStyle=(u.role==='enemy')?'rgba(255,91,91,0.9)':'rgba(106,255,176,0.9)'; pctx.beginPath(); pctx.arc(x,y,Math.max(2,cell*0.25),0,Math.PI*2); pctx.fill(); });
  }

  function draw(){
    if (!state) return;
    if (!gridReady()){
      updateWaitingOverlay();
      return;
    }
    updateWaitingOverlay();
    renderDmPreview();
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;

    ctx.clearRect(0,0,w,h);

    // background
    ctx.fillStyle = "#0a0c12";
    ctx.fillRect(0,0,w,h);

    const cols = state.grid.cols, rows = state.grid.rows;
    if (cols !== lastGrid.cols || rows !== lastGrid.rows){
      fittedToGrid = false;
      lastGrid = {cols, rows};
    }

    // auto-fit on first draw
    if (!fittedToGrid){
      const pad = 24;
      const sx = (w - pad*2) / (cols*zoom);
      const sy = (h - pad*2) / (rows*zoom);
      const s = Math.min(1.0, Math.max(0.35, Math.min(sx, sy)));
      zoom = Math.floor(zoom * s);
      panX = Math.floor((w - cols*zoom)/2);
      panY = Math.floor((h - rows*zoom)/2);
      fittedToGrid = true;
    }

    // grid
    ctx.strokeStyle = "rgba(255,255,255,0.07)";
    ctx.lineWidth = 1;
    for(let c=0;c<=cols;c++){
      const x = panX + c*zoom;
      ctx.beginPath(); ctx.moveTo(x, panY); ctx.lineTo(x, panY + rows*zoom); ctx.stroke();
    }
    for(let r=0;r<=rows;r++){
      const y = panY + r*zoom;
      ctx.beginPath(); ctx.moveTo(panX, y); ctx.lineTo(panX + cols*zoom, y); ctx.stroke();
    }

    // rough terrain
    if (state.rough_terrain && state.rough_terrain.length){
      state.rough_terrain.forEach(cell => {
        const x = panX + cell.col*zoom;
        const y = panY + cell.row*zoom;
        const colorHex = normalizeHexColor(cell.color || "");
        const movementType = cellMovementType(cell);
        const isSwim = movementType === "water";
        const isRough = !!cell.is_rough;
        let alpha = isSwim ? 0.35 : 0.25;
        if (isRough && !isSwim){
          alpha = 0.3;
        }
        const fallback = isSwim ? "rgba(74,163,223,0.32)" : "rgba(141,110,99,0.25)";
        ctx.fillStyle = colorHex ? rgbaFromHex(colorHex, alpha) : fallback;
        ctx.fillRect(x+1,y+1,zoom-2,zoom-2);
      });
    }

    // movement range (claimed token or controlled summon)
    const movableCid = activeControlledUnitCid();
    if (movableCid !== null && state.units){
      const me = state.units.find(u => cidMatches(u.cid, movableCid, "movementRange.unitCid"));
      if (me){
        const move = Math.max(0, Number(me.move_remaining || 0));
        const feet = Math.max(1, Number(state.grid.feet_per_square || 5));
        if (move > 0){
          const roughMap = buildRoughTerrainMap(state.rough_terrain);
          const obstacleSet = buildObstacleSet(state.obstacles);
          const costMap = movementCostMap(
            Number(me.pos.col),
            Number(me.pos.row),
            move,
            me,
            roughMap,
            obstacleSet,
            cols,
            rows,
            feet,
          );
          costMap.forEach((cost, key) => {
            if (!cost) return;
            const [col, row] = key.split(",").map(Number);
            const x = panX + col * zoom;
            const y = panY + row * zoom;
            ctx.fillStyle = "rgba(106,169,255,0.18)";
            ctx.fillRect(x + 1, y + 1, zoom - 2, zoom - 2);
          });
        }
      }
    }

    if (pendingSummonPlacement){
      rebuildSummonValidCells();
      updateSummonPlacementBanner();
      summonValidCells.forEach((key) => {
        const [col, row] = key.split(",").map(Number);
        const x = panX + col * zoom;
        const y = panY + row * zoom;
        ctx.fillStyle = "rgba(106,169,255,0.22)";
        ctx.fillRect(x + 1, y + 1, zoom - 2, zoom - 2);
      });
      if (pendingSummonPlacement.casterPos && Number.isFinite(Number(pendingSummonPlacement.maxRangeFt))){
        const feetPerSquare = Math.max(1, Number(state.grid.feet_per_square || 5));
        const radiusCells = Number(pendingSummonPlacement.maxRangeFt) / feetPerSquare;
        const caster = gridToScreen(pendingSummonPlacement.casterPos.col, pendingSummonPlacement.casterPos.row);
        ctx.save();
        ctx.strokeStyle = "rgba(106,169,255,0.65)";
        ctx.setLineDash([6, 4]);
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(caster.x, caster.y, Math.max(6, radiusCells * zoom), 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }
    } else {
      updateSummonPlacementBanner();
    }

    // obstacles
    if (state.obstacles && state.obstacles.length){
      ctx.fillStyle = "rgba(255,255,255,0.10)";
      state.obstacles.forEach(o => {
        const x = panX + o.col*zoom;
        const y = panY + o.row*zoom;
        ctx.fillRect(x+1,y+1,zoom-2,zoom-2);
      });
    }

    // AoE overlays
    if (state.aoes && state.aoes.length){
      state.aoes.forEach(a => {
        renderAoeOverlay(a);
      });
    }
    if (aoeDragPreview){
      const aoeSource = state?.aoes?.find(a => Number(a.aid) === Number(aoeDragPreview.aid));
      if (aoeSource){
        const override = {};
        if (Number.isFinite(Number(aoeDragPreview.angle_deg))){
          override.angle_deg = Number(aoeDragPreview.angle_deg);
        }
        if (Number.isFinite(Number(aoeDragPreview.spread_deg))){
          override.spread_deg = Number(aoeDragPreview.spread_deg);
        }
        if (Number.isFinite(Number(aoeDragPreview.ax))){
          override.ax = Number(aoeDragPreview.ax);
        }
        if (Number.isFinite(Number(aoeDragPreview.ay))){
          override.ay = Number(aoeDragPreview.ay);
        }
        renderAoeOverlay(aoeSource, {
          cx: aoeDragPreview.cx,
          cy: aoeDragPreview.cy,
          preview: true,
          override: Object.keys(override).length ? override : null,
        });
      }
    }

    // measurement line
    if (measurement.start){
      const start = gridToScreen(measurement.start.col, measurement.start.row);
      ctx.save();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(255,233,106,0.9)";
      ctx.fillStyle = "rgba(255,233,106,0.9)";
      ctx.beginPath();
      ctx.arc(start.x, start.y, Math.max(6, zoom * 0.12), 0, Math.PI * 2);
      ctx.fill();
      if (measurement.end){
        const end = gridToScreen(measurement.end.col, measurement.end.row);
        ctx.beginPath();
        ctx.moveTo(start.x, start.y);
        ctx.lineTo(end.x, end.y);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(end.x, end.y, Math.max(6, zoom * 0.12), 0, Math.PI * 2);
        ctx.fill();
        const feetPerSquare = Math.max(1, Number(state.grid.feet_per_square || 5));
        const dx = measurement.end.col - measurement.start.col;
        const dy = measurement.end.row - measurement.start.row;
        const feet = Math.hypot(dx, dy) * feetPerSquare;
        const label = formatFeet(feet);
        const midX = (start.x + end.x) / 2;
        const midY = (start.y + end.y) / 2;
        ctx.font = `700 ${Math.max(11, Math.floor(zoom * 0.32))}px system-ui`;
        ctx.textAlign = "center";
        ctx.textBaseline = "bottom";
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillText(label, midX + 1, midY - 7 + 1);
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.fillText(label, midX, midY - 7);
      }
      ctx.restore();
    }

    if (losPreview && Date.now() <= losPreview.expiresAt){
      const start = gridToScreen(losPreview.start.col, losPreview.start.row);
      const end = gridToScreen(losPreview.end.col, losPreview.end.row);
      ctx.save();
      ctx.lineWidth = 3;
      ctx.setLineDash([8, 6]);
      ctx.strokeStyle = losPreview.blocked ? "rgba(255,120,120,0.95)" : "rgba(123,233,173,0.95)";
      ctx.beginPath();
      ctx.moveTo(start.x, start.y);
      ctx.lineTo(end.x, end.y);
      ctx.stroke();
      ctx.restore();
    }

    // tokens
    const tokens = state.units || [];
    // group labels by cell
    const cellMap = new Map();
    tokens.forEach(u => {
      const key = `${u.pos.col},${u.pos.row}`;
      if (!cellMap.has(key)) cellMap.set(key, []);
      cellMap.get(key).push(u);
    });

    // draw token circles first
    tokens.forEach(u => {
      const {x,y} = gridToScreen(u.pos.col,u.pos.row);
      const r = Math.max(10, zoom*0.35);
      const active = (state.active_cid !== null && cidMatches(state.active_cid, u.cid, "token.activeCid"));
      const mine = (claimedCid != null && cidMatches(claimedCid, u.cid, "token.claimedCid"));
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);

      // color
      const customFill = u.token_color ? rgbaFromHex(u.token_color, 0.28) : null;
      if (customFill){
        ctx.fillStyle = customFill;
      } else if (u.role === "enemy") {
        ctx.fillStyle = "rgba(255,91,91,0.28)";
      } else {
        ctx.fillStyle = "rgba(106,255,176,0.18)";
      }
      ctx.fill();

      const dmHl = (dmHighlightUntil.get(String(u.cid)) || 0) > Date.now();
      ctx.lineWidth = (active || dmHl) ? 3 : 2;
      const mountStroke = u.is_mount ? "rgba(106,169,255,0.98)" : null;
      ctx.strokeStyle = dmHl ? "rgba(255,218,120,0.98)" : (mountStroke || (mine ? "rgba(106,169,255,0.95)" : (active ? "rgba(255,255,255,0.85)" : "rgba(255,255,255,0.25)")));
      ctx.stroke();
      if (u.is_mount){
        ctx.save();
        ctx.font = `${Math.max(10, Math.floor(zoom*0.28))}px system-ui`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(106,169,255,0.95)";
        ctx.fillText("♞", x, y - (r * 0.55));
        ctx.restore();
      }
      if (isUnitConcentrationLinked(u)){
        ctx.save();
        ctx.font = `${Math.max(10, Math.floor(zoom*0.3))}px system-ui`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(241,201,95,0.98)";
        ctx.fillText("✦", x + (r * 0.58), y - (r * 0.58));
        ctx.restore();
      }

      // condition markers inside
      const marks = (u.marks || "").trim();
      if (marks){
        ctx.font = `${Math.max(10, Math.floor(zoom*0.33))}px system-ui`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.fillText(marks, x, y);
      }
    });

    // labels above: name or group name
    const labelBoxes = [];
    const labelFontSize = Math.max(11, Math.floor(zoom*0.32));
    const labelOffset = zoom*0.40;
    const labelPad = 2;
    const labelStep = Math.max(6, Math.floor(labelFontSize * 0.7));
    const labelOffsets = [0, -labelStep, labelStep, -2*labelStep, 2*labelStep];
    const labelEntries = [];
    cellMap.forEach((arr, key) => {
      const [col,row] = key.split(",").map(Number);
      const {x,y} = gridToScreen(col,row);
      let label = "";
      if (arr.length >= 2){
        const names = arr.map(a => a.name).join(", ");
        label = `Group (${arr.length}): ${names}`;
      } else {
        label = arr[0].name;
      }
      const isActive = arr.some(a => state.active_cid !== null && cidMatches(state.active_cid, a.cid, "label.activeCid"));
      labelEntries.push({label, x, y: y - labelOffset, isActive});
    });
    labelEntries.sort((a, b) => Number(a.isActive) - Number(b.isActive));
    ctx.textAlign = "center";
    ctx.textBaseline = "bottom";
    ctx.font = `600 ${labelFontSize}px system-ui`;
    const overlaps = (a, b) => !(a.x2 < b.x1 || a.x1 > b.x2 || a.y2 < b.y1 || a.y1 > b.y2);
    labelEntries.forEach(entry => {
      const width = ctx.measureText(entry.label).width;
      let placed = false;
      for (const offset of labelOffsets){
        const y = entry.y + offset;
        const box = {
          x1: entry.x - width / 2 - labelPad,
          x2: entry.x + width / 2 + labelPad,
          y1: y - labelFontSize - labelPad,
          y2: y + labelPad,
        };
        if (!labelBoxes.some(b => overlaps(b, box))){
          // shadow
          ctx.fillStyle = "rgba(0,0,0,0.55)";
          ctx.fillText(entry.label, entry.x + 1, y + 1);
          ctx.fillStyle = "rgba(232,238,247,0.92)";
          ctx.fillText(entry.label, entry.x, y);
          labelBoxes.push(box);
          placed = true;
          break;
        }
      }
      if (!placed && (showAllNames || entry.isActive)){
        const y = entry.y;
        const box = {
          x1: entry.x - width / 2 - labelPad,
          x2: entry.x + width / 2 + labelPad,
          y1: y - labelFontSize - labelPad,
          y2: y + labelPad,
        };
        ctx.fillStyle = "rgba(0,0,0,0.55)";
        ctx.fillText(entry.label, entry.x + 1, y + 1);
        ctx.fillStyle = "rgba(232,238,247,0.92)";
        ctx.fillText(entry.label, entry.x, y);
        labelBoxes.push(box);
      }
    });

  }

  function centerOnPoint(col, row){
    if (!state || !state.grid) return false;
    if (!gridReady()) return false;
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    const cols = state.grid.cols, rows = state.grid.rows;
    const desiredX = (w / 2) - (Number(col) + 0.5) * zoom;
    const desiredY = (h / 2) - (Number(row) + 0.5) * zoom;
    const gridW = cols * zoom;
    const gridH = rows * zoom;
    if (gridW <= w) {
      panX = Math.floor((w - gridW) / 2);
    } else {
      const minX = w - gridW;
      panX = Math.min(0, Math.max(minX, desiredX));
    }
    if (gridH <= h) {
      panY = Math.floor((h - gridH) / 2);
    } else {
      const minY = h - gridH;
      panY = Math.min(0, Math.max(minY, desiredY));
    }
    return true;
  }

  function centerOnClaimed(){
    if (!state || !state.units || claimedCid === null || claimedCid === undefined) return false;
    if (!gridReady()) return false;
    const me = state.units.find(u => cidMatches(u.cid, claimedCid, "centerOnClaimed"));
    if (!me) return false;
    const ok = centerOnPoint(me.pos.col, me.pos.row);
    if (ok){
      centeredCid = String(claimedCid);
      draw();
    }
    return ok;
  }

  function centerOnGridCenter(){
    if (!state || !state.grid) return false;
    if (!gridReady()) return false;
    const cols = Number(state.grid.cols || 0);
    const rows = Number(state.grid.rows || 0);
    const col = Math.max(0, (cols - 1) / 2);
    const row = Math.max(0, (rows - 1) / 2);
    const ok = centerOnPoint(col, row);
    if (ok){
      draw();
    }
    return ok;
  }

  function autoCenterOnJoin(){
    if (!gridReady()) return;
    if (claimedCid !== null && claimedCid !== undefined){
      if (!initialCenterDone || (initialCenterFallback && centeredCid !== String(claimedCid))){
        if (centerOnClaimed()){
          initialCenterDone = true;
          initialCenterFallback = false;
        }
      }
    } else if (!initialCenterDone) {
      if (centerOnGridCenter()){
        initialCenterDone = true;
        initialCenterFallback = true;
      }
    }
  }

  function formatTurnOrderLabel(unit){
    if (!unit) return "";
    const role = String(unit.role || "enemy");
    let label = `${unit.name} (${role})`;
    if (unit.summoned_by_cid !== undefined && unit.summoned_by_cid !== null){
      label += ` · controlled by #${unit.summoned_by_cid}`;
    }
    if ((role === "pc" || role === "ally") && Number.isFinite(Number(unit.hp))){
      label += ` ${Number(unit.hp)} HP`;
    }
    return label;
  }

  function hideTurnOrderBubble(){
    if (!activeTurnOrderBubbleEl){
      return;
    }
    activeTurnOrderBubbleEl.classList.remove("show");
  }

  function showTurnOrderBubble(chip, unit){
    if (!activeTurnOrderBubbleEl){
      return;
    }
    if (!chip || !unit){
      hideTurnOrderBubble();
      return;
    }
    activeTurnOrderBubbleEl.textContent = formatTurnOrderLabel(unit);
    activeTurnOrderBubbleEl.classList.add("show");
    const container = activeTurnOrderBubbleEl.offsetParent || activeTurnOrderEl;
    if (!container){
      return;
    }
    const containerRect = container.getBoundingClientRect();
    const chipRect = chip.getBoundingClientRect();
    const bubbleRect = activeTurnOrderBubbleEl.getBoundingClientRect();
    let left = chipRect.left - containerRect.left + (chipRect.width / 2);
    let top = chipRect.top - containerRect.top - bubbleRect.height - 8;
    if (top < 0){
      top = chipRect.bottom - containerRect.top + 8;
    }
    const minLeft = bubbleRect.width / 2;
    const maxLeft = containerRect.width - bubbleRect.width / 2;
    if (maxLeft >= minLeft){
      left = Math.min(Math.max(left, minLeft), maxLeft);
    } else {
      left = containerRect.width / 2;
    }
    top = Math.max(top, 0);
    const maxTop = Math.max(0, containerRect.height - bubbleRect.height);
    top = Math.min(top, maxTop);
    activeTurnOrderBubbleEl.style.left = `${left}px`;
    activeTurnOrderBubbleEl.style.top = `${top}px`;
  }

  function monsterDetailEntryList(entries){
    if (!Array.isArray(entries) || !entries.length){
      return "<p>None.</p>";
    }
    const items = entries.map((entry) => {
      const name = normalizeTextValue(entry?.name || "");
      const desc = normalizeTextValue(entry?.desc || "");
      if (!name && !desc) return "";
      if (!name) return `<li>${escapeHtml(desc)}</li>`;
      if (!desc) return `<li><strong>${escapeHtml(name)}.</strong></li>`;
      return `<li><strong>${escapeHtml(name)}.</strong> ${escapeHtml(desc)}</li>`;
    }).filter(Boolean);
    if (!items.length){
      return "<p>None.</p>";
    }
    return `<ul>${items.join("")}</ul>`;
  }

  function hideMonsterDetail(){
    if (!monsterDetailOverlay) return;
    monsterDetailOverlay.classList.add("hidden");
    monsterDetailOverlay.setAttribute("aria-hidden", "true");
  }

  async function showMonsterDetail(slug, variant, slotLevel){
    if (!monsterDetailOverlay || !monsterDetailContent) return;
    const cleanSlug = normalizeTextValue(slug);
    if (!cleanSlug) return;
    monsterDetailContent.innerHTML = "<p>Loading monster details…</p>";
    monsterDetailOverlay.classList.remove("hidden");
    monsterDetailOverlay.setAttribute("aria-hidden", "false");
    const params = new URLSearchParams();
    const cleanVariant = normalizeTextValue(variant || "");
    if (cleanVariant){
      params.set("variant", cleanVariant);
    }
    const maybeSlot = Number(slotLevel);
    if (Number.isFinite(maybeSlot) && maybeSlot >= 0){
      params.set("slot_level", String(maybeSlot));
    }
    const query = params.toString();
    const url = `/api/monsters/${encodeURIComponent(cleanSlug)}${query ? `?${query}` : ""}`;
    try {
      const response = await fetch(url);
      if (!response.ok){
        throw new Error(`HTTP ${response.status}`);
      }
      const payload = await response.json();
      const mon = payload?.monster || {};
      const abilities = mon.ability_scores || {};
      const abilityCells = [["STR","str"],["DEX","dex"],["CON","con"],["INT","int"],["WIS","wis"],["CHA","cha"]]
        .map(([label,key]) => `<div class="ability-cell"><span>${label}</span><strong>${escapeHtml(String(abilities?.[key] ?? "—"))}</strong></div>`)
        .join("");
      const typeBits = [normalizeTextValue(mon.size), normalizeTextValue(mon.type)].filter(Boolean).join(" ");
      const alignment = normalizeTextValue(mon.alignment);
      const speed = Array.isArray(mon.speed) ? mon.speed.join(", ") : (typeof mon.speed === "object" && mon.speed !== null ? Object.entries(mon.speed).map(([k,v]) => `${k}: ${v}`).join(", ") : (mon.speed ?? "—"));
      const languages = Array.isArray(mon.languages) ? mon.languages.join(", ") : (normalizeTextValue(mon.languages) || "—");
      const senses = normalizeTextValue(mon.senses) || "—";
      const recharge = Array.isArray(mon.recharge) ? mon.recharge : [];
      const spellcasting = mon.spellcasting;
      const spellcastingHtml = spellcasting
        ? `<p>${escapeHtml(typeof spellcasting === "string" ? spellcasting : JSON.stringify(spellcasting))}</p>`
        : "<p>None.</p>";
      monsterDetailContent.innerHTML = `
        <h2>${escapeHtml(normalizeTextValue(mon.name) || cleanSlug)}</h2>
        <p><em>${escapeHtml(typeBits || "Unknown")} ${alignment ? `, ${escapeHtml(alignment)}` : ""}</em></p>
        <p><strong>Armor Class:</strong> ${escapeHtml(String(mon.armor_class ?? "—"))}</p>
        <p><strong>Hit Points:</strong> ${escapeHtml(String(mon.hit_points ?? "—"))}</p>
        <p><strong>Speed:</strong> ${escapeHtml(String(speed ?? "—"))}</p>
        <h3>Ability Scores</h3>
        <div class="ability-grid">${abilityCells}</div>
        <p><strong>Senses:</strong> ${escapeHtml(senses)}</p>
        <p><strong>Languages:</strong> ${escapeHtml(languages)}</p>
        <h3>Traits</h3>
        ${monsterDetailEntryList(mon.traits)}
        <h3>Actions</h3>
        ${monsterDetailEntryList(mon.actions)}
        <h3>Bonus Actions</h3>
        ${monsterDetailEntryList(mon.bonus_actions)}
        <h3>Legendary Actions</h3>
        ${monsterDetailEntryList(mon.legendary_actions)}
        <h3>Spellcasting</h3>
        ${spellcastingHtml}
        <h3>Recharge</h3>
        ${recharge.length ? `<ul>${recharge.map((entry) => `<li>${escapeHtml(String(entry))}</li>`).join("")}</ul>` : "<p>None.</p>"}
      `;
    } catch (error){
      monsterDetailContent.innerHTML = `<p>Could not load monster details for <strong>${escapeHtml(cleanSlug)}</strong>.</p>`;
    }
  }

  function updateTurnOrder(){
    if (!activeTurnOrderEl){
      return;
    }
    const TURN_CHIP_NAME_MAX = 20;
    const formatTurnChipName = (name) => {
      const fullName = String(name ?? "");
      if (fullName.length <= TURN_CHIP_NAME_MAX){
        return fullName;
      }
      return `${fullName.slice(0, TURN_CHIP_NAME_MAX - 1).trimEnd()}…`;
    };
    const order = Array.isArray(state?.turn_order) ? state.turn_order : [];
    activeTurnOrderEl.innerHTML = "";
    if (!order.length){
      if (activeTurnOrderStatusEl){
        activeTurnOrderStatusEl.textContent = "";
      }
      if (activeTurnOrderBubbleEl){
        hideTurnOrderBubble();
      }
      return;
    }
    const activeCid = normalizeCid(state?.active_cid, "turnOrder.activeCid");
    const activeIndex = activeCid === null
      ? -1
      : order.findIndex(cid => cidMatches(cid, activeCid, "turnOrder.activeIndex"));
    const claimedIndex = (claimedCid === null || claimedCid === undefined)
      ? -1
      : order.findIndex(cid => cidMatches(cid, claimedCid, "turnOrder.claimedIndex"));
    const unitsByCid = new Map();
    if (Array.isArray(state?.units)){
      state.units.forEach((unit) => {
        if (unit && unit.cid !== undefined && unit.cid !== null){
          const unitCid = normalizeCid(unit.cid, "turnOrder.unitCid");
          if (unitCid !== null){
            unitsByCid.set(unitCid, unit);
          }
        }
      });
    }
    const chipByCid = new Map();
    order.forEach((cid, idx) => {
      const cidValue = normalizeCid(cid, "turnOrder.orderCid");
      const unit = cidValue !== null ? unitsByCid.get(cidValue) : undefined;
      const chip = document.createElement("div");
      chip.className = "turn-chip";
      const role = String(unit?.role || "enemy");
      const isFriendly = role !== "enemy";
      chip.classList.add(isFriendly ? "friendly" : "enemy");
      if (idx === claimedIndex){
        chip.classList.add("claimed");
      }
      if (idx === activeIndex){
        chip.classList.add("active");
      }
      chip.setAttribute("role", "button");
      chip.setAttribute("tabindex", "0");
      const baseUnitName = unit?.name ? String(unit.name) : `#${cid}`;
      const unitName = unit?.is_mount ? `${baseUnitName} (steed)` : baseUnitName;
      const truncatedUnitName = formatTurnChipName(unitName);
      chip.setAttribute("aria-label", `Turn ${idx + 1}: ${unitName}`);
      chip.setAttribute("data-full-name", unitName);
      chip.setAttribute("title", unitName);
      if (unit?.summoned_by_cid !== undefined && unit?.summoned_by_cid !== null){
        const monsterSlug = normalizeTextValue(unit?.monster_slug || "");
        if (monsterSlug){
          chip.dataset.monsterSlug = monsterSlug;
          const monsterVariant = normalizeTextValue(unit?.summon_variant || "");
          if (monsterVariant){
            chip.dataset.monsterVariant = monsterVariant;
          }
          const slotLevel = Number(unit?.slot_level);
          if (Number.isFinite(slotLevel) && slotLevel >= 0){
            chip.dataset.slotLevel = String(slotLevel);
          }
        }
      }
      if (idx === claimedIndex){
        const claimedMarker = document.createElement("span");
        claimedMarker.className = "turn-chip-marker claimed-marker";
        claimedMarker.setAttribute("aria-hidden", "true");
        chip.appendChild(claimedMarker);
      }
      if (idx === activeIndex){
        const activeMarker = document.createElement("span");
        activeMarker.className = "turn-chip-marker active-marker";
        activeMarker.setAttribute("aria-hidden", "true");
        chip.appendChild(activeMarker);
      }
      const indexEl = document.createElement("span");
      indexEl.className = "turn-chip-index";
      indexEl.textContent = String(idx + 1);
      chip.appendChild(indexEl);
      const nameEl = document.createElement("span");
      nameEl.className = "turn-chip-name";
      nameEl.textContent = isUnitConcentrationLinked(unit) ? `${truncatedUnitName} ✦` : truncatedUnitName;
      nameEl.setAttribute("data-full-name", unitName);
      nameEl.setAttribute("title", unitName);
      chip.appendChild(nameEl);
      chip.addEventListener("click", () => {
        if (cidValue === null) return;
        setSelectedTurnCid(cidValue);
      });
      chip.addEventListener("keydown", (ev) => {
        if (ev.key === "Enter" || ev.key === " "){
          ev.preventDefault();
          if (cidValue === null) return;
          setSelectedTurnCid(cidValue);
        }
      });
      chip.addEventListener("mouseenter", () => {
        if (cidValue === null) return;
        hoveredTurnCid = cidValue;
        showTurnOrderBubble(chip, unit);
      });
      chip.addEventListener("mouseleave", () => {
        if (cidValue !== null && hoveredTurnCid === cidValue){
          hoveredTurnCid = null;
        }
        hideTurnOrderBubble();
      });
      activeTurnOrderEl.appendChild(chip);
      if (cidValue !== null){
        chipByCid.set(cidValue, chip);
      }
    });
    const setSelectedTurnCid = (cid) => {
      selectedTurnCid = cid;
      chipByCid.forEach((chip, key) => {
        chip.classList.toggle("selected", key === cid);
      });
    };
    const claimedUnit = (claimedIndex >= 0 && claimedCid != null) ? unitsByCid.get(claimedCid) : null;
    if (activeTurnOrderStatusEl){
      const activeOrderCid = activeIndex >= 0 ? normalizeCid(order[activeIndex], "turnOrder.activeDisplayCid") : null;
      const activeUnit = activeOrderCid !== null ? unitsByCid.get(activeOrderCid) : null;
      const roundLabel = Number.isFinite(Number(state?.round_num)) ? `Round ${state.round_num}` : "";
      const activeLabel = activeUnit?.name ? `Active: ${activeUnit.name}` : "Active: —";
      let statusText = roundLabel ? `${roundLabel} · ${activeLabel}` : activeLabel;
      if (claimedIndex >= 0 && claimedUnit && !isMapView){
        statusText = `${statusText} · You are #${claimedIndex + 1}: ${claimedUnit.name}`;
      }
      activeTurnOrderStatusEl.textContent = statusText;
    }
    if (mapViewActiveSelectEl){
      const orderCids = order
        .map(cid => normalizeCid(cid, "turnOrder.mapViewOrderCid"))
        .filter(cid => cid !== null);
      mapViewActiveSelectEl.textContent = "";
      const placeholder = document.createElement("option");
      placeholder.value = "";
      placeholder.textContent = "Select a combatant";
      mapViewActiveSelectEl.appendChild(placeholder);
      orderCids.forEach((cid, idx) => {
        const unit = unitsByCid.get(cid);
        const label = unit?.name ? unit.name : `#${cid}`;
        const option = document.createElement("option");
        option.value = String(cid);
        option.textContent = `${idx + 1}. ${label}`;
        mapViewActiveSelectEl.appendChild(option);
      });
      if (activeIndex >= 0){
        const activeOrderCid = normalizeCid(order[activeIndex], "turnOrder.mapViewActiveSelectCid");
        mapViewActiveSelectEl.value = activeOrderCid !== null ? String(activeOrderCid) : "";
      } else {
        mapViewActiveSelectEl.value = "";
      }
      const activeOrderCid = activeIndex >= 0 ? normalizeCid(order[activeIndex], "turnOrder.mapViewActiveUnitCid") : null;
      const activeUnit = activeOrderCid !== null ? unitsByCid.get(activeOrderCid) : null;
      const activeRole = String(activeUnit?.role || "enemy");
      mapViewActiveSelectEl.classList.toggle("friendly", activeRole !== "enemy");
      mapViewActiveSelectEl.classList.toggle("enemy", activeRole === "enemy");
    }
    let fallbackCid = selectedTurnCid;
    if (fallbackCid === null || !chipByCid.has(fallbackCid)){
      if (claimedIndex >= 0){
        fallbackCid = claimedCid;
      } else if (activeIndex >= 0){
        fallbackCid = normalizeCid(order[activeIndex], "turnOrder.fallbackActiveCid");
      } else {
        fallbackCid = normalizeCid(order[0], "turnOrder.fallbackFirstCid");
      }
    }
    setSelectedTurnCid(fallbackCid);
  }

  function normalizeActionEntry(entry, defaultType){
    if (!entry) return null;
    if (typeof entry === "string"){
      const name = String(entry || "").trim();
      if (!name) return null;
      return {name, description: "", type: defaultType};
    }
    if (typeof entry !== "object") return null;
    const name = normalizeTextValue(entry.name);
    if (!name) return null;
    const description = normalizeTextValue(entry.description) || "";
    const type = normalizeLowerValue(entry.type) || defaultType;
    return {name, description, type};
  }

  function normalizeActionList(entries, defaultType){
    const list = Array.isArray(entries) ? entries : [];
    return list
      .map((entry) => normalizeActionEntry(entry, defaultType))
      .filter(Boolean);
  }

  function isSpellActionEntry(entry){
    const name = normalizeLowerValue(entry?.name);
    return name === "magic" || name === "cast a spell" || name === "cast spell" || name === "spellcasting";
  }

  function populateActionSelect(selectEl, options, placeholder){
    if (!selectEl) return;
    const previousValue = selectEl.value;
    selectEl.textContent = "";
    const placeholderOption = document.createElement("option");
    placeholderOption.value = "";
    placeholderOption.textContent = placeholder;
    selectEl.appendChild(placeholderOption);
    const normalized = normalizeActionList(options, "action");
    normalized.forEach((item) => {
      const option = document.createElement("option");
      option.value = item.name;
      option.textContent = item.name;
      selectEl.appendChild(option);
    });
    if (previousValue && normalized.some((item) => item.name === previousValue)){
      selectEl.value = previousValue;
    } else {
      selectEl.value = "";
    }
  }


  function mountCandidatePair(){
    const me = getClaimedUnit();
    if (!me || !state?.units) return null;
    if (me.rider_cid || me.mounted_by_cid) return null;
    const sameTile = state.units.filter(u => u?.ally && Number(u?.pos?.col)===Number(me?.pos?.col) && Number(u?.pos?.row)===Number(me?.pos?.row) && Number(u?.cid)!==Number(me?.cid));
    if (sameTile.length !== 1) return null;
    const mount = sameTile[0];
    if (mount.rider_cid || mount.mounted_by_cid) return null;
    if (!mount.can_be_mounted && !mount.is_mount) return null;
    return {rider: me, mount};
  }

  function updateMountControls(){
    const me = getClaimedUnit();
    const pair = mountCandidatePair();
    pendingMountPair = pair;
    if (mountBtn){
      mountBtn.classList.toggle("hidden", !pair);
      mountBtn.classList.toggle("glow", !!pair);
    }
    if (dismountBtn){
      dismountBtn.classList.toggle("hidden", !(me && me.rider_cid));
    }
  }

  function updateHud(){
    if (!state){ return; }
    const active = state.active_cid;
    const round = state.round_num;
    turnEl.textContent = (active === null) ? "Turn: (not started)" : `Round ${round}`;
    const myTurn = claimedCid != null && active !== null && cidMatches(active, claimedCid, "hud.myTurn");
    if (resetTurnBtn){
      resetTurnBtn.disabled = !myTurn;
    }
    if (dismissSummonsBtn){
      dismissSummonsBtn.disabled = claimedCid == null;
    }
    if (claimedCid && state.units){
      const me = state.units.find(u => cidMatches(u.cid, claimedCid, "hud.claimedUnit"));
      if (me){
        meEl.textContent = me.name;
        const modeLabel = movementModeLabel(me.movement_mode);
        moveEl.textContent = `Move: ${me.move_remaining}/${me.move_total} (${modeLabel})`;
        actionEl.textContent = `Action: ${me.action_remaining ?? 0}`;
        bonusActionEl.textContent = `Bonus Action: ${me.bonus_action_remaining ?? 0}`;
        if (reactionEl){
          reactionEl.textContent = `Reaction: ${me.reaction_remaining ?? 0}`;
        }
        useActionBtn.disabled = Number(me.action_remaining || 0) <= 0;
        useBonusActionBtn.disabled = Number(me.bonus_action_remaining || 0) <= 0;
        populateActionSelect(actionSelectEl, me.actions, "None/Custom");
        populateActionSelect(bonusActionSelectEl, me.bonus_actions, "None/Custom");
        if (actionSelectEl){
          actionSelectEl.disabled = false;
        }
        if (bonusActionSelectEl){
          bonusActionSelectEl.disabled = false;
        }
        if (standUpBtn){
          standUpBtn.disabled = !(myTurn && me.is_prone);
        }
      } else {
        actionEl.textContent = "Action: —";
        bonusActionEl.textContent = "Bonus Action: —";
        if (reactionEl){
          reactionEl.textContent = "Reaction: —";
        }
        useActionBtn.disabled = true;
        useBonusActionBtn.disabled = true;
        populateActionSelect(actionSelectEl, [], "None/Custom");
        populateActionSelect(bonusActionSelectEl, [], "None/Custom");
        if (actionSelectEl){
          actionSelectEl.disabled = true;
        }
        if (bonusActionSelectEl){
          bonusActionSelectEl.disabled = true;
        }
        if (standUpBtn){
          standUpBtn.disabled = true;
        }
      }
    } else {
      actionEl.textContent = "Action: —";
      bonusActionEl.textContent = "Bonus Action: —";
      if (reactionEl){
        reactionEl.textContent = "Reaction: —";
      }
      useActionBtn.disabled = true;
      useBonusActionBtn.disabled = true;
      populateActionSelect(actionSelectEl, [], "None/Custom");
      populateActionSelect(bonusActionSelectEl, [], "None/Custom");
      if (actionSelectEl){
        actionSelectEl.disabled = true;
      }
      if (bonusActionSelectEl){
        bonusActionSelectEl.disabled = true;
      }
      if (standUpBtn){
        standUpBtn.disabled = true;
      }
    }
    renderSpellSlotMonitor();
    updateTurnOrder();
    updateSpellPanelVisibility();
    applyMapViewReadOnlyControls();
    updateEndTurnState();
    updateClaimOverlay();
  }

  function showActionPicker(){
    if (!actionPickerModal) return;
    actionPickerModal.classList.add("show");
    actionPickerModal.setAttribute("aria-hidden", "false");
  }

  function hideActionPicker(){
    if (!actionPickerModal) return;
    actionPickerModal.classList.remove("show");
    actionPickerModal.setAttribute("aria-hidden", "true");
    if (actionPickerList){
      actionPickerList.textContent = "";
    }
  }

  function buildActionPickerItem(entry){
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "action-picker-item";
    const nameEl = document.createElement("div");
    nameEl.className = "action-picker-name";
    const spendLabel = entry.spend === "bonus" ? "Bonus Action" : "Action";
    nameEl.textContent = `${entry.name} (${spendLabel})`;
    btn.appendChild(nameEl);
    if (entry.description){
      const descEl = document.createElement("div");
      descEl.className = "action-picker-meta";
      descEl.textContent = entry.description;
      btn.appendChild(descEl);
    }
    btn.addEventListener("click", () => {
      hideActionPicker();
      if (isSpellActionEntry(entry)){
        pendingSpellActionType = entry.spend === "bonus" ? "bonus_action" : "action";
        setCastOverlayOpen(true);
        return;
      }
      if (!claimedCid) return;
      const msg = {
        type: "perform_action",
        cid: claimedCid,
        spend: entry.spend,
        action: entry.name,
      };
      if (isPlanning){
        planningMutate(msg);
        draw();
        updateHud();
      }
      send(msg);
    });
    return btn;
  }

  function openActionPicker(mode){
    const unit = getClaimedUnit();
    if (!unit){
      localToast("Claim a character first, matey.");
      return;
    }
    if (!actionPickerList || !actionPickerTitle){
      return;
    }
    const actions = normalizeActionList(unit.actions, "action");
    const bonusActions = normalizeActionList(unit.bonus_actions, "bonus_action");
    const items = [];
    if (mode === "action"){
      actionPickerTitle.textContent = "Choose an Action";
      actions.forEach((entry) => items.push({...entry, spend: "action"}));
    } else if (mode === "bonus"){
      actionPickerTitle.textContent = "Choose a Bonus Action";
      bonusActions.forEach((entry) => items.push({...entry, spend: "bonus"}));
    } else {
      actionPickerTitle.textContent = "Choose Dash";
      const dashEntries = (list, spend) => {
        list.forEach((entry) => {
          if (normalizeLowerValue(entry.name) === "dash"){
            items.push({...entry, spend});
          }
        });
      };
      dashEntries(actions, "action");
      dashEntries(bonusActions, "bonus");
    }
    actionPickerList.textContent = "";
    if (!items.length){
      const empty = document.createElement("div");
      empty.className = "action-picker-meta";
      empty.textContent = "No available actions.";
      actionPickerList.appendChild(empty);
    } else {
      items.forEach((entry) => {
        actionPickerList.appendChild(buildActionPickerItem(entry));
      });
    }
    showActionPicker();
  }

  function hideTurnModal(){
    if (!turnModal) return;
    turnModal.classList.remove("show");
    turnModal.setAttribute("aria-hidden", "true");
  }

  function playTurnAlert(){
    turnAlertAudio.currentTime = 0;
    turnAlertAudio.play().catch((err) => {
      console.warn("Turn alert audio failed to play.", err);
    });
  }

  function playKoAlert(){
    koAlertAudio.currentTime = 0;
    koAlertAudio.play().catch((err) => {
      console.warn("KO audio failed to play.", err);
    });
  }

  function fireVibrate(){
    if (!lastVibrateSupported) return false;
    const didVibrate = vibrate([200, 120, 200]);
    if (!didVibrate){
      lastVibrateSupported = false;
      console.debug("Vibration blocked or unsupported.");
    }
    return didVibrate;
  }

  async function unlockTurnAudio(){
    userHasInteracted = true;
    try {
      turnAlertAudio.muted = true;
      turnAlertAudio.currentTime = 0;
      await turnAlertAudio.play();
      turnAlertAudio.pause();
      turnAlertAudio.currentTime = 0;
      turnAlertAudio.muted = false;
      audioUnlocked = true;
      localToast('Turn sounds enabled.');
    } catch (err){
      turnAlertAudio.muted = false;
      console.warn('Turn alert audio unlock failed.', err);
    }
    if (pendingTurnAlert){
      pendingTurnAlert = false;
      playTurnAlert();
    }
    if (pendingVibrate){
      fireVibrate();
      pendingVibrate = false;
    }
  }

  function handleUserGesture(){
    userHasInteracted = true;
    if (!audioUnlocked){
      unlockTurnAudio();
      return;
    }
    if (pendingTurnAlert){
      pendingTurnAlert = false;
      playTurnAlert();
    }
    if (pendingVibrate){
      fireVibrate();
      pendingVibrate = false;
    }
  }

  function maybeNotifyTurnStart(){
    if (!("Notification" in window)) return;
    if (Notification.permission !== "granted") return;
    try {
      const title = "It's your turn!";
      const body = 'Act now in Initiative Tracker.';
      const notification = new Notification(title, {body, tag: 'turn-alert', renotify: true});
      notification.onclick = () => {
        window.focus();
        notification.close();
      };
    } catch (err){
      console.warn('Turn notification failed.', err);
    }
  }

  function showTurnModal(){
    if (!turnModal) return;
    if (focusTabOnTurn){
      try { window.focus(); } catch (err){ console.debug('window.focus blocked.', err); }
    }
    maybeNotifyTurnStart();
    if (document.visibilityState === "hidden") return;
    turnModal.classList.add("show");
    turnModal.setAttribute("aria-hidden", "false");
    if (audioUnlocked){
      playTurnAlert();
    } else {
      pendingTurnAlert = true;
    }
    if (userHasInteracted || navigator.userActivation?.hasBeenActive){
      fireVibrate();
    } else {
      pendingVibrate = true;
    }
  }

  function maybeShowTurnAlert(){
    if (!state || !claimedCid) return;
    const activeCid = state.active_cid;
    const round = state.round_num;
    const activeCidValue = normalizeCid(activeCid, "turnAlert.activeCid");
    const lastActiveCidValue = normalizeCid(lastActiveCid, "turnAlert.lastActiveCid");
    const isNowMyTurn = activeCidValue !== null && activeCidValue === claimedCid;
    const wasMyTurn = lastActiveCidValue !== null && lastActiveCidValue === claimedCid;
    const activeChanged = activeCidValue !== lastActiveCidValue;
    const roundChanged = round !== lastTurnRound;
    if (isNowMyTurn && (!wasMyTurn || activeChanged || roundChanged)){
      showTurnModal();
    }
    lastActiveCid = activeCid;
    lastTurnRound = round;
  }

  const planningFreezeTypes = new Set([
    "state",
    "unit_update",
    "units_snapshot",
    "terrain_update",
    "terrain_patch",
    "grid_update",
    "aoe_patch",
  ]);

  function connect(){
    if (!wsUrl){
      setConn(false, "Disconnected");
      scheduleReconnect(1000);
      return;
    }
    try {
      ws = new WebSocket(wsUrl);
    } catch (err){
      console.warn("WebSocket connect failed.", err);
      setConn(false, "Disconnected");
      scheduleReconnect(1000);
      return;
    }
    ws.addEventListener("open", () => {
      reconnecting = false;
      setConn(true, "Connected");
      if (!isMapView){
        send({type:"client_hello", client_id: clientId});
      }
      send({type:"grid_request"});
      send({type:"terrain_request"});
    });
    ws.addEventListener("close", (ev) => {
      const wasReconnect = reconnecting;
      reconnecting = false;
      const serverError = ev && ev.code === 1011;
      if (serverError){
        setConn(false, "Server error while preparing state.");
        scheduleReconnect(1000);
      } else if (wasReconnect){
        setConn(false, "Reconnecting…");
        scheduleReconnect(200);
      } else {
        setConn(false, "Disconnected");
        scheduleReconnect(1000);
      }
    });
    ws.addEventListener("message", (ev) => {
      let msg = null;
      try { msg = JSON.parse(ev.data); } catch(e){ return; }
      if (isPlanning && planningSnapshotLocked && planningFreezeTypes.has(msg.type)){
        return;
      }
      if (msg.type === "static_data"){
        // Merge static data into state (sent once on connection)
        if (!state){ state = {}; }
        if (Object.prototype.hasOwnProperty.call(msg || {}, "pcs") || Object.prototype.hasOwnProperty.call(msg || {}, "claimable")){
          lastPcList = msg.pcs || msg.claimable || [];
        }
        markClaimMessageSeen("static_data");
        logClaimMessage("static_data", lastPcList);
        if (msg.data && typeof msg.data === "object"){
          if (Array.isArray(msg.data.spell_presets)){
            state.spell_presets = msg.data.spell_presets;
            requestAnimationFrame(() => {
              updateSpellPresetOptions(state?.spell_presets || []);
            });
          }
          if (msg.data.player_spells && typeof msg.data.player_spells === "object"){
            state.player_spells = msg.data.player_spells;
          }
          if (msg.data.player_profiles && typeof msg.data.player_profiles === "object"){
            state.player_profiles = msg.data.player_profiles;
          }
          if (Array.isArray(msg.data.monster_choices)){
            state.monster_choices = msg.data.monster_choices;
          }
          requestAnimationFrame(() => {
            refreshPreSummonControls();
          });
        }
        if (!isMapView && !rosterShownOnStart){
          openRosterPickerIfNeeded(true);
          rosterShownOnStart = true;
        }
        updateClaimOverlay();
      } else if (msg.type === "preset"){
        if (msg.preset && typeof msg.preset === "object"){
          applyGuiPreset(msg.preset, {persist: true});
          persistLocalPreset(msg.preset);
        } else {
          setPresetStatus("No preset saved.", 2500);
        }
      } else if (msg.type === "preset_saved"){
        setPresetStatus("Saved!");
      } else if (msg.type === "preset_error"){
        setPresetStatus(msg.error || "Preset error.", 2500);
      } else if (msg.type === "state"){
        stateUpdateCounter += 1;
        const oldSpellPresets = state?.spell_presets;
        const oldPlayerSpells = state?.player_spells;
        const oldPlayerProfiles = state?.player_profiles;
        const oldMonsterChoices = state?.monster_choices;
        const oldGrid = state?.grid;
        const oldTerrain = state?.rough_terrain;
        const oldObstacles = state?.obstacles;
        state = (msg.state && typeof msg.state === "object") ? msg.state : {};
        // Preserve static data from previous state if not in new message
        // Only preserve if old values exist and new values are undefined (not just missing)
        if (!state.spell_presets && Array.isArray(oldSpellPresets)){
          state.spell_presets = oldSpellPresets;
        }
        if (!state.player_spells && oldPlayerSpells && typeof oldPlayerSpells === "object"){
          state.player_spells = oldPlayerSpells;
        }
        if (!state.player_profiles && oldPlayerProfiles && typeof oldPlayerProfiles === "object"){
          state.player_profiles = oldPlayerProfiles;
        }
        if (!state.monster_choices && Array.isArray(oldMonsterChoices)){
          state.monster_choices = oldMonsterChoices;
        }
        if (!state.grid && oldGrid){
          state.grid = oldGrid;
        }
        if (!state.rough_terrain && Array.isArray(oldTerrain)){
          state.rough_terrain = oldTerrain;
        }
        if (!state.obstacles && Array.isArray(oldObstacles)){
          state.obstacles = oldObstacles;
        }
        if (isMapView){
          claimedCid = null;
          claimStatus = "unclaimed";
        }
        if (!Array.isArray(state.spell_presets)){
          state.spell_presets = [];
        }
        requestAnimationFrame(() => {
          updateSpellPresetOptions(state.spell_presets);
          refreshPreSummonControls();
        });
        if (Object.prototype.hasOwnProperty.call(msg || {}, "pcs") || Object.prototype.hasOwnProperty.call(msg || {}, "claimable")){
          lastPcList = msg.pcs || msg.claimable || [];
        }
        markClaimMessageSeen("state");
        logClaimMessage("state", lastPcList);
        maybeAutoClaimFromState(msg, lastPcList);
        updateWaitingOverlay();
        draw();
        updateHud();
        maybeShowTurnAlert();
        autoCenterOnJoin();
        
        // Use server-authoritative claim state from "you" field
        if (msg.you && "claimed_cid" in msg.you){
          applyServerClaim(msg.you.claimed_cid, msg.you.claimed_name, msg.you.claim_rev);
        } else {
          // Fallback to old logic if "you" field not present (backwards compatibility)
          const claimsMap = (state && typeof state.claims === "object" && state.claims) ? state.claims : {};
          const serverClaimedCid = Object.entries(claimsMap).reduce((found, entry) => {
            if (found !== null && found !== undefined) return found;
            const [cidKey, ownerClientId] = entry;
            if (String(ownerClientId || "") !== clientId) return null;  // Not mine, continue searching
            return normalizeCid(cidKey, "state.claimsCid");
          }, null);
          if (serverClaimedCid !== null && serverClaimedCid !== undefined){
            claimedCid = serverClaimedCid;
            claimStatus = "claimed";
            clearClaimInFlight();
            const claimedName = getClaimablePcName(claimedCid, lastPcList || []) || `#${claimedCid}`;
            if (meEl){
              meEl.textContent = claimedName;
            }
          } else if (!claimInFlight){
            claimedCid = null;
            claimStatus = "unclaimed";
            if (meEl){
              meEl.textContent = "(unclaimed)";
            }
          }
        }
        
        if (!claimedCid){
          showNoOwnedPcToast(msg.pcs || msg.claimable || []);
        }
        refreshTurnAlertStatus();
        if (isPlanning){
          planningSnapshotLocked = true;
        }
        handleAutoClaimStateUpdate();
        if (!isMapView && !rosterShownOnStart){
          openRosterPickerIfNeeded(true);
          rosterShownOnStart = true;
        }
      } else if (msg.type === "turn_update"){
        if (!state){ state = {}; }
        if ("active_cid" in msg){
          state.active_cid = msg.active_cid;
        }
        if ("round_num" in msg){
          state.round_num = msg.round_num;
        }
        if ("turn_order" in msg){
          state.turn_order = msg.turn_order;
        }
        updateHud();
        maybeShowTurnAlert();
        draw();
      } else if (msg.type === "units_snapshot"){
        if (!state){ state = {}; }
        state.units = Array.isArray(msg.units) ? msg.units : [];
        updateHud();
        draw();
      } else if (msg.type === "unit_update"){
        const updates = Array.isArray(msg.updates) ? msg.updates : [];
        if (updates.length){
          applyUnitUpdates(updates);
          updateHud();
          draw();
        }
      } else if (msg.type === "force_claim"){
        if (isMapView) return;
        const applied = applyServerClaim(
          msg.you && Object.prototype.hasOwnProperty.call(msg.you, "claimed_cid") ? msg.you.claimed_cid : msg.cid,
          msg.you?.claimed_name,
          msg.you?.claim_rev ?? msg.claim_rev,
        );
        if (applied && claimedCid !== null && claimedCid !== undefined){
          autoCenterOnJoin();
          if (spellbookOverlay?.classList.contains("show")){
            syncSpellbookClaimedPlayer();
            renderSpellbook();
          }
        }
        updateHud();
        noteEl.textContent = msg.text || "Assigned by the DM.";
        setTimeout(() => noteEl.textContent = "Tip: drag yer token · hold Shift to drag AoE (touch-hold ok)", 2500);
        refreshTurnAlertStatus();
        checkAutoClaimResolved();
      } else if (msg.type === "force_unclaim"){
        if (isMapView) return;
        applyServerClaim(null, null, msg.claim_rev);
        shownNoOwnedToast = false;
        showNoOwnedPcToast(msg.pcs || lastPcList || []);
        if (spellbookOverlay?.classList.contains("show")){
          renderSpellbook();
        }
        refreshTurnAlertStatus();
        updateHud();
        handleAutoClaimFailure();
      } else if (msg.type === "claim_ack"){
        if (isMapView) return;
        if (msg.ok === false){
          claimStatus = "unclaimed";
          clearClaimInFlight();
        }
        if (msg.you && Object.prototype.hasOwnProperty.call(msg.you, "claimed_cid")){
          applyServerClaim(msg.you.claimed_cid, msg.you.claimed_name, msg.you.claim_rev ?? msg.claim_rev);
        } else {
          applyServerClaim(msg.claimed_cid, null, msg.claim_rev);
        }
        if (claimedCid !== null && claimedCid !== undefined){
          autoCenterOnJoin();
        }
        refreshTurnAlertStatus();
        updateHud();
      } else if (msg.type === "unclaim_ack"){
        if (isMapView) return;
        applyServerClaim(null, null, msg.claim_rev);
        refreshTurnAlertStatus();
        updateHud();
      } else if (msg.type === "toast"){
        noteEl.textContent = msg.text || "…";
        setTimeout(() => noteEl.textContent = "Tip: drag yer token · hold Shift to drag AoE (touch-hold ok)", 2500);
      } else if (msg.type === "mount_prompt"){
        pendingMountRequestId = msg.request_id || null;
        if (mountPromptBody){
          mountPromptBody.textContent = `${msg.rider_name || "Someone"} wants to mount you. OK?`;
        }
        if (mountPromptModal){
          mountPromptModal.classList.add("show");
          mountPromptModal.setAttribute("aria-hidden", "false");
        }
      } else if (msg.type === "battle_log"){
        if (logContent){
          const lines = Array.isArray(msg.lines) ? msg.lines : [];
          logContent.textContent = lines.length ? lines.join("\n") : "No log entries yet.";
          dmLogLines = lines;
          const units = state?.units || [];
          const now = Date.now();
          lines.slice(-4).forEach((line)=>{ const text=String(line||""); const unit=units.find(u=>text.includes(u.name)); if (unit){ dmHighlightUntil.set(String(unit.cid), now+2200); }});
          renderDmLogPanel();
        }
        showLogModal();
      } else if (msg.type === "grid_update"){
        if (!state){ state = {}; }
        if ("grid" in msg){
          state.grid = msg.grid;
        }
        if (gridReady()){
          const cols = state.grid.cols;
          const rows = state.grid.rows;
          const gridChanged = cols !== lastGrid.cols || rows !== lastGrid.rows;
          if (gridChanged){
            fittedToGrid = false;
            lastGrid = {cols, rows};
          }
        }
        updateWaitingOverlay();
        lastGridVersion = msg.version ?? lastGridVersion;
        send({type:"grid_ack", version: msg.version});
        draw();
      } else if (msg.type === "terrain_update"){
        applyTerrainPayload(msg.terrain);
        updateWaitingOverlay();
        send({type:"terrain_ack", version: msg.version});
        draw();
      } else if (msg.type === "terrain_patch"){
        applyTerrainPatch(msg);
        updateWaitingOverlay();
        draw();
      } else if (msg.type === "aoe_patch"){
        applyAoePatch(msg);
        draw();
      } else if (msg.type === "aoe_move_ack"){
        console.log("[AOE move ack]", msg);
        if (msg.ok === false){
          const reasonCode = typeof msg.reason_code === "string" ? msg.reason_code : "";
          const reason = reasonCode ? reasonCode.replace(/_/g, " ").toLowerCase() : "";
          const reasonText = reason ? reason[0].toUpperCase() + reason.slice(1) : "";
          localToast(reasonText ? `AOE move rejected (${reasonText}).` : "AOE move rejected.");
        }
      } else if (msg.type === "play_audio"){
        if (!msg.audio) return;
        if (msg.audio !== "ko") return;
        if (!audioUnlocked) return;
        if (msg.cid !== undefined && msg.cid !== null){
          if (!claimedCid || !cidMatches(msg.cid, claimedCid, "playAudio.cid")) return;
        }
        playKoAlert();
      }
    });
  }

  // input
  function pointerPos(ev){
    const r = canvas.getBoundingClientRect();
    return {x: ev.clientX - r.left, y: ev.clientY - r.top};
  }

  function hitTestToken(p){
    if (!state || !state.units) return null;
    for (let i=state.units.length-1; i>=0; i--){
      const u = state.units[i];
      const {x,y} = gridToScreen(u.pos.col,u.pos.row);
      const r = Math.max(12, zoom*0.45);
      const dx = p.x - x, dy = p.y - y;
      if (dx*dx + dy*dy <= r*r){
        return u;
      }
    }
    return null;
  }

  function buildCellMap(tokens){
    const cellMap = new Map();
    tokens.forEach(u => {
      const key = `${u.pos.col},${u.pos.row}`;
      if (!cellMap.has(key)) cellMap.set(key, []);
      cellMap.get(key).push(u);
    });
    return cellMap;
  }

  function groupLabelFromTokens(arr){
    if (!arr || !arr.length) return "";
    const groupName = arr.find(a => a.group_name || a.group_label || a.group)
      ?.group_name
      ?? arr.find(a => a.group_label)?.group_label
      ?? arr.find(a => a.group)?.group;
    if (groupName) return groupName;
    const names = arr.map(a => a.name).filter(Boolean);
    if (!names.length) return `Group (${arr.length})`;
    const first = names[0];
    const allSame = names.every(n => n === first);
    if (allSame){
      return `${arr.length}x ${first}`;
    }
    if (showAllNames){
      return `Group (${arr.length}): ${names.join(", ")}`;
    }
    return `Group (${arr.length})`;
  }

  function setTokenTooltip(text, clientX, clientY){
    if (!tokenTooltip) return;
    if (!text){
      tokenTooltip.classList.remove("show");
      tokenTooltip.setAttribute("aria-hidden", "true");
      return;
    }
    const wrapRect = mapWrap?.getBoundingClientRect();
    if (!wrapRect) return;
    tokenTooltip.textContent = text;
    const pad = 12;
    const left = clientX - wrapRect.left + pad;
    const top = clientY - wrapRect.top + pad;
    tokenTooltip.style.left = `${left}px`;
    tokenTooltip.style.top = `${top}px`;
    tokenTooltip.classList.add("show");
    tokenTooltip.setAttribute("aria-hidden", "false");
  }

  function clampZoom(value){
    return Math.min(90, Math.max(12, value));
  }

  function zoomAt(newZoom, focusX, focusY){
    const preZoom = zoom;
    const nextZoom = clampZoom(newZoom);
    if (Math.abs(nextZoom - preZoom) < 0.01) return;
    const col = (focusX - panX) / preZoom;
    const row = (focusY - panY) / preZoom;
    zoom = nextZoom;
    panX = focusX - col * zoom;
    panY = focusY - row * zoom;
    draw();
  }

  const activePointers = new Map();
  let pinchState = null;
  const AOE_TOUCH_HOLD_MS = 320;
  const AOE_TOUCH_MOVE_THRESHOLD = 8;

  function enforceLoginGate(){
    return false;
  }

  function startPinch(){
    if (activePointers.size < 2) return;
    const pts = Array.from(activePointers.values());
    const dx = pts[0].x - pts[1].x;
    const dy = pts[0].y - pts[1].y;
    const dist = Math.hypot(dx, dy);
    pinchState = {startDist: dist || 1, startZoom: zoom};
  }

  function updatePinch(){
    if (!pinchState || activePointers.size < 2) return;
    const pts = Array.from(activePointers.values());
    const midX = (pts[0].x + pts[1].x) / 2;
    const midY = (pts[0].y + pts[1].y) / 2;
    const dx = pts[0].x - pts[1].x;
    const dy = pts[0].y - pts[1].y;
    const dist = Math.hypot(dx, dy);
    if (pinchState.startDist <= 0) return;
    const scale = dist / pinchState.startDist;
    zoomAt(pinchState.startZoom * scale, midX, midY);
  }

  function clearAoeDragPending(){
    if (aoeDragPending?.timerId){
      clearTimeout(aoeDragPending.timerId);
    }
    aoeDragPending = null;
  }

  function beginAoeDrag({aid, offsetCol, offsetRow, centerCol, centerRow}){
    aoeDragging = {aid, offsetCol, offsetRow, isRotating: false};
    aoeDragPreview = {aid, cx: centerCol, cy: centerRow};
  }

  function getAoeById(aid){
    if (!state || !Array.isArray(state.aoes)) return null;
    return state.aoes.find(a => Number(a?.aid) === Number(aid)) || null;
  }

  function resolveAoeAnchor(aoe){
    const ax = Number(aoe?.ax);
    const ay = Number(aoe?.ay);
    if (Number.isFinite(ax) && Number.isFinite(ay)){
      return {ax, ay};
    }
    const cx = Number(aoe?.cx ?? 0);
    const cy = Number(aoe?.cy ?? 0);
    return {
      ax: Number.isFinite(cx) ? cx : 0,
      ay: Number.isFinite(cy) ? cy : 0,
    };
  }

  function isAoeRotateMode(ev, aoe){
    if (!aoe) return false;
    const kind = String(aoe.kind || "");
    if (kind !== "line" && kind !== "cone" && kind !== "cube") return false;
    return !!(ev?.shiftKey || shiftMoveMode);
  }

  function activateAoeDragPending(){
    if (!aoeDragPending) return;
    const pending = aoeDragPending;
    clearAoeDragPending();
    beginAoeDrag(pending);
  }

  function allowAoeDrag(ev){
    if (isMapView) return false;
    if (isAdminClient()) return true;
    if (!claimedCid) return false;
    if (lockMyAoes) return false;
    if (ev.pointerType === "touch") return true;
    if (isPlanning) return true;
    return true;
  }

  canvas.addEventListener("pointerdown", (ev) => {
    if (enforceLoginGate()) return;
    setTokenTooltip(null);
    canvas.setPointerCapture(ev.pointerId);
    const p = pointerPos(ev);
    activePointers.set(ev.pointerId, p);
    if (activePointers.size >= 2){
      dragging = null;
      panning = null;
      clearAoeDragPending();
      startPinch();
      return;
    }
    if (measurementMode){
      setMeasurementPoint(p);
      return;
    }
    if (isMapView){
      if (!lockMap){
        panning = {x: p.x, y: p.y, panX, panY};
      }
      return;
    }

    const isTouchPointer = ev.pointerType === "touch";
    const isAoeDragMouse = ev.pointerType === "mouse" && (ev.button === 0 || ev.button === 1);
    if ((shiftMoveMode || ev.shiftKey) && (isAoeDragMouse || isTouchPointer) && allowAoeDrag(ev)){
      const hitAoe = hitTestAoe(p);
      if (hitAoe){
        ev.preventDefault();
        const gridPos = screenToGridFloat(p.x, p.y);
        const centerCol = Number(hitAoe.cx ?? 0);
        const centerRow = Number(hitAoe.cy ?? 0);
        const pendingPayload = {
          pointerId: ev.pointerId,
          aid: Number(hitAoe.aid),
          offsetCol: gridPos.col - centerCol,
          offsetRow: gridPos.row - centerRow,
          centerCol,
          centerRow,
          startX: p.x,
          startY: p.y,
        };
        clearAoeDragPending();
        if (isTouchPointer){
          aoeDragPending = {
            ...pendingPayload,
            timerId: setTimeout(() => {
              if (aoeDragPending?.pointerId !== ev.pointerId) return;
              activateAoeDragPending();
            }, AOE_TOUCH_HOLD_MS),
          };
        } else {
          beginAoeDrag(pendingPayload);
        }
        return;
      }
    }
    const hit = hitTestToken(p);
    if (hit){
      // only drag own token
      const controlledCid = activeControlledUnitCid();
      if (!claimedCid || (controlledCid === null || !cidMatches(hit.cid, controlledCid, "dragToken.hitCid"))){
        send({type:"toast", text:"Arrr, that token ain’t yers."});
        return;
      }
      // only on your (or controlled summon's shared) turn
      if (controlledCid === null){
        send({type:"toast", text:"Not yer turn yet, matey."});
        return;
      }
      dragging = {cid: hit.cid, startX: p.x, startY: p.y, origCol: hit.pos.col, origRow: hit.pos.row};
      return;
    }
    if ((isAoeDragMouse || isTouchPointer) && allowAoeDrag(ev)){
      const hitAoe = hitTestAoe(p);
      if (hitAoe){
        ev.preventDefault();
        const gridPos = screenToGridFloat(p.x, p.y);
        const centerCol = Number(hitAoe.cx ?? 0);
        const centerRow = Number(hitAoe.cy ?? 0);
        const pendingPayload = {
          pointerId: ev.pointerId,
          aid: Number(hitAoe.aid),
          offsetCol: gridPos.col - centerCol,
          offsetRow: gridPos.row - centerRow,
          centerCol,
          centerRow,
          startX: p.x,
          startY: p.y,
        };
        clearAoeDragPending();
        if (isTouchPointer){
          aoeDragPending = {
            ...pendingPayload,
            timerId: setTimeout(() => {
              if (aoeDragPending?.pointerId !== ev.pointerId) return;
              activateAoeDragPending();
            }, AOE_TOUCH_HOLD_MS),
          };
        } else {
          beginAoeDrag(pendingPayload);
        }
        return;
      }
    }
    // else pan (if map not locked)
    if (shiftMoveMode){
      return;
    }
    if (!lockMap){
      panning = {x: p.x, y: p.y, panX, panY};
    }
  });

  canvas.addEventListener("pointermove", (ev) => {
    if (enforceLoginGate()) return;
    const p = pointerPos(ev);
    if (activePointers.has(ev.pointerId)){
      activePointers.set(ev.pointerId, p);
    }
    if (aoeDragPending && aoeDragPending.pointerId === ev.pointerId){
      const dx = p.x - aoeDragPending.startX;
      const dy = p.y - aoeDragPending.startY;
      if (Math.hypot(dx, dy) >= AOE_TOUCH_MOVE_THRESHOLD){
        activateAoeDragPending();
      } else {
        setTokenTooltip(null);
        return;
      }
    }
    if (pinchState && activePointers.size >= 2){
      updatePinch();
      setTokenTooltip(null);
      return;
    }
    if (aoeDragging){
      const gridPos = screenToGridFloat(p.x, p.y);
      const aoe = getAoeById(aoeDragging.aid);
      const shouldRotate = isAoeRotateMode(ev, aoe);
      aoeDragging.isRotating = shouldRotate;
      if (shouldRotate && aoe){
        const kind = String(aoe.kind || "");
        const anchor = resolveAoeAnchor(aoe);
        const dx = gridPos.col - anchor.ax;
        const dy = gridPos.row - anchor.ay;
        if (Math.abs(dx) + Math.abs(dy) < 0.01){
          return;
        }
        const angleDeg = (Math.atan2(dy, dx) * 180) / Math.PI;
        const preview = {
          aid: aoeDragging.aid,
          angle_deg: angleDeg,
          ax: anchor.ax,
          ay: anchor.ay,
        };
        if (kind === "cone"){
          if (!Number.isFinite(Number(aoe.spread_deg)) && Number.isFinite(Number(aoe.angle_deg))){
            preview.spread_deg = Number(aoe.angle_deg);
          }
          preview.cx = anchor.ax;
          preview.cy = anchor.ay;
        } else if (kind === "cube"){
          preview.cx = Number(aoe.cx ?? 0);
          preview.cy = Number(aoe.cy ?? 0);
        } else {
          const lengthSq = Number(aoe.length_sq || 0);
          const halfLen = lengthSq / 2;
          const rad = (angleDeg * Math.PI) / 180;
          const cx = anchor.ax + Math.cos(rad) * halfLen;
          const cy = anchor.ay + Math.sin(rad) * halfLen;
          preview.cx = cx;
          preview.cy = cy;
        }
        aoeDragPreview = preview;
      } else {
        const cx = gridPos.col - aoeDragging.offsetCol;
        const cy = gridPos.row - aoeDragging.offsetRow;
        aoeDragPreview = {aid: aoeDragging.aid, cx, cy};
      }
      draw();
      setTokenTooltip(null);
      return;
    }
    if (dragging){
      // update local preview by shifting pan temporarily? simplest: draw ghost at pointer
      draw();
      // ghost
      ctx.save();
      ctx.globalAlpha = 0.85;
      ctx.beginPath();
      ctx.arc(p.x, p.y, Math.max(10, zoom*0.35), 0, Math.PI*2);
      ctx.fillStyle = "rgba(106,169,255,0.25)";
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(106,169,255,0.95)";
      ctx.stroke();
      ctx.restore();
      setTokenTooltip(null);
    } else if (panning){
      panX = panning.panX + (p.x - panning.x);
      panY = panning.panY + (p.y - panning.y);
      draw();
      setTokenTooltip(null);
    } else if (measurementMode){
      setTokenTooltip(null);
    } else {
      if (ev.pointerType === "touch"){
        setTokenTooltip(null);
        return;
      }
      const tokens = state?.units || [];
      const hit = hitTestToken(p);
      if (hit){
        const cellMap = buildCellMap(tokens);
        const key = `${hit.pos.col},${hit.pos.row}`;
        const group = cellMap.get(key) || [];
        const label = group.length > 1 ? groupLabelFromTokens(group) : (hit.name || "Unknown");
        setTokenTooltip(label, ev.clientX, ev.clientY);
      } else {
        setTokenTooltip(null);
      }
    }
  });

  canvas.addEventListener("pointerup", (ev) => {
    if (enforceLoginGate()) return;
    const p = pointerPos(ev);
    activePointers.delete(ev.pointerId);
    if (activePointers.size < 2){
      pinchState = null;
    }
    if (aoeDragPending?.pointerId === ev.pointerId){
      clearAoeDragPending();
    }
    setTokenTooltip(null);
    if (pendingSummonPlacement && !isMapView && !dragging && !panning && !aoeDragging){
      const g = screenToGrid(p.x, p.y);
      if (!gridReady()){
        localToast("Map not ready yet, matey.");
        return;
      }
      const cols = Number(state?.grid?.cols || 0);
      const rows = Number(state?.grid?.rows || 0);
      if (g.col < 0 || g.row < 0 || g.col >= cols || g.row >= rows){
        localToast("That square be off the map.");
        return;
      }
      if (!isSummonPlacementCellValid(g)){
        localToast("That square is out of range—select a valid square.");
        return;
      }
      pendingSummonPlacement.positions.push({col: g.col, row: g.row});
      const remaining = pendingSummonPlacement.summonQuantity - pendingSummonPlacement.positions.length;
      if (remaining > 0){
        localToast(`${remaining} summon placement(s) remaining.`);
        return;
      }
      const payload = {
        ...pendingSummonPlacement.payload,
        summon_positions: pendingSummonPlacement.positions.slice(),
      };
      const msg = {type: "cast_spell", payload, action_type: pendingSummonPlacement.actionType};
      if (pendingSummonPlacement.spellSlug){
        msg.spell_slug = pendingSummonPlacement.spellSlug;
      }
      if (pendingSummonPlacement.spellId){
        msg.spell_id = pendingSummonPlacement.spellId;
      }
      if (Number.isFinite(pendingSummonPlacement.slotLevel)){
        msg.slot_level = pendingSummonPlacement.slotLevel;
      }
      msg.summon_choice = pendingSummonPlacement.summonChoice;
      msg.summon_quantity = pendingSummonPlacement.summonQuantity;
      msg.variant = pendingSummonPlacement.summonVariant || null;
      send(msg);
      clearSummonPlacementState();
      return;
    }

    if (aoeDragging){
      const gridPos = screenToGridFloat(p.x, p.y);
      const preview = aoeDragPreview || {};
      let targetCol = Math.round(gridPos.col - aoeDragging.offsetCol);
      let targetRow = Math.round(gridPos.row - aoeDragging.offsetRow);
      const toPayload = {};
      if (aoeDragging.isRotating && Number.isFinite(Number(preview?.angle_deg))){
        if (Number.isFinite(Number(preview?.cx))) targetCol = Number(preview.cx);
        if (Number.isFinite(Number(preview?.cy))) targetRow = Number(preview.cy);
        toPayload.angle_deg = Number(preview.angle_deg);
        if (Number.isFinite(Number(preview?.ax))) toPayload.ax = Number(preview.ax);
        if (Number.isFinite(Number(preview?.ay))) toPayload.ay = Number(preview.ay);
        if (Number.isFinite(Number(preview?.spread_deg))) toPayload.spread_deg = Number(preview.spread_deg);
      }
      toPayload.cx = targetCol;
      toPayload.cy = targetRow;
      const msg = {type:"aoe_move", aid: Number(aoeDragging.aid), to: toPayload};
      if (isPlanning){
        planningMutate(msg);
        draw();
        updateHud();
      }
      send(msg);
      aoeDragging = null;
      aoeDragPreview = null;
      draw();
      return;
    }
    dragging && (function(){
      const g = screenToGrid(p.x, p.y);
      const msg = {type:"move", cid: Number(dragging.cid), to: {col: g.col, row: g.row}};
      if (isPlanning){
        planningMutate(msg);
        draw();
        updateHud();
      }
      send(msg);
      dragging = null;
    })();
    panning = null;
  });

  canvas.addEventListener("pointercancel", (ev) => {
    if (enforceLoginGate()) return;
    activePointers.delete(ev.pointerId);
    if (activePointers.size < 2){
      pinchState = null;
    }
    if (aoeDragPending?.pointerId === ev.pointerId){
      clearAoeDragPending();
    }
    if (aoeDragging){
      aoeDragging = null;
      aoeDragPreview = null;
      draw();
    }
    setTokenTooltip(null);
  });

  canvas.addEventListener("pointerleave", () => {
    setTokenTooltip(null);
  });

  canvas.addEventListener("wheel", (ev) => {
    if (enforceLoginGate()) return;
    if (pinchState) return;
    ev.preventDefault();
    const p = pointerPos(ev);
    const delta = ev.deltaY || 0;
    const factor = delta > 0 ? 0.9 : 1.1;
    zoomAt(zoom * factor, p.x, p.y);
  }, {passive: false});

  if (zoomInBtn){
    zoomInBtn.addEventListener("click", () => {
      if (enforceLoginGate()) return;
      const r = canvas.getBoundingClientRect();
      zoomAt(zoom + 4, r.width / 2, r.height / 2);
    });
  }
  if (zoomOutBtn){
    zoomOutBtn.addEventListener("click", () => {
      if (enforceLoginGate()) return;
      const r = canvas.getBoundingClientRect();
      zoomAt(zoom - 4, r.width / 2, r.height / 2);
    });
  }
  if (lockMapBtn){
    lockMapBtn.addEventListener("click", (ev) => {
      if (enforceLoginGate()) return;
      lockMap = !lockMap;
      ev.target.textContent = lockMap ? "Unlock Map" : "Lock Map";
    });
  }
  if (lockAoeBtn){
    lockAoeBtn.addEventListener("click", () => {
      if (enforceLoginGate()) return;
      lockMyAoes = !lockMyAoes;
      persistToggle(lockMyAoesKey, lockMyAoes);
      updateAoeLockButton();
    });
  }
  if (centerMapBtn){
    centerMapBtn.addEventListener("click", () => {
      if (enforceLoginGate()) return;
      if (!centerOnClaimed()){
        centerOnGridCenter();
      }
    });
  }
  if (measureToggle){
    measureToggle.addEventListener("click", () => {
      if (enforceLoginGate()) return;
      measurementMode = !measurementMode;
      updateMeasurementControls();
    });
  }
  if (measureClear){
    measureClear.addEventListener("click", () => {
      if (enforceLoginGate()) return;
      clearMeasurement();
    });
  }
  if (tokenColorModeBtn){
    tokenColorModeBtn.addEventListener("click", () => {
      if (enforceLoginGate()) return;
      openClaimedColorModal();
    });
  }

  if (tokenColorInput){
    tokenColorInput.addEventListener("input", (ev) => {
      updateTokenColorSwatch(ev.target.value);
    });
  }
  if (tokenColorConfirm){
    tokenColorConfirm.addEventListener("click", () => {
      const claimedUnit = getClaimedUnit();
      if (!claimedUnit){
        localToast("Claim a character first, matey.");
        closeColorModal();
        return;
      }
      pendingClaim = claimedUnit;
      const color = validateTokenColor(tokenColorInput ? tokenColorInput.value : "");
      if (!color) return;
      localStorage.setItem("inittracker_tokenColor", color);
      const pendingCid = normalizeCid(pendingClaim.cid, "tokenColor.pendingCid");
      if (pendingCid === null) return;
      if (state?.units){
        const unit = state.units.find(u => cidMatches(u.cid, pendingCid, "tokenColor.unitCid"));
        if (unit){
          unit.token_color = color;
          draw();
        }
      }
      send({type:"set_color", cid: pendingCid, color});
      meEl.textContent = pendingClaim.name;
      closeColorModal();
    });
  }
  if (tokenColorCancel){
    tokenColorCancel.addEventListener("click", () => {
      closeColorModal();
      showNoOwnedPcToast(lastPcList || []);
    });
  }
  if (switchCharacterBtn){
    switchCharacterBtn.addEventListener("click", () => {
      if (enforceLoginGate()) return;
      requestCharacterSwitch();
    });
  }
  if (claimConfirmBtn){
    claimConfirmBtn.addEventListener("click", () => {
      if (selectedClaimCid === null || selectedClaimCid === undefined){
        localToast("Pick a character first, matey.");
        return;
      }
      const cidValue = normalizeCid(selectedClaimCid, "confirm.selectedCid");
      if (cidValue === null) return;
      if (claimInFlight){
        return;
      }
      allowUnclaimed = false;
      storeLanSelection(cidValue, lastPcList || []);
      setClaimInFlight(cidValue);
      send({type:"claim", cid: cidValue, client_id: clientId});
      clearSpellFilters();
      clearAutoClaimPending();
      updateClaimOverlay();
      // Don't optimistically set claimedCid here - wait for server confirmation via "you" field
    });
  }
  if (claimSpectatorBtn){
    claimSpectatorBtn.addEventListener("click", () => {
      if (!supportsMapView) return;
      location.href = "/map_view";
    });
  }
  if (claimContinueBtn){
    claimContinueBtn.addEventListener("click", () => {
      if (!isPlanning){
        updateClaimOverlay();
        return;
      }
      allowUnclaimed = true;
      updateClaimOverlay();
    });
  }

  let lastSpellPresetSignature = "";
  let cachedSpellPresets = [];
  let spellPresetBySlug = new Map();
  const normalizeSpellPresets = (presets) => {
    if (!Array.isArray(presets)) return [];
    return presets.filter(p => p && typeof p === "object").map((preset) => {
      const shape = String(preset?.shape || "").trim().toLowerCase();
      const summon = preset.summon && typeof preset.summon === "object" ? preset.summon : null;
      return {
        ...preset,
        isAoE: Boolean(shape && AOE_SHAPES.has(shape)),
        isSummon: Boolean(summon),
      };
    });
  };
  const formatSpellLevelLabel = (level) => {
    const num = Number(level);
    if (!Number.isFinite(num)) return "Unknown";
    if (num === 0) return "Cantrip";
    const suffix = num === 1 ? "st" : num === 2 ? "nd" : num === 3 ? "rd" : "th";
    return `${num}${suffix}`;
  };
  const formatListGroupLabel = (value) => String(value || "")
    .replace(/_/g, " ")
    .replace(/\\b\\w/g, (char) => char.toUpperCase());
  const normalizeTextValue = (value) => String(value || "").trim();
  const normalizeLowerValue = (value) => normalizeTextValue(value).toLowerCase();
  const getSpellKey = (value) => normalizeLowerValue(value);
  const getPresetSlug = (preset) => {
    const slug = normalizeTextValue(preset?.slug);
    if (slug) return slug;
    return normalizeLowerValue(preset?.name).replace(/\\s+/g, "-");
  };
  const AOE_SHAPES = new Set(["circle", "square", "line", "sphere", "cube", "cone", "cylinder", "wall"]);
  const isAoePreset = (preset) => Boolean(preset?.isAoE);
  const isSummonPreset = (preset) => Boolean(preset?.isSummon);
  const loadPreparedSpellFilterList = () => {
    const name = getClaimedPlayerName();
    if (!name) return null;
    const config = getSpellbookConfig(name);
    const cantrips = config.cantrips || [];
    if (!config.prepared.length && !cantrips.length) return null;
    const merged = new Set([
      ...config.prepared.map(normalizeTextValue),
      ...cantrips.map(normalizeTextValue),
    ]);
    return Array.from(merged).filter(Boolean);
  };
  const getPreparedSpellFilterSet = () => {
    if (!claimedCid) return new Set();
    if (!state?.player_spells || typeof state.player_spells !== "object") return null;
    if (!Object.prototype.hasOwnProperty.call(state.player_spells, claimedCid)) return null;
    const list = loadPreparedSpellFilterList();
    if (!list) return new Set();
    return new Set(list.map(getSpellKey));
  };
  const filterPresetsByKnownList = (presets, knownSpellSet) => {
    if (!knownSpellSet || knownSpellSet.size === 0) return presets;
    return presets.filter((preset) => {
      const slug = getPresetSlug(preset);
      if (!slug) return false;
      return knownSpellSet.has(getSpellKey(slug));
    });
  };
  const getSpellListEntries = (lists) => {
    if (!lists || typeof lists !== "object") return [];
    const entries = [];
    Object.entries(lists).forEach(([group, values]) => {
      if (!Array.isArray(values)) return;
      values.forEach((value) => {
        const trimmed = normalizeTextValue(value);
        if (!trimmed) return;
        entries.push({group, value: trimmed});
      });
    });
    return entries;
  };
  const getPresetLevelNumber = (preset) => {
    const num = Number(preset?.level);
    return Number.isFinite(num) ? num : null;
  };
  const updateManualEntryBadge = (preset) => {
    if (!castManualEntryBadge) return;
    if (!preset){
      castManualEntryBadge.classList.remove("show");
      castManualEntryBadge.setAttribute("aria-hidden", "true");
      castManualEntryBadge.removeAttribute("title");
      castManualEntryBadge.removeAttribute("aria-label");
      return;
    }
    const reasons = [];
    const automation = normalizeLowerValue(preset.automation);
    if (automation === "partial" || automation === "manual"){
      reasons.push(`automation is ${automation}`);
    }
    if (!preset.shape && !isSummonPreset(preset)){
      reasons.push("shape is missing");
    }
    if (preset.incomplete){
      const missing = Array.isArray(preset.incomplete_fields)
        ? preset.incomplete_fields.map((field) => String(field || "").trim()).filter(Boolean)
        : [];
      if (missing.length){
        reasons.push(`missing ${missing.join(", ")}`);
      } else {
        reasons.push("missing dimensions");
      }
    }
    if (reasons.length){
      const tooltip = `Manual entry required: ${reasons.join("; ")}.`;
      castManualEntryBadge.classList.add("show");
      castManualEntryBadge.setAttribute("aria-hidden", "false");
      castManualEntryBadge.title = tooltip;
      castManualEntryBadge.setAttribute("aria-label", tooltip);
    } else {
      castManualEntryBadge.classList.remove("show");
      castManualEntryBadge.setAttribute("aria-hidden", "true");
      castManualEntryBadge.removeAttribute("title");
      castManualEntryBadge.removeAttribute("aria-label");
    }
  };
  function getSelectedSpellPreset(){
    const name = normalizeTextValue(castPresetInput?.value);
    if (!name) return null;
    return cachedSpellPresets.find(preset => normalizeTextValue(preset.name) === name) || null;
  }
  function normalizeSpellActionType(value){
    const raw = normalizeLowerValue(value);
    // Order matters: keep bonus action/reaction checks before generic action.
    if (/\bbonus[\s\-_]*action\b/.test(raw)) return "bonus_action";
    if (/\breaction\b/.test(raw)) return "reaction";
    if (/\baction\b/.test(raw)) return "action";
    return "action";
  }
  function getSpellActionType(preset){
    if (!preset) return "action";
    const castingTime = normalizeTextValue(preset.casting_time || preset.castingTime);
    return normalizeSpellActionType(castingTime);
  }
  function unitHasMagicAction(unit, actionType){
    const actions = normalizeActionList(unit?.actions, "action");
    const bonusActions = normalizeActionList(unit?.bonus_actions, "bonus_action");
    if (actionType === "bonus_action"){
      return [...bonusActions, ...actions].some((entry) => isSpellActionEntry(entry));
    }
    return actions.some((entry) => isSpellActionEntry(entry));
  }
  function canSpendSpellAction(unit, actionType){
    if (!unit) return {ok: false, reason: "Claim a character first, matey."};
    const remaining = Number(unit.spell_cast_remaining || 0);
    if (remaining <= 0){
      return {ok: false, reason: "You already cast a spell this turn."};
    }
    if (actionType === "bonus_action"){
      if (!unitHasMagicAction(unit, actionType)){
        return {ok: false, reason: "No bonus-action spellcasting available."};
      }
      if (Number(unit.bonus_action_remaining || 0) <= 0){
        return {ok: false, reason: "No bonus actions left, matey."};
      }
      return {ok: true};
    }
    if (actionType === "reaction"){
      if (Number(unit.reaction_remaining || 0) <= 0){
        return {ok: false, reason: "No reactions left, matey."};
      }
      return {ok: true};
    }
    if (!unitHasMagicAction(unit, actionType)){
      return {ok: false, reason: "No spellcasting action available."};
    }
    if (Number(unit.action_remaining || 0) <= 0){
      return {ok: false, reason: "No actions left, matey."};
    }
    return {ok: true};
  }

  let spellLibraryRecords = [];
  let spellLibraryLoadPromise = null;
  let spellLibraryLoadError = "";
  let spellLibrarySearchTerm = "";
  let spellLibrarySortMode = "alpha";
  let spellLibraryPreviousFocus = null;
  let spellbookMode = "known";
  let spellbookSearchTerm = "";
  let spellbookSortMode = "alpha";
  let spellbookKnownEnabled = true;
  let spellbookKnownLimit = null;
  let spellbookPreparedLimit = null;
  let spellbookCantripsMax = null;
  let pendingKnownSet = new Set();
  let pendingPreparedSet = new Set();
  let pendingCantripsSet = new Set();
  let spellbookLeftSelection = new Set();
  let spellbookRightSelection = new Set();
  let spellbookPreviousFocus = null;
  let spellDetailPreviousFocus = null;
  let activeSpellDetailSlug = null;

  function getPlayerLevel(profile){
    const raw = profile?.leveling?.level ?? profile?.leveling?.total_level ?? profile?.leveling?.lvl;
    const value = Number(raw);
    return Number.isFinite(value) ? Math.max(0, Math.floor(value)) : 0;
  }

  function maxSpellLevelForCharacter(level){
    if (level >= 17) return 9;
    if (level >= 15) return 8;
    if (level >= 13) return 7;
    if (level >= 11) return 6;
    if (level >= 9) return 5;
    if (level >= 7) return 4;
    if (level >= 5) return 3;
    if (level >= 3) return 2;
    if (level >= 1) return 1;
    return 0;
  }

  function getPresetLevelBySlug(slug){
    const preset = spellPresetBySlug.get(getSpellKey(slug));
    return preset ? getPresetLevelNumber(preset) : null;
  }

  function sortSlugsByName(slugs){
    return slugs.slice().sort((a, b) => {
      const presetA = spellPresetBySlug.get(getSpellKey(a));
      const presetB = spellPresetBySlug.get(getSpellKey(b));
      const nameA = normalizeTextValue(presetA?.name || a);
      const nameB = normalizeTextValue(presetB?.name || b);
      return nameA.localeCompare(nameB);
    });
  }

  function getSpellbookSearchText(slug){
    const preset = spellPresetBySlug.get(getSpellKey(slug));
    const tags = Array.isArray(preset?.tags) ? preset.tags.filter(Boolean).join(" ") : "";
    return [
      preset?.name,
      slug,
      preset?.school,
      preset?.casting_time,
      preset?.range,
      tags,
    ].filter(Boolean).join(" ").toLowerCase();
  }

  function filterSpellbookSlugs(slugs){
    const query = spellbookSearchTerm.trim().toLowerCase();
    if (!query) return slugs.slice();
    return slugs.filter((slug) => getSpellbookSearchText(slug).includes(query));
  }

  function sortSpellbookSlugs(slugs){
    return slugs.slice().sort((a, b) => {
      const presetA = spellPresetBySlug.get(getSpellKey(a));
      const presetB = spellPresetBySlug.get(getSpellKey(b));
      const nameA = normalizeTextValue(presetA?.name || a);
      const nameB = normalizeTextValue(presetB?.name || b);
      if (spellbookSortMode === "level"){
        const levelA = Number.isFinite(getPresetLevelNumber(presetA)) ? getPresetLevelNumber(presetA) : 99;
        const levelB = Number.isFinite(getPresetLevelNumber(presetB)) ? getPresetLevelNumber(presetB) : 99;
        if (levelA !== levelB) return levelA - levelB;
      }
      return nameA.localeCompare(nameB);
    });
  }

  function getEligibleSpellSlugs(profile){
    const allowedLevel = maxSpellLevelForCharacter(getPlayerLevel(profile));
    const slugs = [];
    cachedSpellPresets.forEach((preset) => {
      const level = getPresetLevelNumber(preset);
      if (Number.isFinite(level) && level > allowedLevel){
        return;
      }
      const slug = getPresetSlug(preset);
      if (slug){
        slugs.push(slug);
      }
    });
    return sortSlugsByName(Array.from(new Set(slugs.map(normalizeTextValue).filter(Boolean))));
  }

  function getSpellLibraryDescription(data){
    if (!data || typeof data !== "object") return "";
    const text = data.text && typeof data.text === "object" ? data.text : null;
    const importRaw = data.import && typeof data.import === "object" ? data.import.raw : null;
    const summary = normalizeTextValue(text?.summary);
    if (summary) return summary;
    const rules = normalizeTextValue(text?.rules);
    if (rules) return rules;
    const description = normalizeTextValue(importRaw?.description);
    if (description) return description;
    return "";
  }

  function formatSpellLibraryLevel(level){
    const num = Number(level);
    if (!Number.isFinite(num)) return "Level ?";
    if (num === 0) return "Cantrip";
    return `Level ${num}`;
  }

  function formatSpellLibraryList(values){
    if (!Array.isArray(values) || !values.length) return "";
    return values.map((value) => formatListGroupLabel(value)).join(", ");
  }

  function buildSpellLibrarySearchText(record){
    const parts = [
      record.id,
      record.name,
      record.school,
      record.castingTime,
      record.range,
      record.duration,
      record.components,
      record.classes.join(" "),
      record.tags.join(" "),
      record.description,
    ];
    return parts.filter(Boolean).join(" ").toLowerCase();
  }

  function buildSpellLibraryRecord(entry){
    const parsed = entry && typeof entry === "object" ? entry.parsed : null;
    const data = parsed && typeof parsed === "object" ? parsed : null;
    const id = String(entry?.id || data?.id || "").trim();
    const name = typeof data?.name === "string" ? data.name : (id || "Unknown Spell");
    const level = Number.isFinite(data?.level) ? Number(data.level) : null;
    const classes = Array.isArray(data?.lists?.classes) ? data.lists.classes.filter(Boolean) : [];
    const tags = Array.isArray(data?.tags) ? data.tags.filter(Boolean) : [];
    const record = {
      id,
      name,
      level,
      classes,
      tags,
      school: normalizeTextValue(data?.school),
      castingTime: normalizeTextValue(data?.casting_time),
      range: normalizeTextValue(data?.range),
      duration: normalizeTextValue(data?.duration),
      components: normalizeTextValue(data?.components),
      ritual: data?.ritual,
      concentration: data?.concentration,
      description: getSpellLibraryDescription(data),
      color: normalizeHexColor(data?.color || ""),
      data,
      error: entry?.error,
    };
    record.searchText = buildSpellLibrarySearchText(record);
    return record;
  }

  async function loadSpellLibrary(){
    if (spellLibraryLoadPromise) return spellLibraryLoadPromise;
    spellLibraryLoadPromise = (async () => {
      if (spellLibraryStatus) spellLibraryStatus.textContent = "Loading spells…";
      let ids = [];
      let bulkRecords = null;
      try {
        const response = await fetch("/api/spells?details=true");
        const payload = await response.json();
        if (Array.isArray(payload?.ids)){
          ids = payload.ids;
        }
        if (Array.isArray(payload?.spells)){
          bulkRecords = payload.spells;
        }
        spellLibraryLoadError = "";
      } catch (err){
        spellLibraryLoadError = "Unable to load spells.";
        if (spellLibraryStatus) spellLibraryStatus.textContent = spellLibraryLoadError;
        return [];
      }
      let results = bulkRecords;
      if (!Array.isArray(results) || !results.length){
        results = await Promise.all(
          ids.map(async (spellId) => {
            try {
              const response = await fetch(`/api/spells/${encodeURIComponent(spellId)}`);
              if (!response.ok){
                throw new Error(`HTTP ${response.status}`);
              }
              return await response.json();
            } catch (err){
              return {id: spellId, raw: null, parsed: null, error: String(err)};
            }
          })
        );
      }
      spellLibraryRecords = results.map(buildSpellLibraryRecord);
      return spellLibraryRecords;
    })();
    return spellLibraryLoadPromise;
  }

  function renderSpellLibrary(){
    if (!spellLibraryList) return;
    const query = spellLibrarySearchTerm.trim().toLowerCase();
    let records = spellLibraryRecords;
    if (query){
      records = records.filter((record) => record.searchText.includes(query));
    }
    if (!records.length && spellLibraryLoadError){
      if (spellLibraryStatus) spellLibraryStatus.textContent = spellLibraryLoadError;
      spellLibraryList.innerHTML = "";
      return;
    }
    const sorted = records.slice().sort((a, b) => {
      if (spellLibrarySortMode === "level"){
        const levelA = Number.isFinite(a.level) ? a.level : 999;
        const levelB = Number.isFinite(b.level) ? b.level : 999;
        if (levelA !== levelB) return levelA - levelB;
      }
      return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
    });
    spellLibraryList.innerHTML = "";
    if (spellLibraryStatus){
      spellLibraryStatus.textContent = sorted.length
        ? `${sorted.length} spell${sorted.length === 1 ? "" : "s"}`
        : "No spells match that search.";
    }
    if (!sorted.length) return;
    const fragment = document.createDocumentFragment();
    sorted.forEach((record) => {
      const details = document.createElement("details");
      details.className = "spell-library-card";
      const summary = document.createElement("summary");
      summary.className = "spell-library-summary";
      const title = document.createElement("span");
      title.className = "spell-library-summary-title";
      title.textContent = record.name || record.id || "Unnamed Spell";
      const meta = document.createElement("span");
      meta.className = "spell-library-summary-meta";
      meta.textContent = formatSpellLibraryLevel(record.level);
      summary.appendChild(title);
      summary.appendChild(meta);
      details.appendChild(summary);

      const body = document.createElement("div");
      body.className = "spell-library-detail-body";
      if (record.error && !record.data){
        const errorText = document.createElement("div");
        errorText.className = "spell-library-detail-description";
        errorText.textContent = "Spell data unavailable.";
        body.appendChild(errorText);
        details.appendChild(body);
        fragment.appendChild(details);
        return;
      }

      const grid = document.createElement("div");
      grid.className = "spell-library-detail-grid";
      const addRow = (label, value) => {
        if (!value && value !== 0) return;
        const labelEl = document.createElement("div");
        labelEl.className = "spell-library-detail-label";
        labelEl.textContent = label;
        const valueEl = document.createElement("div");
        valueEl.className = "spell-library-detail-value";
        valueEl.textContent = String(value);
        grid.appendChild(labelEl);
        grid.appendChild(valueEl);
      };

      addRow("Level", formatSpellLevelLabel(record.level));
      addRow("School", record.school);
      addRow("Casting Time", record.castingTime);
      addRow("Range", record.range);
      addRow("Duration", record.duration);
      addRow("Components", record.components);
      addRow("Classes", formatSpellLibraryList(record.classes));
      addRow("Tags", formatSpellLibraryList(record.tags));
      addRow("Ritual", record.ritual === true ? "Yes" : record.ritual === false ? "No" : "");
      addRow("Concentration", record.concentration === true ? "Yes" : record.concentration === false ? "No" : "");
      body.appendChild(grid);

      if (record.description){
        const description = document.createElement("div");
        description.className = "spell-library-detail-description";
        description.textContent = record.description;
        body.appendChild(description);
      }

      const preset = spellPresetBySlug.get(getSpellKey(record.id))
        || cachedSpellPresets.find((entry) => normalizeLowerValue(entry?.name) === normalizeLowerValue(record.name));
      if (preset){
        const colorRow = document.createElement("div");
        colorRow.className = "spell-library-action-row";
        const colorWrap = document.createElement("div");
        colorWrap.className = "spell-library-color-row";
        const swatch = document.createElement("span");
        swatch.className = "spell-color-swatch";
        swatch.style.background = resolveSpellColor(preset.color);
        const colorLabel = document.createElement("span");
        colorLabel.className = "spell-library-detail-value";
        colorLabel.textContent = normalizeHexColor(preset.color || "") || "Default";
        colorWrap.appendChild(swatch);
        colorWrap.appendChild(colorLabel);
        const colorBtn = document.createElement("button");
        colorBtn.className = "btn";
        colorBtn.type = "button";
        colorBtn.textContent = "Edit Color";
        colorBtn.addEventListener("click", (event) => {
          event.stopPropagation();
          openSpellDetailOverlay(preset);
        });
        colorRow.appendChild(colorWrap);
        colorRow.appendChild(colorBtn);
        body.appendChild(colorRow);
      }

      details.appendChild(body);
      fragment.appendChild(details);
    });
    spellLibraryList.appendChild(fragment);
  }

  function openSpellLibraryOverlay(open){
    if (!spellLibraryOverlay) return;
    spellLibraryOverlay.classList.toggle("show", open);
    spellLibraryOverlay.setAttribute("aria-hidden", open ? "false" : "true");
    if (open){
      spellLibraryPreviousFocus = document.activeElement instanceof HTMLElement
        ? document.activeElement
        : null;
      if (spellLibrarySearchInput) spellLibrarySearchInput.value = spellLibrarySearchTerm;
      if (spellLibrarySortSelect) spellLibrarySortSelect.value = spellLibrarySortMode;
      loadSpellLibrary().then(() => renderSpellLibrary());
      if (spellLibrarySearchInput) spellLibrarySearchInput.focus();
    } else if (spellLibraryPreviousFocus){
      spellLibraryPreviousFocus.focus();
      spellLibraryPreviousFocus = null;
    }
  }

  function setSpellbookStatus(text){
    if (!spellbookStatus) return;
    spellbookStatus.textContent = text || "";
  }

  function toggleSpellbookSelection(slug, selectionSet){
    if (selectionSet.has(slug)){
      selectionSet.delete(slug);
    } else {
      selectionSet.add(slug);
    }
  }

  function renderSpellbookList(listEl, slugs, selectionSet, emptyLabel){
    if (!listEl) return;
    listEl.textContent = "";
    if (!slugs.length){
      const empty = document.createElement("div");
      empty.className = "spellbook-item";
      empty.textContent = emptyLabel || "No spells available.";
      empty.style.opacity = "0.6";
      listEl.appendChild(empty);
      return;
    }
    slugs.forEach((slug) => {
      const preset = spellPresetBySlug.get(getSpellKey(slug));
      const label = normalizeTextValue(preset?.name || slug);
      const level = getPresetLevelNumber(preset);
      const displayColor = resolveSpellColor(preset?.color);
      const item = document.createElement("button");
      item.type = "button";
      item.className = "spellbook-item";
      if (selectionSet.has(slug)){
        item.classList.add("selected");
        item.style.borderColor = displayColor;
        const highlight = rgbaFromHex(displayColor, 0.18);
        if (highlight){
          item.style.background = highlight;
        }
      }
      item.addEventListener("click", () => {
        toggleSpellbookSelection(slug, selectionSet);
        renderSpellbook();
      });
      const nameWrap = document.createElement("span");
      nameWrap.className = "spellbook-item-name";
      const colorDot = document.createElement("span");
      colorDot.className = "spellbook-color-dot";
      colorDot.style.background = displayColor;
      nameWrap.appendChild(colorDot);
      const nameSpan = document.createElement("span");
      nameSpan.textContent = label;
      nameWrap.appendChild(nameSpan);
      item.appendChild(nameWrap);
      const meta = document.createElement("small");
      if (Number.isFinite(level)){
        meta.textContent = level === 0 ? "Cantrip" : `Lv ${level}`;
      } else {
        meta.textContent = "Level ?";
      }
      item.appendChild(meta);
      listEl.appendChild(item);
    });
  }

  function resetSpellbookSelections(){
    spellbookLeftSelection = new Set();
    spellbookRightSelection = new Set();
  }

  function renderSpellbook(){
    const playerName = getClaimedPlayerName();
    const profile = playerName ? getPlayerProfile(playerName) : null;
    if (!profile){
      setSpellbookStatus("Claim a character to manage spells.");
      return;
    }
    if (spellbookKnownEnabledToggle){
      spellbookKnownEnabledToggle.checked = spellbookKnownEnabled;
    }
    if (spellbookTabKnown){
      spellbookTabKnown.disabled = !spellbookKnownEnabled;
      spellbookTabKnown.classList.toggle("accent", spellbookMode === "known");
    }
    if (spellbookTabPrepared){
      spellbookTabPrepared.classList.toggle("accent", spellbookMode === "prepared");
    }
    const eligibleSlugs = getEligibleSpellSlugs(profile);
    const rightSlugs = spellbookMode === "prepared"
      ? Array.from(pendingPreparedSet)
      : Array.from(new Set([...pendingKnownSet, ...pendingCantripsSet]));
    const rightSet = new Set(rightSlugs.map(getSpellKey));
    let leftSlugs = [];
    if (spellbookMode === "known"){
      leftSlugs = eligibleSlugs.filter((slug) => !rightSet.has(getSpellKey(slug)));
      if (spellbookLeftTitle) spellbookLeftTitle.textContent = "Eligible Spells";
      if (spellbookRightTitle) spellbookRightTitle.textContent = "Known & Cantrips";
    } else {
      if (spellbookKnownEnabled){
        const knownSlugs = sortSlugsByName(Array.from(new Set([...pendingKnownSet, ...pendingCantripsSet])));
        leftSlugs = knownSlugs.filter((slug) => !rightSet.has(getSpellKey(slug)));
        if (spellbookLeftTitle) spellbookLeftTitle.textContent = "Known & Cantrips";
      } else {
        leftSlugs = eligibleSlugs.filter((slug) => !rightSet.has(getSpellKey(slug)));
        if (spellbookLeftTitle) spellbookLeftTitle.textContent = "Eligible Spells";
      }
      if (spellbookRightTitle) spellbookRightTitle.textContent = "Prepared Spells";
    }
    const emptyLabel = spellbookSearchTerm.trim() ? "No spells match that search." : "No spells available.";
    const filteredLeft = filterSpellbookSlugs(leftSlugs);
    const filteredRight = filterSpellbookSlugs(rightSlugs);
    renderSpellbookList(spellbookLeftList, sortSpellbookSlugs(filteredLeft), spellbookLeftSelection, emptyLabel);
    renderSpellbookList(spellbookRightList, sortSpellbookSlugs(filteredRight), spellbookRightSelection, emptyLabel);
    const preparedCount = pendingPreparedSet.size;
    const preparedLimitLabel = Number.isFinite(spellbookPreparedLimit)
      ? `${preparedCount}/${spellbookPreparedLimit} prepared`
      : `${preparedCount} prepared`;
    const knownCount = pendingKnownSet.size;
    const knownLimitLabel = Number.isFinite(spellbookKnownLimit)
      ? `${knownCount}/${spellbookKnownLimit} known`
      : `${knownCount} known`;
    const cantripCount = pendingCantripsSet.size;
    const cantripLimitLabel = Number.isFinite(spellbookCantripsMax)
      ? `${cantripCount}/${spellbookCantripsMax} cantrips`
      : `${cantripCount} cantrips`;
    setSpellbookStatus(`${knownLimitLabel} · ${cantripLimitLabel} · ${preparedLimitLabel}`);
  }

  function syncSpellbookClaimedPlayer(){
    const playerName = getClaimedPlayerName();
    const config = getSpellbookConfig(playerName);
    spellbookKnownEnabled = config.knownEnabled !== false;
    spellbookKnownLimit = config.knownLimit;
    spellbookPreparedLimit = config.max;
    spellbookCantripsMax = config.cantripsMax;
    pendingKnownSet = new Set(config.known.map(normalizeTextValue).filter(Boolean));
    pendingPreparedSet = new Set(config.prepared.map(normalizeTextValue).filter(Boolean));
    pendingCantripsSet = new Set(config.cantrips.map(normalizeTextValue).filter(Boolean));
    spellbookMode = spellbookKnownEnabled ? "known" : "prepared";
    resetSpellbookSelections();
  }

  function openSpellbookOverlay(open){
    if (!spellbookOverlay) return;
    if (open && (claimedCid === null || claimedCid === undefined)){
      allowUnclaimed = false;
      localToast("Select your character to manage spells.");
      updateClaimOverlay();
      return;
    }
    spellbookOverlay.classList.toggle("show", open);
    spellbookOverlay.setAttribute("aria-hidden", open ? "false" : "true");
    if (open){
      spellbookPreviousFocus = document.activeElement instanceof HTMLElement
        ? document.activeElement
        : null;
      syncSpellbookClaimedPlayer();
      if (spellbookSearchInput) spellbookSearchInput.value = spellbookSearchTerm;
      if (spellbookSortSelect) spellbookSortSelect.value = spellbookSortMode;
      renderSpellbook();
      requestAnimationFrame(() => {
        spellbookBackBtn?.focus();
      });
    } else if (spellbookPreviousFocus){
      closeSpellDetailOverlay();
      spellbookPreviousFocus.focus();
      spellbookPreviousFocus = null;
    }
    updateModalOffsets();
    resize();
  }

  function applySpellbookAdd(){
    if (!spellbookLeftSelection.size) return;
    const additions = Array.from(spellbookLeftSelection);
    if (spellbookMode === "prepared"){
      additions.forEach((slug) => {
        if (pendingPreparedSet.has(slug)) return;
        const nextCount = pendingPreparedSet.size + 1;
        if (Number.isFinite(spellbookPreparedLimit) && nextCount > spellbookPreparedLimit){
          localToast(`Prepared spells limited to ${spellbookPreparedLimit}.`);
          return;
        }
        pendingPreparedSet.add(slug);
      });
    } else {
      additions.forEach((slug) => {
        const level = getPresetLevelBySlug(slug);
        if (level === 0){
          const nextCount = pendingCantripsSet.size + 1;
          if (Number.isFinite(spellbookCantripsMax) && nextCount > spellbookCantripsMax){
            localToast(`Cantrips limited to ${spellbookCantripsMax}.`);
            return;
          }
          pendingCantripsSet.add(slug);
        } else {
          if (!spellbookKnownEnabled){
            return;
          }
          const nextCount = pendingKnownSet.size + 1;
          if (Number.isFinite(spellbookKnownLimit) && nextCount > spellbookKnownLimit){
            localToast(`Known spells limited to ${spellbookKnownLimit}.`);
            return;
          }
          pendingKnownSet.add(slug);
        }
      });
    }
    resetSpellbookSelections();
    renderSpellbook();
  }

  function applySpellbookRemove(){
    if (!spellbookRightSelection.size) return;
    const removals = Array.from(spellbookRightSelection);
    if (spellbookMode === "prepared"){
      removals.forEach((slug) => {
        pendingPreparedSet.delete(slug);
      });
    } else {
      removals.forEach((slug) => {
        const level = getPresetLevelBySlug(slug);
        if (level === 0){
          pendingCantripsSet.delete(slug);
        } else {
          pendingKnownSet.delete(slug);
        }
      });
    }
    resetSpellbookSelections();
    renderSpellbook();
  }

  function showSpellbookConfirm(){
    if (!spellbookConfirmModal) return;
    const playerName = getClaimedPlayerName() || "player";
    const fileName = playerName.replace(/[^a-z0-9._-]+/gi, "-");
    if (spellbookConfirmText){
      spellbookConfirmText.textContent = `Overwrite players/${fileName}.yaml?`;
    }
    spellbookConfirmModal.classList.add("show");
    spellbookConfirmModal.setAttribute("aria-hidden", "false");
  }

  function hideSpellbookConfirm(){
    if (!spellbookConfirmModal) return;
    spellbookConfirmModal.classList.remove("show");
    spellbookConfirmModal.setAttribute("aria-hidden", "true");
  }

  async function saveSpellbookChanges(){
    const playerName = getClaimedPlayerName();
    if (!playerName){
      localToast("Claim a character first.");
      return;
    }
    const payload = {
      known_enabled: spellbookKnownEnabled,
      known_list: Array.from(pendingKnownSet),
      prepared_list: Array.from(pendingPreparedSet),
      cantrips_list: Array.from(pendingCantripsSet),
    };
    try {
      const response = await fetch(`/api/players/${encodeURIComponent(playerName)}/spellbook`, {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify(payload),
      });
      if (!response.ok){
        throw new Error(`Failed (${response.status})`);
      }
      const data = await response.json();
      if (data?.player && state?.player_profiles){
        state.player_profiles[data.player.name] = data.player;
      }
      localToast("Spellbook saved.");
      hideSpellbookConfirm();
      refreshSpellPresetOptions();
    } catch (err){
      console.warn("Failed to save spellbook.", err);
      localToast("Unable to save spellbook.");
    }
  }

  function setSpellDetailStatus(text){
    if (!spellDetailStatus) return;
    spellDetailStatus.textContent = text || "";
  }

  function updateSpellDetailColorInputs(color){
    const fallback = color || DEFAULT_SPELL_COLOR;
    if (spellDetailColorSwatch){
      spellDetailColorSwatch.style.background = fallback;
    }
    if (spellDetailColorInput){
      spellDetailColorInput.value = fallback;
    }
    if (spellDetailColorValue){
      spellDetailColorValue.value = color ? color.toUpperCase() : fallback.toUpperCase();
    }
  }

  async function saveSpellDetailColor(slug, color){
    if (!slug) return;
    setSpellDetailStatus("Saving color…");
    try {
      const response = await fetch(`/api/spells/${encodeURIComponent(slug)}/color`, {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({color}),
      });
      if (!response.ok){
        throw new Error(`Failed (${response.status})`);
      }
      const data = await response.json();
      const updatedColor = normalizeHexColor(data?.spell?.color || color) || color;
      const preset = spellPresetBySlug.get(getSpellKey(slug));
      if (preset){
        preset.color = updatedColor;
      }
      updateSpellPresetOptions(cachedSpellPresets);
      updateSpellPresetDetails(preset || null);
      if (spellDetailOverlay?.classList.contains("show")){
        renderSpellDetailOverlay(preset || null);
      }
      setSpellDetailStatus("Color saved.");
    } catch (err){
      console.warn("Failed to save spell color.", err);
      setSpellDetailStatus("Unable to save color.");
      localToast("Unable to save spell color.");
    }
  }

  function renderSpellDetailOverlay(preset){
    if (!spellDetailGrid || !spellDetailName || !spellDetailMeta) return;
    if (!preset){
      spellDetailName.textContent = "Spell";
      spellDetailMeta.textContent = "";
      spellDetailGrid.textContent = "";
      updateSpellDetailColorInputs("");
      setSpellDetailStatus("");
      return;
    }
    const name = normalizeTextValue(preset.name) || normalizeTextValue(preset.slug) || "Spell";
    const levelLabel = formatSpellLevelLabel(preset.level);
    const school = normalizeTextValue(preset.school) || "Unknown";
    spellDetailName.textContent = name;
    spellDetailMeta.textContent = `${levelLabel} · ${school}`;
    const color = normalizeHexColor(preset.color || "");
    const displayColor = resolveSpellColor(preset.color);
    updateSpellDetailColorInputs(displayColor || "");
    setSpellDetailStatus("");
    const fields = [
      {label: "Level", value: levelLabel},
      {label: "School", value: school},
    ];
    const optionalFields = buildOptionalSpellDetails(preset);
    spellDetailGrid.textContent = "";
    [...fields, ...optionalFields].forEach((field) => {
      if (!field || (!field.value && field.value !== 0)) return;
      const row = document.createElement("div");
      row.className = "spell-details-row";
      const label = document.createElement("span");
      label.className = "spell-details-label";
      label.textContent = field.label;
      const value = document.createElement("span");
      value.className = "spell-details-value";
      value.textContent = field.value || "—";
      row.appendChild(label);
      row.appendChild(value);
      spellDetailGrid.appendChild(row);
    });
  }

  function openSpellDetailOverlay(preset){
    if (!spellDetailOverlay) return;
    if (!preset){
      return;
    }
    activeSpellDetailSlug = getPresetSlug(preset);
    spellDetailOverlay.classList.add("show");
    spellDetailOverlay.setAttribute("aria-hidden", "false");
    spellDetailPreviousFocus = document.activeElement instanceof HTMLElement ? document.activeElement : null;
    if (spellDetailTitle){
      spellDetailTitle.textContent = normalizeTextValue(preset.name) || "Spell Details";
    }
    renderSpellDetailOverlay(preset);
    if (spellDetailBackBtn){
      spellDetailBackBtn.focus();
    }
  }

  function closeSpellDetailOverlay(){
    if (!spellDetailOverlay) return;
    spellDetailOverlay.classList.remove("show");
    spellDetailOverlay.setAttribute("aria-hidden", "true");
    activeSpellDetailSlug = null;
    if (spellDetailPreviousFocus){
      spellDetailPreviousFocus.focus();
      spellDetailPreviousFocus = null;
    }
  }

  function commitSpellDetailColor(raw){
    const color = normalizeHexColor(raw || "");
    if (!color){
      localToast("Pick a valid hex color, matey.");
      return;
    }
    updateSpellDetailColorInputs(color);
    if (activeSpellDetailSlug){
      saveSpellDetailColor(activeSpellDetailSlug, color);
    }
  }

  const updateSpellPresetDetails = (preset) => {
    if (!spellPresetDetails) return;
    if (!preset){
      spellPresetDetails.textContent = "Select a preset to see spell details.";
      updateManualEntryBadge(null);
      return;
    }
    updateManualEntryBadge(preset);
    const detailsGrid = document.createElement("div");
    detailsGrid.className = "spell-details-grid";
    const levelLabel = formatSpellLevelLabel(preset.level);
    const tags = Array.isArray(preset.tags) ? preset.tags.filter(Boolean) : [];
    const tagLabel = tags.length ? tags.join(", ") : "—";
    const castingTime = normalizeTextValue(preset.casting_time) || "—";
    const range = normalizeTextValue(preset.range) || "—";
    const ritual = preset.ritual === true ? "Yes" : preset.ritual === false ? "No" : "—";
    const concentration = preset.concentration === true ? "Yes" : preset.concentration === false ? "No" : "—";
    const color = normalizeHexColor(preset.color || "");
    const displayColor = resolveSpellColor(preset.color);
    const lists = getSpellListEntries(preset.lists);
    const listLabel = lists.length
      ? lists.map((entry) => `${formatListGroupLabel(entry.group)}: ${entry.value}`).join(" · ")
      : "—";
    const fields = [
      {label: "Level", value: levelLabel},
      {label: "School", value: normalizeTextValue(preset.school) || "—"},
      {label: "Tags", value: tagLabel},
      {label: "Casting", value: castingTime},
      {label: "Range", value: range},
      {label: "Ritual", value: ritual},
      {label: "Concentration", value: concentration},
      {label: "Lists", value: listLabel},
      {label: "Color", value: color || displayColor, color: displayColor},
    ];
    fields.forEach((field) => {
      const row = document.createElement("div");
      row.className = "spell-details-row";
      const label = document.createElement("span");
      label.className = "spell-details-label";
      label.textContent = field.label;
      const value = document.createElement("span");
      value.className = "spell-details-value";
      if (field.color){
        const swatch = document.createElement("span");
        swatch.className = "spell-color-swatch";
        swatch.style.background = field.color;
        value.appendChild(swatch);
        const text = document.createElement("span");
        text.textContent = ` ${field.value}`;
        value.appendChild(text);
      } else {
        value.textContent = field.value;
      }
      row.appendChild(label);
      row.appendChild(value);
      detailsGrid.appendChild(row);
    });
    spellPresetDetails.textContent = "";
    spellPresetDetails.appendChild(detailsGrid);
  };
  function formatSpellDamageLabel(preset){
    const base = preset?.default_damage ?? preset?.dice ?? "";
    const baseLabel = base !== null && base !== undefined && String(base).trim() ? String(base).trim() : "";
    const damageTypes = Array.isArray(preset?.damage_types)
      ? preset.damage_types.map((entry) => String(entry || "").trim()).filter(Boolean)
      : [];
    if (baseLabel && damageTypes.length){
      return `${baseLabel} (${damageTypes.join(", ")})`;
    }
    if (baseLabel) return baseLabel;
    if (damageTypes.length) return damageTypes.join(", ");
    return "";
  }
  function hasAoeShape(preset){
    if (!preset || typeof preset !== "object") return false;
    return Boolean(
      preset.shape ||
      preset.radius_ft ||
      preset.side_ft ||
      preset.length_ft ||
      preset.width_ft ||
      preset.angle_deg ||
      preset.height_ft ||
      preset.thickness_ft
    );
  }
  function buildOptionalSpellDetails(preset){
    if (!preset || typeof preset !== "object") return [];
    const tags = Array.isArray(preset.tags) ? preset.tags.filter(Boolean) : [];
    const lists = getSpellListEntries(preset.lists);
    const listLabel = lists.length
      ? lists.map((entry) => `${formatListGroupLabel(entry.group)}: ${entry.value}`).join(" · ")
      : "";
    const fields = [
      {label: "Casting Time", value: normalizeTextValue(preset.casting_time)},
      {label: "Range", value: normalizeTextValue(preset.range)},
      {label: "Ritual", value: preset.ritual === true ? "Yes" : preset.ritual === false ? "No" : ""},
      {label: "Concentration", value: preset.concentration === true ? "Yes" : preset.concentration === false ? "No" : ""},
      {label: "Tags", value: tags.length ? tags.join(", ") : ""},
      {label: "Lists", value: listLabel},
      {label: "Shape", value: normalizeTextValue(preset.shape)},
      {label: "Radius (ft)", value: Number.isFinite(Number(preset.radius_ft)) ? String(preset.radius_ft) : ""},
      {label: "Side (ft)", value: Number.isFinite(Number(preset.side_ft)) ? String(preset.side_ft) : ""},
      {label: "Length (ft)", value: Number.isFinite(Number(preset.length_ft)) ? String(preset.length_ft) : ""},
      {label: "Width (ft)", value: Number.isFinite(Number(preset.width_ft)) ? String(preset.width_ft) : ""},
      {label: "Angle (deg)", value: Number.isFinite(Number(preset.angle_deg)) ? String(preset.angle_deg) : ""},
      {label: "Height (ft)", value: Number.isFinite(Number(preset.height_ft)) ? String(preset.height_ft) : ""},
      {label: "Duration (turns)", value: Number.isFinite(Number(preset.duration_turns)) ? String(preset.duration_turns) : ""},
      {label: "Save", value: preset.save_type ? String(preset.save_type || "").toUpperCase() : ""},
      {label: "Save DC", value: Number.isFinite(Number(preset.save_dc)) ? String(preset.save_dc) : ""},
      {label: "Damage", value: formatSpellDamageLabel(preset)},
      {label: "Half on Save", value: preset.half_on_pass ? "Yes" : ""},
      {label: "Automation", value: normalizeTextValue(preset.automation)},
    ];
    return fields.filter((field) => field.value);
  }
  const spellFilterState = {
    search: "",
    levelMin: "",
    levelMax: "",
    schools: [],
    tags: [],
    castingTime: "",
    range: "",
    ritualOnly: false,
    concentrationOnly: false,
    lists: [],
  };

  const readCheckedValues = (container) => {
    if (!container) return [];
    return Array.from(container.querySelectorAll('input[type="checkbox"]:checked')).map((input) => String(input.value || "")).filter(Boolean);
  };

  const updateMultiSelectSummary = (detailsEl, label, values) => {
    if (!detailsEl) return;
    const summary = detailsEl.querySelector('summary');
    if (!summary) return;
    summary.textContent = values.length ? `${label}: ${values.join(', ')}` : `${label}: Any`;
  };

  const renderCheckboxOptions = (container, values, selectedValues, name) => {
    if (!container) return;
    const selected = new Set((selectedValues || []).map(normalizeLowerValue));
    container.textContent = "";
    values.forEach((value, idx) => {
      const id = `${name}_${idx}`;
      const label = document.createElement('label');
      const input = document.createElement('input');
      input.type = 'checkbox';
      input.id = id;
      input.value = value;
      input.checked = selected.has(normalizeLowerValue(value));
      label.appendChild(input);
      const span = document.createElement('span');
      span.textContent = value;
      label.appendChild(span);
      container.appendChild(label);
    });
  };

  const updateSelectOptions = (selectEl, values) => {
    if (!selectEl) return;
    const currentValue = selectEl.value;
    selectEl.textContent = '';
    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = 'Any';
    selectEl.appendChild(placeholder);
    values.forEach((value) => {
      const opt = document.createElement('option');
      opt.value = value;
      opt.textContent = value;
      selectEl.appendChild(opt);
    });
    selectEl.value = values.includes(currentValue) ? currentValue : '';
  };

  const loadSpellFilterState = () => {
    try {
      const raw = localStorage.getItem(spellFilterStorageKey);
      if (!raw) return;
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== 'object') return;
      spellFilterState.search = normalizeTextValue(parsed.search);
      spellFilterState.levelMin = normalizeTextValue(parsed.levelMin);
      spellFilterState.levelMax = normalizeTextValue(parsed.levelMax);
      spellFilterState.schools = Array.isArray(parsed.schools) ? parsed.schools.map(normalizeTextValue).filter(Boolean) : [];
      spellFilterState.tags = Array.isArray(parsed.tags) ? parsed.tags.map(normalizeTextValue).filter(Boolean) : [];
      spellFilterState.castingTime = normalizeTextValue(parsed.castingTime);
      spellFilterState.range = normalizeTextValue(parsed.range);
      spellFilterState.ritualOnly = parsed.ritualOnly === true;
      spellFilterState.concentrationOnly = parsed.concentrationOnly === true;
      spellFilterState.lists = Array.isArray(parsed.lists) ? parsed.lists.map(normalizeTextValue).filter(Boolean) : [];
    } catch (err){
      console.warn('Unable to load spell filter state.', err);
    }
  };

  const saveSpellFilterState = () => {
    try {
      localStorage.setItem(spellFilterStorageKey, JSON.stringify(spellFilterState));
    } catch (err){
      console.warn('Unable to save spell filter state.', err);
    }
  };

  const syncSpellFilterInputsFromState = () => {
    if (castSearchInput) castSearchInput.value = spellFilterState.search;
    if (castFilterLevelMinInput) castFilterLevelMinInput.value = spellFilterState.levelMin;
    if (castFilterLevelMaxInput) castFilterLevelMaxInput.value = spellFilterState.levelMax;
    if (castFilterCastingTimeInput) castFilterCastingTimeInput.value = spellFilterState.castingTime;
    if (castFilterRangeInput) castFilterRangeInput.value = spellFilterState.range;
    if (castFilterRitualInput) castFilterRitualInput.checked = spellFilterState.ritualOnly;
    if (castFilterConcentrationInput) castFilterConcentrationInput.checked = spellFilterState.concentrationOnly;
  };

  const applySpellFilterStateFromInputs = () => {
    spellFilterState.search = normalizeTextValue(castSearchInput?.value);
    spellFilterState.levelMin = normalizeTextValue(castFilterLevelMinInput?.value);
    spellFilterState.levelMax = normalizeTextValue(castFilterLevelMaxInput?.value);
    spellFilterState.schools = readCheckedValues(castFilterSchoolOptions);
    spellFilterState.tags = readCheckedValues(castFilterTagOptions);
    spellFilterState.castingTime = normalizeTextValue(castFilterCastingTimeInput?.value);
    spellFilterState.range = normalizeTextValue(castFilterRangeInput?.value);
    spellFilterState.ritualOnly = castFilterRitualInput?.checked === true;
    spellFilterState.concentrationOnly = castFilterConcentrationInput?.checked === true;
    spellFilterState.lists = readCheckedValues(castFilterListOptions);
    saveSpellFilterState();
  };

  const updateSpellFilterSummary = () => {
    const parts = [];
    if (spellFilterState.search) parts.push(`Search: ${spellFilterState.search}`);
    if (spellFilterState.levelMin || spellFilterState.levelMax){
      const from = spellFilterState.levelMin || 'Any';
      const to = spellFilterState.levelMax || 'Any';
      parts.push(`Level: ${from}-${to}`);
    }
    if (spellFilterState.schools.length) parts.push(`School: ${spellFilterState.schools.join(', ')}`);
    if (spellFilterState.tags.length) parts.push(`Tags: ${spellFilterState.tags.join(', ')}`);
    if (spellFilterState.lists.length) parts.push(`Lists: ${spellFilterState.lists.join(', ')}`);
    if (spellFilterState.castingTime) parts.push(`Casting: ${spellFilterState.castingTime}`);
    if (spellFilterState.range) parts.push(`Range: ${spellFilterState.range}`);
    if (spellFilterState.ritualOnly) parts.push('Ritual only');
    if (spellFilterState.concentrationOnly) parts.push('Concentration only');
    if (spellFilterSummary){
      spellFilterSummary.textContent = parts.length ? parts.join(' · ') : 'No filters active.';
    }
    updateMultiSelectSummary(castFilterSchoolMulti, 'Schools', spellFilterState.schools);
    updateMultiSelectSummary(castFilterTagMulti, 'Tags', spellFilterState.tags);
    updateMultiSelectSummary(castFilterListMulti, 'Lists', spellFilterState.lists);
  };

  const updateSpellFilterOptions = () => {
    const schools = new Set();
    const castingTimes = new Set();
    const ranges = new Set();
    const tags = new Set();
    const lists = new Set();
    cachedSpellPresets.forEach((preset) => {
      const school = normalizeTextValue(preset.school);
      if (school) schools.add(school);
      const castingTime = normalizeTextValue(preset.casting_time);
      if (castingTime) castingTimes.add(castingTime);
      const range = normalizeTextValue(preset.range);
      if (range) ranges.add(range);
      (Array.isArray(preset.tags) ? preset.tags : []).forEach((tag) => {
        const value = normalizeTextValue(tag);
        if (value) tags.add(value);
      });
      getSpellListEntries(preset.lists).forEach((entry) => {
        lists.add(`${formatListGroupLabel(entry.group)}: ${entry.value}`);
      });
    });
    renderCheckboxOptions(castFilterSchoolOptions, Array.from(schools).sort((a,b)=>a.localeCompare(b)), spellFilterState.schools, 'school_filter');
    renderCheckboxOptions(castFilterTagOptions, Array.from(tags).sort((a,b)=>a.localeCompare(b)), spellFilterState.tags, 'tag_filter');
    renderCheckboxOptions(castFilterListOptions, Array.from(lists).sort((a,b)=>a.localeCompare(b)), spellFilterState.lists, 'list_filter');
    updateSelectOptions(castFilterCastingTimeInput, Array.from(castingTimes).sort((a,b)=>a.localeCompare(b)));
    updateSelectOptions(castFilterRangeInput, Array.from(ranges).sort((a,b)=>a.localeCompare(b)));
    syncSpellFilterInputsFromState();
    updateSpellFilterSummary();
  };

  const matchesSpellFilters = (preset) => {
    const levelNum = getPresetLevelNumber(preset);
    const min = spellFilterState.levelMin === '' ? null : Number(spellFilterState.levelMin);
    const max = spellFilterState.levelMax === '' ? null : Number(spellFilterState.levelMax);
    if (Number.isFinite(levelNum)){
      if (min !== null && levelNum < min) return false;
      if (max !== null && levelNum > max) return false;
    }

    if (spellFilterState.schools.length){
      const selected = spellFilterState.schools.map(normalizeLowerValue);
      if (!selected.includes(normalizeLowerValue(preset.school))) return false;
    }

    if (spellFilterState.castingTime){
      if (!normalizeLowerValue(preset.casting_time).includes(normalizeLowerValue(spellFilterState.castingTime))) return false;
    }
    if (spellFilterState.range){
      if (!normalizeLowerValue(preset.range).includes(normalizeLowerValue(spellFilterState.range))) return false;
    }
    if (spellFilterState.ritualOnly && preset.ritual !== true) return false;
    if (spellFilterState.concentrationOnly && preset.concentration !== true) return false;

    if (spellFilterState.tags.length){
      const presetTags = Array.isArray(preset.tags) ? preset.tags.map(normalizeLowerValue) : [];
      if (!spellFilterState.tags.every((tag) => presetTags.includes(normalizeLowerValue(tag)))) return false;
    }

    if (spellFilterState.lists.length){
      const presetLists = getSpellListEntries(preset.lists).map((entry) => `${formatListGroupLabel(entry.group)}: ${entry.value}`.toLowerCase());
      if (!spellFilterState.lists.every((item) => presetLists.includes(item.toLowerCase()))) return false;
    }

    if (spellFilterState.search){
      const haystack = [preset.name, preset.description, preset.casting_time, preset.range, preset.school, ...(Array.isArray(preset.tags) ? preset.tags : [])]
        .map(normalizeLowerValue)
        .join(' ');
      if (!haystack.includes(normalizeLowerValue(spellFilterState.search))) return false;
    }
    return true;
  };

  loadSpellFilterState();

  const refreshSpellPresetOptions = () => {
    if (!castPresetInput) return;
    const currentValue = String(castPresetInput.value || "");
    castPresetInput.textContent = "";
    const availablePresets = cachedSpellPresets.slice();
    if (!availablePresets.length){
      castPresetInput.disabled = true;
      const placeholder = document.createElement("option");
      placeholder.value = "";
      placeholder.textContent = "Presets unavailable";
      castPresetInput.appendChild(placeholder);
      castPresetInput.value = "";
      updateSpellPresetDetails(null);
      return;
    }
    castPresetInput.disabled = false;
    const blank = document.createElement("option");
    blank.value = "";
    blank.textContent = "Custom";
    castPresetInput.appendChild(blank);
    const preparedSpellSet = getPreparedSpellFilterSet();
    const filtered = filterPresetsByKnownList(availablePresets, preparedSpellSet)
      .filter(matchesSpellFilters);
    if (!filtered.length){
      const empty = document.createElement("option");
      empty.value = "";
      empty.textContent = "No spells match filters";
      empty.disabled = true;
      castPresetInput.appendChild(empty);
      castPresetInput.value = "";
      updateSpellPresetDetails(null);
      return;
    }
    const groups = new Map();
    filtered.forEach((preset) => {
      const level = getPresetLevelNumber(preset);
      const key = level === null ? "unknown" : String(level);
      if (!groups.has(key)){
        groups.set(key, []);
      }
      groups.get(key).push(preset);
    });
    const orderedLevels = [];
    for (let i = 0; i <= 9; i += 1){
      if (groups.has(String(i))){
        orderedLevels.push(String(i));
      }
    }
    if (groups.has("unknown")){
      orderedLevels.push("unknown");
    }
    orderedLevels.forEach((levelKey) => {
      const list = groups.get(levelKey) || [];
      list.sort((a, b) => normalizeTextValue(a.name).localeCompare(normalizeTextValue(b.name)));
      const optgroup = document.createElement("optgroup");
      optgroup.label = levelKey === "unknown"
        ? "Unknown Level"
        : formatSpellLevelLabel(Number(levelKey));
      list.forEach((preset) => {
        const name = normalizeTextValue(preset.name);
        if (!name) return;
        const opt = document.createElement("option");
        opt.value = name;
        opt.textContent = name;
        optgroup.appendChild(opt);
      });
      castPresetInput.appendChild(optgroup);
    });
    if (currentValue && filtered.some(p => normalizeTextValue(p.name) === currentValue)){
      castPresetInput.value = currentValue;
    } else {
      castPresetInput.value = "";
    }
    const selected = filtered.find(p => normalizeTextValue(p.name) === castPresetInput.value);
    updateSpellPresetDetails(selected || null);
  };

  const updateSpellPresetOptions = (presets) => {
    const list = normalizeSpellPresets(presets);
    const signature = JSON.stringify(list.map(p => [
      String(p.slug || ""),
      String(p.name || ""),
      String(p.shape || ""),
      String(p.level || ""),
      String(p.school || ""),
      String(p.casting_time || ""),
      String(p.range || ""),
      String(p.ritual || ""),
      String(p.concentration || ""),
      String(p.color || ""),
      String(p.is_aoe || ""),
      String(p.action_type || ""),
      JSON.stringify(p.tags || []),
      JSON.stringify(p.lists || {}),
      JSON.stringify(p.upcast || {}),
      JSON.stringify(p.scaling || {}),
      JSON.stringify(p.summon || {}),
      String(p.isAoE || ""),
      String(p.isSummon || ""),
    ]));
    if (signature === lastSpellPresetSignature){
      return;
    }
    lastSpellPresetSignature = signature;
    cachedSpellPresets = list;
    spellPresetBySlug = new Map();
    list.forEach((preset) => {
      const slug = getPresetSlug(preset);
      if (slug){
        spellPresetBySlug.set(getSpellKey(slug), preset);
      }
    });
    updateSpellFilterOptions();
    refreshSpellPresetOptions();
    if (spellbookOverlay?.classList.contains("show")){
      renderSpellbook();
    }
  };

  const registerSpellFilterListener = (input, useInputEvent = false) => {
    if (!input) return;
    const handler = () => {
      applySpellFilterStateFromInputs();
      updateSpellFilterSummary();
      refreshSpellPresetOptions();
    };
    input.addEventListener('change', handler);
    if (useInputEvent){
      input.addEventListener('input', handler);
    }
  };

  registerSpellFilterListener(castSearchInput, true);
  registerSpellFilterListener(castFilterLevelMinInput);
  registerSpellFilterListener(castFilterLevelMaxInput);
  registerSpellFilterListener(castFilterCastingTimeInput);
  registerSpellFilterListener(castFilterRangeInput);
  registerSpellFilterListener(castFilterRitualInput);
  registerSpellFilterListener(castFilterConcentrationInput);

  [castFilterSchoolOptions, castFilterTagOptions, castFilterListOptions].forEach((container) => {
    container?.addEventListener('change', () => {
      applySpellFilterStateFromInputs();
      updateSpellFilterSummary();
      refreshSpellPresetOptions();
    });
  });

  openSpellFiltersBtn?.addEventListener('click', () => {
    spellFilterModal?.classList.add('show');
    spellFilterModal?.setAttribute('aria-hidden', 'false');
  });
  closeSpellFiltersBtn?.addEventListener('click', () => {
    spellFilterModal?.classList.remove('show');
    spellFilterModal?.setAttribute('aria-hidden', 'true');
  });
  applySpellFiltersBtn?.addEventListener('click', () => {
    applySpellFilterStateFromInputs();
    updateSpellFilterSummary();
    refreshSpellPresetOptions();
    spellFilterModal?.classList.remove('show');
    spellFilterModal?.setAttribute('aria-hidden', 'true');
  });
  const clearSpellFilters = () => {
    Object.assign(spellFilterState, {
      search: '', levelMin: '', levelMax: '', schools: [], tags: [], castingTime: '', range: '', ritualOnly: false, concentrationOnly: false, lists: [],
    });
    saveSpellFilterState();
    updateSpellFilterOptions();
    refreshSpellPresetOptions();
  };
  clearSpellFiltersBtn?.addEventListener('click', () => {
    clearSpellFilters();
  });

  const setCastFieldEnabled = (input, enabled) => {
    if (!input) return;
    input.disabled = !enabled;
    input.readOnly = !enabled;
  };

  const setCastFieldVisible = (field, visible) => {
    if (!field) return;
    field.style.display = visible ? "" : "none";
  };

  const titleCaseFromSlug = (value) => normalizeTextValue(value)
    .split("-")
    .filter(Boolean)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join(" ");

  const getSummonChoices = (preset) => {
    const choices = Array.isArray(preset?.summon?.choices) ? preset.summon.choices : [];
    return choices.filter((choice) => choice && typeof choice === "object").map((choice) => {
      const slug = normalizeTextValue(choice.monster_slug);
      const fallback = titleCaseFromSlug(slug);
      return {
        ...choice,
        monster_slug: slug,
        variants: Array.isArray(choice.variants) ? choice.variants.map(v => normalizeTextValue(v)).filter(Boolean) : [],
        name: normalizeTextValue(choice.name) || fallback || "Unknown creature",
      };
    });
  };

  const getSummonQuantityRule = (preset, slotLevel, selectedChoice) => {
    const count = preset?.summon?.count;
    if (!count || typeof count !== "object") return {min: 1, max: 1, fixed: 1};
    const selectedSlug = normalizeTextValue(selectedChoice);
    const parseEntries = (entry) => {
      if (!entry || typeof entry !== "object") return [];
      const options = Array.isArray(entry.options) ? entry.options : [entry];
      return options
        .filter(opt => opt && typeof opt === "object")
        .map((opt) => {
          const qty = Number(opt.quantity);
          const creatureOptions = Array.isArray(opt.creature_options)
            ? opt.creature_options.map((slug) => normalizeTextValue(slug)).filter(Boolean)
            : [];
          return {
            quantity: Number.isFinite(qty) && qty > 0 ? Math.floor(qty) : null,
            creature_options: creatureOptions,
          };
        })
        .filter(opt => Number.isFinite(opt.quantity));
    };
    const pickBySlot = () => {
      const base = count.base && typeof count.base === "object" ? count.base : null;
      const overrides = Array.isArray(count.slot_overrides) ? count.slot_overrides : [];
      const slot = Number.isFinite(Number(slotLevel)) ? Math.floor(Number(slotLevel)) : Number(base?.slot_level || preset?.level || 0);
      const match = overrides.find((entry) => Number(entry?.slot_level) === slot);
      return parseEntries(match || base);
    };
    let quantities = [];
    if (count.kind === "variable_by_slot"){
      quantities = pickBySlot();
    } else {
      const min = Number(count.min);
      const max = Number(count.max);
      if (Number.isFinite(min) && Number.isFinite(max)){
        return {min: Math.floor(min), max: Math.floor(max), fixed: min === max ? Math.floor(min) : null};
      }
      quantities = parseEntries(count);
    }
    if (!quantities.length){
      return {min: 1, max: 1, fixed: 1};
    }
    const matching = selectedSlug
      ? quantities.filter((item) => !item.creature_options.length || item.creature_options.includes(selectedSlug))
      : quantities;
    const pool = matching.length ? matching : quantities;
    const values = Array.from(new Set(pool.map(item => item.quantity))).sort((a, b) => a - b);
    if (!values.length){
      return {min: 1, max: 1, fixed: 1};
    }
    return {
      min: values[0],
      max: values[values.length - 1],
      fixed: values.length === 1 ? values[0] : null,
    };
  };

  let castSummonValidation = {ok: true, reason: ""};
  const validateSummonForm = (preset, showToast = false) => {
    if (!isSummonPreset(preset)){
      castSummonValidation = {ok: true, reason: ""};
      if (castSubmitBtn) castSubmitBtn.disabled = false;
      return castSummonValidation;
    }
    const choices = getSummonChoices(preset);
    const selectedChoice = normalizeTextValue(castSummonChoiceInput?.value || choices[0]?.monster_slug || "");
    const quantityRule = getSummonQuantityRule(preset, Number(castSlotLevelInput?.value), selectedChoice);
    const rawQty = Number(castSummonQuantityInput?.value);
    const selectedVariant = normalizeTextValue(castSummonVariantInput?.value || "");
    const quantity = Number.isFinite(rawQty) ? Math.floor(rawQty) : null;
    let reason = "";
    if (!selectedChoice){
      reason = "Pick a summon option first, matey.";
    } else if (preset?.summon?.mount && !selectedVariant){
      reason = "Pick a mount variant first, matey.";
    } else if (!Number.isFinite(quantity) || quantity <= 0){
      reason = "Enter a valid summon quantity, matey.";
    } else if (quantityRule.fixed !== null && quantity !== quantityRule.fixed){
      reason = `This spell summons exactly ${quantityRule.fixed}.`;
    } else if (quantity < quantityRule.min || quantity > quantityRule.max){
      reason = `Summon quantity must be between ${quantityRule.min} and ${quantityRule.max}.`;
    }
    castSummonValidation = {ok: !reason, reason};
    if (castSubmitBtn) castSubmitBtn.disabled = !castSummonValidation.ok;
    if (showToast && reason){
      localToast(reason);
    }
    return castSummonValidation;
  };

  const updateSummonOptions = (preset) => {
    const summonSpell = isSummonPreset(preset);
    if (summonOptions){
      summonOptions.classList.toggle("hidden", !summonSpell);
    }
    if (aoeOptions){
      aoeOptions.classList.toggle("hidden", summonSpell);
    }
    const disableForSummon = (input) => {
      if (!input) return;
      input.disabled = summonSpell;
      if (summonSpell){
        input.readOnly = true;
      }
    };
    [castShapeInput, castDefaultDamageInput, castDiceInput, castDamageTypeInput, castAddDamageTypeBtn, castColorInput].forEach(disableForSummon);
    if (!summonSpell){
      if (castShapeInput) castShapeInput.readOnly = false;
      if (castDefaultDamageInput) castDefaultDamageInput.readOnly = false;
      if (castDiceInput) castDiceInput.readOnly = false;
      if (castDamageTypeInput) castDamageTypeInput.readOnly = false;
      if (castColorInput) castColorInput.readOnly = false;
      if (castSummonMeta) castSummonMeta.textContent = "";
      if (castSubmitBtn) castSubmitBtn.disabled = false;
      return;
    }
    const choices = getSummonChoices(preset);
    if (castSummonChoiceInput){
      const current = normalizeTextValue(castSummonChoiceInput.value);
      castSummonChoiceInput.textContent = "";
      choices.forEach((choice) => {
        const opt = document.createElement("option");
        opt.value = choice.monster_slug;
        const desc = normalizeTextValue(choice.description || choice.notes);
        opt.textContent = desc ? `${choice.name} — ${desc}` : choice.name;
        castSummonChoiceInput.appendChild(opt);
      });
      castSummonChoiceInput.value = current || choices[0]?.monster_slug || "";
      if (!castSummonChoiceInput.value && choices[0]?.monster_slug){
        castSummonChoiceInput.value = choices[0].monster_slug;
      }
    }
    const selectedChoice = normalizeTextValue(castSummonChoiceInput?.value || choices[0]?.monster_slug || "");
    const selectedChoiceEntry = choices.find((choice) => normalizeTextValue(choice.monster_slug) === selectedChoice) || choices[0] || null;
    const variants = Array.isArray(selectedChoiceEntry?.variants) ? selectedChoiceEntry.variants : [];
    if (castSummonVariantInput){
      const currentVariant = normalizeTextValue(castSummonVariantInput.value || "");
      castSummonVariantInput.textContent = "";
      const mountMode = Boolean(preset?.summon?.mount);
      castSummonVariantInput.closest('.form-field')?.classList.toggle('hidden', !mountMode);
      if (mountMode){
        variants.forEach((variant) => {
          const opt = document.createElement("option");
          opt.value = variant;
          opt.textContent = variant;
          castSummonVariantInput.appendChild(opt);
        });
        castSummonVariantInput.value = currentVariant || variants[0] || "";
      }
    }
    const rule = getSummonQuantityRule(preset, Number(castSlotLevelInput?.value), selectedChoice);
    if (castSummonVariantInput){
    castSummonVariantInput.addEventListener("change", () => {
      const preset = getSelectedSpellPreset();
      validateSummonForm(preset, false);
    });
  }

  if (castSummonQuantityInput){
      castSummonQuantityInput.min = String(rule.min);
      castSummonQuantityInput.max = String(rule.max);
      if (rule.fixed !== null){
        castSummonQuantityInput.value = String(rule.fixed);
        castSummonQuantityInput.readOnly = true;
      } else {
        const currentQty = Number(castSummonQuantityInput.value);
        const nextQty = Number.isFinite(currentQty)
          ? Math.min(rule.max, Math.max(rule.min, Math.floor(currentQty)))
          : rule.min;
        castSummonQuantityInput.value = String(nextQty);
        castSummonQuantityInput.readOnly = false;
      }
    }
    if (castSummonMeta){
      const initiativeMode = normalizeTextValue(preset?.summon?.initiative?.mode);
      const controlCommands = normalizeTextValue(preset?.summon?.control?.commands);
      const quantityInfo = rule.fixed !== null
        ? `Quantity: fixed at ${rule.fixed}`
        : `Quantity: ${rule.min}–${rule.max}`;
      const metaBits = [quantityInfo];
      if (initiativeMode){
        metaBits.push(`Initiative: ${initiativeMode.replace(/_/g, " ")}`);
      }
      if (controlCommands){
        metaBits.push(`Control: ${controlCommands}`);
      }
      castSummonMeta.textContent = metaBits.join(" · ");
    }
    validateSummonForm(preset, false);
  };

  const updateCastShapeFields = () => {
    const preset = getSelectedSpellPreset();
    if (isSummonPreset(preset)){
      [castRadiusField, castSideField, castLengthField, castWidthField, castAngleField, castOrientField, castThicknessField, castHeightField].forEach((field) => setCastFieldVisible(field, false));
      [castRadiusInput, castSideInput, castLengthInput, castWidthInput, castAngleInput, castOrientInput, castThicknessInput, castHeightInput].forEach((input) => setCastFieldEnabled(input, false));
      return;
    }
    const shape = String(castShapeInput?.value || "").toLowerCase();
    const usesRadius = shape === "circle" || shape === "sphere" || shape === "cylinder";
    const usesSide = shape === "square" || shape === "cube";
    const usesLength = shape === "line" || shape === "cone" || shape === "wall";
    const usesWidth = shape === "line" || shape === "wall";
    const usesAngle = shape === "line" || shape === "cone" || shape === "wall";
    const usesOrient = shape === "line" || shape === "cone" || shape === "wall";
    const usesThickness = shape === "wall";
    const usesHeight = shape === "wall" || shape === "cylinder";
    setCastFieldVisible(castRadiusField, usesRadius);
    setCastFieldVisible(castSideField, usesSide);
    setCastFieldVisible(castLengthField, usesLength);
    setCastFieldVisible(castWidthField, usesWidth);
    setCastFieldVisible(castAngleField, usesAngle);
    setCastFieldVisible(castOrientField, usesOrient);
    setCastFieldVisible(castThicknessField, usesThickness);
    setCastFieldVisible(castHeightField, usesHeight);
    setCastFieldEnabled(castRadiusInput, usesRadius);
    setCastFieldEnabled(castSideInput, usesSide);
    setCastFieldEnabled(castLengthInput, usesLength);
    setCastFieldEnabled(castWidthInput, usesWidth);
    setCastFieldEnabled(castAngleInput, usesAngle);
    setCastFieldEnabled(castOrientInput, usesOrient);
    setCastFieldEnabled(castThicknessInput, usesThickness);
    setCastFieldEnabled(castHeightInput, usesHeight);
  };

  if (castShapeInput){
    castShapeInput.addEventListener("change", updateCastShapeFields);
    updateCastShapeFields();
  }
  updateSummonOptions(null);

  const parseDiceSpec = (value) => {
    if (typeof value !== "string") return null;
    const raw = value.trim().toLowerCase();
    const match = raw.match(/^(\\d+)d(4|6|8|10|12)$/);
    if (!match) return null;
    const count = Number(match[1]);
    const sides = Number(match[2]);
    if (!Number.isFinite(count) || count <= 0) return null;
    return {count, sides};
  };

  const formatDiceSpec = (spec) => `${spec.count}d${spec.sides}`;

  const normalizeUpcastConfig = (upcast) => {
    if (!upcast || typeof upcast !== "object") return null;
    const baseLevel = Number(upcast.base_level);
    if (!Number.isFinite(baseLevel) || baseLevel < 0){
      console.warn("Invalid upcast base_level; ignoring upcast config.", upcast);
      return null;
    }
    const rawIncrements = Array.isArray(upcast.increments) ? upcast.increments : [];
    const increments = [];
    const slotAddDice = typeof upcast.add_per_slot_above === "string" ? upcast.add_per_slot_above : "";
    if (slotAddDice && parseDiceSpec(slotAddDice)){
      increments.push({
        levels_per_increment: 1,
        add_dice: slotAddDice,
      });
    }
    rawIncrements.forEach((entry) => {
      if (!entry || typeof entry !== "object"){
        console.warn("Invalid upcast increment entry; skipping.", entry);
        return;
      }
      const addDice = typeof entry.add_dice === "string" ? entry.add_dice : "";
      if (!parseDiceSpec(addDice)){
        console.warn("Invalid upcast add_dice; skipping.", entry);
        return;
      }
      const levelsPer = Number(entry.levels_per_increment);
      if (Number.isFinite(levelsPer) && levelsPer > 0){
        increments.push({
          levels_per_increment: levelsPer,
          add_dice: addDice,
        });
        return;
      }
      const levelThreshold = Number(entry.level);
      if (Number.isFinite(levelThreshold) && levelThreshold > baseLevel){
        increments.push({
          level: levelThreshold,
          add_dice: addDice,
        });
        return;
      }
      console.warn("Invalid upcast increment entry; skipping.", entry);
    });
    if (!increments.length){
      console.warn("Upcast increments contained no valid entries; ignoring upcast config.", upcast);
      return null;
    }
    return {base_level: baseLevel, increments};
  };

  const computeUpcastValues = (baseDice, baseDefaultDamage, upcastConfig, slotLevel) => {
    if (!upcastConfig || !Number.isFinite(slotLevel)) return {dice: baseDice, defaultDamage: baseDefaultDamage};
    const baseLevel = Number(upcastConfig.base_level);
    if (!Number.isFinite(baseLevel)) return {dice: baseDice, defaultDamage: baseDefaultDamage};
    const deltaLevels = Math.floor(slotLevel - baseLevel);
    if (deltaLevels <= 0) return {dice: baseDice, defaultDamage: baseDefaultDamage};
    const baseDiceSpec = parseDiceSpec(baseDice) || parseDiceSpec(baseDefaultDamage);
    let totalDiceSpec = baseDiceSpec ? {count: baseDiceSpec.count, sides: baseDiceSpec.sides} : null;
    let applied = false;
    (upcastConfig.increments || []).forEach((inc) => {
      const addDiceSpec = parseDiceSpec(inc.add_dice);
      if (!addDiceSpec) return;
      let steps = 0;
      const levelsPer = Number(inc.levels_per_increment);
      if (Number.isFinite(levelsPer) && levelsPer > 0){
        steps = Math.floor(deltaLevels / levelsPer);
      } else {
        const levelThreshold = Number(inc.level);
        if (Number.isFinite(levelThreshold) && slotLevel >= levelThreshold){
          steps = 1;
        }
      }
      if (steps <= 0) return;
      const addCount = addDiceSpec.count * steps;
      if (!totalDiceSpec){
        totalDiceSpec = {count: addCount, sides: addDiceSpec.sides};
        applied = true;
        return;
      }
      if (totalDiceSpec.sides !== addDiceSpec.sides){
        console.warn("Upcast dice sides mismatch; skipping increment.", inc);
        return;
      }
      totalDiceSpec.count += addCount;
      applied = true;
    });
    const dice = totalDiceSpec ? formatDiceSpec(totalDiceSpec) : baseDice;
    let defaultDamage = baseDefaultDamage;
    if (applied){
      const defaultDamageDice = parseDiceSpec(baseDefaultDamage);
      if (defaultDamageDice || baseDefaultDamage === null || baseDefaultDamage === ""){
        defaultDamage = dice;
      }
    }
    return {dice, defaultDamage};
  };

  const castDamageTypes = new Set();
  let castDurationTurns = null;
  let castOverTime = null;
  let castMovePerTurnFt = null;
  let castTriggerOnStartOrEnter = null;
  let castPersistent = null;
  let castPinnedDefault = null;
  let castUpcastConfig = null;
  let castBaseDice = null;
  let castBaseDefaultDamage = null;
  const setCastDamageTypes = (types) => {
    castDamageTypes.clear();
    if (Array.isArray(types)){
      types.forEach((entry) => {
        const dtype = String(entry || "").trim();
        if (dtype){
          castDamageTypes.add(dtype);
        }
      });
    }
    renderCastDamageTypes();
  };
  const renderCastDamageTypes = () => {
    if (!castDamageTypeList) return;
    castDamageTypeList.textContent = "";
    for (const dtype of castDamageTypes){
      const chip = document.createElement("span");
      chip.className = "chip damage-type-chip";
      const label = document.createElement("span");
      label.textContent = dtype;
      const removeBtn = document.createElement("button");
      removeBtn.type = "button";
      removeBtn.setAttribute("aria-label", `Remove ${dtype}`);
      removeBtn.textContent = "×";
      removeBtn.addEventListener("click", () => {
        castDamageTypes.delete(dtype);
        renderCastDamageTypes();
      });
      chip.appendChild(label);
      chip.appendChild(removeBtn);
      castDamageTypeList.appendChild(chip);
    }
  };
  const addCastDamageType = (value) => {
    const dtype = String(value || "").trim();
    if (!dtype){
      localToast("Choose a damage type first, matey.");
      return;
    }
    if (castDamageTypes.has(dtype)){
      localToast("That damage type be added already.");
      return;
    }
    castDamageTypes.add(dtype);
    renderCastDamageTypes();
  };

  const applySpellPreset = (preset) => {
    if (!preset || typeof preset !== "object") return;
    if (castNameInput && preset.name){
      castNameInput.value = String(preset.name || "");
    }
    if (castShapeInput){
      castShapeInput.value = preset.shape ? String(preset.shape || "").toLowerCase() : "";
    }
    updateSummonOptions(preset);
    updateCastShapeFields();
    if (castRadiusInput){
      castRadiusInput.value = Number.isFinite(Number(preset.radius_ft)) ? Number(preset.radius_ft) : "";
    }
    if (castSideInput){
      castSideInput.value = Number.isFinite(Number(preset.side_ft)) ? Number(preset.side_ft) : "";
    }
    if (castLengthInput){
      castLengthInput.value = Number.isFinite(Number(preset.length_ft)) ? Number(preset.length_ft) : "";
    }
    if (castWidthInput){
      castWidthInput.value = Number.isFinite(Number(preset.width_ft)) ? Number(preset.width_ft) : "";
    }
    if (castAngleInput){
      castAngleInput.value = Number.isFinite(Number(preset.angle_deg)) ? Number(preset.angle_deg) : "";
    }
    if (castOrientInput){
      castOrientInput.value = preset.orient ? String(preset.orient || "").toLowerCase() : "vertical";
    }
    if (castThicknessInput){
      castThicknessInput.value = Number.isFinite(Number(preset.thickness_ft)) ? Number(preset.thickness_ft) : "";
    }
    if (castHeightInput){
      castHeightInput.value = Number.isFinite(Number(preset.height_ft)) ? Number(preset.height_ft) : "";
    }
    if (castDcTypeInput){
      castDcTypeInput.value = preset.save_type ? String(preset.save_type || "").toLowerCase() : "";
    }
    if (castDcValueInput){
      const presetDc = Number(preset.save_dc);
      castDcValueInput.value = Number.isFinite(presetDc) ? Number(presetDc) : "";
      if (!Number.isFinite(presetDc)){
        applyDefaultSpellSaveDc();
      }
    }
    if (castDefaultDamageInput){
      const defaultDamage = preset.default_damage;
      castDefaultDamageInput.value = defaultDamage !== undefined && defaultDamage !== null ? String(defaultDamage) : "";
      castBaseDefaultDamage = defaultDamage !== undefined && defaultDamage !== null ? String(defaultDamage) : "";
    }
    if (castDiceInput){
      const dice = preset.dice;
      castDiceInput.value = dice !== undefined && dice !== null ? String(dice) : "";
      castBaseDice = dice !== undefined && dice !== null ? String(dice) : "";
    }
    if (castColorInput){
      castColorInput.value = normalizeHexColor(preset.color || "") || DEFAULT_SPELL_COLOR;
    }
    setCastDamageTypes(preset.damage_types);
    if (Number.isFinite(Number(preset.duration_turns))){
      castDurationTurns = Number(preset.duration_turns);
    } else {
      castDurationTurns = null;
    }
    if (typeof preset.over_time === "boolean"){
      castOverTime = preset.over_time;
    } else {
      castOverTime = null;
    }
    const movePerTurn = Number(preset.move_per_turn_ft);
    if (Number.isFinite(movePerTurn)){
      castMovePerTurnFt = movePerTurn;
    } else {
      castMovePerTurnFt = null;
    }
    if (preset.trigger_on_start_or_enter){
      castTriggerOnStartOrEnter = String(preset.trigger_on_start_or_enter || "").toLowerCase();
    } else {
      castTriggerOnStartOrEnter = null;
    }
    if (typeof preset.persistent === "boolean"){
      castPersistent = preset.persistent;
    } else {
      castPersistent = null;
    }
    if (typeof preset.pinned_default === "boolean"){
      castPinnedDefault = preset.pinned_default;
    } else {
      castPinnedDefault = null;
    }
    castUpcastConfig = normalizeUpcastConfig(preset.upcast);
    if (castSlotLevelInput){
      const presetLevel = Number.isFinite(Number(preset.level)) ? Math.max(0, Math.floor(Number(preset.level))) : 0;
      const baseLevel = castUpcastConfig && Number.isFinite(Number(castUpcastConfig.base_level))
        ? Math.max(0, Math.floor(Number(castUpcastConfig.base_level)))
        : presetLevel;
      castSlotLevelInput.disabled = false;
      castSlotLevelInput.readOnly = false;
      castSlotLevelInput.min = String(Math.max(0, baseLevel));
      castSlotLevelInput.value = String(Math.max(0, baseLevel));
    }
    const slotLevelValue = Number(castSlotLevelInput?.value);
    const upcastValues = computeUpcastValues(castBaseDice, castBaseDefaultDamage, castUpcastConfig, slotLevelValue);
    if (castDiceInput && upcastValues.dice !== undefined && upcastValues.dice !== null){
      castDiceInput.value = String(upcastValues.dice || "");
    }
    if (castDefaultDamageInput && upcastValues.defaultDamage !== undefined && upcastValues.defaultDamage !== null){
      castDefaultDamageInput.value = String(upcastValues.defaultDamage || "");
    }
  };

  const updateUpcastFields = () => {
    if (!castUpcastConfig) return;
    const slotLevelValue = Number(castSlotLevelInput?.value);
    const upcastValues = computeUpcastValues(castBaseDice, castBaseDefaultDamage, castUpcastConfig, slotLevelValue);
    if (castDiceInput && upcastValues.dice !== undefined && upcastValues.dice !== null){
      castDiceInput.value = String(upcastValues.dice || "");
    }
    if (castDefaultDamageInput && upcastValues.defaultDamage !== undefined && upcastValues.defaultDamage !== null){
      castDefaultDamageInput.value = String(upcastValues.defaultDamage || "");
    }
  };

  function validateCastSlotSelection(preset, showToast = false){
    const baseLevel = Number.isFinite(Number(preset?.level)) ? Math.max(0, Math.floor(Number(preset.level))) : 0;
    const rawLevel = Number(castSlotLevelInput?.value);
    const slotLevel = Number.isFinite(rawLevel) ? Math.floor(rawLevel) : baseLevel;
    if (slotLevel < baseLevel){
      const msg = "Ye can't downcast that spell, matey.";
      if (showToast) localToast(msg);
      return {ok: false, reason: msg};
    }
    const profile = getPlayerProfile(getClaimedPlayerName());
    if (slotLevel >= 1 && getAvailableSlotCountAtOrAbove(profile, slotLevel) <= 0){
      const msg = "No spell slots left for that level, matey.";
      if (showToast) localToast(msg);
      return {ok: false, reason: msg};
    }
    return {ok: true, slotLevel};
  }

  if (castPresetInput){
    castPresetInput.addEventListener("change", () => {
      const name = String(castPresetInput.value || "").trim();
      if (!name){
        castDurationTurns = null;
        castOverTime = null;
        castMovePerTurnFt = null;
        castTriggerOnStartOrEnter = null;
        castPersistent = null;
        castPinnedDefault = null;
        castUpcastConfig = null;
        castBaseDice = null;
        castBaseDefaultDamage = null;
        if (castDefaultDamageInput){
          castDefaultDamageInput.value = "";
        }
        if (castDiceInput){
          castDiceInput.value = "";
        }
        if (castDcValueInput){
          castDcValueInput.value = "";
          applyDefaultSpellSaveDc();
        }
        if (castSlotLevelInput){
          castSlotLevelInput.value = "";
          castSlotLevelInput.min = "0";
          castSlotLevelInput.disabled = false;
          castSlotLevelInput.readOnly = false;
        }
        updateSummonOptions(null);
        updateSpellPresetDetails(null);
        return;
      }
      const preset = cachedSpellPresets.find(p => String(p.name || "") === name);
      updateSpellPresetDetails(preset || null);
      applySpellPreset(preset);
    });
  }

  if (castSlotLevelInput){
    castSlotLevelInput.addEventListener("input", () => {
      updateUpcastFields();
      const preset = getSelectedSpellPreset();
      const check = validateCastSlotSelection(preset, false);
      castSlotLevelInput.setCustomValidity(check.ok ? "" : (check.reason || "Invalid slot level"));
      updateSummonOptions(preset);
      validateSummonForm(preset, false);
    });
  }

  if (castSummonChoiceInput){
    castSummonChoiceInput.addEventListener("change", () => {
      const preset = getSelectedSpellPreset();
      updateSummonOptions(preset);
      validateSummonForm(preset, false);
    });
  }

  if (castSummonQuantityInput){
    castSummonQuantityInput.addEventListener("input", () => {
      const preset = getSelectedSpellPreset();
      validateSummonForm(preset, false);
    });
  }

  if (castAddDamageTypeBtn){
    castAddDamageTypeBtn.addEventListener("click", () => {
      addCastDamageType(castDamageTypeInput?.value || "");
    });
  }

  if (castForm){
    castForm.addEventListener("submit", (ev) => {
      ev.preventDefault();
      if (!claimedCid){
        localToast("Claim a character first, matey.");
        return;
      }
      if (!state){
        localToast("Map not ready yet, matey.");
        return;
      }
      const preset = getSelectedSpellPreset();
      const spellActionType = getSpellActionType(preset);
      const actionType = pendingSpellActionType || spellActionType;
      if (pendingSpellActionType && pendingSpellActionType !== spellActionType){
        const expectedLabel = spellActionType === "bonus_action" ? "bonus action" : spellActionType;
        localToast(`That spell uses a ${expectedLabel}.`);
        return;
      }
      pendingSpellActionType = null;
      const unit = getClaimedUnit();
      const actionCheck = canSpendSpellAction(unit, actionType);
      if (!actionCheck.ok){
        localToast(actionCheck.reason || "You can't cast right now.");
        return;
      }
      const actionLabel = actionType === "bonus_action" ? "bonus action" : actionType;
      const spellName = normalizeTextValue(castNameInput?.value) || "this spell";
      if (!confirm(`Cast ${spellName} using your ${actionLabel}?`)){
        return;
      }
      const shape = String(castShapeInput?.value || "").toLowerCase();
      const aoeSpell = isAoePreset(preset);
      const summonSpell = isSummonPreset(preset);
      if (aoeSpell && !shape){
        localToast("Pick a spell shape first, matey.");
        return;
      }
      const slotCheck = validateCastSlotSelection(preset, true);
      if (!slotCheck.ok){
        return;
      }
      const slotLevel = Number.isFinite(slotCheck.slotLevel) ? Math.floor(Number(slotCheck.slotLevel)) : null;
      if (summonSpell){
        const summonValidation = validateSummonForm(preset, true);
        if (!summonValidation.ok){
          return;
        }
        const choices = getSummonChoices(preset);
        const summonChoice = normalizeTextValue(castSummonChoiceInput?.value || choices[0]?.monster_slug || "");
        const summonVariant = normalizeTextValue(castSummonVariantInput?.value || "");
        const summonQuantity = Number(castSummonQuantityInput?.value);
        const presetSlug = normalizeTextValue(preset?.slug);
        const presetId = normalizeTextValue(preset?.id);
        const normalizedQuantity = Number.isFinite(summonQuantity) && summonQuantity > 0 ? Math.floor(summonQuantity) : 1;
        const payload = {
          action_type: actionType,
          name: String(castNameInput?.value || "").trim() || null,
          slot_level: slotLevel,
          spell_slug: presetSlug || null,
          spell_id: presetId || null,
          summon_choice: summonChoice || null,
          summon_quantity: normalizedQuantity,
          variant: summonVariant || null,
        };
        const caster = getClaimedUnit();
        if (!caster || !caster.pos){
          localToast("Could not find caster position, matey.");
          return;
        }
        pendingSummonPlacement = {
          actionType,
          slotLevel,
          spellSlug: presetSlug || null,
          spellId: presetId || null,
          summonChoice: summonChoice || null,
          summonVariant: summonVariant || null,
          summonQuantity: normalizedQuantity,
          casterPos: {col: Number(caster.pos.col), row: Number(caster.pos.row)},
          maxRangeFt: parseSpellRangeFeet(preset?.range),
          positions: [],
          payload,
          spellName,
        };
        rebuildSummonValidCells();
        updateSummonPlacementBanner();
        localToast("Summon placement started. Choose valid highlighted squares.");
        return;
      }
      const parsePositive = (value) => {
        const num = parseFloat(value || "");
        return Number.isFinite(num) && num > 0 ? num : null;
      };
      const parseNonnegative = (value) => {
        const num = parseFloat(value || "");
        return Number.isFinite(num) && num >= 0 ? num : null;
      };
      const radiusFt = parsePositive(castRadiusInput?.value);
      const sideFt = parsePositive(castSideInput?.value);
      const lengthFt = parsePositive(castLengthInput?.value);
      const widthFt = parsePositive(castWidthInput?.value);
      const angleRaw = String(castAngleInput?.value || "").trim();
      const angleDeg = angleRaw ? parseNonnegative(castAngleInput?.value) : null;
      const widthRaw = String(castWidthInput?.value || "").trim();
      const thicknessFt = parsePositive(castThicknessInput?.value);
      const thicknessRaw = String(castThicknessInput?.value || "").trim();
      const heightFt = parsePositive(castHeightInput?.value);
      const heightRaw = String(castHeightInput?.value || "").trim();
      const orientValue = String(castOrientInput?.value || "vertical").toLowerCase();
      const orient = orientValue === "horizontal" ? "horizontal" : "vertical";
      if (shape === "circle" && radiusFt === null){
        localToast("Enter a valid radius, matey.");
        return;
      }
      if ((shape === "sphere" || shape === "cylinder") && radiusFt === null){
        localToast("Enter a valid radius, matey.");
        return;
      }
      if (shape === "cylinder" && heightRaw && heightFt === null){
        localToast("Enter a valid height, matey.");
        return;
      }
      if (shape === "square" && sideFt === null){
        localToast("Enter a valid side length, matey.");
        return;
      }
      if (shape === "cube" && sideFt === null){
        localToast("Enter a valid side length, matey.");
        return;
      }
      if (shape === "line" && (lengthFt === null || widthFt === null)){
        localToast("Enter a valid line size, matey.");
        return;
      }
      if (shape === "cone" && lengthFt === null){
        localToast("Enter a valid cone length, matey.");
        return;
      }
      if (shape === "cone" && angleRaw && (angleDeg === null || angleDeg <= 0)){
        localToast("Enter a valid cone angle, matey.");
        return;
      }
      if ((shape === "line" || shape === "wall") && angleRaw && angleDeg === null){
        localToast("Enter a valid angle, matey.");
        return;
      }
      if (shape === "wall" && widthRaw && widthFt === null){
        localToast("Enter a valid wall width, matey.");
        return;
      }
      if (shape === "wall" && thicknessRaw && thicknessFt === null){
        localToast("Enter a valid wall thickness, matey.");
        return;
      }
      if (shape === "wall" && heightRaw && heightFt === null){
        localToast("Enter a valid wall height, matey.");
        return;
      }
      if (shape === "wall"){
        if (lengthFt === null){
          localToast("Enter a valid wall length, matey.");
          return;
        }
        if (widthFt === null && (thicknessFt === null || heightFt === null)){
          localToast("Enter a valid wall thickness and height (or width), matey.");
          return;
        }
      }
      const dcType = String(castDcTypeInput?.value || "").trim().toLowerCase();
      const dcValue = parseInt(castDcValueInput?.value || "", 10);
      const damageTypes = Array.from(castDamageTypes);
      if (!damageTypes.length){
        const fallbackType = String(castDamageTypeInput?.value || "").trim();
        if (fallbackType){
          damageTypes.push(fallbackType);
        }
      }
      const damageType = damageTypes.length === 1 ? damageTypes[0] : "";
      const name = String(castNameInput?.value || "").trim();
      const color = normalizeHexColor(castColorInput?.value || "") || null;
      let defaultDamage = String(castDefaultDamageInput?.value || "").trim();
      let dice = String(castDiceInput?.value || "").trim();
      if (castUpcastConfig){
        const slotLevelValue = Number(castSlotLevelInput?.value);
        const upcastValues = computeUpcastValues(
          castBaseDice || dice,
          castBaseDefaultDamage || defaultDamage,
          castUpcastConfig,
          slotLevelValue
        );
        if (upcastValues.dice !== undefined && upcastValues.dice !== null){
          dice = String(upcastValues.dice || "");
        }
        if (upcastValues.defaultDamage !== undefined && upcastValues.defaultDamage !== null){
          defaultDamage = String(upcastValues.defaultDamage || "");
        }
      }
      const center = defaultAoeCenter();
      if (aoeSpell && shape !== "line"){
        const caster = getClaimedUnit();
        if (caster && caster.pos){
          const start = {col: Number(caster.pos.col), row: Number(caster.pos.row)};
          const end = {col: Number(center.cx), row: Number(center.cy)};
          const blocked = isLineOfSightBlocked(start, end);
          setLosPreview(start, end, blocked);
          if (blocked){
            localToast("No line of sight to spell center.");
            return;
          }
        }
      }
      const payload = {
        shape,
        action_type: actionType,
        dc: Number.isFinite(dcValue) ? dcValue : null,
        save_type: dcType || null,
        damage_type: damageType || null,
        damage_types: damageTypes,
        name: name || null,
        color,
        cx: center.cx,
        cy: center.cy,
      };
      if (typeof preset?.concentration === "boolean"){
        payload.concentration = preset.concentration;
      }
      if (Number.isFinite(preset?.level)){
        payload.level = Math.max(0, Math.floor(Number(preset.level)));
      }
      if (defaultDamage){
        payload.default_damage = defaultDamage;
      }
      if (dice){
        payload.dice = dice;
      }
      if (Number.isFinite(Number(castDurationTurns)) && Number(castDurationTurns) >= 0){
        payload.duration_turns = Number(castDurationTurns);
      }
      if (typeof castOverTime === "boolean"){
        payload.over_time = castOverTime;
      }
      if (Number.isFinite(Number(castMovePerTurnFt)) && Number(castMovePerTurnFt) >= 0){
        payload.move_per_turn_ft = Number(castMovePerTurnFt);
      }
      if (castTriggerOnStartOrEnter){
        payload.trigger_on_start_or_enter = castTriggerOnStartOrEnter;
      }
      if (typeof castPersistent === "boolean"){
        payload.persistent = castPersistent;
      }
      if (typeof castPinnedDefault === "boolean"){
        payload.pinned_default = castPinnedDefault;
      }
      if (aoeSpell && shape === "circle"){
        payload.radius_ft = radiusFt;
      } else if (aoeSpell && (shape === "sphere" || shape === "cylinder")){
        payload.radius_ft = radiusFt;
        if (heightFt !== null){
          payload.height_ft = heightFt;
        }
      } else if (aoeSpell && (shape === "square" || shape === "cube")){
        payload.side_ft = sideFt;
      } else if (aoeSpell && shape === "line"){
        payload.length_ft = lengthFt;
        payload.width_ft = widthFt;
        payload.orient = orient;
        if (angleDeg !== null){
          payload.angle_deg = angleDeg;
        }
      } else if (aoeSpell && shape === "cone"){
        payload.length_ft = lengthFt;
        payload.angle_deg = angleDeg !== null ? angleDeg : 90;
        payload.orient = orient;
      } else if (aoeSpell && shape === "wall"){
        payload.length_ft = lengthFt;
        payload.orient = orient;
        if (widthFt !== null){
          payload.width_ft = widthFt;
        }
        if (thicknessFt !== null){
          payload.thickness_ft = thicknessFt;
        }
        if (heightFt !== null){
          payload.height_ft = heightFt;
        }
        if (angleDeg !== null){
          payload.angle_deg = angleDeg;
        }
      }
      const msg = {type: aoeSpell ? "cast_aoe" : "cast_spell", payload, action_type: actionType};
      const presetSlug = normalizeTextValue(preset?.slug);
      const presetId = normalizeTextValue(preset?.id);
      if (presetSlug){
        msg.spell_slug = presetSlug;
      }
      if (presetId){
        msg.spell_id = presetId;
      }
      if (Number.isFinite(slotLevel)){
        msg.slot_level = slotLevel;
      }
      if (aoeSpell && isPlanning){
        planningMutate(msg);
        draw();
        updateHud();
      }
      send(msg);
    });
  }

  if (dashBtn){
    dashBtn.addEventListener("click", () => {
      if (isMapView) return;
      if (!claimedCid) return;
      openActionPicker("dash");
    });
  }
  if (dashActionBtn){
    dashActionBtn.addEventListener("click", () => {
      if (isMapView) return;
      const actionCid = activeControlledUnitCid();
      if (actionCid === null) return;
      const msg = {type:"dash", cid: actionCid, spend:"action"};
      if (isPlanning){
        planningMutate(msg);
        draw();
        updateHud();
      }
      send(msg);
      hideDashModal();
    });
  }
  if (dashBonusActionBtn){
    dashBonusActionBtn.addEventListener("click", () => {
      if (isMapView) return;
      const actionCid = activeControlledUnitCid();
      if (actionCid === null) return;
      const msg = {type:"dash", cid: actionCid, spend:"bonus"};
      if (isPlanning){
        planningMutate(msg);
        draw();
        updateHud();
      }
      send(msg);
      hideDashModal();
    });
  }
  if (dashCancelBtn){
    dashCancelBtn.addEventListener("click", () => {
      hideDashModal();
    });
  }
  if (actionPickerCancelBtn){
    actionPickerCancelBtn.addEventListener("click", () => {
      hideActionPicker();
    });
  }
  if (battleLogBtn){
    battleLogBtn.addEventListener("click", () => {
      requestBattleLog();
      showLogModal();
    });
  }
  if (logRefreshBtn){
    logRefreshBtn.addEventListener("click", () => {
      requestBattleLog();
    });
  }
  if (logCloseBtn){
    logCloseBtn.addEventListener("click", () => {
      hideLogModal();
    });
  }
  if (configBtn){
    configBtn.addEventListener("click", () => {
      if (!configModal) return;
      if (configModal.classList.contains("show")){
        hideConfigModal();
        return;
      }
      showConfigModal();
    });
  }
  if (initiativeToggleBtn){
    initiativeToggleBtn.addEventListener("click", () => {
      toggleInitiativeBar();
    });
  }
  if (planningBtn){
    planningBtn.classList.toggle("hidden", isPlanning);
    planningBtn.disabled = isPlanning;
    planningBtn.setAttribute("aria-disabled", isPlanning ? "true" : "false");
    if (!isPlanning){
      planningBtn.addEventListener("click", () => {
        const baseUrl = window.LAN_BASE_URL || window.location.origin;
        const planningUrl = new URL(`${baseUrl.replace(/\/$/, "")}/planning`);
        if (clientId){
          planningUrl.searchParams.set("client_id", clientId);
        }
        if (claimedCid !== null && claimedCid !== undefined){
          planningUrl.searchParams.set("player_cid", String(claimedCid));
        }
        window.open(planningUrl.toString(), "_blank", "noopener,noreferrer");
      });
    }
  }
  if (configCloseBtn){
    configCloseBtn.addEventListener("click", () => {
      hideConfigModal();
    });
  }
  if (configModal){
    configModal.addEventListener("click", (event) => {
      if (event.target === configModal){
        hideConfigModal();
      }
    });
  }
  const mapViewSettingInputs = [
    mapViewTextSizeInput,
    mapViewBarHeightInput,
    mapViewChipPaddingInput,
    mapViewChipGapInput,
    mapViewCornerRadiusInput,
    mapViewShowTitleInput,
    mapViewShowStatusInput,
    mapViewShowIndexInput,
  ].filter(Boolean);
  mapViewSettingInputs.forEach((inputEl) => {
    inputEl.addEventListener("input", () => {
      if (!mapViewSettings){
        mapViewSettings = readMapViewSettings();
      }
      mapViewSettings = {
        ...mapViewSettings,
        textSize: Number(mapViewTextSizeInput?.value || mapViewSettings.textSize),
        barHeight: Number(mapViewBarHeightInput?.value || mapViewSettings.barHeight),
        chipPadding: Number(mapViewChipPaddingInput?.value || mapViewSettings.chipPadding),
        chipGap: Number(mapViewChipGapInput?.value || mapViewSettings.chipGap),
        cornerRadius: Number(mapViewCornerRadiusInput?.value || mapViewSettings.cornerRadius),
        showTitle: !!mapViewShowTitleInput?.checked,
        showStatus: !!mapViewShowStatusInput?.checked,
        showIndex: !!mapViewShowIndexInput?.checked,
      };
      applyMapViewSettings(mapViewSettings);
      persistMapViewSettings();
    });
  });
  if (adminMenuBtn && adminMenuPopover){
    adminMenuBtn.addEventListener("click", (event) => {
      event.stopPropagation();
      const isOpen = adminMenuPopover.classList.contains("show");
      setAdminMenu(!isOpen);
    });
  }
  if (adminMenuOpenBtn){
    adminMenuOpenBtn.addEventListener("click", async () => {
      closeAdminMenu();
      try {
        await requestAdminLogin();
      } catch (err){
        return;
      }
      showAdminModal();
      fetchAdminSessions();
    });
  }
  if (adminMenuRefreshBtn){
    adminMenuRefreshBtn.addEventListener("click", async () => {
      closeAdminMenu();
      try {
        await requestAdminLogin();
      } catch (err){
        return;
      }
      fetchAdminSessions();
    });
  }
  if (adminMenuResetPcsBtn){
    adminMenuResetPcsBtn.addEventListener("click", async () => {
      await sendAdminAction("reset_player_characters");
    });
  }
  if (adminRefreshBtn){
    adminRefreshBtn.addEventListener("click", () => {
      fetchAdminSessions();
    });
  }
  if (assignPreSummonBtn){
    assignPreSummonBtn.addEventListener("click", async () => {
      try {
        const token = await requestAdminLogin();
        const targetCid = Number(preSummonTargetInput?.value);
        const spellSlug = normalizeTextValue(preSummonSpellInput?.value || "");
        const monsterSlug = normalizeTextValue(preSummonMonsterInput?.value || "");
        const variant = normalizeTextValue(preSummonVariantInput?.value || "");
        const slotLevel = Number(preSummonSlotLevelInput?.value);
        if (!Number.isFinite(targetCid) || !spellSlug || !monsterSlug){
          localToast("Pick target, spell, and monster first.");
          return;
        }
        send({
          type: "assign_pre_summon",
          admin_token: token,
          target_cid: targetCid,
          spell_slug: spellSlug,
          monster_slug: monsterSlug,
          slot_level: Number.isFinite(slotLevel) ? Math.floor(slotLevel) : null,
          variant: variant || null,
        });
        localToast("Pre-summon assigned.");
      } catch (err){
        console.warn("Assign pre-summon canceled.", err);
      }
    });
  }
  if (adminCloseBtn){
    adminCloseBtn.addEventListener("click", () => {
      hideAdminModal();
    });
  }

  if (rosterPickerRefreshBtn){
    rosterPickerRefreshBtn.addEventListener("click", () => {
      fetchRosterPickerPlayers({forceRefresh: true}).catch(() => {});
    });
  }
  if (rosterPickerCloseBtn){
    rosterPickerCloseBtn.addEventListener("click", () => {
      hideRosterPickerModal();
    });
  }
  if (rosterPickerAddBtn){
    rosterPickerAddBtn.addEventListener("click", async () => {
      const selected = Array.from((rosterPickerList || document.createElement("div")).querySelectorAll('input[type="checkbox"]:checked')).map((el) => el.value).filter(Boolean);
      if (!selected.length){
        localToast("Select at least one player.");
        return;
      }
      try {
        const token = await requestAdminLogin();
        const res = await fetch("/api/encounter/players/add", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${token}`
          },
          body: JSON.stringify({names: selected})
        });
        if (!res.ok){
          throw new Error(`HTTP ${res.status}`);
        }
        hideRosterPickerModal();
        localToast("Players added.");
      } catch (err){
        console.warn("Failed to add roster players", err);
        localToast("Failed to add players.");
      }
    });
  }
  if (rosterPickerModal){
    rosterPickerModal.addEventListener("click", (event) => {
      if (event.target === rosterPickerModal){
        hideRosterPickerModal();
      }
    });
  }
  if (adminModal){
    adminModal.addEventListener("click", (event) => {
      if (event.target === adminModal){
        hideAdminModal();
      }
    });
  }
  if (adminLoginSubmit){
    adminLoginSubmit.addEventListener("click", () => {
      submitAdminLogin();
    });
  }
  if (adminLoginCancel){
    adminLoginCancel.addEventListener("click", () => {
      hideAdminLoginModal();
      finalizeAdminLogin(false);
    });
  }
  if (adminLoginModal){
    adminLoginModal.addEventListener("click", (event) => {
      if (event.target === adminLoginModal){
        hideAdminLoginModal();
        finalizeAdminLogin(false);
      }
    });
  }
  if (adminPasswordInput){
    adminPasswordInput.addEventListener("keydown", (event) => {
      if (event.key === "Enter"){
        event.preventDefault();
        submitAdminLogin();
      }
    });
  }
  if (presetSaveBtn){
    presetSaveBtn.addEventListener("click", () => {
      const preset = buildGuiPreset();
      persistLocalPreset(preset);
      send({type: "save_preset", preset});
    });
  }
  if (presetLoadBtn){
    presetLoadBtn.addEventListener("click", () => {
      send({type: "load_preset"});
    });
  }
  if (focusTabOnTurnInput){
    focusTabOnTurnInput.checked = focusTabOnTurn;
    focusTabOnTurnInput.addEventListener("change", (event) => {
      focusTabOnTurn = event.target.checked;
      localStorage.setItem(focusTabOnTurnStorageKey, focusTabOnTurn ? "1" : "0");
    });
  }
  if (unlockAudioBtn){
    unlockAudioBtn.addEventListener("click", () => {
      unlockTurnAudio();
    });
  }
  if (enableNotificationsBtn){
    enableNotificationsBtn.addEventListener("click", async () => {
      if (!("Notification" in window)){
        setNotificationStatus("Notifications are not supported.");
        return;
      }
      try {
        if (!swRegistration){
          swRegistration = await navigator.serviceWorker.ready;
        }
      } catch (err){
        console.warn("Service worker not ready.", err);
        setNotificationStatus("Service worker not ready.");
        return;
      }
      const permission = await Notification.requestPermission();
      if (permission !== "granted"){
        setNotificationStatus("Notifications blocked.");
        return;
      }
      if (!("PushManager" in window)){
        setNotificationStatus("Push is not supported.");
        return;
      }
      try {
        const existing = await swRegistration.pushManager.getSubscription();
        if (existing){
          setNotificationStatus("Notifications already enabled.");
          return;
        }
        if (!pushPublicKey){
          setNotificationStatus("Missing push public key.");
          return;
        }
        const subscription = await swRegistration.pushManager.subscribe({
          userVisibleOnly: true,
          applicationServerKey: urlBase64ToUint8Array(pushPublicKey),
        });
        console.log("Push subscription:", JSON.stringify(subscription));
        setNotificationStatus("Notifications enabled.");
      } catch (err){
        console.warn("Push subscription failed.", err);
        setNotificationStatus("Failed to enable notifications.");
      }
    });
  }
  if (enableTurnAlertsBtn){
    enableTurnAlertsBtn.addEventListener("click", async () => {
      try {
        const identity = getTurnAlertIdentity();
        await ensurePushSubscribed({
          vapidPublicKey: pushPublicKey,
          playerId: identity.playerId,
        });
        localToast("Turn alerts enabled.");
      } catch (err){
        const message = err?.message ? String(err.message) : "Failed to enable alerts.";
        setTurnAlertStatus(message);
        localToast(message);
      }
    });
  }
  if (hideTurnAlertsBtn && turnAlertsPanel){
    hideTurnAlertsBtn.addEventListener("click", () => {
      localStorage.setItem(turnAlertHideKey, "1");
      turnAlertsPanel.classList.add("hidden");
    });
  }
  if (castOverlayOpenBtn){
    castOverlayOpenBtn.addEventListener("click", () => {
      setCastOverlayOpen(true);
    });
  }
  if (castOverlayBackBtn){
    castOverlayBackBtn.addEventListener("click", () => {
      setCastOverlayOpen(false);
    });
  }
  if (spellLibraryBtn){
    spellLibraryBtn.addEventListener("click", () => {
      openSpellLibraryOverlay(true);
    });
  }
  if (spellLibraryCloseBtn){
    spellLibraryCloseBtn.addEventListener("click", () => {
      openSpellLibraryOverlay(false);
    });
  }
  if (spellLibrarySearchInput){
    spellLibrarySearchInput.addEventListener("input", (event) => {
      spellLibrarySearchTerm = String(event.target.value || "");
      renderSpellLibrary();
    });
  }
  if (spellLibrarySortSelect){
    spellLibrarySortSelect.addEventListener("change", (event) => {
      spellLibrarySortMode = String(event.target.value || "alpha");
      renderSpellLibrary();
    });
  }
  if (spellbookOpenBtn){
    spellbookOpenBtn.addEventListener("click", () => {
      openSpellbookOverlay(true);
    });
  }
  if (spellbookBackBtn){
    spellbookBackBtn.addEventListener("click", () => {
      openSpellbookOverlay(false);
    });
  }
  if (spellbookBackFloatingBtn){
    spellbookBackFloatingBtn.addEventListener("click", () => {
      openSpellbookOverlay(false);
    });
  }
  if (spellDetailBackBtn){
    spellDetailBackBtn.addEventListener("click", () => {
      closeSpellDetailOverlay();
    });
  }
  if (spellDetailColorInput){
    spellDetailColorInput.addEventListener("input", (event) => {
      const value = String(event.target.value || "");
      updateSpellDetailColorInputs(normalizeHexColor(value) || value);
    });
    spellDetailColorInput.addEventListener("change", (event) => {
      commitSpellDetailColor(event.target.value || "");
    });
  }
  if (spellDetailColorValue){
    spellDetailColorValue.addEventListener("change", (event) => {
      commitSpellDetailColor(event.target.value || "");
    });
  }
  if (spellbookTabKnown){
    spellbookTabKnown.addEventListener("click", () => {
      spellbookMode = "known";
      resetSpellbookSelections();
      renderSpellbook();
    });
  }
  if (spellbookTabPrepared){
    spellbookTabPrepared.addEventListener("click", () => {
      spellbookMode = "prepared";
      resetSpellbookSelections();
      renderSpellbook();
    });
  }
  if (spellbookKnownEnabledToggle){
    spellbookKnownEnabledToggle.addEventListener("change", (event) => {
      spellbookKnownEnabled = !!event.target.checked;
      if (!spellbookKnownEnabled){
        spellbookMode = "prepared";
      }
      resetSpellbookSelections();
      renderSpellbook();
    });
  }
  if (spellbookSearchInput){
    spellbookSearchInput.addEventListener("input", (event) => {
      spellbookSearchTerm = String(event.target.value || "");
      renderSpellbook();
    });
  }
  if (spellbookSortSelect){
    spellbookSortSelect.addEventListener("change", (event) => {
      spellbookSortMode = String(event.target.value || "alpha");
      renderSpellbook();
    });
  }
  if (spellbookAddBtn){
    spellbookAddBtn.addEventListener("click", () => {
      applySpellbookAdd();
    });
  }
  if (spellbookRemoveBtn){
    spellbookRemoveBtn.addEventListener("click", () => {
      applySpellbookRemove();
    });
  }
  if (spellbookSaveBtn){
    spellbookSaveBtn.addEventListener("click", () => {
      showSpellbookConfirm();
    });
  }
  if (spellbookConfirmCancel){
    spellbookConfirmCancel.addEventListener("click", () => {
      hideSpellbookConfirm();
    });
  }
  if (spellbookConfirmYes){
    spellbookConfirmYes.addEventListener("click", () => {
      saveSpellbookChanges();
    });
  }
  if (spellbookConfirmModal){
    spellbookConfirmModal.addEventListener("click", (event) => {
      if (event.target === spellbookConfirmModal){
        hideSpellbookConfirm();
      }
    });
  }
  if (mapViewTurnOrderEl){
    mapViewTurnOrderEl.addEventListener("click", async (event) => {
      const chip = event.target.closest(".turn-chip");
      const slug = chip?.dataset?.monsterSlug;
      if (!slug) return;
      const variant = chip.dataset.monsterVariant || "";
      const slotLevel = chip.dataset.slotLevel || "";
      showMonsterDetail(slug, variant, slotLevel);
    });
  }
  if (monsterDetailCloseBtn){
    monsterDetailCloseBtn.addEventListener("click", hideMonsterDetail);
  }
  if (monsterDetailOverlay){
    monsterDetailOverlay.addEventListener("click", (event) => {
      if (event.target === event.currentTarget){
        hideMonsterDetail();
      }
    });
  }
  window.addEventListener("keydown", (event) => {
    if (event.key === "Escape"){
      hideMonsterDetail();
    }
  });

  if (connEl && connPopoverEl){
    connEl.addEventListener("click", (event) => {
      event.stopPropagation();
      const isOpen = connPopoverEl.classList.contains("show");
      setConnPopover(!isOpen);
    });
  }
  if (connReconnectBtn){
    connReconnectBtn.addEventListener("click", () => {
      softReconnect();
    });
  }
  document.addEventListener("click", (event) => {
    if (!connPopoverEl || !connEl) return;
    if (connPopoverEl.contains(event.target) || connEl.contains(event.target)) return;
    closeConnPopover();
  });
  document.addEventListener("click", (event) => {
    if (!adminMenuPopover || !adminMenuBtn) return;
    if (adminMenuPopover.contains(event.target) || adminMenuBtn.contains(event.target)) return;
    closeAdminMenu();
  });
  document.addEventListener("keydown", (event) => {
    if (event.key === "Escape"){
      if (!monsterDetailOverlay?.classList.contains("hidden")){
        hideMonsterDetail();
        return;
      }
      if (spellbookConfirmModal?.classList.contains("show")){
        hideSpellbookConfirm();
        return;
      }
      if (spellLibraryOverlay?.classList.contains("show")){
        openSpellLibraryOverlay(false);
        return;
      }
      if (spellDetailOverlay?.classList.contains("show")){
        closeSpellDetailOverlay();
        return;
      }
      if (spellbookOverlay?.classList.contains("show")){
        openSpellbookOverlay(false);
        return;
      }
      if (castOverlay?.classList.contains("show")){
        setCastOverlayOpen(false);
        return;
      }
      closeConnPopover();
      closeAdminMenu();
      hideAdminModal();
    }
  });
  document.addEventListener("keydown", (event) => {
    if (isShiftKey(event)){
      shiftMoveMode = true;
    }
  });
  document.addEventListener("keyup", (event) => {
    if (isShiftKey(event)){
      shiftMoveMode = false;
    }
  });
  if (toggleTopbarTitle){
    toggleTopbarTitle.addEventListener("change", (event) => {
      showTopbarTitle = !!event.target.checked;
      persistToggle(uiToggleKeys.topbarTitle, showTopbarTitle);
      applyUiConfig();
    });
  }
  if (toggleConnIndicator){
    toggleConnIndicator.addEventListener("change", (event) => {
      showConnIndicator = !!event.target.checked;
      persistToggle(uiToggleKeys.connIndicator, showConnIndicator);
      applyUiConfig();
    });
  }
  if (connStyleButtons.length){
    connStyleButtons.forEach((button) => {
      button.addEventListener("click", () => {
        const nextStyle = button.dataset.connStyle === "compact" ? "compact" : "full";
        if (connStyle === nextStyle) return;
        connStyle = nextStyle;
        persistChoice(uiSelectKeys.connStyle, connStyle);
        applyUiConfig();
      });
    });
  }
  if (toggleLockMap){
    toggleLockMap.addEventListener("change", (event) => {
      showLockMap = !!event.target.checked;
      persistToggle(uiToggleKeys.lockMap, showLockMap);
      applyUiConfig();
    });
  }
  if (toggleCenterMap){
    toggleCenterMap.addEventListener("change", (event) => {
      showCenterMap = !!event.target.checked;
      persistToggle(uiToggleKeys.centerMap, showCenterMap);
      applyUiConfig();
    });
  }
  if (toggleMeasure){
    toggleMeasure.addEventListener("change", (event) => {
      showMeasure = !!event.target.checked;
      persistToggle(uiToggleKeys.measure, showMeasure);
      applyUiConfig();
    });
  }
  if (toggleMeasureClear){
    toggleMeasureClear.addEventListener("change", (event) => {
      showMeasureClear = !!event.target.checked;
      persistToggle(uiToggleKeys.measureClear, showMeasureClear);
      applyUiConfig();
    });
  }
  if (toggleZoomIn){
    toggleZoomIn.addEventListener("change", (event) => {
      showZoomIn = !!event.target.checked;
      persistToggle(uiToggleKeys.zoomIn, showZoomIn);
      applyUiConfig();
    });
  }
  if (toggleZoomOut){
    toggleZoomOut.addEventListener("change", (event) => {
      showZoomOut = !!event.target.checked;
      persistToggle(uiToggleKeys.zoomOut, showZoomOut);
      applyUiConfig();
    });
  }
  if (toggleBattleLog){
    toggleBattleLog.addEventListener("change", (event) => {
      showBattleLog = !!event.target.checked;
      persistToggle(uiToggleKeys.battleLog, showBattleLog);
      applyUiConfig();
    });
  }
  if (initiativeStyleSelect){
    initiativeStyleSelect.addEventListener("change", (event) => {
      const value = event.target.value;
      initiativeStyle = ["full", "compact", "hidden"].includes(value) ? value : "full";
      persistChoice(uiSelectKeys.initiativeStyle, initiativeStyle);
      applyUiConfig();
    });
  }
  if (toggleUseAction){
    toggleUseAction.addEventListener("change", (event) => {
      showUseAction = !!event.target.checked;
      persistToggle(uiToggleKeys.useAction, showUseAction);
      applyUiConfig();
    });
  }
  if (toggleUseBonusAction){
    toggleUseBonusAction.addEventListener("change", (event) => {
      showUseBonusAction = !!event.target.checked;
      persistToggle(uiToggleKeys.useBonusAction, showUseBonusAction);
      applyUiConfig();
    });
  }
  if (toggleDash){
    toggleDash.addEventListener("change", (event) => {
      showDash = !!event.target.checked;
      persistToggle(uiToggleKeys.dash, showDash);
      applyUiConfig();
    });
  }
  if (toggleStandUp){
    toggleStandUp.addEventListener("change", (event) => {
      showStandUp = !!event.target.checked;
      persistToggle(uiToggleKeys.standUp, showStandUp);
      applyUiConfig();
    });
  }
  if (toggleResetTurn){
    toggleResetTurn.addEventListener("change", (event) => {
      showResetTurn = !!event.target.checked;
      persistToggle(uiToggleKeys.resetTurn, showResetTurn);
      applyUiConfig();
    });
  }
  if (toggleSpellMenu){
    toggleSpellMenu.addEventListener("change", (event) => {
      hideSpellMenu = !!event.target.checked;
      persistToggle(uiToggleKeys.hideSpellMenu, hideSpellMenu);
      applyUiConfig();
    });
  }
  if (toggleLockMenus){
    toggleLockMenus.addEventListener("change", (event) => {
      menusLocked = !!event.target.checked;
      persistToggle(uiToggleKeys.lockMenus, menusLocked);
      applyUiConfig();
    });
  }
  Object.entries(hotkeyConfig).forEach(([action, config]) => {
    if (!config || !config.input) return;
    config.input.addEventListener("keydown", (event) => {
      event.preventDefault();
      if (event.key === "Escape"){
        config.input.blur();
        return;
      }
      if (event.key === "Backspace" || event.key === "Delete"){
        setHotkey(action, "");
        return;
      }
      const combo = normalizeHotkeyEvent(event);
      if (!combo) return;
      setHotkey(action, combo);
    });
    config.input.addEventListener("focus", () => {
      config.input.select();
    });
  });
  useActionBtn.addEventListener("click", () => {
    if (isMapView) return;
    if (!claimedCid) return;
    openActionPicker("action");
  });
  useBonusActionBtn.addEventListener("click", () => {
    if (isMapView) return;
    if (!claimedCid) return;
    openActionPicker("bonus");
  });
  if (standUpBtn){
    standUpBtn.addEventListener("click", () => {
      if (isMapView) return;
      if (!claimedCid) return;
      send({type:"stand_up", cid: claimedCid});
    });
  }
  if (resetTurnBtn){
    resetTurnBtn.addEventListener("click", () => {
      if (isMapView) return;
      if (!claimedCid) return;
      send({type:"reset_turn", cid: claimedCid});
    });
  }

  if (mountBtn){
    mountBtn.addEventListener("click", () => {
      if (!pendingMountPair) return;
      send({type:"mount_request", rider_cid:Number(pendingMountPair.rider.cid), mount_cid:Number(pendingMountPair.mount.cid)});
    });
  }
  if (dismountBtn){
    dismountBtn.addEventListener("click", () => send({type:"dismount"}));
  }
  if (mountPromptYes){
    mountPromptYes.addEventListener("click", () => {
      send({type:"mount_response", request_id: pendingMountRequestId, accept:true});
      if (mountPromptModal){ mountPromptModal.classList.remove("show"); mountPromptModal.setAttribute("aria-hidden", "true"); }
    });
  }
  if (mountPromptNo){
    mountPromptNo.addEventListener("click", () => {
      send({type:"mount_response", request_id: pendingMountRequestId, accept:false});
      if (mountPromptModal){ mountPromptModal.classList.remove("show"); mountPromptModal.setAttribute("aria-hidden", "true"); }
    });
  }

  if (endTurnBtn){
    endTurnBtn.addEventListener("click", () => {
      if (isMapView) return;
      if (!claimedCid){
        localToast("Claim a character first, matey.");
        return;
      }
      send({type:"end_turn", cid: claimedCid});
    });
  }
  if (dismissSummonsBtn){
    dismissSummonsBtn.addEventListener("click", () => {
      if (isMapView) return;
      if (!claimedCid){
        localToast("Claim a character first, matey.");
        return;
      }
      send({type:"dismiss_summons", target_caster_cid: claimedCid, cid: claimedCid});
    });
  }
  if (turnModalOk){
    turnModalOk.addEventListener("click", () => {
      handleUserGesture();
      hideTurnModal();
    });
  }

  document.addEventListener("keydown", (event) => {
    if (event.defaultPrevented) return;
    if (isTypingTarget(event.target)) return;
    const combo = normalizeHotkeyEvent(event);
    if (!combo) return;
    const action = hotkeyBindings.get(combo);
    if (!action) return;
    event.preventDefault();
    const config = hotkeyConfig[action];
    if (config && typeof config.action === "function"){
      config.action();
    }
  });
  document.addEventListener("pointerdown", handleUserGesture, {passive: true});
  document.addEventListener("keydown", handleUserGesture);

  const mapWrap = document.querySelector(".mapWrap");
  if (mapWrap && window.ResizeObserver){
    const ro = new ResizeObserver(() => resize());
    ro.observe(mapWrap);
  }
  resize();
  updateMeasurementControls();
  updateWaitingOverlay();

  if (toggleDmLogPanelInput){
    toggleDmLogPanelInput.checked = dmUiPrefs.showLogPanel === true;
    toggleDmLogPanelInput.addEventListener('change', ()=>{ dmUiPrefs.showLogPanel = toggleDmLogPanelInput.checked; saveDmUiPrefs(); renderDmLogPanel(); });
  }
  if (toggleDmMapPreviewInput){
    toggleDmMapPreviewInput.checked = dmUiPrefs.showMapPreview === true;
    toggleDmMapPreviewInput.addEventListener('change', ()=>{ dmUiPrefs.showMapPreview = toggleDmMapPreviewInput.checked; saveDmUiPrefs(); renderDmLogPanel(); renderDmPreview(); });
  }

  connect();
})();
</script>
</body>
</html>
"""
